diff --git a/Android.bp b/Android.bp
index 2c557a68..7e72e7c5 100644
--- a/Android.bp
+++ b/Android.bp
@@ -1,6 +1,6 @@
 /******************************************************************************
   *
-  *  Copyright 2021 NXP
+  *  Copyright 2021,2023 NXP
   *
   *  Licensed under the Apache License, Version 2.0 (the "License");
   *  you may not use this file except in compliance with the License.
@@ -32,5 +32,5 @@ license {
 }
 
 subdirs = [
-    "snxxx","intf","pn8x",
+    "pn72xx","intf",
 ]
diff --git a/SCR.txt b/SCR.txt
new file mode 100644
index 00000000..77a81ed5
--- /dev/null
+++ b/SCR.txt
@@ -0,0 +1,49 @@
+NXP Software Content Register
+Outgoing License: LA_OPT_NXP_Software_License v33 Jan 2022
+License File:     LA_OPT_NXP_Software_License.pdf
+â€‹
+--------------------------------------------
+Outgoing License:          Apache Version 2.0
+License Files:             COPYING
+Package Category:          NFC Middleware
+Type of content:           Source
+Description and comments:  NCI based NFC stack
+Release Location:          
+Origin:                    The Android Open Source Project (Apache-2.0) - https://source.android.com/
+                           NXP (Apache-2.0)
+--------------------------------------------
+Outgoing License:          Apache Version 2.0
+License Files:             COPYING
+Package Category:          NFC Middleware
+Type of content:           Source
+Description and comments:  JNI NCI NFC
+Release Location:          
+Origin:                    The Android Open Source Project (Apache-2.0) - https://source.android.com/
+                           NXP (Apache-2.0)
+--------------------------------------------
+Outgoing License:          Apache Version 2.0
+License Files:             COPYING
+Package Category:          NFC SE Middleware
+Type of content:           Source
+Description and comments:  Hardware abstraction layer for NXP specific controllers
+Release Location:          
+Origin:                    The Android Open Source Project (Apache-2.0) - https://source.android.com/
+                           The Android Open Source Project (MIT) - https://source.android.com/
+                           NXP (Apache-2.0)
+--------------------------------------------
+Outgoing License:          Apache Version 2.0
+License Files:             COPYING
+Package Category:          NFC Middleware and Test Application
+Type of content:           Source
+Description and comments:  Device Test Application (DTA) used for NFC Forum testing
+Release Location:          https://github.com/NXPNFCProject/NXPAndroidDTA
+Origin:                    NXP (Apache-2.0)
+--------------------------------------------
+Outgoing License:          LA_OPT_NXP_Software_License
+License File:              COPYING
+Package Category:          NFC Firmware
+Type of content:           Binariy
+Description and comments:  NFC controller firmware
+Release Location:          
+Origin:                    NXP (proprietary)
+--------------------------------------------
\ No newline at end of file
diff --git a/intf/nxpnfc/2.0/manifest.xml b/intf/nxpnfc/2.0/manifest.xml
index 1d112973..bdcc5882 100644
--- a/intf/nxpnfc/2.0/manifest.xml
+++ b/intf/nxpnfc/2.0/manifest.xml
@@ -4,11 +4,19 @@
         <transport>hwbinder</transport>
         <impl level="generic"></impl>
         <version>1.0</version>
+        <interface>
+            <name>INfc</name>
+            <instance>default</instance>
+        </interface>
     </hal>
     <hal format="hidl">
         <name>vendor.nxp.nxpnfc</name>
         <transport>hwbinder</transport>
         <impl level="generic"></impl>
         <version>2.0</version>
+        <interface>
+            <name>INfc</name>
+            <instance>default</instance>
+        </interface>
     </hal>
 </manifest>
diff --git a/pn72xx/1.1/Nfc.cpp b/pn72xx/1.1/Nfc.cpp
new file mode 100644
index 00000000..151b149d
--- /dev/null
+++ b/pn72xx/1.1/Nfc.cpp
@@ -0,0 +1,147 @@
+/******************************************************************************
+ *
+ *  Copyright 2018 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "android.hardware.nfc@1.1-impl"
+#include "Nfc.h"
+
+#include <log/log.h>
+
+#include "halimpl/inc/phNxpNciHal_Adaptation.h"
+#include "phNfcStatus.h"
+
+#define CHK_STATUS(x) \
+  ((x) == NFCSTATUS_SUCCESS) ? (V1_0::NfcStatus::OK) : (V1_0::NfcStatus::FAILED)
+
+extern bool nfc_debug_enabled;
+
+namespace android {
+namespace hardware {
+namespace nfc {
+namespace V1_1 {
+namespace implementation {
+
+sp<V1_1::INfcClientCallback> Nfc::mCallbackV1_1 = nullptr;
+sp<V1_0::INfcClientCallback> Nfc::mCallbackV1_0 = nullptr;
+
+Return<V1_0::NfcStatus> Nfc::open_1_1(
+    const sp<V1_1::INfcClientCallback>& clientCallback) {
+  if (clientCallback == nullptr) {
+    ALOGD_IF(nfc_debug_enabled, "Nfc::open null callback");
+    return V1_0::NfcStatus::FAILED;
+  } else {
+    mCallbackV1_1 = clientCallback;
+    mCallbackV1_1->linkToDeath(this, 0 /*cookie*/);
+  }
+  return open(clientCallback);
+}
+
+// Methods from ::android::hardware::nfc::V1_0::INfc follow.
+Return<V1_0::NfcStatus> Nfc::open(
+    const sp<V1_0::INfcClientCallback>& clientCallback) {
+  ALOGD_IF(nfc_debug_enabled, "Nfc::open Enter");
+  if (clientCallback == nullptr) {
+    ALOGD_IF(nfc_debug_enabled, "Nfc::open null callback");
+    return V1_0::NfcStatus::FAILED;
+  } else {
+    mCallbackV1_0 = clientCallback;
+    mCallbackV1_0->linkToDeath(this, 0 /*cookie*/);
+  }
+
+  NFCSTATUS status = phNxpNciHal_open(eventCallback, dataCallback);
+  ALOGD_IF(nfc_debug_enabled, "Nfc::open Exit");
+  return CHK_STATUS(status);
+}
+
+Return<uint32_t> Nfc::write(const hidl_vec<uint8_t>& data) {
+  hidl_vec<uint8_t> copy = data;
+  return phNxpNciHal_write(copy.size(), &copy[0]);
+}
+
+Return<V1_0::NfcStatus> Nfc::coreInitialized(const hidl_vec<uint8_t>& data) {
+  hidl_vec<uint8_t> copy = data;
+  NFCSTATUS status = phNxpNciHal_core_initialized(copy.size(), &copy[0]);
+  return CHK_STATUS(status);
+}
+
+Return<V1_0::NfcStatus> Nfc::prediscover() {
+  NFCSTATUS status = phNxpNciHal_pre_discover();
+  return CHK_STATUS(status);
+}
+
+Return<V1_0::NfcStatus> Nfc::close() {
+  if (mCallbackV1_1 == nullptr && mCallbackV1_0 == nullptr) {
+    return V1_0::NfcStatus::FAILED;
+  }
+  NFCSTATUS status = phNxpNciHal_close(false);
+
+  if (mCallbackV1_1 != nullptr) {
+    mCallbackV1_1->unlinkToDeath(this);
+    mCallbackV1_1 = nullptr;
+  }
+  if (mCallbackV1_0 != nullptr) {
+    mCallbackV1_0->unlinkToDeath(this);
+    mCallbackV1_0 = nullptr;
+  }
+  return CHK_STATUS(status);
+}
+
+Return<V1_0::NfcStatus> Nfc::controlGranted() {
+  NFCSTATUS status = phNxpNciHal_control_granted();
+  return CHK_STATUS(status);
+}
+
+Return<V1_0::NfcStatus> Nfc::powerCycle() {
+  NFCSTATUS status = phNxpNciHal_power_cycle();
+  return CHK_STATUS(status);
+}
+
+// Methods from ::android::hardware::nfc::V1_1::INfc follow.
+Return<void> Nfc::factoryReset() {
+  phNxpNciHal_do_factory_reset();
+  return Void();
+}
+
+Return<V1_0::NfcStatus> Nfc::closeForPowerOffCase() {
+  if (mCallbackV1_1 == nullptr && mCallbackV1_0 == nullptr) {
+    return V1_0::NfcStatus::FAILED;
+  }
+  NFCSTATUS status = phNxpNciHal_configDiscShutdown();
+
+  if (mCallbackV1_1 != nullptr) {
+    mCallbackV1_1->unlinkToDeath(this);
+    mCallbackV1_1 = nullptr;
+  }
+  if (mCallbackV1_0 != nullptr) {
+    mCallbackV1_0->unlinkToDeath(this);
+    mCallbackV1_0 = nullptr;
+  }
+  return CHK_STATUS(status);
+}
+
+Return<void> Nfc::getConfig(getConfig_cb hidl_cb) {
+  NfcConfig nfcVendorConfig;
+  phNxpNciHal_getVendorConfig(nfcVendorConfig);
+  hidl_cb(nfcVendorConfig);
+  return Void();
+}
+
+}  // namespace implementation
+}  // namespace V1_1
+}  // namespace nfc
+}  // namespace hardware
+}  // namespace android
diff --git a/pn72xx/1.1/Nfc.h b/pn72xx/1.1/Nfc.h
new file mode 100644
index 00000000..ef467def
--- /dev/null
+++ b/pn72xx/1.1/Nfc.h
@@ -0,0 +1,112 @@
+/******************************************************************************
+ *
+ *  Copyright 2018 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef ANDROID_HARDWARE_NFC_V1_1_NFC_H
+#define ANDROID_HARDWARE_NFC_V1_1_NFC_H
+
+#include <android/hardware/nfc/1.1/INfc.h>
+#include <android/hardware/nfc/1.1/types.h>
+#include <hidl/MQDescriptor.h>
+#include <hidl/Status.h>
+#include <log/log.h>
+
+namespace android {
+namespace hardware {
+namespace nfc {
+namespace V1_1 {
+namespace implementation {
+
+using ::android::sp;
+using ::android::hardware::hidl_array;
+using ::android::hardware::hidl_memory;
+using ::android::hardware::hidl_string;
+using ::android::hardware::hidl_vec;
+using ::android::hardware::Return;
+using ::android::hardware::Void;
+using ::android::hardware::nfc::V1_1::INfc;
+using ::android::hidl::base::V1_0::IBase;
+struct Nfc : public V1_1::INfc, public hidl_death_recipient {
+ public:
+  // Methods from ::android::hardware::nfc::V1_0::INfc follow.
+  Return<V1_0::NfcStatus> open(
+      const sp<V1_0::INfcClientCallback>& clientCallback) override;
+  Return<V1_0::NfcStatus> open_1_1(
+      const sp<V1_1::INfcClientCallback>& clientCallback) override;
+  Return<uint32_t> write(const hidl_vec<uint8_t>& data) override;
+  Return<V1_0::NfcStatus> coreInitialized(
+      const hidl_vec<uint8_t>& data) override;
+  Return<V1_0::NfcStatus> prediscover() override;
+  Return<V1_0::NfcStatus> close() override;
+  Return<V1_0::NfcStatus> controlGranted() override;
+  Return<V1_0::NfcStatus> powerCycle() override;
+
+  // Methods from ::android::hardware::nfc::V1_1::INfc follow.
+  Return<void> factoryReset();
+  Return<V1_0::NfcStatus> closeForPowerOffCase();
+  Return<void> getConfig(getConfig_cb config);
+
+  // Methods from ::android::hidl::base::V1_0::IBase follow.
+
+  static void eventCallback(uint8_t event, uint8_t status) {
+    if (mCallbackV1_1 != nullptr) {
+      auto ret = mCallbackV1_1->sendEvent_1_1((V1_1::NfcEvent)event,
+                                              (V1_0::NfcStatus)status);
+      if (!ret.isOk()) {
+        ALOGW("failed to send event!!!");
+      }
+    } else if (mCallbackV1_0 != nullptr) {
+      auto ret = mCallbackV1_0->sendEvent((V1_0::NfcEvent)event,
+                                          (V1_0::NfcStatus)status);
+      if (!ret.isOk()) {
+        ALOGE("failed to send event!!!");
+      }
+    }
+  }
+
+  static void dataCallback(uint16_t data_len, uint8_t* p_data) {
+    hidl_vec<uint8_t> data;
+    data.setToExternal(p_data, data_len);
+    if (mCallbackV1_1 != nullptr) {
+      auto ret = mCallbackV1_1->sendData(data);
+      if (!ret.isOk()) {
+        ALOGW("failed to send data!!!");
+      }
+    } else if (mCallbackV1_0 != nullptr) {
+      auto ret = mCallbackV1_0->sendData(data);
+      if (!ret.isOk()) {
+        ALOGE("failed to send data!!!");
+      }
+    }
+  }
+
+  virtual void serviceDied(uint64_t /*cookie*/, const wp<IBase>& /*who*/) {
+    close();
+  }
+
+ private:
+  static sp<V1_1::INfcClientCallback> mCallbackV1_1;
+  static sp<V1_0::INfcClientCallback> mCallbackV1_0;
+};
+
+}  // namespace implementation
+}  // namespace V1_1
+}  // namespace nfc
+}  // namespace hardware
+}  // namespace android
+
+#endif  // ANDROID_HARDWARE_NFC_V1_1_NFC_H
diff --git a/pn72xx/1.1/NxpNfcService.cpp b/pn72xx/1.1/NxpNfcService.cpp
new file mode 100644
index 00000000..3d7ea648
--- /dev/null
+++ b/pn72xx/1.1/NxpNfcService.cpp
@@ -0,0 +1,80 @@
+/******************************************************************************
+ *
+ *  Copyright 2018-2020 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "nxpnfc@1.0-service"
+#include <android/hardware/nfc/1.1/INfc.h>
+#include <unistd.h>
+#include <vendor/nxp/nxpnfc/2.0/INxpNfc.h>
+
+#include <hidl/LegacySupport.h>
+#include "Nfc.h"
+#include "NxpNfc.h"
+#include "eSEClientExtns.h"
+
+// Generated HIDL files
+using android::OK;
+using android::sp;
+using android::status_t;
+using android::hardware::configureRpcThreadpool;
+using android::hardware::joinRpcThreadpool;
+using android::hardware::nfc::V1_1::INfc;
+using android::hardware::nfc::V1_1::implementation::Nfc;
+using vendor::nxp::nxpnfc::V2_0::INxpNfc;
+using vendor::nxp::nxpnfc::V2_0::implementation::NxpNfc;
+
+int main() {
+  status_t status;
+
+  sp<INfc> nfc_service = nullptr;
+  sp<INxpNfc> nxp_nfc_service = nullptr;
+
+  ALOGD("NFC HAL Service 1.1 is starting.");
+  nfc_service = new Nfc();
+  if (nfc_service == nullptr) {
+    ALOGE("Can not create an instance of NFC HAL Iface, exiting.");
+    return -1;
+  }
+
+  initializeEseClient();
+  configureRpcThreadpool(1, true /*callerWillJoin*/);
+  checkEseClientUpdate();
+  status = nfc_service->registerAsService();
+  if (status != OK) {
+    LOG_ALWAYS_FATAL("Could not register service for NFC HAL Iface (%d).",
+                     status);
+    return -1;
+  }
+
+  ALOGI("NXP NFC Extn Service 1.0 is starting.");
+  nxp_nfc_service = new NxpNfc();
+  if (nxp_nfc_service == nullptr) {
+    ALOGE("Can not create an instance of NXP NFC Extn Iface, exiting.");
+    return -1;
+  }
+
+  status = nxp_nfc_service->registerAsService();
+  if (status != OK) {
+    ALOGE("Could not register service for NXP NFC Extn Iface (%d).", status);
+  }
+  ALOGE("Before calling JCOP JCOS_doDownload");
+  perform_eSEClientUpdate();
+  ALOGE("After calling JCOS_doDownload");
+  ALOGI("NFC service is ready");
+  joinRpcThreadpool();
+  return 1;
+}
diff --git a/pn72xx/1.1/android.hardware.nfc_pn72xx@1.1-service.rc b/pn72xx/1.1/android.hardware.nfc_pn72xx@1.1-service.rc
new file mode 100644
index 00000000..7f086268
--- /dev/null
+++ b/pn72xx/1.1/android.hardware.nfc_pn72xx@1.1-service.rc
@@ -0,0 +1,4 @@
+service vendor.nfc_hal_service /vendor/bin/hw/android.hardware.nfc_pn72xx@1.1-service
+    class hal
+    user nfc
+    group nfc
diff --git a/pn72xx/1.2/Nfc.cpp b/pn72xx/1.2/Nfc.cpp
new file mode 100644
index 00000000..542cf9f6
--- /dev/null
+++ b/pn72xx/1.2/Nfc.cpp
@@ -0,0 +1,191 @@
+/******************************************************************************
+ *
+ *  Copyright 2019-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "android.hardware.nfc@1.2-impl"
+#include "Nfc.h"
+#include "halimpl/inc/phNxpNciHal_Adaptation.h"
+#include "phNfcStatus.h"
+#include <log/log.h>
+#include <memunreachable/memunreachable.h>
+
+#define CHK_STATUS(x) \
+  ((x) == NFCSTATUS_SUCCESS) ? (V1_0::NfcStatus::OK) : (V1_0::NfcStatus::FAILED)
+
+#define NXP_EN_PN7150 1
+#define NXP_EN_PN7160 1
+#define NXP_EN_PN7220 1
+#define NFC_NXP_MW_ANDROID_VER (13U)   /* Android version used by NFC MW */
+#define NFC_NXP_MW_VERSION_MAJ (0x04)  /* MW Major Version */
+#define NFC_NXP_MW_VERSION_MIN (0x00)  /* MW Minor Version */
+
+extern bool nfc_debug_enabled;
+
+namespace android {
+namespace hardware {
+namespace nfc {
+namespace V1_2 {
+namespace implementation {
+
+sp<V1_1::INfcClientCallback> Nfc::mCallbackV1_1 = nullptr;
+sp<V1_0::INfcClientCallback> Nfc::mCallbackV1_0 = nullptr;
+
+static void printNfcMwVersion() {
+  uint32_t validation = (NXP_EN_PN7220 << 2);
+
+  ALOGE("MW-HAL Version: NFC_AR_INFRA_%04X_%02d.%02x.%02x",
+        validation, NFC_NXP_MW_ANDROID_VER,
+        NFC_NXP_MW_VERSION_MAJ, NFC_NXP_MW_VERSION_MIN);
+}
+
+Return<V1_0::NfcStatus> Nfc::open_1_1(
+    const sp<V1_1::INfcClientCallback>& clientCallback) {
+  if (clientCallback == nullptr) {
+    ALOGD_IF(nfc_debug_enabled, "Nfc::open null callback");
+    return V1_0::NfcStatus::FAILED;
+  } else {
+    mCallbackV1_1 = clientCallback;
+    mCallbackV1_1->linkToDeath(this, 0 /*cookie*/);
+  }
+  return open(clientCallback);
+}
+
+// Methods from ::android::hardware::nfc::V1_0::INfc follow.
+Return<V1_0::NfcStatus> Nfc::open(
+    const sp<V1_0::INfcClientCallback>& clientCallback) {
+  ALOGD_IF(nfc_debug_enabled, "Nfc::open Enter");
+  if (clientCallback == nullptr) {
+    ALOGD_IF(nfc_debug_enabled, "Nfc::open null callback");
+    return V1_0::NfcStatus::FAILED;
+  } else {
+    mCallbackV1_0 = clientCallback;
+    mCallbackV1_0->linkToDeath(this, 0 /*cookie*/);
+  }
+
+  printNfcMwVersion();
+  NFCSTATUS status = phNxpNciHal_open(eventCallback, dataCallback);
+  ALOGD_IF(nfc_debug_enabled, "Nfc::open Exit");
+  return CHK_STATUS(status);
+}
+
+Return<uint32_t> Nfc::write(const hidl_vec<uint8_t>& data) {
+  hidl_vec<uint8_t> copy = data;
+  return phNxpNciHal_write(copy.size(), &copy[0]);
+}
+
+Return<V1_0::NfcStatus> Nfc::coreInitialized(const hidl_vec<uint8_t>& data) {
+  hidl_vec<uint8_t> copy = data;
+  NFCSTATUS status = phNxpNciHal_core_initialized(copy.size(), &copy[0]);
+  return CHK_STATUS(status);
+}
+
+Return<V1_0::NfcStatus> Nfc::prediscover() {
+  NFCSTATUS status = phNxpNciHal_pre_discover();
+  return CHK_STATUS(status);
+}
+
+Return<V1_0::NfcStatus> Nfc::close() {
+  if (mCallbackV1_1 == nullptr && mCallbackV1_0 == nullptr) {
+    return V1_0::NfcStatus::FAILED;
+  }
+  NFCSTATUS status = phNxpNciHal_close(false);
+
+  if (mCallbackV1_1 != nullptr) {
+    mCallbackV1_1->unlinkToDeath(this);
+    mCallbackV1_1 = nullptr;
+  }
+  if (mCallbackV1_0 != nullptr) {
+    mCallbackV1_0->unlinkToDeath(this);
+    mCallbackV1_0 = nullptr;
+  }
+  return CHK_STATUS(status);
+}
+
+Return<V1_0::NfcStatus> Nfc::controlGranted() {
+  NFCSTATUS status = phNxpNciHal_control_granted();
+  return CHK_STATUS(status);
+}
+
+Return<V1_0::NfcStatus> Nfc::powerCycle() {
+  NFCSTATUS status = phNxpNciHal_power_cycle();
+  return CHK_STATUS(status);
+}
+
+// Methods from ::android::hardware::nfc::V1_1::INfc follow.
+Return<void> Nfc::factoryReset() {
+  phNxpNciHal_do_factory_reset();
+  return Void();
+}
+
+Return<V1_0::NfcStatus> Nfc::closeForPowerOffCase() {
+  if (mCallbackV1_1 == nullptr && mCallbackV1_0 == nullptr) {
+    return V1_0::NfcStatus::FAILED;
+  }
+  NFCSTATUS status = phNxpNciHal_configDiscShutdown();
+
+  if (mCallbackV1_1 != nullptr) {
+    mCallbackV1_1->unlinkToDeath(this);
+    mCallbackV1_1 = nullptr;
+  }
+  if (mCallbackV1_0 != nullptr) {
+    mCallbackV1_0->unlinkToDeath(this);
+    mCallbackV1_0 = nullptr;
+  }
+  return CHK_STATUS(status);
+}
+
+Return<void> Nfc::getConfig(getConfig_cb hidl_cb) {
+  android::hardware::nfc::V1_1::NfcConfig nfcVendorConfig;
+  phNxpNciHal_getVendorConfig(nfcVendorConfig);
+  hidl_cb(nfcVendorConfig);
+  return Void();
+}
+
+Return<void> Nfc::getConfig_1_2(getConfig_1_2_cb hidl_cb) {
+  NfcConfig nfcVendorConfig;
+  phNxpNciHal_getVendorConfig_1_2(nfcVendorConfig);
+  hidl_cb(nfcVendorConfig);
+  return Void();
+}
+
+void Nfc::serviceDied(uint64_t /*cookie*/, const wp<IBase>& /*who*/) {
+  if (mCallbackV1_1 == nullptr && mCallbackV1_0 == nullptr) {
+    return;
+  }
+  phNxpNciHal_close(true);
+
+  if (mCallbackV1_1 != nullptr) {
+    mCallbackV1_1->unlinkToDeath(this);
+    mCallbackV1_1 = nullptr;
+  }
+  if (mCallbackV1_0 != nullptr) {
+    mCallbackV1_0->unlinkToDeath(this);
+    mCallbackV1_0 = nullptr;
+  }
+}
+Return<void> Nfc::debug(const hidl_handle & /* fd */,
+                        const hidl_vec<hidl_string> & /* options */) {
+  ALOGD_IF(nfc_debug_enabled, "\n Nfc HAL MemoryLeak Info =  %s \n",
+           android::GetUnreachableMemoryString(true, 10000).c_str());
+  return Void();
+}
+
+}  // namespace implementation
+}  // namespace V1_2
+}  // namespace nfc
+}  // namespace hardware
+}  // namespace android
diff --git a/pn72xx/1.2/Nfc.h b/pn72xx/1.2/Nfc.h
new file mode 100644
index 00000000..68b31d76
--- /dev/null
+++ b/pn72xx/1.2/Nfc.h
@@ -0,0 +1,114 @@
+/******************************************************************************
+ *
+ *  Copyright 2019-2021,2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef ANDROID_HARDWARE_NFC_V1_2_NFC_H
+#define ANDROID_HARDWARE_NFC_V1_2_NFC_H
+
+#include <android/hardware/nfc/1.2/INfc.h>
+#include <android/hardware/nfc/1.2/types.h>
+#include <hidl/MQDescriptor.h>
+#include <hidl/Status.h>
+#include <log/log.h>
+
+namespace android {
+namespace hardware {
+namespace nfc {
+namespace V1_2 {
+namespace implementation {
+
+using ::android::sp;
+using ::android::hardware::hidl_array;
+using ::android::hardware::hidl_memory;
+using ::android::hardware::hidl_string;
+using ::android::hardware::hidl_vec;
+using ::android::hardware::Return;
+using ::android::hardware::Void;
+using ::android::hardware::nfc::V1_2::INfc;
+using ::android::hidl::base::V1_0::IBase;
+struct Nfc : public V1_2::INfc, public hidl_death_recipient {
+ public:
+   // Methods from ::android::hidl::base::V1_0::IBase follow.
+   Return<void> debug(const hidl_handle &handle,
+                      const hidl_vec<hidl_string> &options) override;
+   // Methods from ::android::hardware::nfc::V1_0::INfc follow.
+   Return<V1_0::NfcStatus>
+   open(const sp<V1_0::INfcClientCallback> &clientCallback) override;
+   Return<V1_0::NfcStatus>
+   open_1_1(const sp<V1_1::INfcClientCallback> &clientCallback) override;
+   Return<uint32_t> write(const hidl_vec<uint8_t> &data) override;
+   Return<V1_0::NfcStatus>
+   coreInitialized(const hidl_vec<uint8_t> &data) override;
+   Return<V1_0::NfcStatus> prediscover() override;
+   Return<V1_0::NfcStatus> close() override;
+   Return<V1_0::NfcStatus> controlGranted() override;
+   Return<V1_0::NfcStatus> powerCycle() override;
+
+   // Methods from ::android::hardware::nfc::V1_1::INfc follow.
+   Return<void> factoryReset();
+   Return<V1_0::NfcStatus> closeForPowerOffCase();
+   Return<void> getConfig(getConfig_cb config);
+   Return<void> getConfig_1_2(getConfig_1_2_cb config);
+
+   // Methods from ::android::hidl::base::V1_0::IBase follow.
+
+   static void eventCallback(uint8_t event, uint8_t status) {
+     if (mCallbackV1_1 != nullptr) {
+       auto ret = mCallbackV1_1->sendEvent_1_1((V1_1::NfcEvent)event,
+                                               (V1_0::NfcStatus)status);
+       if (!ret.isOk()) {
+         ALOGW("failed to send event!!!");
+       }
+     } else if (mCallbackV1_0 != nullptr) {
+       auto ret = mCallbackV1_0->sendEvent((V1_0::NfcEvent)event,
+                                           (V1_0::NfcStatus)status);
+       if (!ret.isOk()) {
+         ALOGE("failed to send event!!!");
+       }
+     }
+  }
+
+  static void dataCallback(uint16_t data_len, uint8_t* p_data) {
+    hidl_vec<uint8_t> data;
+    data.setToExternal(p_data, data_len);
+    if (mCallbackV1_1 != nullptr) {
+      auto ret = mCallbackV1_1->sendData(data);
+      if (!ret.isOk()) {
+        ALOGW("failed to send data!!!");
+      }
+    } else if (mCallbackV1_0 != nullptr) {
+      auto ret = mCallbackV1_0->sendData(data);
+      if (!ret.isOk()) {
+        ALOGE("failed to send data!!!");
+      }
+    }
+  }
+
+  virtual void serviceDied(uint64_t /*cookie*/, const wp<IBase>& /*who*/);
+
+ private:
+  static sp<V1_1::INfcClientCallback> mCallbackV1_1;
+  static sp<V1_0::INfcClientCallback> mCallbackV1_0;
+};
+
+}  // namespace implementation
+}  // namespace V1_2
+}  // namespace nfc
+}  // namespace hardware
+}  // namespace android
+
+#endif  // ANDROID_HARDWARE_NFC_V1_2_NFC_H
diff --git a/pn72xx/1.2/NxpNfcService.cpp b/pn72xx/1.2/NxpNfcService.cpp
new file mode 100644
index 00000000..364b855a
--- /dev/null
+++ b/pn72xx/1.2/NxpNfcService.cpp
@@ -0,0 +1,78 @@
+/******************************************************************************
+ *
+ *  Copyright 2019-2021,2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "nxpnfc@2.0-service"
+#include <android/hardware/nfc/1.1/INfc.h>
+#include <unistd.h>
+#include <vendor/nxp/nxpnfc/2.0/INxpNfc.h>
+
+#include <hidl/LegacySupport.h>
+#include "Nfc.h"
+#include "NxpNfc.h"
+
+// Generated HIDL files
+using android::OK;
+using android::sp;
+using android::status_t;
+using android::hardware::configureRpcThreadpool;
+using android::hardware::joinRpcThreadpool;
+using android::hardware::nfc::V1_2::INfc;
+using android::hardware::nfc::V1_2::implementation::Nfc;
+using vendor::nxp::nxpnfc::V2_0::INxpNfc;
+using vendor::nxp::nxpnfc::V2_0::implementation::NxpNfc;
+
+int main() {
+  status_t status;
+
+  sp<INfc> nfc_service = nullptr;
+  sp<INxpNfc> nxp_nfc_service = nullptr;
+
+  try {
+    ALOGD("NFC HAL Service 1.2 is starting.");
+    nfc_service = new Nfc();
+    if (nfc_service == nullptr) {
+      ALOGE("Can not create an instance of NFC HAL Iface, exiting.");
+      return -1;
+    }
+
+    configureRpcThreadpool(1, true /*callerWillJoin*/);
+    status = nfc_service->registerAsService();
+    if (status != OK) {
+      LOG_ALWAYS_FATAL("Could not register service for NFC HAL Iface (%d).",
+                       status);
+      return -1;
+    }
+
+    ALOGI("NXP NFC Extn Service 1.0 is starting.");
+    nxp_nfc_service = new NxpNfc();
+    if (nxp_nfc_service == nullptr) {
+      ALOGE("Can not create an instance of NXP NFC Extn Iface, exiting.");
+      return -1;
+    }
+    status = nxp_nfc_service->registerAsService();
+    if (status != OK) {
+      ALOGE("Could not register service for NXP NFC Extn Iface (%d).", status);
+    }
+    ALOGI("NFC service is ready");
+    joinRpcThreadpool();
+  } catch (const std::length_error& le) {
+  } catch (const std::__1::ios_base::failure& e) {
+  } catch (std::__1::system_error& e) {
+  }
+  return 1;
+}
diff --git a/pn72xx/1.2/android.hardware.nfc_pn72xx@1.2-service.rc b/pn72xx/1.2/android.hardware.nfc_pn72xx@1.2-service.rc
new file mode 100644
index 00000000..d27a9ace
--- /dev/null
+++ b/pn72xx/1.2/android.hardware.nfc_pn72xx@1.2-service.rc
@@ -0,0 +1,4 @@
+service vendor.nfc_hal_service /vendor/bin/hw/android.hardware.nfc_pn72xx@1.2-service
+    class hal
+    user nfc
+    group nfc
diff --git a/pn72xx/Android.bp b/pn72xx/Android.bp
new file mode 100644
index 00000000..b60d5f98
--- /dev/null
+++ b/pn72xx/Android.bp
@@ -0,0 +1,153 @@
+//
+// Copyright (C) 2018-2019 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "hardware_nxp_nfc_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["hardware_nxp_nfc_license"],
+}
+
+cc_library_shared {
+    name: "nfc_nci_nxp_pn72xx",
+    defaults: ["hidl_defaults"],
+    proprietary: true,
+
+    cflags: [
+        "-Wall",
+        "-Werror",
+        "-Wextra",
+        "-DNXP_EXTNS=TRUE",
+        "-DNXP_SRD=TRUE",
+        "-DNXP_NFC_RECOVERY=TRUE",
+        "-DNXP_QTAG=TRUE",
+        "-DNXP_FORCE_FW_DOWNLOAD=1"
+    ],
+    srcs: [
+        "halimpl/dnld/phDnldNfc.cc",
+        "halimpl/dnld/phDnldNfc_Internal.cc",
+        "halimpl/dnld/phDnldNfc_Utils.cc",
+        "halimpl/dnld/phNxpNciHal_Dnld.cc",
+        "halimpl/hal/phNxpNciHal.cc",
+        "halimpl/hal/phNxpNciHal_dta.cc",
+        "halimpl/hal/phNxpNciHal_ext.cc",
+        "halimpl/log/phNxpLog.cc",
+        "halimpl/tml/phDal4Nfc_messageQueueLib.cc",
+        "halimpl/tml/phOsalNfc_Timer.cc",
+        "halimpl/tml/phTmlNfc.cc",
+        "halimpl/tml/NfccTransportFactory.cc",
+        "halimpl/tml/transport/*.cc",
+        "halimpl/utils/NxpNfcCapability.cc",
+        "halimpl/utils/NxpNfcThreadMutex.cc",
+        "halimpl/utils/phNxpConfig.cc",
+        "halimpl/utils/phNxpNciHal_utils.cc",
+        "halimpl/utils/sparse_crc32.cc",
+        "halimpl/hal/phNxpNciHal_IoctlOperations.cc",
+        "halimpl/hal/phNxpNciHal_extOperations.cc",
+        "halimpl/mifare/NxpMfcReader.cc",
+    ],
+
+    local_include_dirs: [
+        "halimpl/common",
+        "halimpl/dnld",
+        "halimpl/hal",
+        "halimpl/inc",
+        "halimpl/log",
+        "halimpl/tml/transport",
+        "halimpl/tml",
+        "halimpl/utils",
+        "halimpl/src/include",
+        "halimpl/mifare",
+        "extns/impl/nxpnfc/2.0",
+    ],
+
+    include_dirs: [
+        "hardware/nxp/secure_element/snxxx/extns/impl",
+    ],
+
+    shared_libs: [
+        "android.hardware.nfc@1.0",
+        "android.hardware.nfc@1.1",
+        "android.hardware.nfc@1.2",
+        "android.hardware.secure_element@1.0",
+        "libbase",
+        "libcutils",
+        "libdl",
+        "libhardware",
+        "libhardware_legacy",
+        "libhidlbase",
+        "liblog",
+        "libutils",
+        "vendor.nxp.nxpese@1.0",
+        "vendor.nxp.nxpnfc@2.0",
+    ],
+}
+
+cc_binary {
+    name: "android.hardware.nfc_pn72xx@1.2-service",
+    defaults: ["hidl_defaults"],
+    proprietary: true,
+    init_rc: ["1.2/android.hardware.nfc_pn72xx@1.2-service.rc"],
+    relative_install_path: "hw",
+    cflags: [
+         "-Wall",
+         "-Werror",
+         "-Wextra",
+         "-fexceptions",
+         "-DNXP_EXTNS=TRUE",
+         "-DNXP_NFC_RECOVERY=TRUE"
+     ],
+
+    srcs: [
+        "1.2/NxpNfcService.cpp",
+        "1.2/Nfc.cpp",
+        "extns/impl/nxpnfc/2.0/NxpNfc.cpp",
+    ],
+
+    shared_libs: [
+        "nfc_nci_nxp_pn72xx",
+        "libbase",
+        "libcutils",
+        "libdl",
+        "libhardware",
+        "liblog",
+        "libutils",
+        "android.hardware.nfc@1.0",
+        "android.hardware.nfc@1.1",
+        "android.hardware.nfc@1.2",
+        "libhidlbase",
+        "vendor.nxp.nxpese@1.0",
+        "vendor.nxp.nxpnfc@2.0",
+        "libmemunreachable",
+    ],
+
+    local_include_dirs: [
+        "halimpl/common",
+        "halimpl/dnld",
+        "halimpl/hal",
+        "halimpl/inc",
+        "halimpl/log",
+        "halimpl/tml",
+        "halimpl/utils",
+        "halimpl/mifare",
+        "extns/impl/nxpnfc/2.0",
+    ],
+
+    include_dirs: [
+        "hardware/nxp/secure_element/snxxx/extns/impl",
+    ],
+}
diff --git a/pn72xx/extns/impl/nxpnfc/2.0/NxpNfc.cpp b/pn72xx/extns/impl/nxpnfc/2.0/NxpNfc.cpp
new file mode 100644
index 00000000..19485bfa
--- /dev/null
+++ b/pn72xx/extns/impl/nxpnfc/2.0/NxpNfc.cpp
@@ -0,0 +1,79 @@
+/******************************************************************************
+ *
+ *  Copyright 2018-2021,2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <log/log.h>
+
+#include "NxpNfc.h"
+#include "phNxpNciHal.h"
+#include "phNxpNciHal_Adaptation.h"
+
+extern bool nfc_debug_enabled;
+
+namespace vendor {
+namespace nxp {
+namespace nxpnfc {
+namespace V2_0 {
+namespace implementation {
+
+Return<void> NxpNfc::getVendorParam(const ::android::hardware::hidl_string& key,
+                                    getVendorParam_cb _hidl_cb) {
+  string val = phNxpNciHal_getSystemProperty(key);
+  _hidl_cb(val);
+  return Void();
+}
+
+Return<bool> NxpNfc::setVendorParam(
+    const ::android::hardware::hidl_string& key,
+    const ::android::hardware::hidl_string& value) {
+  return phNxpNciHal_setSystemProperty(key, value);
+}
+
+Return<bool> NxpNfc::resetEse(uint64_t resetType) {
+  resetType = 0xff;
+  return false;
+}
+
+Return<bool> NxpNfc::setEseUpdateState(NxpNfcHalEseState eSEState) {
+  eSEState = NxpNfcHalEseState::HAL_NFC_ESE_JCOP_UPDATE_COMPLETED;
+  return false;
+}
+
+Return<bool> NxpNfc::setNxpTransitConfig(
+    const ::android::hardware::hidl_string& strval) {
+  bool status = true;
+  ALOGD("NxpNfc::setNxpTransitConfig Entry");
+
+  status = phNxpNciHal_setNxpTransitConfig((char*)strval.c_str());
+
+  ALOGD("NxpNfc::setNxpTransitConfig Exit");
+  return status;
+}
+
+Return<bool> NxpNfc::isJcopUpdateRequired() {
+  return false;
+}
+
+Return<bool> NxpNfc::isLsUpdateRequired() {
+  return false;
+}
+
+}  // namespace implementation
+}  // namespace V2_0
+}  // namespace nxpnfc
+}  // namespace nxp
+}  // namespace vendor
diff --git a/pn72xx/extns/impl/nxpnfc/2.0/NxpNfc.h b/pn72xx/extns/impl/nxpnfc/2.0/NxpNfc.h
new file mode 100644
index 00000000..a00f947c
--- /dev/null
+++ b/pn72xx/extns/impl/nxpnfc/2.0/NxpNfc.h
@@ -0,0 +1,62 @@
+/******************************************************************************
+ *
+ *  Copyright 2018-2020 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef VENDOR_NXP_NXPNFC_V2_0_NXPNFC_H
+#define VENDOR_NXP_NXPNFC_V2_0_NXPNFC_H
+
+#include <hidl/MQDescriptor.h>
+#include <hidl/Status.h>
+#include <vendor/nxp/nxpnfc/2.0/INxpNfc.h>
+
+enum Constants : uint16_t {
+  HAL_NFC_ESE_HARD_RESET = 5,
+};
+
+namespace vendor {
+namespace nxp {
+namespace nxpnfc {
+namespace V2_0 {
+namespace implementation {
+
+using ::android::hardware::hidl_vec;
+using ::android::hardware::Return;
+using ::android::hardware::Void;
+using ::android::hidl::base::V1_0::IBase;
+using ::vendor::nxp::nxpnfc::V2_0::INxpNfc;
+
+struct NxpNfc : public INxpNfc {
+  Return<void> getVendorParam(const ::android::hardware::hidl_string& key,
+                              getVendorParam_cb _hidl_cb) override;
+  Return<bool> setVendorParam(
+      const ::android::hardware::hidl_string& key,
+      const ::android::hardware::hidl_string& value) override;
+  Return<bool> resetEse(uint64_t resetType) override;
+  Return<bool> setEseUpdateState(NxpNfcHalEseState state) override;
+  Return<bool> setNxpTransitConfig(
+      const ::android::hardware::hidl_string& strval) override;
+  Return<bool> isJcopUpdateRequired() override;
+  Return<bool> isLsUpdateRequired() override;
+};
+
+}  // namespace implementation
+}  // namespace V2_0
+}  // namespace nxpnfc
+}  // namespace nxp
+}  // namespace vendor
+
+#endif  // VENDOR_NXP_NXPNFC_V2_0_NXPNFC_H
diff --git a/pn72xx/extns/impl/nxpnfc/2.0/Nxp_Features.h b/pn72xx/extns/impl/nxpnfc/2.0/Nxp_Features.h
new file mode 100644
index 00000000..d9e46c9b
--- /dev/null
+++ b/pn72xx/extns/impl/nxpnfc/2.0/Nxp_Features.h
@@ -0,0 +1,199 @@
+/******************************************************************************
+ *
+ *  Copyright 2018-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#if (NXP_EXTNS == TRUE)
+#include <stdint.h>
+#else
+#include <unistd.h>
+#endif
+#include <string>
+#ifndef NXP_FEATURES_H
+#define NXP_FEATURES_H
+
+#define STRMAX_2 100
+#define FW_MOBILE_MAJOR_NUMBER_SN100U 0x010
+#define FW_MOBILE_MAJOR_NUMBER_SN220U 0x01
+#define FW_MOBILE_MAJOR_NUMBER_PN7220 0x00
+
+/*Including T4T NFCEE by incrementing 1*/
+#define NFA_EE_MAX_EE_SUPPORTED 5
+
+#ifndef FW_LIB_ROOT_DIR
+#if (defined(__arm64__) || defined(__aarch64__) || defined(_M_ARM64))
+#define FW_LIB_ROOT_DIR "/vendor/lib64/"
+#else
+#define FW_LIB_ROOT_DIR "/vendor/lib/"
+#endif
+#endif
+#ifndef FW_BIN_ROOT_DIR
+#define FW_BIN_ROOT_DIR "/vendor/firmware/"
+#endif
+#ifndef FW_LIB_EXTENSION
+#define FW_LIB_EXTENSION ".so"
+#endif
+#ifndef FW_BIN_EXTENSION
+#define FW_BIN_EXTENSION ".bin"
+#endif
+using namespace std;
+typedef enum {
+  NFCC_DWNLD_WITH_VEN_RESET,
+  NFCC_DWNLD_WITH_NCI_CMD
+} tNFCC_DnldType;
+
+typedef enum {
+  DEFAULT_CHIP_TYPE = 0x00,
+  sn100u,
+  sn220u,
+  pn7220,
+  pn7221
+} tNFC_chipType;
+
+typedef struct {
+  /*Flags common to all chip types*/
+  uint8_t _NXP_NFCC_EMPTY_DATA_PACKET : 1;
+  uint8_t _GEMALTO_SE_SUPPORT : 1;
+  uint8_t _NFCC_I2C_READ_WRITE_IMPROVEMENT : 1;
+  uint8_t _NFCC_MIFARE_TIANJIN : 1;
+  uint8_t _NFCC_MW_RCVRY_BLK_FW_DNLD : 1;
+  uint8_t _NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH : 1;
+  uint8_t _NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH : 1;
+  uint8_t _NFCC_FW_WA : 1;
+  uint8_t _NFCC_FORCE_NCI1_0_INIT : 1;
+  uint8_t _NFCC_ROUTING_BLOCK_BIT : 1;
+  uint8_t _NFCC_SPI_FW_DOWNLOAD_SYNC : 1;
+  uint8_t _HW_ANTENNA_LOOP4_SELF_TEST : 1;
+  uint8_t _NFCEE_REMOVED_NTF_RECOVERY : 1;
+  uint8_t _NFCC_FORCE_FW_DOWNLOAD : 1;
+  uint8_t _UICC_CREATE_CONNECTIVITY_PIPE : 1;
+  uint8_t _NFCC_AID_MATCHING_PLATFORM_CONFIG : 1;
+  uint8_t _NFCC_ROUTING_BLOCK_BIT_PROP : 1;
+  uint8_t _NXP_NFC_UICC_ETSI12 : 1;
+  uint8_t _NFA_EE_MAX_EE_SUPPORTED : 3;
+  uint8_t _NFCC_DWNLD_MODE : 1;
+} tNfc_nfccFeatureList;
+
+typedef struct {
+  uint8_t _NFCC_RESET_RSP_LEN;
+} tNfc_platformFeatureList;
+
+typedef struct {
+  uint8_t _NCI_INTERFACE_UICC_DIRECT;
+  uint8_t _NCI_INTERFACE_ESE_DIRECT;
+  uint8_t _NCI_PWR_LINK_PARAM_CMD_SIZE;
+  uint8_t _NCI_EE_PWR_LINK_ALWAYS_ON;
+  uint8_t _NFA_EE_MAX_AID_ENTRIES;
+  uint8_t _NFC_NXP_AID_MAX_SIZE_DYN : 1;
+} tNfc_nfcMwFeatureList;
+
+typedef struct {
+  tNFC_chipType chipType;
+  std::string _FW_LIB_PATH;
+  std::string _PLATFORM_LIB_PATH;
+  std::string _PKU_LIB_PATH;
+  std::string _FW_BIN_PATH;
+  uint16_t _PHDNLDNFC_USERDATA_EEPROM_OFFSET;
+  uint16_t _PHDNLDNFC_USERDATA_EEPROM_LEN;
+  uint8_t _FW_MOBILE_MAJOR_NUMBER;
+  tNfc_nfccFeatureList nfccFL;
+  tNfc_platformFeatureList platformFL;
+  tNfc_nfcMwFeatureList nfcMwFL;
+} tNfc_featureList;
+
+extern tNfc_featureList nfcFL;
+
+#define CONFIGURE_FEATURELIST(chipType)                                       \
+  {                                                                           \
+    nfcFL.chipType = chipType;                                                \
+    if ((chipType == sn100u) || (chipType == sn220u)) {                       \
+      CONFIGURE_FEATURELIST_NFCC_WITH_ESE(chipType)                           \
+    } else {                                                                  \
+      CONFIGURE_FEATURELIST_NFCC(chipType)                                    \
+    }                                                                         \
+  }
+
+#define CONFIGURE_FEATURELIST_NFCC_WITH_ESE(chipType)                        \
+  {                                                                          \
+      CONFIGURE_FEATURELIST_NFCC(chipType)                                   \
+  }
+
+#define CONFIGURE_FEATURELIST_NFCC(chipType)                                   \
+  {                                                                            \
+    nfcFL.nfccFL._NXP_NFC_UICC_ETSI12 = false;                                 \
+    nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC = false;                           \
+                                                                               \
+    nfcFL.platformFL._NFCC_RESET_RSP_LEN = 0;                                  \
+                                                                               \
+    nfcFL.nfcMwFL._NCI_INTERFACE_UICC_DIRECT = 0x00;                           \
+    nfcFL.nfcMwFL._NCI_INTERFACE_ESE_DIRECT = 0x00;                            \
+    nfcFL.nfcMwFL._NCI_PWR_LINK_PARAM_CMD_SIZE = 0x02;                         \
+    nfcFL.nfcMwFL._NCI_EE_PWR_LINK_ALWAYS_ON = 0x01;                           \
+    nfcFL._PHDNLDNFC_USERDATA_EEPROM_OFFSET = 0x023CU;                         \
+    nfcFL._PHDNLDNFC_USERDATA_EEPROM_LEN = 0x0C80U;                            \
+    nfcFL._FW_MOBILE_MAJOR_NUMBER = FW_MOBILE_MAJOR_NUMBER_PN7220;             \
+    nfcFL.nfccFL._NFCC_DWNLD_MODE = NFCC_DWNLD_WITH_VEN_RESET;                 \
+                                                                               \
+    if (chipType >= pn7220) {                                                  \
+      nfcFL.nfccFL._NFCC_I2C_READ_WRITE_IMPROVEMENT = true;                    \
+      nfcFL.nfccFL._NFCC_MIFARE_TIANJIN = false;                               \
+      nfcFL.nfccFL._NFCC_MW_RCVRY_BLK_FW_DNLD = true;                          \
+      nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH = false;                 \
+      nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH = true;               \
+      nfcFL.nfccFL._NFCC_FW_WA = true;                                         \
+      nfcFL.nfccFL._NFCC_FORCE_NCI1_0_INIT = false;                            \
+      nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC = true;                          \
+      nfcFL.nfccFL._HW_ANTENNA_LOOP4_SELF_TEST = false;                        \
+      nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY = true;                         \
+      nfcFL.nfccFL._NFCC_FORCE_FW_DOWNLOAD = true;                             \
+      nfcFL.nfccFL._UICC_CREATE_CONNECTIVITY_PIPE = true;                      \
+      nfcFL.nfccFL._NXP_NFC_UICC_ETSI12 = false;                               \
+      nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED = 3;                               \
+                                                                               \
+      nfcFL.platformFL._NFCC_RESET_RSP_LEN = 0x10U;                            \
+                                                                               \
+      nfcFL.nfcMwFL._NCI_INTERFACE_UICC_DIRECT = 0x82;                         \
+      nfcFL.nfcMwFL._NCI_INTERFACE_ESE_DIRECT = 0x83;                          \
+                                                                               \
+      SRTCPY_FW("libpn72xx_fw", "libpn72xx_fw_platform", "libpn72xx_fw_pku")   \
+      STRCPY_FW_BIN("pn72xx")                                                  \
+    } else if (chipType == DEFAULT_CHIP_TYPE) {                                \
+      nfcFL.nfccFL._NFCC_FORCE_FW_DOWNLOAD = true;                             \
+    }                                                                          \
+  }
+#define STRCPY_FW_BIN(str)                       \
+  {                                              \
+    nfcFL._FW_BIN_PATH.clear();                  \
+    nfcFL._FW_BIN_PATH.append(FW_BIN_ROOT_DIR);  \
+    nfcFL._FW_BIN_PATH.append(str);              \
+    nfcFL._FW_BIN_PATH.append(FW_BIN_EXTENSION); \
+  }
+#define SRTCPY_FW(str1, str2, str3)                    \
+  {                                                    \
+    nfcFL._FW_LIB_PATH.clear();                        \
+    nfcFL._FW_LIB_PATH.append(FW_LIB_ROOT_DIR);        \
+    nfcFL._FW_LIB_PATH.append(str1);                   \
+    nfcFL._FW_LIB_PATH.append(FW_LIB_EXTENSION);       \
+    nfcFL._PLATFORM_LIB_PATH.clear();                  \
+    nfcFL._PLATFORM_LIB_PATH.append(FW_LIB_ROOT_DIR);  \
+    nfcFL._PLATFORM_LIB_PATH.append(str2);             \
+    nfcFL._PLATFORM_LIB_PATH.append(FW_LIB_EXTENSION); \
+    nfcFL._PKU_LIB_PATH.clear();                       \
+    nfcFL._PKU_LIB_PATH.append(FW_LIB_ROOT_DIR);       \
+    nfcFL._PKU_LIB_PATH.append(str3);                  \
+    nfcFL._PKU_LIB_PATH.append(FW_LIB_EXTENSION);      \
+  }
+#endif
diff --git a/pn72xx/halimpl/common/phNfcCommon.h b/pn72xx/halimpl/common/phNfcCommon.h
new file mode 100644
index 00000000..ee6ac851
--- /dev/null
+++ b/pn72xx/halimpl/common/phNfcCommon.h
@@ -0,0 +1,148 @@
+/******************************************************************************
+ *
+ *  Copyright 2010-2018, 2021,2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/*
+ *  OSAL header files related to memory, debug, random, semaphore and mutex
+ * functions.
+ */
+
+#ifndef PHNFCCOMMON_H
+#define PHNFCCOMMON_H
+
+/*
+************************* Include Files ****************************************
+*/
+
+#include <phDal4Nfc_messageQueueLib.h>
+#include <phNfcCompId.h>
+#include <phNfcStatus.h>
+#include <phOsalNfc_Timer.h>
+#include <pthread.h>
+#include <semaphore.h>
+
+#define FW_DLL_ROOT_DIR "/system/vendor/"
+#define FW_DLL_EXTENSION ".so"
+
+/* HAL Version number (Updated as per release) */
+#define NXP_MW_VERSION_MAJ (0x03)
+#define NXP_MW_VERSION_MIN (0x02)
+
+#define GET_EEPROM_DATA (1U)
+#define SET_EEPROM_DATA (2U)
+
+#define BITWISE (1U)
+#define BYTEWISE (2U)
+
+#define GET_FW_DWNLD_FLAG (1U)
+#define RESET_FW_DWNLD_FLAG (2U)
+
+#define FLASH_UPPER_VERSION (1)
+#define FLASH_DIFFERENT_VERSION (2)
+#define FLASH_ALWAYS (3)
+/*
+ *****************************************************************
+ ***********  System clock source selection configuration ********
+ *****************************************************************
+ */
+#define CLK_SRC_XTAL 1
+#define CLK_SRC_PLL 2
+
+/*Extern crystal clock source*/
+/* Use one of CLK_SRC_<value> */
+#define NXP_SYS_CLK_SRC_SEL CLK_SRC_XTAL
+/*Direct clock*/
+
+/*
+ *****************************************************************
+ ***********  System clock frequency selection configuration ****************
+ * If Clk_Src is set to PLL, make sure to set the Clk_Freq also*
+ *****************************************************************
+ */
+
+/*
+ * Currently only 24MHz, 32MHz, 48MHz and XTAL configuration supported,
+ * others are RFUs.
+ */
+#define CLK_FREQ_8MHZ 0
+#define CLK_FREQ_12MHZ 1
+#define CLK_FREQ_16MHZ 2
+#define CLK_FREQ_24MHZ 3
+#define CLK_FREQ_32MHZ 4
+#define CLK_FREQ_48MHZ 5
+#define CLK_FREQ_RFU 6
+#define CLK_FREQ_22_5MHZ_HFO 7
+#define CLK_FREQ_XTAL 8
+
+/* Set to one of CLK_FREQ_<value> */
+#define NXP_SYS_CLK_FREQ_SEL CLK_FREQ_XTAL
+
+#define CLK_REQ_DELAY_MIN 1
+#define CLK_REQ_DELAY_MAX 31
+#define CLK_REQ_DELAY_DEF 22
+#define CLK_REQ_DELAY_MASK 0x1F
+#define CLK_REQ_DELAY_PLL_OFFSET 13
+#define CLK_REQ_DELAY_XTAL_OFFSET 14
+/*
+ *  information to configure OSAL
+ */
+typedef struct phOsalNfc_Config {
+  uint8_t *pLogFile;            /* Log File Name*/
+  uintptr_t dwCallbackThreadId; /* Client ID to which message is posted */
+} phOsalNfc_Config_t, *pphOsalNfc_Config_t /* Pointer to #phOsalNfc_Config_t */;
+
+/*
+ * Deferred call declaration.
+ * This type of API is called from ClientApplication (main thread) to notify
+ * specific callback.
+ */
+typedef void (*pphOsalNfc_DeferFuncPointer_t)(void *);
+
+/*
+ * Deferred message specific info declaration.
+ */
+typedef struct phOsalNfc_DeferedCallInfo {
+  pphOsalNfc_DeferFuncPointer_t pDeferedCall; /* pointer to Deferred callback */
+  void *pParam; /* contains timer message specific details*/
+} phOsalNfc_DeferedCallInfo_t;
+
+/*
+ * States in which a OSAL timer exist.
+ */
+typedef enum {
+  eTimerIdle = 0,          /* Indicates Initial state of timer */
+  eTimerRunning = 1,       /* Indicate timer state when started */
+  eTimerStopped = 2        /* Indicates timer state when stopped */
+} phOsalNfc_TimerStates_t; /* Variable representing State of timer */
+
+/*
+ **Timer Handle structure containing details of a timer.
+ */
+typedef struct phOsalNfc_TimerHandle {
+  uint32_t TimerId;     /* ID of the timer */
+  timer_t hTimerHandle; /* Handle of the timer */
+  /* Timer callback function to be invoked */
+  pphOsalNfc_TimerCallbck_t Application_callback;
+  void *pContext; /* Parameter to be passed to the callback function */
+  phOsalNfc_TimerStates_t eState; /* Timer states */
+  /* Osal Timer message posted on User Thread */
+  phLibNfc_Message_t tOsalMessage;
+  /* Deferred Call structure to Invoke Callback function */
+  phOsalNfc_DeferedCallInfo_t tDeferedCallInfo;
+  /* Variables for Structure Instance and Structure Ptr */
+} phOsalNfc_TimerHandle_t, *pphOsalNfc_TimerHandle_t;
+
+#endif /*  PHOSALNFC_H  */
diff --git a/pn72xx/halimpl/common/phNfcCompId.h b/pn72xx/halimpl/common/phNfcCompId.h
new file mode 100644
index 00000000..9930e0c2
--- /dev/null
+++ b/pn72xx/halimpl/common/phNfcCompId.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2010-2014 NXP Semiconductors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * NFC Component ID Values - Used for Function Return Codes
+ */
+
+#ifndef PHNFCCOMPID_H
+#define PHNFCCOMPID_H
+
+/*
+ *  Component IDs
+ *
+ *  IDs for all NFC components. Combined with the Status Code they build the
+ * value (status)
+ *  returned by each function.
+ *
+ *  ID Number Spaces:
+ *  - 01..1F: HAL
+ *  - 20..3F: NFC-MW (Local Device)
+ *  - 40..5F: NFC-MW (Remote Device)
+ *  .
+ *
+ *         The value CID_NFC_NONE does not exist for Component IDs. Do not use
+ * this value except
+ *         for NFCSTATUS_SUCCESS. The enumeration function uses CID_NFC_NONE
+ *         to mark unassigned "References".
+ */
+/* Unassigned or doesn't apply (see #NFCSTATUS_SUCCESS) */
+#define CID_NFC_NONE 0x00
+#define CID_NFC_TML 0x01 /* Transport Mapping Layer */
+#define CID_NFC_LLC 0x07 /* Logical Link Control Layer */
+/* NFC Controller(NFCC) Interface Layer */
+#define CID_NFC_NCI 0x08
+/* Firmware Download Management Layer */
+#define CID_NFC_DNLD 0x09
+#define CID_NFC_HAL 0x10 /* Hardware Abstraction Layer */
+/* Operating System Abstraction Layer*/
+#define CID_NFC_OSAL CID_NFC_NONE
+#define CID_FRI_NFC_OVR_HAL 0x20       /* NFC-Device, HAL-based */
+#define CID_FRI_NFC_NDEF_RECORD 0x22   /* NDEF Record Tools Library. */
+#define CID_FRI_NFC_NDEF_MAP 0x23      /* NDEF Mapping. */
+#define CID_FRI_NFC_NDEF_REGISTRY 0x24 /* NDEF_REGISTRY. */
+/* Automatic Device Discovery. */
+#define CID_FRI_NFC_AUTO_DEV_DIS 0x25
+#define CID_FRI_NFC_NDEF_SMTCRDFMT 0x26 /* Smart Card Formatting */
+#define CID_NFC_LIB 0x30                /* NFC Library Layer*/
+/* The maximum CID value that is defined. */
+#define CID_MAX_VALUE 0xF0
+/* Logical Link Control Protocol */
+#define CID_FRI_NFC_LLCP 0x40
+#define CID_FRI_NFC_LLCP_TRANSPORT 0x50
+#define CID_FRI_NFC_LLCP_MAC 0x60
+
+#endif /* PHNFCCOMPID_H */
diff --git a/pn72xx/halimpl/common/phNfcStatus.h b/pn72xx/halimpl/common/phNfcStatus.h
new file mode 100644
index 00000000..b3085183
--- /dev/null
+++ b/pn72xx/halimpl/common/phNfcStatus.h
@@ -0,0 +1,393 @@
+/*
+ * Copyright 2010-2018, 2020-2021,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * NFC Status Values - Function Return Codes
+ */
+
+#ifndef PHNFCSTATUS_H
+#define PHNFCSTATUS_H
+
+#include <phNfcTypes.h>
+
+/* Internally required by PHNFCSTVAL. */
+#define PHNFCSTSHL8 (8U)
+/* Required by PHNFCSTVAL. */
+#define PHNFCSTBLOWER ((NFCSTATUS)(0x00FFU))
+
+/*
+ *  NFC Status Composition Macro
+ *
+ *  This is the macro which must be used to compose status values.
+ *
+ *  phNfcCompID Component ID, as defined in phNfcCompId.h .
+ *  phNfcStatus Status values, as defined in phNfcStatus.h .
+ *
+ *  The macro is not required for the NFCSTATUS_SUCCESS value.
+ *  This is the only return value to be used directly.
+ *  For all other values it shall be used in assignment and conditional
+ * statements, e.g.:
+ *     NFCSTATUS status = PHNFCSTVAL(phNfcCompID, phNfcStatus); ...
+ *     if (status == PHNFCSTVAL(phNfcCompID, phNfcStatus)) ...
+ */
+#define PHNFCSTVAL(phNfcCompID, phNfcStatus)                                   \
+  (((phNfcStatus) == (NFCSTATUS_SUCCESS))                                      \
+       ? (NFCSTATUS_SUCCESS)                                                   \
+       : ((((NFCSTATUS)(phNfcStatus)) & (PHNFCSTBLOWER)) |                     \
+          (((uint16_t)(phNfcCompID)) << (PHNFCSTSHL8))))
+
+/*
+ * PHNFCSTATUS
+ * Get grp_retval from Status Code
+ */
+#define PHNFCSTATUS(phNfcStatus) ((phNfcStatus)&0x00FFU)
+#define PHNFCCID(phNfcStatus) (((phNfcStatus)&0xFF00U) >> 8)
+
+#define PHNFC_I2C_FRAGMENT_SIZE 554
+/*
+ *  Status Codes
+ *
+ *  Generic Status codes for the NFC components. Combined with the Component ID
+ *  they build the value (status) returned by each function.
+ *  Example:
+ *      grp_comp_id "Component ID" -  e.g. 0x10, plus
+ *      status code as listed in this file - e.g. 0x03
+ *      result in a status value of 0x0003.
+ */
+
+/*
+ * The function indicates successful completion
+ */
+#define NFCSTATUS_SUCCESS (0x0000)
+
+/*
+ *  The function indicates successful completion
+ */
+#define NFCSTATUS_OK (NFCSTATUS_SUCCESS)
+
+/*
+ * At least one parameter could not be properly interpreted
+ */
+#define NFCSTATUS_INVALID_PARAMETER (0x0001)
+
+/*
+ * The buffer provided by the caller is too small
+ */
+#define NFCSTATUS_BUFFER_TOO_SMALL (0x0003)
+
+/*
+ * The function indicates given module not initialized
+ */
+#define NFC_STATUS_NOT_INITIALIZED_PROP (0x0004)
+
+/*
+ * The function indicates given module not initialized
+ */
+#define NFCSTATUS_FW_CHECK_INTEGRITY_FAILED (0x0005)
+
+/*
+ * Device specifier/handle value is invalid for the operation
+ */
+#define NFCSTATUS_INVALID_DEVICE (0x0006)
+
+/*
+ * The function executed successfully but could have returned
+ * more information than space provided by the caller
+ */
+#define NFCSTATUS_MORE_INFORMATION (0x0008)
+
+/*
+ * No response from the remote device received: Time-out
+ */
+#define NFCSTATUS_RF_TIMEOUT (0x0009)
+
+/*
+ * RF Error during data transaction with the remote device
+ */
+#define NFCSTATUS_RF_ERROR (0x000A)
+
+/*
+ * Not enough resources Memory, Timer etc(e.g. allocation failed.)
+ */
+#define NFCSTATUS_INSUFFICIENT_RESOURCES (0x000C)
+
+/*
+ * A non-blocking function returns this immediately to indicate
+ * that an internal operation is in progress
+ */
+#define NFCSTATUS_PENDING (0x000D)
+
+/*
+ * A board communication error occurred
+ * (e.g. Configuration went wrong)
+ */
+#define NFCSTATUS_BOARD_COMMUNICATION_ERROR (0x000F)
+
+/*
+ * Invalid State of the particular state machine
+ */
+#define NFCSTATUS_INVALID_STATE (0x0011)
+
+/*
+ * This Layer is Not initialized, hence initialization required.
+ */
+#define NFCSTATUS_NOT_INITIALISED (0x0031)
+
+/*
+ * The Layer is already initialized, hence initialization repeated.
+ */
+#define NFCSTATUS_ALREADY_INITIALISED (0x0032)
+
+/*
+ * Feature not supported
+ */
+#define NFCSTATUS_FEATURE_NOT_SUPPORTED (0x0033)
+
+/*  The Unregistration command has failed because the user wants to unregister
+ * on an element for which user was not registered
+ */
+#define NFCSTATUS_NOT_REGISTERED (0x0034)
+
+/* The Registration command has failed because the user wants to register on
+ * an element for which user is already registered
+ */
+#define NFCSTATUS_ALREADY_REGISTERED (0x0035)
+
+/*  Single Tag with Multiple
+    Protocol support detected */
+#define NFCSTATUS_MULTIPLE_PROTOCOLS (0x0036)
+
+/*
+ * Feature not supported
+ */
+#define NFCSTATUS_MULTIPLE_TAGS (0x0037)
+
+/*
+ * A DESELECT event has occurred
+ */
+#define NFCSTATUS_DESELECTED (0x0038)
+
+/*
+ * A RELEASE event has occurred
+ */
+#define NFCSTATUS_RELEASED (0x0039)
+
+/*
+ * The operation is currently not possible or not allowed
+ */
+#define NFCSTATUS_NOT_ALLOWED (0x003A)
+
+/*
+ * FW version error while performing FW download,
+ * FW major version mismatch (cannot downgrade FW major version) or FW version
+ * already upto date
+ * User may be trying to flash Mobile FW on top of Infra FW, which is not
+ * allowed
+ * Download appropriate version of FW
+ */
+#define NFCSTATUS_FW_VERSION_ERROR (0x003C)
+
+/*
+ *  The system is busy with the previous operation.
+ */
+#define NFCSTATUS_BUSY (0x006F)
+
+/* NDEF Mapping error codes */
+
+/* The remote device (type) is not valid for this request. */
+#define NFCSTATUS_INVALID_REMOTE_DEVICE (0x001D)
+
+/* Read operation failed */
+#define NFCSTATUS_READ_FAILED (0x0014)
+
+/*
+ * Write operation failed
+ */
+#define NFCSTATUS_WRITE_FAILED (0x0015)
+
+/* Non Ndef Compliant */
+#define NFCSTATUS_NO_NDEF_SUPPORT (0x0016)
+
+/* Could not proceed further with the write operation: reached card EOF*/
+#define NFCSTATUS_EOF_NDEF_CONTAINER_REACHED (0x001A)
+
+/* Incorrect number of bytes received from the card*/
+#define NFCSTATUS_INVALID_RECEIVE_LENGTH (0x001B)
+
+/* The data format/composition is not understood/correct. */
+#define NFCSTATUS_INVALID_FORMAT (0x001C)
+
+/* There is not sufficient storage available. */
+#define NFCSTATUS_INSUFFICIENT_STORAGE (0x001F)
+
+/* The Ndef Format procedure has failed. */
+#define NFCSTATUS_FORMAT_ERROR (0x0023)
+
+/* The NCI Cedit error */
+#define NFCSTATUS_CREDIT_TIMEOUT (0x0024)
+
+/*
+ * Response Time out for the control message(NFCC not responded)
+ */
+#define NFCSTATUS_RESPONSE_TIMEOUT (0x0025)
+
+/*
+ * Device is already connected
+ */
+#define NFCSTATUS_ALREADY_CONNECTED (0x0026)
+
+/*
+ * Device is already connected
+ */
+#define NFCSTATUS_ANOTHER_DEVICE_CONNECTED (0x0027)
+
+/*
+ * Single Target Detected and Activated
+ */
+#define NFCSTATUS_SINGLE_TAG_ACTIVATED (0x0028)
+
+/*
+ * Single Target Detected
+ */
+#define NFCSTATUS_SINGLE_TAG_DISCOVERED (0x0029)
+
+/*
+ * Secure element Detected and Activated
+ */
+#define NFCSTATUS_SECURE_ELEMENT_ACTIVATED (0x0028)
+
+/*
+ * Unknown error Status Codes
+ */
+#define NFCSTATUS_UNKNOWN_ERROR (0x00FE)
+
+/*
+ * Status code for failure
+ */
+#define NFCSTATUS_FAILED (0x00FF)
+
+/*
+ * The function/command has been aborted
+ */
+#define NFCSTATUS_CMD_ABORTED (0x0002)
+
+/*
+ * No target found after poll
+ */
+#define NFCSTATUS_NO_TARGET_FOUND (0x000A)
+
+/* Attempt to disconnect a not connected remote device. */
+#define NFCSTATUS_NO_DEVICE_CONNECTED (0x000B)
+
+/* External RF field detected. */
+#define NFCSTATUS_EXTERNAL_RF_DETECTED (0x000E)
+
+/* Message is not allowed by the state machine
+ * (e.g. configuration went wrong)
+ */
+#define NFCSTATUS_MSG_NOT_ALLOWED_BY_FSM (0x0010)
+
+/*
+ * No access has been granted
+ */
+#define NFCSTATUS_ACCESS_DENIED (0x001E)
+
+/* No registry node matches the specified input data. */
+#define NFCSTATUS_NODE_NOT_FOUND (0x0017)
+
+/* The current module is busy ; one might retry later */
+#define NFCSTATUS_SMX_BAD_STATE (0x00F0)
+
+/* The Abort mechanism has failed for unexpected reason: user can try again*/
+#define NFCSTATUS_ABORT_FAILED (0x00F2)
+
+/* The Registration command has failed because the user wants to register as
+ * target
+ * on a operating mode not supported
+ */
+#define NFCSTATUS_REG_OPMODE_NOT_SUPPORTED (0x00F5)
+
+/*
+ * Shutdown in progress, cannot handle the request at this time.
+ */
+#define NFCSTATUS_SHUTDOWN (0x0091)
+
+/*
+ * Target is no more in RF field
+ */
+#define NFCSTATUS_TARGET_LOST (0x0092)
+
+/*
+ * Request is rejected
+ */
+#define NFCSTATUS_REJECTED (0x0093)
+
+/*
+ * Target is not connected
+ */
+#define NFCSTATUS_TARGET_NOT_CONNECTED (0x0094)
+
+/*
+ * Invalid handle for the operation
+ */
+#define NFCSTATUS_INVALID_HANDLE (0x0095)
+
+/*
+ * Process aborted
+ */
+#define NFCSTATUS_ABORTED (0x0096)
+
+/*
+ * Requested command is not supported
+ */
+#define NFCSTATUS_COMMAND_NOT_SUPPORTED (0x0097)
+
+/*
+ * Tag is not NDEF compilant
+ */
+#define NFCSTATUS_NON_NDEF_COMPLIANT (0x0098)
+
+/*
+ * Not enough memory available to complete the requested operation
+ */
+#define NFCSTATUS_NOT_ENOUGH_MEMORY (0x001F)
+
+/*
+ * Indicates incoming connection
+ */
+#define NFCSTATUS_INCOMING_CONNECTION (0x0045)
+
+/*
+ * Indicates Connection was successful
+ */
+#define NFCSTATUS_CONNECTION_SUCCESS (0x0046)
+
+/*
+ * Indicates Connection failed
+ */
+#define NFCSTATUS_CONNECTION_FAILED (0x0047)
+
+/*
+ * Indicates file is not present at the specified location
+ */
+#define NFCSTATUS_FILE_NOT_FOUND (0x0048)
+
+/*
+ * Indicates force download is required
+ */
+#define NFCSTATUS_FORCE_FWDWNLD (0x0049)
+
+#endif /* PHNFCSTATUS_H */
diff --git a/pn72xx/halimpl/common/phNfcTypes.h b/pn72xx/halimpl/common/phNfcTypes.h
new file mode 100644
index 00000000..69fc2b42
--- /dev/null
+++ b/pn72xx/halimpl/common/phNfcTypes.h
@@ -0,0 +1,137 @@
+/*
+ * Copyright 2010-2020,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef PHNFCTYPES_H
+#define PHNFCTYPES_H
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#if (NXP_EXTNS == FALSE)
+#include <unistd.h>
+#endif
+#include "Nxp_Features.h"
+
+#ifndef true
+#define true (0x01) /* Logical True Value */
+#endif
+#ifndef TRUE
+#define TRUE (0x01) /* Logical True Value */
+#endif
+#ifndef false
+#define false (0x00) /* Logical False Value */
+#endif
+#ifndef FALSE
+#define FALSE (0x00) /* Logical False Value */
+#endif
+typedef uint8_t utf8_t;     /* UTF8 Character String */
+typedef uint8_t bool_t;     /* boolean data type */
+typedef uint16_t NFCSTATUS; /* Return values */
+#define STATIC static
+
+#define PHNFC_MAX_UID_LENGTH 0x0AU /* Maximum UID length expected */
+/* Maximum ATR_RES (General Bytes) length expected */
+#define PHNFC_MAX_ATR_LENGTH 0x30U
+#define PHNFC_NFCID_LENGTH 0x0AU /* Maximum length of NFCID 1.3*/
+#define PHNFC_ATQA_LENGTH 0x02U  /* ATQA length */
+
+/*
+ * Possible Hardware Configuration exposed to upper layer.
+ * Typically this should be port name (Ex:"COM1","COM2") to which PN72xx is
+ * connected.
+ */
+typedef enum {
+  ENUM_LINK_TYPE_COM1,
+  ENUM_LINK_TYPE_COM2,
+  ENUM_LINK_TYPE_COM3,
+  ENUM_LINK_TYPE_COM4,
+  ENUM_LINK_TYPE_COM5,
+  ENUM_LINK_TYPE_COM6,
+  ENUM_LINK_TYPE_COM7,
+  ENUM_LINK_TYPE_COM8,
+  ENUM_LINK_TYPE_I2C,
+  ENUM_LINK_TYPE_SPI,
+  ENUM_LINK_TYPE_USB,
+  ENUM_LINK_TYPE_TCP,
+  ENUM_LINK_TYPE_NB
+} phLibNfc_eConfigLinkType;
+
+/*
+ * Deferred message. This message type will be posted to the client application
+ * thread
+ * to notify that a deferred call must be invoked.
+ */
+#define PH_LIBNFC_DEFERREDCALL_MSG (0x311)
+
+/*
+ * Deferred call declaration.
+ * This type of API is called from ClientApplication ( main thread) to notify
+ * specific callback.
+ */
+typedef void (*pphLibNfc_DeferredCallback_t)(void *);
+
+/*
+ * Deferred parameter declaration.
+ * This type of data is passed as parameter from ClientApplication (main thread)
+ * to the
+ * callback.
+ */
+typedef void *pphLibNfc_DeferredParameter_t;
+
+/*
+ * Possible Hardware Configuration exposed to upper layer.
+ * Typically this should be at least the communication link (Ex:"COM1","COM2")
+ * the controller is connected to.
+ */
+typedef struct phLibNfc_sConfig {
+  uint8_t *pLogFile; /* Log File Name*/
+  /* Hardware communication link to the controller */
+  phLibNfc_eConfigLinkType nLinkType;
+  /* The client ID (thread ID or message queue ID) */
+  uintptr_t nClientId;
+} phLibNfc_sConfig_t, *pphLibNfc_sConfig_t;
+
+/*
+ * NFC Message structure contains message specific details like
+ * message type, message specific data block details, etc.
+ */
+typedef struct phLibNfc_Message {
+  uint32_t eMsgType; /* Type of the message to be posted*/
+  void *pMsgData;    /* Pointer to message specific data block in case any*/
+  uint32_t Size;     /* Size of the datablock*/
+} phLibNfc_Message_t, *pphLibNfc_Message_t;
+
+/*
+ * Deferred message specific info declaration.
+ * This type of information is packed as message data when
+ * PH_LIBNFC_DEFERREDCALL_MSG
+ * type message is posted to message handler thread.
+ */
+typedef struct phLibNfc_DeferredCall {
+  pphLibNfc_DeferredCallback_t pCallback;   /* pointer to Deferred callback */
+  pphLibNfc_DeferredParameter_t pParameter; /* pointer to Deferred parameter */
+} phLibNfc_DeferredCall_t;
+
+/*
+ *  Enumerated MIFARE Commands
+ */
+
+#define UNUSED_PROP(X) (void)(X);
+
+/* PHNFCTYPES_H */
+#endif
diff --git a/pn72xx/halimpl/dnld/phDnldNfc.cc b/pn72xx/halimpl/dnld/phDnldNfc.cc
new file mode 100644
index 00000000..861453b9
--- /dev/null
+++ b/pn72xx/halimpl/dnld/phDnldNfc.cc
@@ -0,0 +1,1200 @@
+/*
+ *  Copyright 2010-2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Download Component
+ * Download Interface routines implementation
+ */
+
+#include <dlfcn.h>
+#include <phDnldNfc_Internal.h>
+#include <phNxpConfig.h>
+#include <phNxpLog.h>
+#include <phTmlNfc.h>
+#include <string>
+
+static void *pFwHandle; /* Global firmware handle*/
+uint16_t wMwVer = 0;    /* Middleware version no */
+uint16_t wFwVer = 0;    /* Firmware version no */
+uint8_t gRecFWDwnld;    /* flag set to true to indicate recovery FW download */
+phTmlNfc_i2cfragmentation_t fragmentation_enabled = I2C_FRAGMENATATION_DISABLED;
+static pphDnldNfc_DlContext_t gpphDnldContext = NULL; /* Download contex */
+#undef EEPROM_Read_Mem_IMP
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_Reset
+**
+** Description      Performs a soft reset of the download module
+**
+** Parameters       pNotify  - notify caller after getting response
+**                  pContext - caller context
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - reset request to NFCC is successful
+**                  NFCSTATUS_FAILED - reset request failed due to internal
+**                                     error
+**                  NFCSTATUS_NOT_ALLOWED - command not allowed
+**                  Other command specific errors
+**
+*******************************************************************************/
+NFCSTATUS phDnldNfc_Reset(pphDnldNfc_RspCb_t pNotify, void *pContext) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  if ((NULL == pNotify) || (NULL == pContext)) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameters!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    if (phDnldNfc_TransitionIdle != gpphDnldContext->tDnldInProgress) {
+      NXPLOG_FWDNLD_E("Dnld Cmd Request in Progress..Cannot Continue!!");
+      wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_BUSY);
+    } else {
+      (gpphDnldContext->FrameInp.Type) = phDnldNfc_FTNone;
+      (gpphDnldContext->tCmdId) = PH_DL_CMD_RESET;
+      (gpphDnldContext->tRspBuffInfo.pBuff) = NULL;
+      (gpphDnldContext->tRspBuffInfo.wLen) = 0;
+      (gpphDnldContext->tUserData.pBuff) = NULL;
+      (gpphDnldContext->tUserData.wLen) = 0;
+      (gpphDnldContext->UserCb) = pNotify;
+      (gpphDnldContext->UserCtxt) = pContext;
+
+      wStatus = phDnldNfc_CmdHandler(gpphDnldContext, phDnldNfc_EventReset);
+
+      if (NFCSTATUS_PENDING == wStatus) {
+        NXPLOG_FWDNLD_D("Reset Request submitted successfully");
+      } else {
+        NXPLOG_FWDNLD_E("Reset Request Failed!!");
+      }
+    }
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_GetVersion
+**
+** Description      Retrieves Hardware version, ROM Code version, Protected Data
+**                  version, Trim data version, User data version, and Firmware
+**                  version information
+**
+** Parameters       pVersionInfo - response buffer which gets updated with
+**                                 complete version info from NFCC
+**                  pNotify - notify caller after getting response
+**                  pContext - caller context
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - GetVersion request to NFCC is successful
+**                  NFCSTATUS_FAILED - GetVersion request failed due to internal
+**                                     error
+**                  NFCSTATUS_NOT_ALLOWED - command not allowed
+**                  Other command specific errors
+**
+*******************************************************************************/
+NFCSTATUS phDnldNfc_GetVersion(pphDnldNfc_Buff_t pVersionInfo,
+                               pphDnldNfc_RspCb_t pNotify, void *pContext) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  if ((NULL == pVersionInfo) || (NULL == pNotify) || (NULL == pContext)) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameters!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    if (phDnldNfc_TransitionIdle != gpphDnldContext->tDnldInProgress) {
+      NXPLOG_FWDNLD_E("Dnld Cmd Request in Progress..Cannot Continue!!");
+      wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_BUSY);
+    } else {
+      if ((NULL != pVersionInfo->pBuff) && (0 != pVersionInfo->wLen)) {
+        (gpphDnldContext->tRspBuffInfo.pBuff) = pVersionInfo->pBuff;
+        (gpphDnldContext->tRspBuffInfo.wLen) = pVersionInfo->wLen;
+        (gpphDnldContext->FrameInp.Type) = phDnldNfc_FTNone;
+        (gpphDnldContext->tCmdId) = PH_DL_CMD_GETVERSION;
+        (gpphDnldContext->tUserData.pBuff) = NULL;
+        (gpphDnldContext->tUserData.wLen) = 0;
+        (gpphDnldContext->UserCb) = pNotify;
+        (gpphDnldContext->UserCtxt) = pContext;
+
+        wStatus = phDnldNfc_CmdHandler(gpphDnldContext, phDnldNfc_EventGetVer);
+
+        if (NFCSTATUS_PENDING == wStatus) {
+          NXPLOG_FWDNLD_D("GetVersion Request submitted successfully");
+        } else {
+          NXPLOG_FWDNLD_E("GetVersion Request Failed!!");
+        }
+      } else {
+        NXPLOG_FWDNLD_E("Invalid Buff Parameters!!");
+        wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+      }
+    }
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_GetSessionState
+**
+** Description      Retrieves the current session state of NFCC
+**
+** Parameters       pSession - response buffer which gets updated with complete
+**                             version info from NFCC
+**                  pNotify - notify caller after getting response
+**                  pContext - caller context
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - GetSessionState request to NFCC is
+**                                      successful
+**                  NFCSTATUS_FAILED - GetSessionState request failed due to
+**                                     internal error
+**                  NFCSTATUS_NOT_ALLOWED - command not allowed
+**                  Other command specific errors
+**
+*******************************************************************************/
+NFCSTATUS phDnldNfc_GetSessionState(pphDnldNfc_Buff_t pSession,
+                                    pphDnldNfc_RspCb_t pNotify,
+                                    void *pContext) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  if ((NULL == pSession) || (NULL == pNotify) || (NULL == pContext)) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameters!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    if (phDnldNfc_TransitionIdle != gpphDnldContext->tDnldInProgress) {
+      NXPLOG_FWDNLD_E("Dnld Cmd Request in Progress..Cannot Continue!!");
+      wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_BUSY);
+    } else {
+      if ((NULL != pSession->pBuff) && (0 != pSession->wLen)) {
+        (gpphDnldContext->tRspBuffInfo.pBuff) = pSession->pBuff;
+        (gpphDnldContext->tRspBuffInfo.wLen) = pSession->wLen;
+        (gpphDnldContext->FrameInp.Type) = phDnldNfc_FTNone;
+        (gpphDnldContext->tCmdId) = PH_DL_CMD_GETSESSIONSTATE;
+        (gpphDnldContext->tUserData.pBuff) = NULL;
+        (gpphDnldContext->tUserData.wLen) = 0;
+        (gpphDnldContext->UserCb) = pNotify;
+        (gpphDnldContext->UserCtxt) = pContext;
+
+        wStatus =
+            phDnldNfc_CmdHandler(gpphDnldContext, phDnldNfc_EventGetSesnSt);
+
+        if (NFCSTATUS_PENDING == wStatus) {
+          NXPLOG_FWDNLD_D("GetSessionState Request submitted successfully");
+        } else {
+          NXPLOG_FWDNLD_E("GetSessionState Request Failed!!");
+        }
+      } else {
+        NXPLOG_FWDNLD_E("Invalid Buff Parameters!!");
+        wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+      }
+    }
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_CheckIntegrity
+**
+** Description      Inspects the integrity of EEPROM and FLASH contents of the
+**                  NFCC, provides CRC for each section
+**                  NOTE: The user data section CRC is valid only after fresh
+**                        download
+**
+** Parameters       bChipVer - current ChipVersion for including additional
+**                             parameters in request payload
+**                  pCRCData - response buffer which gets updated with
+**                             respective section CRC status and CRC bytes from
+**                             NFCC
+**                  pNotify - notify caller after getting response
+**                  pContext - caller context
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - CheckIntegrity request is successful
+**                  NFCSTATUS_FAILED - CheckIntegrity request failed due to
+**                                     internal error
+**                  NFCSTATUS_NOT_ALLOWED - command not allowed
+**                  Other command specific errors
+**
+*******************************************************************************/
+NFCSTATUS phDnldNfc_CheckIntegrity(uint8_t bChipVer, pphDnldNfc_Buff_t pCRCData,
+                                   pphDnldNfc_RspCb_t pNotify, void *pContext) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  if ((NULL == pNotify) || (NULL == pContext)) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameters!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    if (phDnldNfc_TransitionIdle != gpphDnldContext->tDnldInProgress) {
+      NXPLOG_FWDNLD_E("Dnld Cmd Request in Progress..Cannot Continue!!");
+      wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_BUSY);
+    } else {
+      if ((PHDNLDNFC_HWVER_MRA2_1 == bChipVer) ||
+          (PHDNLDNFC_HWVER_MRA2_2 == bChipVer) ||
+#if (NXP_EXTNS == TRUE)
+          ((nfcFL.chipType >= pn7220) &&
+           (PHDNLDNFC_HWVER_PN7220_MRA1_0 == bChipVer))
+#endif
+      ) {
+        (gpphDnldContext->FrameInp.Type) = phDnldNfc_ChkIntg;
+      } else {
+        (gpphDnldContext->FrameInp.Type) = phDnldNfc_FTNone;
+      }
+
+      if ((NULL != pCRCData->pBuff) && (0 != pCRCData->wLen)) {
+        (gpphDnldContext->tRspBuffInfo.pBuff) = pCRCData->pBuff;
+        (gpphDnldContext->tRspBuffInfo.wLen) = pCRCData->wLen;
+        (gpphDnldContext->tCmdId) = PH_DL_CMD_CHECKINTEGRITY;
+        (gpphDnldContext->tUserData.pBuff) = NULL;
+        (gpphDnldContext->tUserData.wLen) = 0;
+        (gpphDnldContext->UserCb) = pNotify;
+        (gpphDnldContext->UserCtxt) = pContext;
+
+        wStatus =
+            phDnldNfc_CmdHandler(gpphDnldContext, phDnldNfc_EventIntegChk);
+
+        if (NFCSTATUS_PENDING == wStatus) {
+          NXPLOG_FWDNLD_D("CheckIntegrity Request submitted successfully");
+        } else {
+          NXPLOG_FWDNLD_E("CheckIntegrity Request Failed!!");
+        }
+      } else {
+        NXPLOG_FWDNLD_E("Invalid Buff Parameters!!");
+        wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+      }
+    }
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_Write
+**
+** Description      Writes requested  data of length len to desired EEPROM/FLASH
+**                  address
+**
+** Parameters       bRecoverSeq - flag to indicate whether recover sequence data
+**                                needs to be written or not
+**                  pData - data buffer to write into EEPROM/FLASH by user
+**                  pNotify - notify caller after getting response
+**                  pContext - caller context
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - Write request to NFCC is successful
+**                  NFCSTATUS_FAILED - Write request failed due to internal
+**                                     error
+**                  NFCSTATUS_NOT_ALLOWED - command not allowed
+**                  Other command specific errors
+**
+*******************************************************************************/
+NFCSTATUS phDnldNfc_Write(bool_t bRecoverSeq, pphDnldNfc_Buff_t pData,
+                          pphDnldNfc_RspCb_t pNotify, void *pContext) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  uint8_t *pImgPtr = NULL;
+  uint32_t wLen = 0;
+  phDnldNfc_Buff_t tImgBuff;
+
+  if ((NULL == pNotify) || (NULL == pContext)) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameters!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    if (phDnldNfc_TransitionIdle != gpphDnldContext->tDnldInProgress) {
+      NXPLOG_FWDNLD_E("Dnld Cmd Request in Progress..Cannot Continue!!");
+      wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_BUSY);
+    } else {
+      if (NULL != pData) {
+        pImgPtr = pData->pBuff;
+        wLen = pData->wLen;
+      } else {
+        if (bRecoverSeq == false) {
+          pImgPtr = (uint8_t *)gpphDnldContext->nxp_nfc_fw;
+          wLen = gpphDnldContext->nxp_nfc_fw_len;
+
+        } else {
+          pImgPtr = NULL;
+          wLen = 0;
+          NXPLOG_FWDNLD_E("Pn72xx Don't support FW recovery");
+        }
+      }
+
+      if ((NULL != pImgPtr) && (0 != wLen)) {
+        tImgBuff.pBuff = pImgPtr;
+        tImgBuff.wLen = wLen;
+
+        (gpphDnldContext->tCmdId) = PH_DL_CMD_WRITE;
+        (gpphDnldContext->FrameInp.Type) = phDnldNfc_FTWrite;
+        (gpphDnldContext->tRspBuffInfo.pBuff) = NULL;
+        (gpphDnldContext->tRspBuffInfo.wLen) = 0;
+        (gpphDnldContext->tUserData.pBuff) = pImgPtr;
+        (gpphDnldContext->tUserData.wLen) = wLen;
+        (gpphDnldContext->bResendLastFrame) = false;
+
+        memset(&(gpphDnldContext->tRWInfo), 0,
+               sizeof(gpphDnldContext->tRWInfo));
+        (gpphDnldContext->tRWInfo.bFirstWrReq) = true;
+        (gpphDnldContext->UserCb) = pNotify;
+        (gpphDnldContext->UserCtxt) = pContext;
+
+        wStatus = phDnldNfc_CmdHandler(gpphDnldContext, phDnldNfc_EventWrite);
+
+        if (NFCSTATUS_PENDING == wStatus) {
+          NXPLOG_FWDNLD_D("Write Request submitted successfully");
+        } else {
+          NXPLOG_FWDNLD_E("Write Request Failed!!");
+        }
+      } else {
+        NXPLOG_FWDNLD_E("Download Image Primitives extraction failed!!");
+        wStatus = NFCSTATUS_FAILED;
+      }
+    }
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_Log
+**
+** Description      Provides a full page free write to EEPROM
+**
+** Parameters       pData - data buffer to write into EEPROM/FLASH by user
+**                  pNotify - notify caller after getting response
+**                  pContext - caller context
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - Write request to NFCC is successful
+**                  NFCSTATUS_FAILED - Write request failed due to internal
+**                                     error
+**                  NFCSTATUS_NOT_ALLOWED - command not allowed
+**                  Other command specific error
+**
+*******************************************************************************/
+NFCSTATUS phDnldNfc_Log(pphDnldNfc_Buff_t pData, pphDnldNfc_RspCb_t pNotify,
+                        void *pContext) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  if ((NULL == pNotify) || (NULL == pData) || (NULL == pContext)) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameters!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    if (phDnldNfc_TransitionIdle != gpphDnldContext->tDnldInProgress) {
+      NXPLOG_FWDNLD_E("Dnld Cmd Request in Progress..Cannot Continue!!");
+      wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_BUSY);
+    } else {
+      if ((NULL != (pData->pBuff)) &&
+          ((0 != (pData->wLen) && (PHDNLDNFC_MAX_LOG_SIZE >= (pData->wLen))))) {
+        (gpphDnldContext->tCmdId) = PH_DL_CMD_LOG;
+        (gpphDnldContext->FrameInp.Type) = phDnldNfc_FTLog;
+        (gpphDnldContext->tRspBuffInfo.pBuff) = NULL;
+        (gpphDnldContext->tRspBuffInfo.wLen) = 0;
+        (gpphDnldContext->tUserData.pBuff) = (pData->pBuff);
+        (gpphDnldContext->tUserData.wLen) = (pData->wLen);
+
+        memset(&(gpphDnldContext->tRWInfo), 0,
+               sizeof(gpphDnldContext->tRWInfo));
+        (gpphDnldContext->UserCb) = pNotify;
+        (gpphDnldContext->UserCtxt) = pContext;
+
+        wStatus = phDnldNfc_CmdHandler(gpphDnldContext, phDnldNfc_EventLog);
+
+        if (NFCSTATUS_PENDING == wStatus) {
+          NXPLOG_FWDNLD_D("Log Request submitted successfully");
+        } else {
+          NXPLOG_FWDNLD_E("Log Request Failed!!");
+        }
+      } else {
+        NXPLOG_FWDNLD_E("Invalid Input Parameters for Log!!");
+        wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+      }
+    }
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_Force
+**
+** Description      Used as an emergency recovery procedure for NFCC due to
+**                  corrupt settings of system platform specific parameters by
+**                  the host
+**
+** Parameters       pInputs - input buffer which contains  clk src & clk freq
+**                            settings for desired platform
+**                  pNotify - notify caller after getting response
+**                  pContext - caller context
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - Emergency Recovery request is successful
+**                  NFCSTATUS_FAILED - Emergency Recovery failed due to internal
+**                                     error
+**                  NFCSTATUS_NOT_ALLOWED - command not allowed
+**                  Other command specific errors
+**
+*******************************************************************************/
+NFCSTATUS phDnldNfc_Force(pphDnldNfc_Buff_t pInputs, pphDnldNfc_RspCb_t pNotify,
+                          void *pContext) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  uint8_t bPldVal[3] = {
+      0x11, 0x00, 0x00}; /* default values to be used if input not provided */
+
+  if ((NULL == pNotify) || (NULL == pContext)) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameters!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    if (phDnldNfc_TransitionIdle != gpphDnldContext->tDnldInProgress) {
+      NXPLOG_FWDNLD_E("Dnld Cmd Request in Progress..Cannot Continue!!");
+      wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_BUSY);
+    } else {
+      (gpphDnldContext->tCmdId) = PH_DL_CMD_FORCE;
+      (gpphDnldContext->FrameInp.Type) = phDnldNfc_FTForce;
+      (gpphDnldContext->tRspBuffInfo.pBuff) = NULL;
+      (gpphDnldContext->tRspBuffInfo.wLen) = 0;
+      bPldVal[0] = 0U;
+      bPldVal[0] = ((pInputs->pBuff[0] << 3U) | pInputs->pBuff[1]);
+
+      (gpphDnldContext->tUserData.pBuff) = bPldVal;
+      (gpphDnldContext->tUserData.wLen) = sizeof(bPldVal);
+
+      memset(&(gpphDnldContext->tRWInfo), 0, sizeof(gpphDnldContext->tRWInfo));
+      (gpphDnldContext->UserCb) = pNotify;
+      (gpphDnldContext->UserCtxt) = pContext;
+
+      wStatus = phDnldNfc_CmdHandler(gpphDnldContext, phDnldNfc_EventForce);
+
+      if (NFCSTATUS_PENDING == wStatus) {
+        NXPLOG_FWDNLD_D("Force Command Request submitted successfully");
+      } else {
+        NXPLOG_FWDNLD_E("Force Command Request Failed!!");
+      }
+    }
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_SetHwDevHandle
+**
+** Description      Stores the HwDev handle to download context. The handle is
+**                  required for subsequent operations
+**
+** Parameters       None
+**
+** Returns          None                -
+**
+*******************************************************************************/
+void phDnldNfc_SetHwDevHandle(void) {
+  pphDnldNfc_DlContext_t psDnldContext = NULL;
+
+  if (NULL == gpphDnldContext) {
+    NXPLOG_FWDNLD_D("Allocating Mem for Dnld Context..");
+    /* Create the memory for Download Mgmt Context */
+    psDnldContext =
+        (pphDnldNfc_DlContext_t)malloc(sizeof(phDnldNfc_DlContext_t));
+
+    if (psDnldContext != NULL) {
+      (void)memset((void *)psDnldContext, 0, sizeof(phDnldNfc_DlContext_t));
+      gpphDnldContext = psDnldContext;
+    } else {
+      NXPLOG_FWDNLD_E("Error Allocating Mem for Dnld Context..");
+    }
+  } else {
+    (void)memset((void *)gpphDnldContext, 0, sizeof(phDnldNfc_DlContext_t));
+  }
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_ReSetHwDevHandle
+**
+** Description      Frees the HwDev handle to download context.
+**
+** Parameters       None
+**
+** Returns          None                -
+**
+*******************************************************************************/
+void phDnldNfc_ReSetHwDevHandle(void) {
+  if (gpphDnldContext != NULL) {
+    NXPLOG_FWDNLD_D("Freeing Mem for Dnld Context..");
+    free(gpphDnldContext);
+    gpphDnldContext = NULL;
+  }
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_RawReq
+**
+** Description      Sends raw frame request to NFCC.
+**                  It is currently used for sending an NCI RESET cmd after
+**                  doing a production key update
+**
+** Parameters       pFrameData - input buffer, contains raw frame packet to be
+**                               sent to NFCC
+**                  pRspData - response buffer received from NFCC
+**                  pNotify - notify caller after getting response
+**                  pContext - caller context
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - GetSessionState request to NFCC is
+**                                      successful
+**                  NFCSTATUS_FAILED - GetSessionState request failed due to
+**                                     internal error
+**                  NFCSTATUS_NOT_ALLOWED - command not allowed
+**                  Other command specific errors
+**
+*******************************************************************************/
+NFCSTATUS phDnldNfc_RawReq(pphDnldNfc_Buff_t pFrameData,
+                           pphDnldNfc_Buff_t pRspData,
+                           pphDnldNfc_RspCb_t pNotify, void *pContext) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  if ((NULL == pFrameData) || (NULL == pNotify) || (NULL == pRspData) ||
+      (NULL == pContext)) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameters!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    if (phDnldNfc_TransitionIdle != gpphDnldContext->tDnldInProgress) {
+      NXPLOG_FWDNLD_E("Raw Cmd Request in Progress..Cannot Continue!!");
+      wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_BUSY);
+    } else {
+      if (((NULL != pFrameData->pBuff) && (0 != pFrameData->wLen)) &&
+          ((NULL != pRspData->pBuff) && (0 != pRspData->wLen))) {
+        (gpphDnldContext->tRspBuffInfo.pBuff) = pRspData->pBuff;
+        (gpphDnldContext->tRspBuffInfo.wLen) = pRspData->wLen;
+        (gpphDnldContext->FrameInp.Type) = phDnldNfc_FTRaw;
+        (gpphDnldContext->tCmdId) = PH_DL_CMD_NONE;
+        (gpphDnldContext->tUserData.pBuff) = pFrameData->pBuff;
+        (gpphDnldContext->tUserData.wLen) = pFrameData->wLen;
+        (gpphDnldContext->UserCb) = pNotify;
+        (gpphDnldContext->UserCtxt) = pContext;
+
+        wStatus = phDnldNfc_CmdHandler(gpphDnldContext, phDnldNfc_EventRaw);
+
+        if (NFCSTATUS_PENDING == wStatus) {
+          NXPLOG_FWDNLD_D("RawFrame Request submitted successfully");
+        } else {
+          NXPLOG_FWDNLD_E("RawFrame Request Failed!!");
+        }
+      } else {
+        NXPLOG_FWDNLD_E("Invalid Buff Parameters!!");
+        wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+      }
+    }
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_InitImgInfo
+**
+** Description      Extracts image information and stores it in respective
+**                  variables, to be used internally for write operation
+**
+** Parameters       bMinimalFw - flag indicates for minimal FW Image
+**
+** Returns          NFC status
+**
+*******************************************************************************/
+NFCSTATUS phDnldNfc_InitImgInfo(bool bMinimalFw) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  uint8_t *pImageInfo = NULL;
+  uint32_t ImageInfoLen = 0;
+  unsigned long fwType = FW_FORMAT_SO;
+
+  /* if memory is not allocated then allocate memory for download context
+   * structure */
+  phDnldNfc_SetHwDevHandle();
+
+  gpphDnldContext->FwFormat = FW_FORMAT_UNKNOWN;
+  phDnldNfc_SetDlRspTimeout((uint16_t)PHDNLDNFC_RSP_TIMEOUT);
+  if (bMinimalFw) {
+    fwType = FW_FORMAT_ARRAY;
+  } else if (GetNxpNumValue(NAME_NXP_FW_TYPE, &fwType, sizeof(fwType)) ==
+             true) {
+    /*Read Firmware file name from config file*/
+    NXPLOG_FWDNLD_D("firmware type from conf file: %lu", fwType);
+  } else {
+    NXPLOG_FWDNLD_W("firmware type not found. Taking default value: %lu",
+                    fwType);
+  }
+
+  if (fwType == FW_FORMAT_ARRAY) {
+    gpphDnldContext->FwFormat = FW_FORMAT_ARRAY;
+    wStatus = NFCSTATUS_SUCCESS;
+  } else if (fwType == FW_FORMAT_BIN) {
+    gpphDnldContext->FwFormat = FW_FORMAT_BIN;
+    wStatus = phDnldNfc_LoadBinFW(&pImageInfo, &ImageInfoLen);
+  } else if (fwType == FW_FORMAT_SO) {
+    gpphDnldContext->FwFormat = FW_FORMAT_SO;
+    wStatus = phDnldNfc_LoadFW(Fw_Lib_Path, &pImageInfo, &ImageInfoLen);
+  } else {
+    NXPLOG_FWDNLD_E("firmware file format mismatch!!!\n");
+    return NFCSTATUS_FAILED;
+  }
+
+  NXPLOG_FWDNLD_D("FW Image Length - ImageInfoLen %d", ImageInfoLen);
+  NXPLOG_FWDNLD_D("FW Image Info Pointer - pImageInfo %p", pImageInfo);
+
+  if ((pImageInfo == NULL) || (ImageInfoLen == 0)) {
+    NXPLOG_FWDNLD_E(
+        "Image extraction Failed - invalid imginfo or imginfolen!!");
+    wStatus = NFCSTATUS_FAILED;
+  }
+
+  if (wStatus != NFCSTATUS_SUCCESS) {
+    NXPLOG_FWDNLD_E("Error loading FW file !!\n");
+  }
+
+  /* get the MW version */
+  if (NFCSTATUS_SUCCESS == wStatus) {
+    // NXPLOG_FWDNLD_D("MW Major Version Num - %x",NXP_MW_VERSION_MAJ);
+    // NXPLOG_FWDNLD_D("MW Minor Version Num - %x",NXP_MW_VERSION_MIN);
+    wMwVer = (((uint16_t)(NXP_MW_VERSION_MAJ) << 8U) | (NXP_MW_VERSION_MIN));
+  }
+
+  if (NFCSTATUS_SUCCESS == wStatus) {
+    gpphDnldContext->nxp_nfc_fw = (uint8_t *)pImageInfo;
+    gpphDnldContext->nxp_nfc_fw_len = ImageInfoLen;
+    if ((NULL != gpphDnldContext->nxp_nfc_fw) &&
+        (0 != gpphDnldContext->nxp_nfc_fw_len)) {
+      uint16_t offsetFwMajorNum, offsetFwMinorNum;
+      if (nfcFL.chipType == sn220u) {
+        offsetFwMajorNum = ((uint16_t)(gpphDnldContext->nxp_nfc_fw[795]) << 8U);
+        offsetFwMinorNum = ((uint16_t)(gpphDnldContext->nxp_nfc_fw[794]));
+      } else {
+        offsetFwMajorNum = ((uint16_t)(gpphDnldContext->nxp_nfc_fw[5]) << 8U);
+        offsetFwMinorNum = ((uint16_t)(gpphDnldContext->nxp_nfc_fw[4]));
+      }
+      NXPLOG_FWDNLD_D("FW Major Version Num - %x", offsetFwMajorNum);
+      NXPLOG_FWDNLD_D("FW Minor Version Num - %x", offsetFwMinorNum);
+      /* get the FW version */
+      wFwVer = (offsetFwMajorNum | offsetFwMinorNum);
+
+      NXPLOG_FWDNLD_D("FW Image Length - %d", ImageInfoLen);
+      NXPLOG_FWDNLD_D("FW Image Info Pointer - %p", pImageInfo);
+      wStatus = NFCSTATUS_SUCCESS;
+    } else {
+      NXPLOG_FWDNLD_E("Image details extraction Failed!!");
+      wStatus = NFCSTATUS_FAILED;
+    }
+  }
+
+  /* gpphDnldContext reset by phDnldNfc_SetHwDevHandle()
+     so reassign the Fragment Length based on chip version */
+  if (NFCSTATUS_SUCCESS == wStatus) {
+    phDnldNfc_SetI2CFragmentLength(PHDNLDNFC_CMDRESP_MAX_BUFF_SIZE_PN72XX);
+  }
+
+  return wStatus;
+}
+/*******************************************************************************
+**
+** Function         phDnldNfc_CloseFwLibHandle
+**
+** Description      Closes previously opened fw library handle as part of
+**                  dynamic loader processing
+**
+** Parameters       None
+**
+** Returns          None
+**
+*******************************************************************************/
+void phDnldNfc_CloseFwLibHandle(void) {
+  NFCSTATUS wStatus = NFCSTATUS_FAILED;
+  if (gpphDnldContext->FwFormat == FW_FORMAT_SO) {
+    wStatus = phDnldNfc_UnloadFW();
+    if (wStatus != NFCSTATUS_SUCCESS) {
+      NXPLOG_FWDNLD_E("free library FAILED !!\n");
+    } else {
+      NXPLOG_FWDNLD_E("free library SUCCESS !!\n");
+    }
+  } else if (gpphDnldContext->FwFormat == FW_FORMAT_BIN) {
+    if (pFwHandle != NULL) {
+      free(pFwHandle);
+      pFwHandle = NULL;
+    }
+  }
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_LoadFW
+**
+** Description      Load the firmware version form firmware lib
+**
+** Parameters       pathName    - Firmware image path
+**                  pImgInfo    - Firmware image handle
+**                  pImgInfoLen - Firmware image length
+**
+** Returns          NFC status
+**
+*******************************************************************************/
+NFCSTATUS phDnldNfc_LoadFW(const char *pathName, uint8_t **pImgInfo,
+                           uint32_t *pImgInfoLen) {
+  void *pImageInfo = NULL;
+  void *pImageInfoLen = NULL;
+
+  /* check for path name */
+  if (pathName == NULL)
+    pathName = nfcFL._FW_LIB_PATH.c_str();
+
+  /* check if the handle is not NULL then free the library */
+  if (pFwHandle != NULL) {
+    phDnldNfc_CloseFwLibHandle();
+    pFwHandle = NULL;
+  }
+
+  /* load the DLL file */
+  pFwHandle = dlopen(pathName, RTLD_LAZY);
+  NXPLOG_FWDNLD_D("@@@%s", pathName);
+
+  /* if library load failed then handle will be NULL */
+  if (pFwHandle == NULL) {
+    NXPLOG_FWDNLD_E(
+        "NULL handler : unable to load the library file, specify correct path");
+    return NFCSTATUS_FAILED;
+  }
+
+  dlerror(); /* Clear any existing error */
+
+  /* load the address of download image pointer and image size */
+  pImageInfo = (void *)dlsym(pFwHandle, "gphDnldNfc_DlSeq");
+
+  if (dlerror() || (NULL == pImageInfo)) {
+    NXPLOG_FWDNLD_E("Problem loading symbol : gphDnldNfc_DlSeq");
+    return NFCSTATUS_FAILED;
+  }
+  (*pImgInfo) = (*(uint8_t **)pImageInfo);
+
+  pImageInfoLen = (void *)dlsym(pFwHandle, "gphDnldNfc_DlSeqSz");
+  if (dlerror() || (NULL == pImageInfoLen)) {
+    NXPLOG_FWDNLD_E("Problem loading symbol : gphDnldNfc_DlSeqSz");
+    return NFCSTATUS_FAILED;
+  }
+
+  if (nfcFL.chipType >= sn100u) {
+    (*pImgInfoLen) = (uint32_t)(*((uint32_t *)pImageInfoLen));
+    NXPLOG_FWDNLD_D("FW image loded for chipType sn100u (%x)", nfcFL.chipType)
+  } else {
+    (*pImgInfoLen) = (uint16_t)(*((uint16_t *)pImageInfoLen));
+    NXPLOG_FWDNLD_D("FW image loded for chipType pn557 (%x)", nfcFL.chipType)
+  }
+
+  return NFCSTATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_LoadBinFW
+**
+** Description      Load the firmware version form firmware lib
+**
+** Parameters       pImgInfo    - Firmware image handle
+**                  pImgInfoLen - Firmware image length
+**
+** Returns          NFC status
+**
+*******************************************************************************/
+NFCSTATUS phDnldNfc_LoadBinFW(uint8_t **pImgInfo, uint32_t *pImgInfoLen) {
+  FILE *pFile = NULL;
+  long fileSize = 0;
+  long bytesRead = 0;
+  long ftellFileSize = 0;
+
+  /* check for path name */
+  if (nfcFL._FW_BIN_PATH.c_str() == NULL) {
+    NXPLOG_FWDNLD_E("Invalid FW file path!!!\n");
+    return NFCSTATUS_FAILED;
+  }
+
+  /* check if the handle is not NULL then free the memory*/
+  if (pFwHandle != NULL) {
+    phDnldNfc_CloseFwLibHandle();
+    pFwHandle = NULL;
+  }
+
+  /* Open the FW binary image file to be read */
+  pFile = fopen(nfcFL._FW_BIN_PATH.c_str(), "r");
+  if (NULL == pFile) {
+    NXPLOG_FWDNLD_E("Failed to load FW binary image file!!!\n");
+    return NFCSTATUS_FAILED;
+  }
+
+  /* Seek to the end of the file */
+  fseek(pFile, 0, SEEK_END);
+
+  /* get the actual length of the file */
+  ftellFileSize = ftell(pFile);
+
+  if (ftellFileSize > 0) {
+    fileSize = ftellFileSize;
+  } else {
+    fileSize = 0;
+  }
+
+  /* Seek to the start of the file, to move file handle back to start of file*/
+  fseek(pFile, 0, SEEK_SET);
+
+  /* allocate the memory to read the FW binary image */
+  pFwHandle = (void *)malloc(sizeof(uint8_t) * fileSize);
+
+  /* check for valid memory allocation */
+  if (NULL == pFwHandle) {
+    NXPLOG_FWDNLD_E("Failed to allocate memory to load FW image !!!\n");
+    fclose(pFile);
+    return NFCSTATUS_FAILED;
+  }
+
+  /* Read the actual contents of the FW binary image */
+  bytesRead =
+      (uint32_t)fread(pFwHandle, sizeof(uint8_t), (size_t)fileSize, pFile);
+  if (bytesRead != fileSize) {
+    NXPLOG_FWDNLD_E("Unable to read the specified size from file !!!\n");
+    fclose(pFile);
+    free(pFwHandle);
+    pFwHandle = NULL;
+    return NFCSTATUS_FAILED;
+  }
+
+  /* Update the image info pointer to the caller */
+  *pImgInfo = (uint8_t *)pFwHandle;
+  *pImgInfoLen = (uint32_t)(bytesRead & 0xFFFFFFFF);
+
+  /* close the FW binary image file */
+  fclose(pFile);
+  return NFCSTATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_UnloadFW
+**
+** Description      Deinit the firmware handle
+**
+** Parameters       None
+**
+** Returns          NFC status
+**
+*******************************************************************************/
+NFCSTATUS phDnldNfc_UnloadFW(void) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  int32_t status;
+
+  /* check if the handle is not NULL then free the library */
+  if (pFwHandle != NULL) {
+    status = dlclose(pFwHandle);
+    pFwHandle = NULL;
+
+    dlerror(); /* Clear any existing error */
+    if (status != 0) {
+      wStatus = NFCSTATUS_FAILED;
+      NXPLOG_FWDNLD_E("Free library file failed");
+    }
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_SetDlRspTimeout
+**
+** Description      This function sets the timeout value dnld cmd response
+**
+** Parameters       timeout : timeout value for dnld response
+**
+** Returns          None
+**
+*******************************************************************************/
+void phDnldNfc_SetDlRspTimeout(uint16_t timeout) {
+  gpphDnldContext->TimerInfo.rspTimeout = timeout;
+  NXPLOG_FWDNLD_E("phDnldNfc_SetDlRspTimeout timeout value =%x", timeout);
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_SetI2CFragmentLength
+**
+** Description      sets the fragment length
+**
+** Parameters       Fragment Length
+**
+** Returns          None                -
+**
+*******************************************************************************/
+void phDnldNfc_SetI2CFragmentLength(uint16_t len) {
+  if (NULL != gpphDnldContext) {
+    gpphDnldContext->nxp_i2c_fragment_len = len;
+    NXPLOG_FWDNLD_D("fragment len set %x",
+                    gpphDnldContext->nxp_i2c_fragment_len);
+  } else {
+    NXPLOG_FWDNLD_E("Error setting the fragment length");
+  }
+  return;
+}
+
+#ifdef EEPROM_Read_Mem_IMP
+static pphDnldNfc_RspCb_t UserCb; /* Upper layer call back function */
+static void *UserCtxt;            /* Pointer to upper layer context */
+/* Function prototype declaration */
+static void phDnldNfc_ReadComplete(void *pContext, NFCSTATUS status,
+                                   void *pInfo);
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_ReadMem
+**
+** Description      Dumps the contents of EEPROM. The handle is required for
+**                  subsequent operations
+**
+** Parameters       pHwRef - pointer to the hardware device
+**                  pNotify - notify caller after getting response
+**                  pContext - caller context
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - request to NFCC is successful
+**                  NFCSTATUS_FAILED - request failed due to internal error
+**                  NFCSTATUS_NOT_ALLOWED - command not allowed
+**                  Other command specific errors
+**
+*******************************************************************************/
+NFCSTATUS phDnldNfc_ReadMem(void *pHwRef, pphDnldNfc_RspCb_t pNotify,
+                            void *pContext) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  uint32_t wAddr = 0x2011C0; /* eeprom platform specific area start address */
+  uint32_t wRdAddr = 0;
+  uint8_t *pAddr;
+  static uint8_t bRdData[3519]; /* buffer to hold the read data */
+  static phDnldNfc_Buff_t Data;
+
+  if ((NULL == pNotify) || (NULL == pContext)) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameters!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    /* Call Tml Ioctl to enable download mode */
+    wStatus = phTmlNfc_IoCtl(phTmlNfc_e_EnableDownloadMode);
+
+    if (NFCSTATUS_SUCCESS == wStatus) {
+      /* Set the obtained device handle to download module */
+      phDnldNfc_SetHwDevHandle();
+      /* gpphDnldContext reset by phDnldNfc_SetHwDevHandle()
+      so reassign the Fragment Length 554 (0x22A) for chip sn1xx*/
+      phDnldNfc_SetI2CFragmentLength(PHDNLDNFC_CMDRESP_MAX_BUFF_SIZE_PN72XX);
+    } else {
+      wStatus = NFCSTATUS_FAILED;
+    }
+
+    if (NFCSTATUS_SUCCESS == wStatus) {
+      pAddr = (uint8_t *)&wAddr;
+
+      wRdAddr = (pAddr[3]);
+      wRdAddr <<= 8;
+      wRdAddr |= (pAddr[2]);
+      wRdAddr <<= 8;
+      wRdAddr |= (pAddr[1]);
+      wRdAddr <<= 8;
+      wRdAddr |= (pAddr[0]);
+
+      Data.pBuff = bRdData;
+      Data.wLen = sizeof(bRdData);
+      UserCb = pNotify;
+      UserCtxt = pContext;
+
+      wStatus = phDnldNfc_Read(&Data, wRdAddr,
+                               (pphDnldNfc_RspCb_t)phDnldNfc_ReadComplete,
+                               gpphDnldContext);
+    } else {
+      Data.pBuff = NULL;
+      Data.wLen = 0;
+      wStatus = NFCSTATUS_FAILED;
+    }
+
+    if (NFCSTATUS_PENDING == wStatus) {
+      NXPLOG_FWDNLD_D("Read Request submitted successfully..");
+    } else {
+      NXPLOG_FWDNLD_E("Read Request submission failed!!");
+    }
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_ReadComplete
+**
+** Description      Read complete
+**
+** Parameters       pContext - caller layer context
+**                  status   - status of the transaction
+**                  pInfo    - transaction info
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phDnldNfc_ReadComplete(void *pContext, NFCSTATUS status,
+                                   void *pInfo) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  UNUSED_PROP(pContext);
+
+  /* Call Tml Ioctl to enable/restore normal mode */
+  wStatus = phTmlNfc_IoCtl(phTmlNfc_e_EnableNormalMode);
+
+  if (NFCSTATUS_SUCCESS == wStatus) {
+    NXPLOG_FWDNLD_D("Read Done!!");
+  }
+
+  UserCb(&UserCtxt, status, pInfo);
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_Read
+**
+** Description      Retrieves requested data of specified length from desired
+**                  EEPROM address
+**
+** Parameters       pData - response buffer which gets updated with data from
+**                          EEPROM
+**                  dwRdAddr - EEPROM address for data read
+**                  pNotify - notify caller after getting response
+**                  pContext - caller context
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - Read request to NFCC is successful
+**                  NFCSTATUS_FAILED - Read request failed due to internal error
+**                  NFCSTATUS_NOT_ALLOWED - command not allowed
+**                  Other command specific errors
+**
+*******************************************************************************/
+NFCSTATUS phDnldNfc_Read(pphDnldNfc_Buff_t pData, uint32_t dwRdAddr,
+                         pphDnldNfc_RspCb_t pNotify, void *pContext) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  if ((NULL == pNotify) || (NULL == pData) || (NULL == pContext)) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameters!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    if (phDnldNfc_TransitionIdle != gpphDnldContext->tDnldInProgress) {
+      NXPLOG_FWDNLD_E("Dnld Cmd Request in Progress..Cannot Continue!!");
+      wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_BUSY);
+    } else {
+      if ((NULL != pData->pBuff) && (0 != pData->wLen)) {
+        (gpphDnldContext->tCmdId) = PH_DL_CMD_READ;
+        (gpphDnldContext->FrameInp.Type) = phDnldNfc_FTRead;
+        (gpphDnldContext->FrameInp.dwAddr) = dwRdAddr;
+        (gpphDnldContext->tRspBuffInfo.pBuff) = pData->pBuff;
+        (gpphDnldContext->tRspBuffInfo.wLen) = pData->wLen;
+        (gpphDnldContext->tUserData.pBuff) = NULL;
+        (gpphDnldContext->tUserData.wLen) = 0;
+        (gpphDnldContext->UserCb) = pNotify;
+        (gpphDnldContext->UserCtxt) = pContext;
+
+        memset(&(gpphDnldContext->tRWInfo), 0,
+               sizeof(gpphDnldContext->tRWInfo));
+
+        wStatus = phDnldNfc_CmdHandler(gpphDnldContext, phDnldNfc_EventRead);
+
+        if (NFCSTATUS_PENDING == wStatus) {
+          NXPLOG_FWDNLD_D("Read Request submitted successfully");
+        } else {
+          NXPLOG_FWDNLD_E("Read Request Failed!!");
+        }
+      } else {
+        NXPLOG_FWDNLD_E("Invalid Buff Parameters!!");
+        wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+      }
+    }
+  }
+
+  return wStatus;
+}
+#endif
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_GetDieId
+**
+** Description      Retrieves the Die ID of NFCC
+**
+** Parameters       pGetDieId - response buffer which gets updated with complete
+**                             version info from NFCC
+**                  pNotify - notify caller after getting response
+**                  pContext - caller context
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - Get Die ID request to NFCC is
+**                                      successful
+**                  NFCSTATUS_FAILED - Get Die ID request failed due to
+**                                     internal error
+**                  NFCSTATUS_NOT_ALLOWED - command not allowed
+**                  Other command specific errors
+**
+*******************************************************************************/
+NFCSTATUS phDnldNfc_GetDieId(pphDnldNfc_Buff_t pGetDieId,
+                             pphDnldNfc_RspCb_t pNotify, void *pContext) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  if ((NULL == pGetDieId) || (NULL == pNotify) || (NULL == pContext)) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameters!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    if (phDnldNfc_TransitionIdle != gpphDnldContext->tDnldInProgress) {
+      NXPLOG_FWDNLD_E("Dnld Cmd Request in Progress..Cannot Continue!!");
+      wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_BUSY);
+    } else {
+      if ((NULL != pGetDieId->pBuff) && (0 != pGetDieId->wLen)) {
+        (gpphDnldContext->tRspBuffInfo.pBuff) = pGetDieId->pBuff;
+        (gpphDnldContext->tRspBuffInfo.wLen) = pGetDieId->wLen;
+        (gpphDnldContext->FrameInp.Type) = phDnldNfc_FTNone;
+        (gpphDnldContext->tCmdId) = PH_DL_CMD_GETDIE_ID;
+        (gpphDnldContext->tUserData.pBuff) = NULL;
+        (gpphDnldContext->tUserData.wLen) = 0;
+        (gpphDnldContext->UserCb) = pNotify;
+        (gpphDnldContext->UserCtxt) = pContext;
+
+        wStatus =
+            phDnldNfc_CmdHandler(gpphDnldContext, phDnldNfc_EventGetDieId);
+
+        if (NFCSTATUS_PENDING == wStatus) {
+          NXPLOG_FWDNLD_D("phDnldNfc_GetDieId Request submitted successfully");
+        } else {
+          NXPLOG_FWDNLD_E("phDnldNfc_GetDieId Request Failed!!");
+        }
+      } else {
+        NXPLOG_FWDNLD_E("Invalid Buff Parameters!!");
+        wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+      }
+    }
+  }
+
+  return wStatus;
+}
diff --git a/pn72xx/halimpl/dnld/phDnldNfc.h b/pn72xx/halimpl/dnld/phDnldNfc.h
new file mode 100644
index 00000000..f6349940
--- /dev/null
+++ b/pn72xx/halimpl/dnld/phDnldNfc.h
@@ -0,0 +1,121 @@
+/*
+ *  Copyright 2010-2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Firmware Download Interface File
+ */
+#ifndef PHDNLDNFC_H
+#define PHDNLDNFC_H
+
+#include <phNfcStatus.h>
+
+/*
+ *
+ * Callback for handling the received data/response from PN72xx.
+ * Parameters to be passed/registered to download context during respective
+ * download function call:
+ *      pContext - Upper layer context
+ *      wStatus  - Status of the transaction
+ *      pInfo    - Contains the Transaction Info
+ */
+typedef void (*pphDnldNfc_RspCb_t)(void *pContext, NFCSTATUS wStatus,
+                                   void *pInfo);
+
+/* Timeout value to wait for response from NFCC */
+#define PHDNLDNFC_RSP_TIMEOUT (2500)
+/* Timeout value to wait for dnld  reset rsp */
+#define PHDNLDNFC_RESET_RSP_TIMEOUT (15)
+
+#define PHLIBNFC_FWDNLD_SESSNOPEN (0x01U)   /* download session is Open */
+#define PHLIBNFC_FWDNLD_SESSNCLOSED (0x00U) /* download session is Closed */
+
+#define PHDNLDNFC_HWVER_MRA1_0 (0x01U) /* ChipVersion MRA1.0 */
+#define PHDNLDNFC_HWVER_MRA1_1 (0x02U) /* ChipVersion MRA1.1 */
+#define PHDNLDNFC_HWVER_MRA2_0 (0x03U) /* ChipVersion MRA2.0 */
+#define PHDNLDNFC_HWVER_MRA2_1 (0x04U) /* ChipVersion MRA2.1 */
+#define PHDNLDNFC_HWVER_MRA2_2 (0x05U) /* ChipVersion MRA2.2 */
+
+#define PHDNLDNFC_HWVER_PN7220_MRA1_0 (0x53U)
+/*
+ * Enum definition contains Download Life Cycle States
+ */
+typedef enum phDnldNfc_LC {
+  phDnldNfc_LCCreat = 11, /* Life Cycle Creation*/
+  phDnldNfc_LCInit = 13,  /* Life Cycle Initializing */
+  phDnldNfc_LCOper = 17,  /* Life Cycle Operational */
+  phDnldNfc_LCTerm = 19   /* Life Cycle Termination */
+} phDnldNfc_LC_t;
+
+/*
+ * Struct contains buffer where user payload shall be stored
+ */
+typedef struct phDnldNfc_Buff {
+  uint8_t *pBuff; /*pointer to the buffer where user payload shall be stored*/
+  uint32_t wLen;  /*Buffer length*/
+} phDnldNfc_Buff_t, *pphDnldNfc_Buff_t; /* pointer to #phDnldNfc_Buff_t */
+
+typedef struct phDnldChkIntegrityRsp_Buff {
+  uint8_t *pBuff; /* pointer to the buffer where chk integrity rsp is stored*/
+  uint32_t wLen;  /* check integrity rsp Buffer length*/
+  uint8_t
+      data_len; /* length of data area whose CRC is checked, maximum 28 bits*/
+  uint8_t
+      code_len; /* length of code area whose CRC is checked, maximum 4 bits*/
+  uint32_t crc_status; /* crc info of all the sections*/
+} phDnldChkIntegrityRsp_Buff_t;
+/*
+*********************** Function Prototype Declaration *************************
+*/
+
+extern NFCSTATUS phDnldNfc_Reset(pphDnldNfc_RspCb_t pNotify, void *pContext);
+extern NFCSTATUS phDnldNfc_GetVersion(pphDnldNfc_Buff_t pVersionInfo,
+                                      pphDnldNfc_RspCb_t pNotify,
+                                      void *pContext);
+extern NFCSTATUS phDnldNfc_CheckIntegrity(uint8_t bChipVer,
+                                          pphDnldNfc_Buff_t pCRCData,
+                                          pphDnldNfc_RspCb_t pNotify,
+                                          void *pContext);
+extern NFCSTATUS phDnldNfc_GetSessionState(pphDnldNfc_Buff_t pSession,
+                                           pphDnldNfc_RspCb_t pNotify,
+                                           void *pContext);
+
+extern NFCSTATUS phDnldNfc_GetDieId(pphDnldNfc_Buff_t pSession,
+                                    pphDnldNfc_RspCb_t pNotify, void *pContext);
+
+extern NFCSTATUS phDnldNfc_Force(pphDnldNfc_Buff_t pInputs,
+                                 pphDnldNfc_RspCb_t pNotify, void *pContext);
+extern NFCSTATUS phDnldNfc_Read(pphDnldNfc_Buff_t pData, uint32_t dwRdAddr,
+                                pphDnldNfc_RspCb_t pNotify, void *pContext);
+extern NFCSTATUS phDnldNfc_Write(bool_t bRecoverSeq, pphDnldNfc_Buff_t pData,
+                                 pphDnldNfc_RspCb_t pNotify, void *pContext);
+extern NFCSTATUS phDnldNfc_Log(pphDnldNfc_Buff_t pData,
+                               pphDnldNfc_RspCb_t pNotify, void *pContext);
+extern void phDnldNfc_SetHwDevHandle(void);
+void phDnldNfc_ReSetHwDevHandle(void);
+extern NFCSTATUS phDnldNfc_ReadMem(void *pHwRef, pphDnldNfc_RspCb_t pNotify,
+                                   void *pContext);
+extern NFCSTATUS phDnldNfc_RawReq(pphDnldNfc_Buff_t pFrameData,
+                                  pphDnldNfc_Buff_t pRspData,
+                                  pphDnldNfc_RspCb_t pNotify, void *pContext);
+extern NFCSTATUS phDnldNfc_InitImgInfo(bool bMinimalFw = false);
+extern void phDnldNfc_CloseFwLibHandle(void);
+extern NFCSTATUS phDnldNfc_LoadFW(const char *pathName, uint8_t **pImgInfo,
+                                  uint32_t *pImgInfoLen);
+extern NFCSTATUS phDnldNfc_LoadBinFW(uint8_t **pImgInfo, uint32_t *pImgInfoLen);
+extern NFCSTATUS phDnldNfc_UnloadFW(void);
+extern void phDnldNfc_SetDlRspTimeout(uint16_t timeout);
+extern void phDnldNfc_SetI2CFragmentLength(uint16_t len);
+#endif /* PHDNLDNFC_H */
diff --git a/pn72xx/halimpl/dnld/phDnldNfc_Cmd.h b/pn72xx/halimpl/dnld/phDnldNfc_Cmd.h
new file mode 100644
index 00000000..8fa591f3
--- /dev/null
+++ b/pn72xx/halimpl/dnld/phDnldNfc_Cmd.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2010-2014,2022-2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Firmware Download command values
+ */
+
+#ifndef PHDNLDNFC_CMD_H
+#define PHDNLDNFC_CMD_H
+
+#include <phNfcStatus.h>
+
+/*
+ * Enum definition contains Firmware Download Command Ids
+ */
+
+typedef enum phDnldNfc_CmdId {
+  PH_DL_CMD_NONE = 0x00,           /* Invalid Cmd */
+  PH_DL_CMD_RESET = 0xE5,          /* Reset */
+  PH_DL_CMD_GETVERSION = 0xE1,     /* Get Version */
+  PH_DL_CMD_CHECKINTEGRITY = 0xE7, /* Check Integrity */
+  PH_DL_CMD_WRITE = 0x8C,          /* Write */
+  PH_DL_CMD_READ = 0xA2,
+  /* Read */ /* TODO: Cuurently,this cmd is not support by FW, keep it to avoid
+                the compilation issue */
+  PH_DL_CMD_LOG = 0xA7,
+  /* Log */ /* TODO: Cuurently,this cmd is not support by FW, keep it to avoid
+               the compilation issue */
+  PH_DL_CMD_FORCE = 0xD0,
+  /* Force */ /* TODO: Cuurently,this cmd is not support by FW, keep it to avoid
+                 the compilation issue */
+  PH_DL_CMD_GETSESSIONSTATE = 0xDB, /* Get Session State */
+  PH_DL_CMD_GETDIE_ID = 0xDF        /* Fetch Die ID */
+} phDnldNfc_CmdId_t;
+
+#endif /* PHDNLDNFC_CMD_H */
diff --git a/pn72xx/halimpl/dnld/phDnldNfc_Internal.cc b/pn72xx/halimpl/dnld/phDnldNfc_Internal.cc
new file mode 100644
index 00000000..71f7b3d2
--- /dev/null
+++ b/pn72xx/halimpl/dnld/phDnldNfc_Internal.cc
@@ -0,0 +1,1217 @@
+/*
+ * Copyright 2010-2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Internal Download Management routines
+ * Download Component
+ */
+
+#include <phDnldNfc_Internal.h>
+#include <phDnldNfc_Utils.h>
+#include <phNxpLog.h>
+#include <phNxpNciHal_utils.h>
+#include <phTmlNfc.h>
+
+#include "NxpNfcThreadMutex.h"
+
+/* Minimum length of payload including 1 byte CmdId */
+#define PHDNLDNFC_MIN_PLD_LEN (0x04U)
+
+/* Offset of Length byte within the frame */
+#define PHDNLDNFC_FRAME_HDR_OFFSET (0x00)
+/* Offset of FrameId within the frame */
+#define PHDNLDNFC_FRAMEID_OFFSET (PHDNLDNFC_FRAME_HDR_LEN)
+/* Offset of status byte within the frame */
+#define PHDNLDNFC_FRAMESTATUS_OFFSET PHDNLDNFC_FRAMEID_OFFSET
+/* Offset within frame where payload starts*/
+#define PHDNLDNFC_PLD_OFFSET (PHDNLDNFC_MIN_PLD_LEN - 1)
+
+#define PHDNLDNFC_FRAME_RDDATA_OFFSET                                          \
+  ((PHDNLDNFC_FRAME_HDR_LEN) +                                                 \
+   (PHDNLDNFC_MIN_PLD_LEN)) /* recvd frame offset where data starts */
+
+/* Size of first secure write frame Signature */
+#define PHDNLDNFC_FRAME_SIGNATURE_SIZE (0xC0U)
+/* Size of first secure write frame payload */
+#define PHDNLDNFC_FIRST_FRAME_PLD_SIZE (0xE4U)
+
+/* Status response for first fragmented write frame */
+#define PHDNLDNFC_FIRST_FRAGFRAME_RESP (0x2DU)
+/* Status response for subsequent fragmented write frame */
+#define PHDNLDNFC_NEXT_FRAGFRAME_RESP (0x2EU)
+
+#define PHDNLDNFC_SET_HDR_FRAGBIT(n)                                           \
+  ((n) | (1 << 10)) /* Header chunk bit set macro */
+#define PHDNLDNFC_CLR_HDR_FRAGBIT(n)                                           \
+  ((n) & ~(1U << 10)) /* Header chunk bit clear macro */
+#define PHDNLDNFC_CHK_HDR_FRAGBIT(n)                                           \
+  ((n)&0x04) /* macro to check if frag bit is set in Hdr */
+
+/* Timeout value to wait before resending the last frame */
+#define PHDNLDNFC_RETRY_FRAME_WRITE (50)
+
+/* size of EEPROM user data length */
+#define PHDNLDNFC_USERDATA_EEPROM_LENSIZE (0x02U)
+/* size of EEPROM offset */
+#define PHDNLDNFC_USERDATA_EEPROM_OFFSIZE (0x02U)
+
+#define PH_LIBNFC_VEN_RESET_ON_DOWNLOAD_TIMEOUT (1)
+
+static NfcHalThreadMutex sProcessSeqStateLock;
+static NfcHalThreadMutex sProcessRwSeqStateLock;
+
+/* Function prototype declarations */
+static void phDnldNfc_ProcessSeqState(void *pContext,
+                                      phTmlNfc_TransactInfo_t *pInfo);
+static void phDnldNfc_ProcessRWSeqState(void *pContext,
+                                        phTmlNfc_TransactInfo_t *pInfo);
+static NFCSTATUS phDnldNfc_ProcessFrame(void *pContext,
+                                        phTmlNfc_TransactInfo_t *pInfo);
+static NFCSTATUS phDnldNfc_ProcessRecvInfo(void *pContext,
+                                           phTmlNfc_TransactInfo_t *pInfo);
+static NFCSTATUS phDnldNfc_BuildFramePkt(pphDnldNfc_DlContext_t pDlContext);
+static NFCSTATUS phDnldNfc_CreateFramePld(pphDnldNfc_DlContext_t pDlContext);
+static NFCSTATUS phDnldNfc_SetupResendTimer(pphDnldNfc_DlContext_t pDlContext);
+static NFCSTATUS phDnldNfc_UpdateRsp(pphDnldNfc_DlContext_t pDlContext,
+                                     phTmlNfc_TransactInfo_t *pInfo,
+                                     uint16_t wPldLen);
+static void phDnldNfc_RspTimeOutCb(uint32_t TimerId, void *pContext);
+static void phDnldNfc_ResendTimeOutCb(uint32_t TimerId, void *pContext);
+
+/*
+*************************** Function Definitions ***************************
+*/
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_CmdHandler
+**
+** Description      Download Command Handler Mechanism
+**                  - holds the sub states for each command processing
+**                  - coordinates with TML download thread to complete a
+**                    download command request
+**                  - calls the user callback on completion of a cmd
+**
+** Parameters       pContext  - pointer to the download context structure
+**                  TrigEvent - event requested by user
+**
+** Returns          NFC status:
+**                  NFCSTATUS_PENDING - download request sent to NFCC
+**                                      successfully,response pending
+**                  NFCSTATUS_BUSY - handler is busy processing a download
+**                                   request
+**                  NFCSTATUS_INVALID_PARAMETER - one or more of the supplied
+**                                                parameters could not be
+**                                                interpreted properly
+**                  Other errors
+**
+*******************************************************************************/
+NFCSTATUS phDnldNfc_CmdHandler(void *pContext, phDnldNfc_Event_t TrigEvent) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  pphDnldNfc_DlContext_t pDlCtxt = (pphDnldNfc_DlContext_t)pContext;
+
+  if (NULL == pDlCtxt) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameter!!");
+    status = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    switch (TrigEvent) {
+#if (NXP_EXTNS == TRUE)
+    case phDnldNfc_EventGetDieId:
+#endif
+    case phDnldNfc_EventReset:
+    case phDnldNfc_EventGetVer:
+    case phDnldNfc_EventIntegChk:
+    case phDnldNfc_EventGetSesnSt:
+    case phDnldNfc_EventRaw: {
+      if (phDnldNfc_EventInvalid == (pDlCtxt->tCurrEvent)) {
+        NXPLOG_FWDNLD_D("Processing Normal Sequence..");
+        pDlCtxt->tCurrEvent = TrigEvent;
+        pDlCtxt->tDnldInProgress = phDnldNfc_TransitionBusy;
+
+        phDnldNfc_ProcessSeqState(pDlCtxt, NULL);
+
+        status = pDlCtxt->wCmdSendStatus;
+      } else {
+        NXPLOG_FWDNLD_E("Prev Norml Sequence not completed/restored!!");
+        status = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_FAILED);
+      }
+      break;
+    }
+    case phDnldNfc_EventWrite:
+    case phDnldNfc_EventRead:
+    case phDnldNfc_EventLog:
+    case phDnldNfc_EventForce: {
+      if (phDnldNfc_EventInvalid == (pDlCtxt->tCurrEvent)) {
+        NXPLOG_FWDNLD_D("Processing R/W Sequence..");
+        pDlCtxt->tCurrEvent = TrigEvent;
+        pDlCtxt->tDnldInProgress = phDnldNfc_TransitionBusy;
+
+        phDnldNfc_ProcessRWSeqState(pDlCtxt, NULL);
+
+        status = pDlCtxt->wCmdSendStatus;
+      } else {
+        NXPLOG_FWDNLD_E("Prev R/W Sequence not completed/restored!!");
+        status = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_FAILED);
+      }
+      break;
+    }
+    default: {
+      /* Unknown Event */
+      NXPLOG_FWDNLD_E("Unknown Event Parameter!!");
+      status = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+      break;
+    }
+    }
+  }
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_ProcessSeqState
+**
+** Description      Processes all cmd/resp sequences except read & write
+**
+** Parameters       pContext - pointer to the download context structure
+**                  pInfo - pointer to the Transaction buffer updated by TML
+**                          Thread
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phDnldNfc_ProcessSeqState(void *pContext,
+                                      phTmlNfc_TransactInfo_t *pInfo) {
+  NfcHalAutoThreadMutex a(sProcessSeqStateLock);
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  NFCSTATUS wIntStatus;
+  uint32_t TimerId;
+  pphDnldNfc_DlContext_t pDlCtxt = (pphDnldNfc_DlContext_t)pContext;
+
+  if (NULL == pDlCtxt) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameter!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    switch (pDlCtxt->tCurrState) {
+    case phDnldNfc_StateInit: {
+      NXPLOG_FWDNLD_D("Initializing Sequence..");
+
+      if (0 == (pDlCtxt->TimerInfo.dwRspTimerId)) {
+        TimerId = phOsalNfc_Timer_Create();
+
+        if (0 == TimerId) {
+          NXPLOG_FWDNLD_W("Response Timer Create failed!!");
+          wStatus = NFCSTATUS_INSUFFICIENT_RESOURCES;
+          pDlCtxt->wCmdSendStatus = wStatus;
+          break;
+        } else {
+          NXPLOG_FWDNLD_D("Response Timer Created Successfully");
+          (pDlCtxt->TimerInfo.dwRspTimerId) = TimerId;
+          (pDlCtxt->TimerInfo.TimerStatus) = 0;
+          (pDlCtxt->TimerInfo.wTimerExpStatus) = 0;
+        }
+      }
+      pDlCtxt->tCurrState = phDnldNfc_StateSend;
+    }
+      [[fallthrough]];
+    case phDnldNfc_StateSend: {
+      wStatus = phDnldNfc_BuildFramePkt(pDlCtxt);
+
+      if (NFCSTATUS_SUCCESS == wStatus) {
+        pDlCtxt->tCurrState = phDnldNfc_StateRecv;
+        wStatus = phTmlNfc_Write(
+            (pDlCtxt->tCmdRspFrameInfo.aFrameBuff),
+            (uint16_t)(pDlCtxt->tCmdRspFrameInfo.dwSendlength),
+            (pphTmlNfc_TransactCompletionCb_t)&phDnldNfc_ProcessSeqState,
+            pDlCtxt);
+      }
+      pDlCtxt->wCmdSendStatus = wStatus;
+      break;
+    }
+    case phDnldNfc_StateRecv: {
+      wStatus = phDnldNfc_ProcessRecvInfo(pContext, pInfo);
+
+      if (NFCSTATUS_SUCCESS == wStatus) {
+        wStatus = phOsalNfc_Timer_Start((pDlCtxt->TimerInfo.dwRspTimerId),
+                                        pDlCtxt->TimerInfo.rspTimeout,
+                                        &phDnldNfc_RspTimeOutCb, pDlCtxt);
+        if (NFCSTATUS_SUCCESS == wStatus) {
+          NXPLOG_FWDNLD_D("Response timer started");
+          pDlCtxt->TimerInfo.TimerStatus = 1;
+          pDlCtxt->tCurrState = phDnldNfc_StateTimer;
+        } else {
+          NXPLOG_FWDNLD_W("Response timer not started");
+          pDlCtxt->tCurrState = phDnldNfc_StateResponse;
+        }
+        phTmlNfc_Read(
+            pDlCtxt->tCmdRspFrameInfo.aFrameBuff,
+            (uint16_t)pDlCtxt->nxp_i2c_fragment_len,
+            (pphTmlNfc_TransactCompletionCb_t)&phDnldNfc_ProcessSeqState,
+            (void *)pDlCtxt);
+        break;
+      } else {
+        /* Setting TimerExpStatus below to avoid frame processing in response
+         * state */
+        (pDlCtxt->TimerInfo.wTimerExpStatus) = NFCSTATUS_RF_TIMEOUT;
+        pDlCtxt->tCurrState = phDnldNfc_StateResponse;
+      }
+    }
+      [[fallthrough]];
+    case phDnldNfc_StateTimer: {
+      if (1 == (pDlCtxt->TimerInfo.TimerStatus)) /*Is Timer Running*/
+      {
+        /*Stop Timer*/
+        (void)phOsalNfc_Timer_Stop(pDlCtxt->TimerInfo.dwRspTimerId);
+        (pDlCtxt->TimerInfo.TimerStatus) = 0; /*timer stopped*/
+      }
+      pDlCtxt->tCurrState = phDnldNfc_StateResponse;
+    }
+      [[fallthrough]];
+    case phDnldNfc_StateResponse: {
+      if (NFCSTATUS_RF_TIMEOUT != (pDlCtxt->TimerInfo.wTimerExpStatus)) {
+        /* Process response */
+        wStatus = phDnldNfc_ProcessFrame(pContext, pInfo);
+      } else {
+        if (phDnldNfc_EventReset != pDlCtxt->tCurrEvent) {
+          wStatus = (pDlCtxt->TimerInfo.wTimerExpStatus);
+        } else {
+          wStatus = NFCSTATUS_SUCCESS;
+        }
+        (pDlCtxt->TimerInfo.wTimerExpStatus) = 0;
+      }
+
+      /* Abort TML read operation which is always kept open */
+      wIntStatus = phTmlNfc_ReadAbort();
+
+      if (NFCSTATUS_SUCCESS != wIntStatus) {
+        /* TODO:-Action to take in this case:-Tml read abort failed!? */
+        NXPLOG_FWDNLD_W("Tml Read Abort failed!!");
+      }
+
+      pDlCtxt->tCurrEvent = phDnldNfc_EventInvalid;
+      pDlCtxt->tDnldInProgress = phDnldNfc_TransitionIdle;
+      pDlCtxt->tCurrState = phDnldNfc_StateInit;
+
+      /* Delete the timer & reset timer primitives in context */
+      (void)phOsalNfc_Timer_Delete(pDlCtxt->TimerInfo.dwRspTimerId);
+      (pDlCtxt->TimerInfo.dwRspTimerId) = 0;
+      (pDlCtxt->TimerInfo.TimerStatus) = 0;
+      (pDlCtxt->TimerInfo.wTimerExpStatus) = 0;
+
+      if ((NULL != (pDlCtxt->UserCb)) && (NULL != (pDlCtxt->UserCtxt))) {
+        pDlCtxt->UserCb((pDlCtxt->UserCtxt), wStatus, &(pDlCtxt->tRspBuffInfo));
+      }
+      break;
+    }
+    default: {
+      pDlCtxt->tCurrEvent = phDnldNfc_EventInvalid;
+      pDlCtxt->tDnldInProgress = phDnldNfc_TransitionIdle;
+      break;
+    }
+    }
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_ProcessRWSeqState
+**
+** Description      Processes read/write cmd/rsp sequence
+**
+** Parameters       pContext - pointer to the download context structure
+**                  pInfo - pointer to the Transaction buffer updated by TML
+**                             Thread
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phDnldNfc_ProcessRWSeqState(void *pContext,
+                                        phTmlNfc_TransactInfo_t *pInfo) {
+  NfcHalAutoThreadMutex a(sProcessRwSeqStateLock);
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  NFCSTATUS wIntStatus = wStatus;
+  uint32_t TimerId;
+  pphDnldNfc_DlContext_t pDlCtxt = (pphDnldNfc_DlContext_t)pContext;
+
+  if (NULL == pDlCtxt) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameter!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    switch (pDlCtxt->tCurrState) {
+    case phDnldNfc_StateInit: {
+      if (0 == (pDlCtxt->TimerInfo.dwRspTimerId)) {
+        TimerId = phOsalNfc_Timer_Create();
+
+        if (0 == TimerId) {
+          NXPLOG_FWDNLD_E("Response Timer Create failed!!");
+          wStatus = NFCSTATUS_INSUFFICIENT_RESOURCES;
+        } else {
+          NXPLOG_FWDNLD_D("Response Timer Created Successfully");
+          (pDlCtxt->TimerInfo.dwRspTimerId) = TimerId;
+          (pDlCtxt->TimerInfo.TimerStatus) = 0;
+          (pDlCtxt->TimerInfo.wTimerExpStatus) = 0;
+        }
+      }
+      pDlCtxt->tCurrState = phDnldNfc_StateSend;
+    }
+      [[fallthrough]];
+    case phDnldNfc_StateSend: {
+      if (pDlCtxt->bResendLastFrame == false) {
+        wStatus = phDnldNfc_BuildFramePkt(pDlCtxt);
+      } else {
+        pDlCtxt->bResendLastFrame = false;
+      }
+
+      if (NFCSTATUS_SUCCESS == wStatus) {
+        pDlCtxt->tCurrState = phDnldNfc_StateRecv;
+
+        wStatus = phTmlNfc_Write(
+            (pDlCtxt->tCmdRspFrameInfo.aFrameBuff),
+            (uint16_t)(pDlCtxt->tCmdRspFrameInfo.dwSendlength),
+            (pphTmlNfc_TransactCompletionCb_t)&phDnldNfc_ProcessRWSeqState,
+            pDlCtxt);
+      }
+      pDlCtxt->wCmdSendStatus = wStatus;
+      break;
+    }
+    case phDnldNfc_StateRecv: {
+      wStatus = phDnldNfc_ProcessRecvInfo(pContext, pInfo);
+
+      if (NFCSTATUS_SUCCESS == wStatus) {
+        /* processing For Pipelined write before calling timer below */
+        wStatus = phOsalNfc_Timer_Start((pDlCtxt->TimerInfo.dwRspTimerId),
+                                        pDlCtxt->TimerInfo.rspTimeout,
+                                        &phDnldNfc_RspTimeOutCb, pDlCtxt);
+
+        if (NFCSTATUS_SUCCESS == wStatus) {
+          NXPLOG_FWDNLD_D("Response timer started");
+          pDlCtxt->TimerInfo.TimerStatus = 1;
+          pDlCtxt->tCurrState = phDnldNfc_StateTimer;
+        } else {
+          NXPLOG_FWDNLD_W("Response timer not started");
+          pDlCtxt->tCurrState = phDnldNfc_StateResponse;
+          /* Todo:- diagnostic in this case */
+        }
+        /* Call TML_Read function and register the call back function */
+        phTmlNfc_Read(
+            pDlCtxt->tCmdRspFrameInfo.aFrameBuff,
+            (uint16_t)pDlCtxt->nxp_i2c_fragment_len,
+            (pphTmlNfc_TransactCompletionCb_t)&phDnldNfc_ProcessRWSeqState,
+            (void *)pDlCtxt);
+        break;
+      } else {
+        /* Setting TimerExpStatus below to avoid frame processing in response
+         * state */
+        (pDlCtxt->TimerInfo.wTimerExpStatus) = NFCSTATUS_RF_TIMEOUT;
+        pDlCtxt->tCurrState = phDnldNfc_StateResponse;
+      }
+    }
+      [[fallthrough]];
+    case phDnldNfc_StateTimer: {
+      if (1 == (pDlCtxt->TimerInfo.TimerStatus)) /*Is Timer Running*/
+      {
+        /* Stop Timer */
+        (void)phOsalNfc_Timer_Stop(pDlCtxt->TimerInfo.dwRspTimerId);
+        (pDlCtxt->TimerInfo.TimerStatus) = 0; /*timer stopped*/
+      }
+      pDlCtxt->tCurrState = phDnldNfc_StateResponse;
+    }
+      [[fallthrough]];
+    case phDnldNfc_StateResponse: {
+      if (NFCSTATUS_RF_TIMEOUT != (pDlCtxt->TimerInfo.wTimerExpStatus)) {
+        /* Process response */
+        wStatus = phDnldNfc_ProcessFrame(pContext, pInfo);
+
+        if (NFCSTATUS_BUSY == wStatus) {
+          /* store the status for use in subsequent processing */
+          wIntStatus = wStatus;
+
+          /* setup the resend wait timer */
+          wStatus = phDnldNfc_SetupResendTimer(pDlCtxt);
+
+          if (NFCSTATUS_SUCCESS == wStatus) {
+            /* restore the last mem_bsy status to avoid re-building frame
+             * below */
+            wStatus = wIntStatus;
+          }
+        }
+      } else {
+        wStatus = (pDlCtxt->TimerInfo.wTimerExpStatus);
+        (pDlCtxt->TimerInfo.wTimerExpStatus) = 0;
+      }
+
+      if ((0 != (pDlCtxt->tRWInfo.wRemBytes)) &&
+          (NFCSTATUS_SUCCESS == wStatus)) {
+        /* Abort TML read operation which is always kept open */
+        wIntStatus = phTmlNfc_ReadAbort();
+
+        if (NFCSTATUS_SUCCESS != wIntStatus) {
+          NXPLOG_FWDNLD_W("Tml read abort failed!");
+        }
+
+        wStatus = phDnldNfc_BuildFramePkt(pDlCtxt);
+
+        if (NFCSTATUS_SUCCESS == wStatus) {
+          pDlCtxt->tCurrState = phDnldNfc_StateRecv;
+          wStatus = phTmlNfc_Write(
+              (pDlCtxt->tCmdRspFrameInfo.aFrameBuff),
+              (uint16_t)(pDlCtxt->tCmdRspFrameInfo.dwSendlength),
+              (pphTmlNfc_TransactCompletionCb_t)&phDnldNfc_ProcessRWSeqState,
+              pDlCtxt);
+
+          /* TODO:- Verify here if TML_Write returned NFC_PENDING status &
+             take appropriate
+                action otherwise ?? */
+        }
+      } else if (NFCSTATUS_BUSY == wStatus) {
+        /* No processing to be done,since resend wait timer should have
+         * already been started */
+      } else {
+        (pDlCtxt->tRWInfo.bFramesSegmented) = false;
+        /* Abort TML read operation which is always kept open */
+        wIntStatus = phTmlNfc_ReadAbort();
+
+        if (NFCSTATUS_SUCCESS != wIntStatus) {
+          NXPLOG_FWDNLD_W("Tml read abort failed!");
+        }
+
+        pDlCtxt->tCurrEvent = phDnldNfc_EventInvalid;
+        pDlCtxt->tDnldInProgress = phDnldNfc_TransitionIdle;
+        pDlCtxt->tCurrState = phDnldNfc_StateInit;
+        pDlCtxt->bResendLastFrame = false;
+
+        /* Delete the timer & reset timer primitives in context */
+        (void)phOsalNfc_Timer_Delete(pDlCtxt->TimerInfo.dwRspTimerId);
+        (pDlCtxt->TimerInfo.dwRspTimerId) = 0;
+        (pDlCtxt->TimerInfo.TimerStatus) = 0;
+        (pDlCtxt->TimerInfo.wTimerExpStatus) = 0;
+
+        if ((NULL != (pDlCtxt->UserCb)) && (NULL != (pDlCtxt->UserCtxt))) {
+          pDlCtxt->UserCb((pDlCtxt->UserCtxt), wStatus,
+                          &(pDlCtxt->tRspBuffInfo));
+        }
+      }
+      break;
+    }
+    default: {
+      pDlCtxt->tCurrEvent = phDnldNfc_EventInvalid;
+      pDlCtxt->tDnldInProgress = phDnldNfc_TransitionIdle;
+      break;
+    }
+    }
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_BuildFramePkt
+**
+** Description      Forms the frame packet
+**
+** Parameters       pDlContext - pointer to the download context structure
+**
+** Returns          NFC status
+**
+*******************************************************************************/
+static NFCSTATUS phDnldNfc_BuildFramePkt(pphDnldNfc_DlContext_t pDlContext) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  uint16_t wFrameLen = 0;
+  uint16_t wCrcVal;
+  uint8_t *pFrameByte;
+
+  if (NULL == pDlContext) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameter!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    if (phDnldNfc_FTWrite == (pDlContext->FrameInp.Type)) {
+      if ((0 == (pDlContext->tUserData.wLen)) ||
+          (NULL == (pDlContext->tUserData.pBuff))) {
+        NXPLOG_FWDNLD_E("Invalid Input Parameter(s) for Write!!");
+        wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+      } else {
+        if ((pDlContext->tRWInfo.bFirstWrReq) == true) {
+          (pDlContext->tRWInfo.wRemBytes) = (pDlContext->tUserData.wLen);
+          (pDlContext->tRWInfo.wOffset) = 0;
+        }
+      }
+    } else if (phDnldNfc_FTRead == (pDlContext->FrameInp.Type)) {
+      if ((0 == (pDlContext->tRspBuffInfo.wLen)) ||
+          (NULL == (pDlContext->tRspBuffInfo.pBuff))) {
+        NXPLOG_FWDNLD_E("Invalid Input Parameter(s) for Read!!");
+        wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+      } else {
+        if ((pDlContext->tRWInfo.bFramesSegmented) == false) {
+          NXPLOG_FWDNLD_D("Verifying RspBuffInfo for Read Request..");
+          wFrameLen =
+              (uint16_t)(pDlContext->tRspBuffInfo.wLen) + PHDNLDNFC_MIN_PLD_LEN;
+
+          (pDlContext->tRWInfo.wRWPldSize) =
+              (((pDlContext->nxp_i2c_fragment_len) -
+                (PHDNLDNFC_FRAME_HDR_LEN + PHDNLDNFC_FRAME_CRC_LEN)) -
+               PHDNLDNFC_MIN_PLD_LEN);
+          (pDlContext->tRWInfo.wRemBytes) = (pDlContext->tRspBuffInfo.wLen);
+          (pDlContext->tRWInfo.dwAddr) = (pDlContext->FrameInp.dwAddr);
+          (pDlContext->tRWInfo.wOffset) = 0;
+          (pDlContext->tRWInfo.wBytesRead) = 0;
+
+          if (((pDlContext->nxp_i2c_fragment_len) -
+               (PHDNLDNFC_FRAME_HDR_LEN + PHDNLDNFC_FRAME_CRC_LEN)) <
+              wFrameLen) {
+            (pDlContext->tRWInfo.bFramesSegmented) = true;
+          }
+        }
+      }
+    } else if (phDnldNfc_FTLog == (pDlContext->FrameInp.Type)) {
+      if ((0 == (pDlContext->tUserData.wLen)) ||
+          (NULL == (pDlContext->tUserData.pBuff))) {
+        NXPLOG_FWDNLD_E("Invalid Input Parameter(s) for Log!!");
+        wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+      }
+    } else {
+    }
+
+    if (NFCSTATUS_SUCCESS == wStatus) {
+      wStatus = phDnldNfc_CreateFramePld(pDlContext);
+    }
+
+    if (NFCSTATUS_SUCCESS == wStatus) {
+      wFrameLen = 0;
+      wFrameLen = (pDlContext->tCmdRspFrameInfo.dwSendlength);
+      if (wFrameLen > pDlContext->nxp_i2c_fragment_len) {
+        NXPLOG_FWDNLD_E("wFrameLen (%x) exceeds the limit %x", wFrameLen,
+                        pDlContext->nxp_i2c_fragment_len);
+        return NFCSTATUS_FAILED;
+      }
+
+      if (phDnldNfc_FTRaw != (pDlContext->FrameInp.Type)) {
+        if (phDnldNfc_FTWrite != (pDlContext->FrameInp.Type)) {
+          pFrameByte = (uint8_t *)&wFrameLen;
+
+          pDlContext->tCmdRspFrameInfo.aFrameBuff[PHDNLDNFC_FRAME_HDR_OFFSET] =
+              pFrameByte[1];
+          pDlContext->tCmdRspFrameInfo
+              .aFrameBuff[PHDNLDNFC_FRAME_HDR_OFFSET + 1] = pFrameByte[0];
+
+          NXPLOG_FWDNLD_D("Inserting FrameId ..");
+          pDlContext->tCmdRspFrameInfo.aFrameBuff[PHDNLDNFC_FRAMEID_OFFSET] =
+              (pDlContext->tCmdId);
+
+          wFrameLen += PHDNLDNFC_FRAME_HDR_LEN;
+        } else {
+          if (0 != (pDlContext->tRWInfo.wRWPldSize)) {
+            if ((pDlContext->tRWInfo.bFramesSegmented) == true) {
+              /* Turning ON the Fragmentation bit in FrameLen */
+              wFrameLen = PHDNLDNFC_SET_HDR_FRAGBIT(wFrameLen);
+            }
+
+            pFrameByte = (uint8_t *)&wFrameLen;
+
+            pDlContext->tCmdRspFrameInfo
+                .aFrameBuff[PHDNLDNFC_FRAME_HDR_OFFSET] = pFrameByte[1];
+            pDlContext->tCmdRspFrameInfo
+                .aFrameBuff[PHDNLDNFC_FRAME_HDR_OFFSET + 1] = pFrameByte[0];
+
+            /* To ensure we have no frag bit set for crc calculation */
+            wFrameLen = PHDNLDNFC_CLR_HDR_FRAGBIT(wFrameLen);
+            wFrameLen += PHDNLDNFC_FRAME_HDR_LEN;
+          }
+        }
+        /*Check whether enough space is left for 2 bytes of CRC append*/
+        if (wFrameLen > (pDlContext->nxp_i2c_fragment_len - 2)) {
+          NXPLOG_FWDNLD_D("wFrameLen exceeds the limit");
+          return NFCSTATUS_FAILED;
+        }
+        /* calculate CRC16 */
+        wCrcVal = phDnldNfc_CalcCrc16((pDlContext->tCmdRspFrameInfo.aFrameBuff),
+                                      wFrameLen);
+
+        pFrameByte = (uint8_t *)&wCrcVal;
+
+        /* Insert the computed Crc value */
+        pDlContext->tCmdRspFrameInfo.aFrameBuff[wFrameLen] = pFrameByte[1];
+        pDlContext->tCmdRspFrameInfo.aFrameBuff[wFrameLen + 1] = pFrameByte[0];
+
+        wFrameLen += PHDNLDNFC_FRAME_CRC_LEN;
+      }
+
+      (pDlContext->tCmdRspFrameInfo.dwSendlength) = wFrameLen;
+      NXPLOG_FWDNLD_D("Frame created successfully");
+    } else {
+      NXPLOG_FWDNLD_E("Frame creation failed!!");
+      wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_FAILED);
+    }
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_CreateFramePld
+**
+** Description      Forms the frame payload
+**
+** Parameters       pDlContext - pointer to the download context structure
+**
+** Returns          NFC status
+**
+*******************************************************************************/
+static NFCSTATUS phDnldNfc_CreateFramePld(pphDnldNfc_DlContext_t pDlContext) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  uint32_t wBuffIdx = 0;
+  uint16_t wChkIntgVal = 0;
+  uint16_t wFrameLen = 0;
+
+  if (NULL == pDlContext) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameter!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    memset((pDlContext->tCmdRspFrameInfo.aFrameBuff), 0,
+           pDlContext->nxp_i2c_fragment_len);
+    (pDlContext->tCmdRspFrameInfo.dwSendlength) = 0;
+
+    if (phDnldNfc_FTNone == (pDlContext->FrameInp.Type)) {
+      (pDlContext->tCmdRspFrameInfo.dwSendlength) += PHDNLDNFC_MIN_PLD_LEN;
+    } else if (phDnldNfc_ChkIntg == (pDlContext->FrameInp.Type)) {
+      (pDlContext->tCmdRspFrameInfo.dwSendlength) += PHDNLDNFC_MIN_PLD_LEN;
+      if (nfcFL.chipType < sn100u) {
+        wChkIntgVal = nfcFL._PHDNLDNFC_USERDATA_EEPROM_OFFSET;
+
+        memcpy(&(pDlContext->tCmdRspFrameInfo
+                     .aFrameBuff[PHDNLDNFC_FRAME_RDDATA_OFFSET]),
+               &wChkIntgVal, sizeof(wChkIntgVal));
+
+        wChkIntgVal = nfcFL._PHDNLDNFC_USERDATA_EEPROM_LEN;
+        memcpy(&(pDlContext->tCmdRspFrameInfo
+                     .aFrameBuff[PHDNLDNFC_FRAME_RDDATA_OFFSET +
+                                 PHDNLDNFC_USERDATA_EEPROM_OFFSIZE]),
+               &wChkIntgVal, sizeof(wChkIntgVal));
+
+        (pDlContext->tCmdRspFrameInfo.dwSendlength) +=
+            PHDNLDNFC_USERDATA_EEPROM_LENSIZE;
+        (pDlContext->tCmdRspFrameInfo.dwSendlength) +=
+            PHDNLDNFC_USERDATA_EEPROM_OFFSIZE;
+      }
+    } else if (phDnldNfc_FTWrite == (pDlContext->FrameInp.Type)) {
+      wBuffIdx = (pDlContext->tRWInfo.wOffset);
+
+      if ((pDlContext->tRWInfo.bFramesSegmented) == false) {
+        wFrameLen = (pDlContext->tUserData.pBuff[wBuffIdx]);
+        wFrameLen <<= 8;
+        wFrameLen |= (pDlContext->tUserData.pBuff[wBuffIdx + 1]);
+
+        (pDlContext->tRWInfo.wRWPldSize) = wFrameLen;
+      }
+
+      if ((pDlContext->tRWInfo.wRWPldSize) >
+          ((pDlContext->nxp_i2c_fragment_len) -
+           (PHDNLDNFC_FRAME_HDR_LEN + PHDNLDNFC_FRAME_CRC_LEN))) {
+        if ((pDlContext->tRWInfo.bFirstChunkResp) == false) {
+          (pDlContext->tRWInfo.wRemChunkBytes) = wFrameLen;
+          (pDlContext->tRWInfo.wOffset) += PHDNLDNFC_FRAME_HDR_LEN;
+          wBuffIdx = (pDlContext->tRWInfo.wOffset);
+        }
+
+        if (((pDlContext->nxp_i2c_fragment_len) -
+             (PHDNLDNFC_FRAME_HDR_LEN + PHDNLDNFC_FRAME_CRC_LEN)) <
+            (pDlContext->tRWInfo.wRemChunkBytes)) {
+          (pDlContext->tRWInfo.wBytesToSendRecv) =
+              ((pDlContext->nxp_i2c_fragment_len) -
+               (PHDNLDNFC_FRAME_HDR_LEN + PHDNLDNFC_FRAME_CRC_LEN));
+          (pDlContext->tRWInfo.bFramesSegmented) = true;
+        } else {
+          (pDlContext->tRWInfo.wBytesToSendRecv) =
+              (pDlContext->tRWInfo.wRemChunkBytes);
+          (pDlContext->tRWInfo.bFramesSegmented) = false;
+        }
+
+        memcpy(&(pDlContext->tCmdRspFrameInfo
+                     .aFrameBuff[PHDNLDNFC_FRAMEID_OFFSET]),
+               &(pDlContext->tUserData.pBuff[wBuffIdx]),
+               (pDlContext->tRWInfo.wBytesToSendRecv));
+      } else {
+        (pDlContext->tRWInfo.wRWPldSize) = 0;
+        (pDlContext->tRWInfo.wBytesToSendRecv) =
+            (wFrameLen + PHDNLDNFC_FRAME_HDR_LEN);
+
+        memcpy(&(pDlContext->tCmdRspFrameInfo.aFrameBuff[0]),
+               &(pDlContext->tUserData.pBuff[wBuffIdx]),
+               (pDlContext->tRWInfo.wBytesToSendRecv));
+      }
+      (pDlContext->tCmdRspFrameInfo.dwSendlength) +=
+          (pDlContext->tRWInfo.wBytesToSendRecv);
+    } else if (phDnldNfc_FTRead == (pDlContext->FrameInp.Type)) {
+      (pDlContext->tRWInfo.wBytesToSendRecv) =
+          ((pDlContext->tRWInfo.wRemBytes) > (pDlContext->tRWInfo.wRWPldSize))
+              ? (pDlContext->tRWInfo.wRWPldSize)
+              : (uint16_t)(pDlContext->tRWInfo.wRemBytes);
+
+      wBuffIdx = (PHDNLDNFC_PLD_OFFSET +
+                  ((sizeof(pDlContext->tRWInfo.wBytesToSendRecv)) %
+                   PHDNLDNFC_MIN_PLD_LEN) -
+                  1);
+
+      memcpy(&(pDlContext->tCmdRspFrameInfo.aFrameBuff[wBuffIdx]),
+             &(pDlContext->tRWInfo.wBytesToSendRecv),
+             (sizeof(pDlContext->tRWInfo.wBytesToSendRecv)));
+
+      wBuffIdx += (uint32_t)sizeof(pDlContext->tRWInfo.wBytesToSendRecv);
+
+      memcpy(&(pDlContext->tCmdRspFrameInfo.aFrameBuff[wBuffIdx]),
+             &(pDlContext->tRWInfo.dwAddr), sizeof(pDlContext->tRWInfo.dwAddr));
+
+      (pDlContext->tCmdRspFrameInfo.dwSendlength) +=
+          (PHDNLDNFC_MIN_PLD_LEN + (sizeof(pDlContext->tRWInfo.dwAddr)));
+    } else if (phDnldNfc_FTLog == (pDlContext->FrameInp.Type)) {
+      (pDlContext->tCmdRspFrameInfo.dwSendlength) += PHDNLDNFC_MIN_PLD_LEN;
+
+      wBuffIdx = (PHDNLDNFC_MIN_PLD_LEN + PHDNLDNFC_FRAME_HDR_LEN);
+
+      memcpy(&(pDlContext->tCmdRspFrameInfo.aFrameBuff[wBuffIdx]),
+             (pDlContext->tUserData.pBuff), (pDlContext->tUserData.wLen));
+
+      (pDlContext->tCmdRspFrameInfo.dwSendlength) +=
+          (uint16_t)(pDlContext->tUserData.wLen);
+    } else if (phDnldNfc_FTForce == (pDlContext->FrameInp.Type)) {
+      (pDlContext->tCmdRspFrameInfo.dwSendlength) += PHDNLDNFC_MIN_PLD_LEN;
+
+      wBuffIdx = PHDNLDNFC_PLD_OFFSET;
+
+      memcpy(&(pDlContext->tCmdRspFrameInfo.aFrameBuff[wBuffIdx]),
+             (pDlContext->tUserData.pBuff), (pDlContext->tUserData.wLen));
+    } else if (phDnldNfc_FTRaw == (pDlContext->FrameInp.Type)) {
+      if ((0 == (pDlContext->tUserData.wLen)) ||
+          (NULL == (pDlContext->tUserData.pBuff))) {
+        NXPLOG_FWDNLD_E("Invalid Input Parameter(s) for Raw Request!!");
+        wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+      } else {
+        memcpy(&(pDlContext->tCmdRspFrameInfo.aFrameBuff[wBuffIdx]),
+               (pDlContext->tUserData.pBuff), (pDlContext->tUserData.wLen));
+
+        (pDlContext->tCmdRspFrameInfo.dwSendlength) +=
+            (uint16_t)(pDlContext->tUserData.wLen);
+      }
+    } else {
+    }
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_ProcessFrame
+**
+** Description      Processes response frame received
+**
+** Parameters       pContext - pointer to the download context structure
+**                  pInfo - pointer to the Transaction buffer updated by TML
+**                          Thread
+**
+** Returns          NFCSTATUS_SUCCESS - parameters successfully validated
+**                  NFCSTATUS_INVALID_PARAMETER - invalid parameters
+**
+*******************************************************************************/
+static NFCSTATUS phDnldNfc_ProcessFrame(void *pContext,
+                                        phTmlNfc_TransactInfo_t *pInfo) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  uint16_t wCrcVal, wRecvdCrc, wRecvdLen, wPldLen;
+  pphDnldNfc_DlContext_t pDlCtxt = (pphDnldNfc_DlContext_t)pContext;
+
+  if ((NULL == pDlCtxt) || (NULL == pInfo)) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameters!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    if ((PH_DL_STATUS_OK != pInfo->wStatus) || (0 == pInfo->wLength) ||
+        (NULL == pInfo->pBuff)) {
+      NXPLOG_FWDNLD_E("Dnld Cmd Request Failed!!");
+      wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_FAILED);
+    } else {
+      if (phDnldNfc_FTRaw == (pDlCtxt->FrameInp.Type)) {
+        if ((0 != (pDlCtxt->tRspBuffInfo.wLen)) &&
+            (NULL != (pDlCtxt->tRspBuffInfo.pBuff))) {
+          memcpy((pDlCtxt->tRspBuffInfo.pBuff), (pInfo->pBuff),
+                 (pInfo->wLength));
+
+          (pDlCtxt->tRspBuffInfo.wLen) = (pInfo->wLength);
+        } else {
+          NXPLOG_FWDNLD_E("Cannot update Response buff with received data!!");
+        }
+      } else {
+        if (pInfo->wLength <= PHDNLDNFC_FRAME_CRC_LEN) {
+          NXPLOG_FWDNLD_E("Invalid frame received");
+          wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_FAILED);
+          return wStatus;
+        }
+        /* calculate CRC16 */
+        wCrcVal = phDnldNfc_CalcCrc16(
+            (pInfo->pBuff), ((pInfo->wLength) - PHDNLDNFC_FRAME_CRC_LEN));
+
+        wRecvdCrc = 0;
+        wRecvdCrc = (((uint16_t)(pInfo->pBuff[(pInfo->wLength) - 2]) << 8U) |
+                     (pInfo->pBuff[(pInfo->wLength) - 1]));
+
+        if (wRecvdCrc == wCrcVal) {
+          wRecvdLen =
+              (((uint16_t)(pInfo->pBuff[PHDNLDNFC_FRAME_HDR_OFFSET]) << 8U) |
+               (pInfo->pBuff[PHDNLDNFC_FRAME_HDR_OFFSET + 1]));
+
+          wPldLen = ((pInfo->wLength) -
+                     (PHDNLDNFC_FRAME_HDR_LEN + PHDNLDNFC_FRAME_CRC_LEN));
+
+          if (wRecvdLen != wPldLen) {
+            NXPLOG_FWDNLD_E("Invalid frame payload length received");
+            wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_FAILED);
+          } else {
+            wStatus = phDnldNfc_UpdateRsp(pDlCtxt, pInfo, (wPldLen - 1));
+          }
+        } else {
+          NXPLOG_FWDNLD_E("Invalid frame received");
+          wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_FAILED);
+        }
+      }
+    }
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_ProcessRecvInfo
+**
+** Description      Processes the response during the state phDnldNfc_StateRecv
+**
+** Parameters       pContext - pointer to the download context structure
+**                  pInfo - pointer to the Transaction buffer updated by TML
+**                          Thread
+**
+** Returns          NFCSTATUS_SUCCESS - parameters successfully validated
+**                  NFCSTATUS_INVALID_PARAMETER - invalid parameters
+**
+*******************************************************************************/
+static NFCSTATUS phDnldNfc_ProcessRecvInfo(void *pContext,
+                                           phTmlNfc_TransactInfo_t *pInfo) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  if (NULL != pContext) {
+    if (NULL == pInfo) {
+      NXPLOG_FWDNLD_E("Invalid pInfo received from TML!!");
+      wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_FAILED);
+    } else {
+      wStatus = PHNFCSTATUS(pInfo->wStatus);
+
+      if (NFCSTATUS_SUCCESS == wStatus) {
+        NXPLOG_FWDNLD_D("Send Success");
+      } else {
+        NXPLOG_FWDNLD_E("Tml Write error!!");
+        wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_FAILED);
+      }
+    }
+  } else {
+    NXPLOG_FWDNLD_E("Invalid context received from TML!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_FAILED);
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_SetupResendTimer
+**
+** Description      Sets up the timer for resending the previous write frame
+**
+** Parameters       pDlContext - pointer to the download context structure
+**
+** Returns          NFC status
+**
+*******************************************************************************/
+static NFCSTATUS phDnldNfc_SetupResendTimer(pphDnldNfc_DlContext_t pDlContext) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  wStatus = phOsalNfc_Timer_Start((pDlContext->TimerInfo.dwRspTimerId),
+                                  PHDNLDNFC_RETRY_FRAME_WRITE,
+                                  &phDnldNfc_ResendTimeOutCb, pDlContext);
+
+  if (NFCSTATUS_SUCCESS == wStatus) {
+    NXPLOG_FWDNLD_D("Frame Resend wait timer started");
+    (pDlContext->TimerInfo.TimerStatus) = 1;
+    pDlContext->tCurrState = phDnldNfc_StateTimer;
+  } else {
+    NXPLOG_FWDNLD_W("Frame Resend wait timer not started");
+    (pDlContext->TimerInfo.TimerStatus) = 0; /*timer stopped*/
+    pDlContext->tCurrState = phDnldNfc_StateResponse;
+    /* Todo:- diagnostic in this case */
+  }
+
+  return wStatus;
+}
+
+#if !defined(PH_LIBNFC_VEN_RESET_ON_DOWNLOAD_TIMEOUT)
+#error PH_LIBNFC_VEN_RESET_ON_DOWNLOAD_TIMEOUT has to be defined
+#endif
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_RspTimeOutCb
+**
+** Description      Callback function in case of timer expiration
+**
+** Parameters       TimerId  - expired timer id
+**                  pContext - pointer to the download context structure
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phDnldNfc_RspTimeOutCb(uint32_t TimerId, void *pContext) {
+  pphDnldNfc_DlContext_t pDlCtxt = (pphDnldNfc_DlContext_t)pContext;
+
+  if (NULL != pDlCtxt) {
+    UNUSED_PROP(TimerId);
+
+    if (1 == pDlCtxt->TimerInfo.TimerStatus) {
+      /* No response received and the timer expired */
+      pDlCtxt->TimerInfo.TimerStatus = 0; /* Reset timer status flag */
+
+      NXPLOG_FWDNLD_D("%x", pDlCtxt->tLastStatus);
+
+#if (PH_LIBNFC_VEN_RESET_ON_DOWNLOAD_TIMEOUT == TRUE)
+      if (PH_DL_STATUS_SIGNATURE_ERROR == pDlCtxt->tLastStatus) {
+        /* Do a VEN Reset of the chip. */
+        NXPLOG_FWDNLD_E("Performing a VEN Reset");
+        phTmlNfc_IoCtl(phTmlNfc_e_EnableNormalMode);
+        phTmlNfc_IoCtl(phTmlNfc_e_EnableDownloadMode);
+        NXPLOG_FWDNLD_E("VEN Reset Done");
+      }
+#endif
+
+      (pDlCtxt->TimerInfo.wTimerExpStatus) = NFCSTATUS_RF_TIMEOUT;
+
+      if ((phDnldNfc_EventRead == pDlCtxt->tCurrEvent) ||
+          (phDnldNfc_EventWrite == pDlCtxt->tCurrEvent)) {
+        phDnldNfc_ProcessRWSeqState(pDlCtxt, NULL);
+      } else {
+        phDnldNfc_ProcessSeqState(pDlCtxt, NULL);
+      }
+    }
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_ResendTimeOutCb
+**
+** Description      Callback function in case of Frame Resend Wait timer
+**                  expiration
+**
+** Parameters       TimerId  - expired timer id
+**                  pContext - pointer to the download context structure
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phDnldNfc_ResendTimeOutCb(uint32_t TimerId, void *pContext) {
+  pphDnldNfc_DlContext_t pDlCtxt = (pphDnldNfc_DlContext_t)pContext;
+
+  if (NULL != pDlCtxt) {
+    UNUSED_PROP(TimerId);
+
+    if (1 == pDlCtxt->TimerInfo.TimerStatus) {
+      /* No response received and the timer expired */
+      pDlCtxt->TimerInfo.TimerStatus = 0; /* Reset timer status flag */
+
+      (pDlCtxt->TimerInfo.wTimerExpStatus) = 0;
+
+      pDlCtxt->tCurrState = phDnldNfc_StateSend;
+
+      /* set the flag to trigger last frame re-transmission */
+      pDlCtxt->bResendLastFrame = true;
+
+      phDnldNfc_ProcessRWSeqState(pDlCtxt, NULL);
+    }
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_UpdateRsp
+**
+** Description      verifies the payload status byte and copies data
+**                  to response buffer if successful
+**
+** Parameters       pDlContext - pointer to the download context structure
+**                  pInfo - pointer to the Transaction buffer updated by TML
+**                          Thread
+**                  wPldLen - Length of the payload bytes to copy to response
+**                            buffer
+**
+** Returns          NFC status
+**
+*******************************************************************************/
+static NFCSTATUS phDnldNfc_UpdateRsp(pphDnldNfc_DlContext_t pDlContext,
+                                     phTmlNfc_TransactInfo_t *pInfo,
+                                     uint16_t wPldLen) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  uint16_t wReadLen = 0;
+
+  if ((NULL == pDlContext) || (NULL == pInfo)) {
+    NXPLOG_FWDNLD_E("Invalid Input Parameters!!");
+    wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    if (PH_DL_CMD_WRITE == (pDlContext->tCmdId)) {
+      if (PH_DL_STATUS_OK == (pInfo->pBuff[PHDNLDNFC_FRAMESTATUS_OFFSET])) {
+        /* first write frame response received case */
+        if ((pDlContext->tRWInfo.bFirstWrReq) == true) {
+          NXPLOG_FWDNLD_D("First Write Frame Success Status received!!");
+          (pDlContext->tRWInfo.bFirstWrReq) = false;
+        }
+
+        if ((pDlContext->tRWInfo.bFirstChunkResp) == true) {
+          if ((pDlContext->tRWInfo.bFramesSegmented) == false) {
+            NXPLOG_FWDNLD_D("Chunked Write Frame Success Status received!!");
+            (pDlContext->tRWInfo.wRemChunkBytes) -=
+                (pDlContext->tRWInfo.wBytesToSendRecv);
+            (pDlContext->tRWInfo.bFirstChunkResp) = false;
+          } else {
+            NXPLOG_FWDNLD_E("UnExpected Status received!!");
+            wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_FAILED);
+          }
+        }
+
+        if (NFCSTATUS_SUCCESS == wStatus) {
+          (pDlContext->tRWInfo.wRemBytes) -=
+              (pDlContext->tRWInfo.wBytesToSendRecv);
+          (pDlContext->tRWInfo.wOffset) +=
+              (pDlContext->tRWInfo.wBytesToSendRecv);
+        }
+      } else if (((pDlContext->tRWInfo.bFirstChunkResp) == false) &&
+                 ((pDlContext->tRWInfo.bFramesSegmented) == true) &&
+                 (PHDNLDNFC_FIRST_FRAGFRAME_RESP ==
+                  (pInfo->pBuff[PHDNLDNFC_FRAMESTATUS_OFFSET]))) {
+        (pDlContext->tRWInfo.bFirstChunkResp) = true;
+        (pDlContext->tRWInfo.wRemChunkBytes) -=
+            (pDlContext->tRWInfo.wBytesToSendRecv);
+        (pDlContext->tRWInfo.wRemBytes) -=
+            ((pDlContext->tRWInfo.wBytesToSendRecv) + PHDNLDNFC_FRAME_HDR_LEN);
+        (pDlContext->tRWInfo.wOffset) += (pDlContext->tRWInfo.wBytesToSendRecv);
+
+        /* first write frame response received case */
+        if ((pDlContext->tRWInfo.bFirstWrReq) == true) {
+          NXPLOG_FWDNLD_D("First Write Frame Success Status received!!");
+          (pDlContext->tRWInfo.bFirstWrReq) = false;
+        }
+      } else if (((pDlContext->tRWInfo.bFirstChunkResp) == true) &&
+                 ((pDlContext->tRWInfo.bFramesSegmented) == true) &&
+                 (PHDNLDNFC_NEXT_FRAGFRAME_RESP ==
+                  (pInfo->pBuff[PHDNLDNFC_FRAMESTATUS_OFFSET]))) {
+        (pDlContext->tRWInfo.wRemChunkBytes) -=
+            (pDlContext->tRWInfo.wBytesToSendRecv);
+        (pDlContext->tRWInfo.wRemBytes) -=
+            (pDlContext->tRWInfo.wBytesToSendRecv);
+        (pDlContext->tRWInfo.wOffset) += (pDlContext->tRWInfo.wBytesToSendRecv);
+      } else if (PH_DL_STATUS_FIRMWARE_VERSION_ERROR ==
+                 (pInfo->pBuff[PHDNLDNFC_FRAMESTATUS_OFFSET])) {
+        NXPLOG_FWDNLD_E(
+            "FW version Error !!!could be either due to FW major version "
+            "mismatch or Firmware Already Up To Date !!");
+        (pDlContext->tRWInfo.bFirstWrReq) = false;
+        /* resetting wRemBytes to 0 to avoid any further write frames send */
+        (pDlContext->tRWInfo.wRemBytes) = 0;
+        (pDlContext->tRWInfo.wOffset) = 0;
+        wStatus = NFCSTATUS_FW_VERSION_ERROR;
+      } else if (PH_DL_STATUS_PLL_ERROR ==
+                 (pInfo->pBuff[PHDNLDNFC_FRAMESTATUS_OFFSET])) {
+        NXPLOG_FWDNLD_E("PLL Error Status received!!");
+        (pDlContext->tLastStatus) = PH_DL_STATUS_PLL_ERROR;
+        wStatus = NFCSTATUS_WRITE_FAILED;
+      } else if (PH_DL_STATUS_SIGNATURE_ERROR ==
+                 (pInfo->pBuff[PHDNLDNFC_FRAMESTATUS_OFFSET])) {
+        NXPLOG_FWDNLD_E("Signature Mismatch Error received!!");
+        /* save the status for use in loading the relevant recovery image
+         * (either signature or platform) */
+        (pDlContext->tLastStatus) = PH_DL_STATUS_SIGNATURE_ERROR;
+        wStatus = NFCSTATUS_REJECTED;
+      } else if (PH_DL_STATUS_MEM_BSY ==
+                 (pInfo->pBuff[PHDNLDNFC_FRAMESTATUS_OFFSET])) {
+        NXPLOG_FWDNLD_E("Mem Busy Status received!!");
+        (pDlContext->tLastStatus) = PH_DL_STATUS_MEM_BSY;
+        wStatus = NFCSTATUS_BUSY;
+      } else {
+        NXPLOG_FWDNLD_E("Unsuccessful Status received!!");
+        wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_FAILED);
+      }
+    } else if (PH_DL_CMD_READ == (pDlContext->tCmdId)) {
+      if (PH_DL_STATUS_OK == (pInfo->pBuff[PHDNLDNFC_FRAMESTATUS_OFFSET])) {
+        wReadLen = (((uint16_t)(pInfo->pBuff[PHDNLDNFC_FRAMESTATUS_OFFSET + 3])
+                     << 8U) |
+                    (pInfo->pBuff[PHDNLDNFC_FRAMESTATUS_OFFSET + 2]));
+
+        if (wReadLen != (pDlContext->tRWInfo.wBytesToSendRecv)) {
+          NXPLOG_FWDNLD_E("Desired Length bytes not received!!");
+          wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_FAILED);
+        } else {
+          memcpy(
+              &(pDlContext->tRspBuffInfo.pBuff[(pDlContext->tRWInfo.wOffset)]),
+              &(pInfo->pBuff[PHDNLDNFC_FRAME_RDDATA_OFFSET]), wReadLen);
+
+          (pDlContext->tRWInfo.wBytesRead) += wReadLen;
+
+          (pDlContext->tRspBuffInfo.wLen) = (pDlContext->tRWInfo.wBytesRead);
+
+          (pDlContext->tRWInfo.wRemBytes) -=
+              (pDlContext->tRWInfo.wBytesToSendRecv);
+          (pDlContext->tRWInfo.dwAddr) +=
+              (pDlContext->tRWInfo.wBytesToSendRecv);
+          (pDlContext->tRWInfo.wOffset) +=
+              (pDlContext->tRWInfo.wBytesToSendRecv);
+        }
+      } else {
+        NXPLOG_FWDNLD_E("Unsuccessful Status received!!");
+        wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_FAILED);
+      }
+    } else {
+      if (PH_DL_STATUS_OK == (pInfo->pBuff[PHDNLDNFC_FRAMESTATUS_OFFSET])) {
+        if ((pDlContext->tRspBuffInfo.wLen) >= wPldLen) {
+          if ((0 != (pDlContext->tRspBuffInfo.wLen)) &&
+              (NULL != (pDlContext->tRspBuffInfo.pBuff))) {
+            memcpy((pDlContext->tRspBuffInfo.pBuff),
+                   &(pInfo->pBuff[PHDNLDNFC_FRAMESTATUS_OFFSET + 1]), wPldLen);
+
+            (pDlContext->tRspBuffInfo.wLen) = wPldLen;
+          }
+        } else if ((pDlContext->tRspBuffInfo.wLen) == 0) {
+          NXPLOG_FWDNLD_D("Ignore the response");
+        }
+      } else {
+        NXPLOG_FWDNLD_E("Unsuccessful Status received!! wPldLen = 0x%x "
+                        ",pDlContext->tRspBuffInfo.wLen = 0x%x",
+                        wPldLen, pDlContext->tRspBuffInfo.wLen);
+        wStatus = PHNFCSTVAL(CID_NFC_DNLD, NFCSTATUS_FAILED);
+      }
+    }
+  }
+
+  return wStatus;
+}
diff --git a/pn72xx/halimpl/dnld/phDnldNfc_Internal.h b/pn72xx/halimpl/dnld/phDnldNfc_Internal.h
new file mode 100644
index 00000000..051eb2be
--- /dev/null
+++ b/pn72xx/halimpl/dnld/phDnldNfc_Internal.h
@@ -0,0 +1,216 @@
+/*
+ * Copyright 2010-2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Internal Primitives (Functions + Variables) used for Firmware Download
+ */
+#ifndef PHDNLDNFC_INTERNAL_H
+#define PHDNLDNFC_INTERNAL_H
+
+#include <phDnldNfc.h>
+#include <phDnldNfc_Cmd.h>
+#include <phDnldNfc_Status.h>
+
+/*The fragment length must be increased to send a complete FW package in
+  one command since firmware doesn't support chunk packages.*/
+#define PHDNLDNFC_CMDRESP_MAX_BUFF_SIZE_PN72XX (0x22AU)
+
+/* DL Host Short Frame Buffer Size for pipelined WRITE RSP */
+#define PHDNLDNFC_WRITERSP_BUFF_SIZE (0x08U)
+
+/* DL Host Frame Buffer Header Length */
+#define PHDNLDNFC_FRAME_HDR_LEN (0x02U)
+/* DL Host Frame Buffer CRC Length */
+#define PHDNLDNFC_FRAME_CRC_LEN (PHDNLDNFC_FRAME_HDR_LEN)
+#define PHDNLDNFC_FRAME_ID_LEN (0x01U) /* Length of Cmd Id */
+
+/* size of EEPROM/Flash address */
+#define PHDNLDNFC_EEFL_ADDR_SIZE (0x03U)
+/* 2 Byte size of data */
+#define PHDNLDNFC_DATA_SIZE (PHDNLDNFC_FRAME_HDR_LEN)
+
+/* Start of EEPROM address for log */
+#define PHDNLDNFC_EEPROM_LOG_START_ADDR (0x201F80U)
+/* End of EEPROM address for log */
+#define PHDNLDNFC_EEPROM_LOG_END_ADDR (0x201FBFU)
+
+#define PHDNLDNFC_MAX_LOG_SIZE                                                 \
+  ((PHDNLDNFC_EEPROM_LOG_END_ADDR - PHDNLDNFC_EEPROM_LOG_START_ADDR) + 1)
+
+/*
+ * Enum definition contains Download Event Types
+ */
+typedef enum phDnldNfc_Event {
+  phDnldNfc_EventInvalid = 0x00, /*Invalid Event Value*/
+  phDnldNfc_EventReset,          /* Reset event */
+  phDnldNfc_EventGetVer,         /* Get Version event*/
+  phDnldNfc_EventWrite,          /* Write event*/
+  phDnldNfc_EventRead,           /* Read event*/
+  phDnldNfc_EventIntegChk,       /* Integrity Check event*/
+  phDnldNfc_EventGetSesnSt,      /* Get Session State event*/
+#if (NXP_EXTNS == TRUE)
+  phDnldNfc_EventGetDieId, /* Get Die ID event*/
+#endif
+  phDnldNfc_EventLog,   /* Log event*/
+  phDnldNfc_EventForce, /* Force event*/
+  phDnldNfc_EventRaw, /* Raw Req/Rsp event,used currently for sending NCI RESET
+                         cmd */
+  phDnldNfc_EVENT_INT_MAX /* Max Event Count*/
+} phDnldNfc_Event_t;
+
+/*
+ * Enum definition contains Download Handler states for each event requested
+ */
+typedef enum phDnldNfc_State {
+  phDnldNfc_StateInit = 0x00, /* Handler init state */
+  phDnldNfc_StateSend,        /* Send frame to NFCC state */
+  phDnldNfc_StateRecv,        /* Recv Send complete State */
+  phDnldNfc_StateTimer, /* State to stop prev set timer on Recv or handle timed
+                           out scenario */
+  phDnldNfc_StateResponse,  /* Process response from NFCC state */
+  phDnldNfc_StatePipelined, /* Write requests to be pipelined state */
+  phDnldNfc_StateInvalid    /* Invalid Handler state */
+} phDnldNfc_State_t;
+
+/*
+ * Enum definition contains Download Handler Transition
+ */
+typedef enum phDnldNfc_Transition {
+  phDnldNfc_TransitionIdle =
+      0x00, /* Handler in Idle state - No Download in progress */
+  phDnldNfc_TransitionBusy,   /* Handler is busy processing download request */
+  phDnldNfc_TransitionInvalid /* Invalid Handler Transition */
+} phDnldNfc_Transition_t;
+
+/*
+ * Enum definition contains the Frame input type for CmdId in process
+ */
+typedef enum {
+  phDnldNfc_FTNone = 0, /* input type None */
+  phDnldNfc_ChkIntg, /* user eeprom offset & len to be added for Check Integrity
+                        Request */
+  phDnldNfc_FTWrite, /* Frame inputs for Write request */
+  phDnldNfc_FTLog,   /* Frame inputs for Log request */
+  phDnldNfc_FTForce, /* Frame input for Force cmd request */
+  phDnldNfc_FTRead,  /* Addr input required for read request */
+  phDnldNfc_FTRaw    /* Raw Req/Rsp type */
+} phDnldNfc_FrameInputType_t;
+
+/*
+ * Enum definition contains Firmware file format
+ */
+typedef enum phDnldNfc_FwFormat {
+  FW_FORMAT_UNKNOWN = 0x00,
+  FW_FORMAT_SO = 0x01,
+  FW_FORMAT_BIN = 0x02,
+  FW_FORMAT_ARRAY = 0x03,
+} phDnldNfc_FwFormat_t;
+
+/*
+ * Contains Host Frame Buffer information.
+ */
+typedef struct phDnldNfc_FrameInfo {
+  uint16_t dwSendlength; /* length of the payload  */
+  uint8_t aFrameBuff[PHDNLDNFC_CMDRESP_MAX_BUFF_SIZE_PN72XX]; /* Buffer to store
+                                                          command that needs to
+                                                          be sent*/
+} phDnldNfc_FrameInfo_t,
+    *pphDnldNfc_FrameInfo_t; /* pointer to #phDnldNfc_FrameInfo_t */
+
+/*
+ * Frame Input Type & Value for CmdId in Process
+ */
+typedef struct phDnldNfc_FrameInput {
+  phDnldNfc_FrameInputType_t
+      Type;        /* Type of frame input required for current cmd in process */
+  uint32_t dwAddr; /* Address value required for Read/Write Cmd*/
+} phDnldNfc_FrameInput_t,
+    *pphDnldNfc_FrameInput_t; /* pointer to #phDnldNfc_FrameInput_t */
+
+/*
+ * Context for the response timeout
+ */
+typedef struct phDnldNfc_RspTimerInfo {
+  uint32_t dwRspTimerId;     /* Timer for Core to handle response */
+  uint8_t TimerStatus;       /* 0 = Timer not running 1 = timer running*/
+  NFCSTATUS wTimerExpStatus; /* Holds the status code on timer expiry */
+  uint16_t rspTimeout;       /*FW download rsp timeout value*/
+} phDnldNfc_RspTimerInfo_t;
+
+/*
+ * Read/Write Processing Info
+ */
+typedef struct phDnldNfc_RWInfo {
+  uint32_t dwAddr;    /* current Addr updated for read/write */
+  uint32_t wOffset;   /* current offset within the user buffer to read/write */
+  uint32_t wRemBytes; /* Remaining bytes to read/write */
+  uint16_t wRemChunkBytes; /* Remaining bytes within the chunked frame */
+  uint16_t wRWPldSize;     /* Size of the read/write payload per transaction */
+  uint16_t wBytesToSendRecv; /* Num of Bytes being written/read currently */
+  uint16_t wBytesRead;       /* Bytes read from read cmd currently */
+  bool_t bFramesSegmented;   /* Flag to indicate if Read/Write frames are
+                                segmented */
+  bool_t bFirstWrReq; /* Flag to indicate if this is the first write frame being
+                         sent */
+  bool_t
+      bFirstChunkResp; /* Flag to indicate if we got the first chunk response */
+} phDnldNfc_RWInfo_t, *pphDnldNfc_RWInfo_t; /* pointer to #phDnldNfc_RWInfo_t */
+
+/*
+ * Download context structure
+ */
+typedef struct phDnldNfc_DlContext {
+  const uint8_t *nxp_nfc_fw; /* Pointer to firmware version from image */
+  const uint8_t
+      *nxp_nfc_fwp; /* Pointer to firmware version from get_version cmd */
+  uint32_t nxp_nfc_fwp_len; /* Length of firmware image length */
+  uint32_t nxp_nfc_fw_len;  /* Firmware image length */
+  uint16_t nxp_i2c_fragment_len;
+  bool_t bResendLastFrame; /* Flag to resend the last write frame after MEM_BSY
+                              status */
+  phDnldNfc_Transition_t
+      tDnldInProgress; /* Flag to indicate if download request is ongoing */
+  phDnldNfc_Event_t tCurrEvent; /* Current event being processed */
+  phDnldNfc_State_t tCurrState; /* Current state being processed */
+  pphDnldNfc_RspCb_t UserCb;    /* Upper layer call back function */
+  void *UserCtxt;               /* Pointer to upper layer context */
+  phDnldNfc_Buff_t tUserData;   /* Data buffer provided by caller */
+  phDnldNfc_Buff_t
+      tRspBuffInfo; /* Buffer to store payload field of the received response*/
+  phDnldNfc_FrameInfo_t tCmdRspFrameInfo; /* Buffer to hold the cmd/resp frame
+                                             except pipeline write */
+  phDnldNfc_FrameInfo_t
+      tPipeLineWrFrameInfo; /* Buffer to hold the pipelined write frame */
+  NFCSTATUS
+  wCmdSendStatus; /* Holds the status of cmd request made to cmd handler */
+  phDnldNfc_CmdId_t tCmdId; /* Cmd Id of the currently processed cmd */
+  phDnldNfc_FrameInput_t
+      FrameInp; /* input value required for current cmd in process */
+  phDnldNfc_RspTimerInfo_t
+      TimerInfo;              /* Timer context handled into download context*/
+  phDnldNfc_Buff_t tTKey;     /* Default Transport Key provided by caller */
+  phDnldNfc_RWInfo_t tRWInfo; /* Read/Write segmented frame info */
+  phDnldNfc_Status_t tLastStatus; /* saved status to distinguish signature or
+                                     pltform recovery */
+  phDnldNfc_FwFormat_t FwFormat;  /*FW file format either lib or bin*/
+} phDnldNfc_DlContext_t,
+    *pphDnldNfc_DlContext_t; /* pointer to #phDnldNfc_DlContext_t structure */
+
+/* The phDnldNfc_CmdHandler function declaration */
+extern NFCSTATUS phDnldNfc_CmdHandler(void *pContext,
+                                      phDnldNfc_Event_t TrigEvent);
+
+#endif /* PHDNLDNFC_INTERNAL_H */
diff --git a/pn72xx/halimpl/dnld/phDnldNfc_Status.h b/pn72xx/halimpl/dnld/phDnldNfc_Status.h
new file mode 100644
index 00000000..a5b9125f
--- /dev/null
+++ b/pn72xx/halimpl/dnld/phDnldNfc_Status.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2010-2014 NXP Semiconductors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Firmware Download Status Values
+ */
+#ifndef PHDNLDNFC_STATUS_H
+#define PHDNLDNFC_STATUS_H
+
+#include <phNfcStatus.h>
+
+/* reusing LibNfcStatus.h value below as a placeholder for now, need to find
+   the right value */
+#define NFCSTATUS_ABORTED (0x0096) /* Command aborted */
+
+/*
+ * Enum definition contains Firmware Download Status codes
+ */
+typedef enum phDnldNfc_Status {
+  PH_DL_STATUS_PLL_ERROR = 0x0D,
+  PH_DL_STATUS_LC_WRONG = 0x13,
+  PH_DL_STATUS_LC_TERMINATION_NOT_SUPPORTED = 0x14,
+  PH_DL_STATUS_LC_CREATION_NOT_SUPPORTED = 0x15,
+  PH_DL_STATUS_LC_UNKNOWN = 0x16,
+  PH_DL_STATUS_AUTHENTICATION_ERROR = 0x19,
+  PH_DL_STATUS_NOT_AUTHENTICATED = 0x1A,
+  PH_DL_STATUS_AUTHENTICATION_LOST = 0x1B,
+  PH_DL_STATUS_WRITE_PROTECTED = 0x1C,
+  PH_DL_STATUS_READ_PROTECTED = 0x1D,
+  PH_DL_STATUS_ADDR_RANGE_OFL_ERROR = 0x1E,
+  PH_DL_STATUS_BUFFER_OFL_ERROR = 0x1F,
+  PH_DL_STATUS_MEM_BSY = 0x20,
+  PH_DL_STATUS_SIGNATURE_ERROR = 0x21,
+  PH_DL_STATUS_SESSION_WAS_OPEN = 0x22,
+  PH_DL_STATUS_SESSION_WAS_CLOSED = 0x23,
+  /* the Firmware version passed to CommitSession is not greater than
+      the EEPROM resident stored Firmware version number */
+  PH_DL_STATUS_FIRMWARE_VERSION_ERROR = 0x24,
+  PH_DL_STATUS_LOOPBACK_DATA_MISSMATCH_ERROR = 0x25,
+  /*****************************/
+  PH_DL_STATUS_HOST_PAYLOAD_UFL_ERROR = 0x26,
+  PH_DL_STATUS_HOST_PAYLOAD_OFL_ERROR = 0x27,
+  PH_DL_STATUS_PROTOCOL_ERROR = 0x28,
+  /* Download codes re-mapped to generic entries */
+  PH_DL_STATUS_INVALID_ADDR = NFCSTATUS_INVALID_PARAMETER,
+  PH_DL_STATUS_GENERIC_ERROR = NFCSTATUS_FAILED,
+  PH_DL_STATUS_ABORTED_CMD = NFCSTATUS_ABORTED,
+  PH_DL_STATUS_FLASH_WRITE_PROTECTED = PH_DL_STATUS_WRITE_PROTECTED,
+  PH_DL_STATUS_FLASH_READ_PROTECTED = PH_DL_STATUS_READ_PROTECTED,
+  PH_DL_STATUS_USERDATA_WRITE_PROTECTED = PH_DL_STATUS_WRITE_PROTECTED,
+  PH_DL_STATUS_USERDATA_READ_PROTECTED = PH_DL_STATUS_READ_PROTECTED,
+  PH_DL_STATUS_OK = NFCSTATUS_SUCCESS
+} phDnldNfc_Status_t;
+
+#endif /* PHDNLDNFC_STATUS_H */
diff --git a/pn72xx/halimpl/dnld/phDnldNfc_Utils.cc b/pn72xx/halimpl/dnld/phDnldNfc_Utils.cc
new file mode 100644
index 00000000..162c6cf2
--- /dev/null
+++ b/pn72xx/halimpl/dnld/phDnldNfc_Utils.cc
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2010-2014,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Download Component
+ * Download Utility routines implementation
+ */
+
+#include <phDnldNfc_Utils.h>
+#include <phNxpLog.h>
+
+static uint16_t const aCrcTab[256] = {
+    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7, 0x8108,
+    0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef, 0x1231, 0x0210,
+    0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6, 0x9339, 0x8318, 0xb37b,
+    0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de, 0x2462, 0x3443, 0x0420, 0x1401,
+    0x64e6, 0x74c7, 0x44a4, 0x5485, 0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee,
+    0xf5cf, 0xc5ac, 0xd58d, 0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6,
+    0x5695, 0x46b4, 0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d,
+    0xc7bc, 0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
+    0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b, 0x5af5,
+    0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12, 0xdbfd, 0xcbdc,
+    0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a, 0x6ca6, 0x7c87, 0x4ce4,
+    0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41, 0xedae, 0xfd8f, 0xcdec, 0xddcd,
+    0xad2a, 0xbd0b, 0x8d68, 0x9d49, 0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13,
+    0x2e32, 0x1e51, 0x0e70, 0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a,
+    0x9f59, 0x8f78, 0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e,
+    0xe16f, 0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
+    0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e, 0x02b1,
+    0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256, 0xb5ea, 0xa5cb,
+    0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d, 0x34e2, 0x24c3, 0x14a0,
+    0x0481, 0x7466, 0x6447, 0x5424, 0x4405, 0xa7db, 0xb7fa, 0x8799, 0x97b8,
+    0xe75f, 0xf77e, 0xc71d, 0xd73c, 0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657,
+    0x7676, 0x4615, 0x5634, 0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9,
+    0xb98a, 0xa9ab, 0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882,
+    0x28a3, 0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
+    0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92, 0xfd2e,
+    0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9, 0x7c26, 0x6c07,
+    0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1, 0xef1f, 0xff3e, 0xcf5d,
+    0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8, 0x6e17, 0x7e36, 0x4e55, 0x5e74,
+    0x2e93, 0x3eb2, 0x0ed1, 0x1ef0};
+
+/*******************************************************************************
+**
+** Function         phDnldNfc_CalcCrc16
+**
+** Description      Calculates CRC16 for the frame buffer
+**
+** Parameters       pBuff - CRC16 calculation input buffer
+**                  wLen  - input buffer length
+**
+** Returns          wCrc  - computed 2 byte CRC16 value
+**
+*******************************************************************************/
+uint16_t phDnldNfc_CalcCrc16(uint8_t *pBuff, uint16_t wLen) {
+  uint16_t wTmp;
+  uint16_t wValue;
+  uint16_t wCrc = 0xffff;
+  uint32_t i;
+
+  if ((NULL == pBuff) || (0 == wLen)) {
+    NXPLOG_FWDNLD_W("Invalid Params supplied!!");
+  } else {
+    /* Perform CRC calculation according to ccitt with a initial value of 0x1d0f
+     */
+    for (i = 0; i < wLen; i++) {
+      wValue = 0x00ffU & (uint16_t)pBuff[i];
+      wTmp = (wCrc >> 8U) ^ wValue;
+      wCrc = (wCrc << 8U) ^ aCrcTab[wTmp];
+    }
+  }
+
+  return wCrc;
+}
diff --git a/pn72xx/halimpl/dnld/phDnldNfc_Utils.h b/pn72xx/halimpl/dnld/phDnldNfc_Utils.h
new file mode 100644
index 00000000..c9f61911
--- /dev/null
+++ b/pn72xx/halimpl/dnld/phDnldNfc_Utils.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2010-2014,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Firmware Download Utilities File
+ */
+#ifndef PHDNLDNFC_UTILS_H
+#define PHDNLDNFC_UTILS_H
+
+#include <phDnldNfc.h>
+
+extern uint16_t phDnldNfc_CalcCrc16(uint8_t *pBuff, uint16_t wLen);
+
+#endif /* PHDNLDNFC_UTILS_H */
diff --git a/pn72xx/halimpl/dnld/phNxpNciHal_Dnld.cc b/pn72xx/halimpl/dnld/phNxpNciHal_Dnld.cc
new file mode 100644
index 00000000..fedd2568
--- /dev/null
+++ b/pn72xx/halimpl/dnld/phNxpNciHal_Dnld.cc
@@ -0,0 +1,1586 @@
+/*
+ * Copyright 2012-2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <phDnldNfc.h>
+#include <phNxpConfig.h>
+#include <phNxpLog.h>
+#include <phNxpNciHal_Dnld.h>
+#include <phNxpNciHal_utils.h>
+#include <phTmlNfc.h>
+
+#include "NfccTransportFactory.h"
+
+/* Macro */
+#define PHLIBNFC_IOCTL_DNLD_MAX_ATTEMPTS 3
+#define PHLIBNFC_IOCTL_DNLD_GETVERLEN (0x0BU)
+#define PHLIBNFC_IOCTL_DNLD_GETVERLEN_MRA2_1 (0x09U)
+#define PHLIBNFC_DNLD_MEM_READ (0xECU)
+#define PHLIBNFC_DNLD_MEM_WRITE (0xEDU)
+#define PHLIBNFC_DNLD_READ_LOG (0xEEU)
+#define NFC_MEM_READ (0xD0U)
+#define NFC_MEM_WRITE (0xD1U)
+#define NFC_FW_DOWNLOAD (0x09F7U)
+#define PHLIBNFC_DNLD_CHECKINTEGRITYLEN (0x1FU)
+#define MAX_GET_VER_RESP_LEN (0x0FU)
+#define MAX_GET_DIE_ID_RESP_LEN (0x17U)
+
+/* Mask MSB Byte to ignore MSB Value */
+#define MASK_MSB_BYTE 0xFFFF0000
+
+/* External global variable to get FW version */
+extern uint16_t wFwVer;
+extern uint16_t wMwVer;
+extern uint8_t
+    gRecFWDwnld; /* flag  set to true to  indicate recovery FW download */
+extern spTransport gpTransportObj;
+extern phTmlNfc_Context_t *gpphTmlNfc_Context;
+
+/* RF Configuration structure */
+typedef struct phLibNfc_IoctlSetRfConfig {
+  uint8_t bNumOfParams;   /* Number of Rf configurable parameters to be set */
+  uint8_t *pInputBuffer;  /* Buffer containing Rf configurable parameters */
+  uint8_t bSetSysPmuFlag; /* Flag to decide whether to set SystemPmu or no from
+                             the first byte */
+} phLibNfc_IoctlSetRfConfig;
+
+/* Structure to hold information from EEPROM */
+typedef struct phLibNfc_EELogParams {
+  uint16_t wCurrMwVer;      /* Holds current MW version on the chip */
+  uint16_t wCurrFwVer;      /* Holds current FW version on the chip */
+  uint16_t wNumDnldTrig;    /* Total number of times dnld has been attempted */
+  uint16_t wNumDnldSuccess; /* Total number of times dnld has been successful */
+  uint16_t wNumDnldFail;    /* Total number of times dnld has Failed */
+  uint16_t wDnldFailCnt;    /* holds the number of times dnld has failed,will be
+                               reset on success */
+  bool_t bConfig; /* Flag to be set in dnld mode after successful dnld,to be
+                    reset in NCI Mode
+                    after setting the NCI configuration */
+} phLibNfc_EELogParams_t;
+
+/* FW download module context structure */
+typedef struct {
+  bool_t bDnldEepromWrite; /* Flag to indicate eeprom write request*/
+  bool_t
+      bSkipSeq; /* Flag to indicate FW download sequence to be skipped or not */
+  bool_t bSkipReset; /* Flag to indicate Reset cmd to be skipped or not in FW
+                        download sequence */
+  bool_t bSkipForce; /* Flag to indicate Force cmd to be skipped or not in FW
+                        recovery sequence */
+  bool_t bPrevSessnOpen; /* Flag to indicate previous download session is open
+                            or not */
+  bool_t bLibNfcCtxtMem; /* flag to indicate if mem was allocated for
+                            gpphLibNfc_Context */
+  bool_t bDnldInitiated; /* Flag to indicate if fw upgrade was initiated */
+  bool_t
+      bSendNciCmd; /* Flag to indicate if NCI cmd to be sent or not,after PKU */
+  uint8_t bChipVer;     /* holds the hw chip version */
+  bool_t bDnldRecovery; /* Flag to indicate if dnld recovery sequence needs to
+                           be triggered */
+  bool_t bForceDnld; /* Flag to indicate if forced download option is enabled */
+  bool_t bRetryDnld; /* Flag to indicate retry download after successful
+                        recovery complete */
+  bool_t bVenReset;  /* Flag to indicate VEN_RESET is needed after DL_RESET */
+  uint8_t
+      bDnldAttempts;  /* Holds the count of no. of dnld attempts made.max 3 */
+  uint16_t IoctlCode; /* Ioctl code*/
+  bool_t bDnldAttemptFailed; /* Flag to indicate last download attempt failed */
+  NFCSTATUS bLastStatus; /* Holds the actual download write attempt status */
+  phLibNfc_EELogParams_t tLogParams; /* holds the params that could be logged to
+                                        reserved EE address */
+  uint8_t bClkSrcVal; /* Holds the System clock source read from config file */
+  uint8_t
+      bClkFreqVal; /* Holds the System clock frequency read from config file */
+} phNxpNciHal_fw_Ioctl_Cntx_t;
+
+/* Global variables used in this file only*/
+static phNxpNciHal_fw_Ioctl_Cntx_t gphNxpNciHal_fw_IoctlCtx;
+
+/* Local function prototype */
+static NFCSTATUS phNxpNciHal_fw_dnld_reset(void *pContext, NFCSTATUS status,
+                                           void *pInfo);
+
+static void phNxpNciHal_fw_dnld_reset_cb(void *pContext, NFCSTATUS status,
+                                         void *pInfo);
+
+static NFCSTATUS phNxpNciHal_fw_dnld_force(void *pContext, NFCSTATUS status,
+                                           void *pInfo);
+
+static void phNxpNciHal_fw_dnld_force_cb(void *pContext, NFCSTATUS status,
+                                         void *pInfo);
+
+static void phNxpNciHal_fw_dnld_get_version_cb(void *pContext, NFCSTATUS status,
+                                               void *pInfo);
+
+static NFCSTATUS phNxpNciHal_fw_dnld_get_version(void *pContext,
+                                                 NFCSTATUS status, void *pInfo);
+
+static void phNxpNciHal_fw_dnld_get_sessn_state_cb(void *pContext,
+                                                   NFCSTATUS status,
+                                                   void *pInfo);
+
+static NFCSTATUS phNxpNciHal_fw_dnld_get_sessn_state(void *pContext,
+                                                     NFCSTATUS status,
+                                                     void *pInfo);
+
+static void phNxpNciHal_fw_dnld_get_die_id_cb(void *pContext, NFCSTATUS status,
+                                              void *pInfo);
+
+static NFCSTATUS phNxpNciHal_fw_dnld_get_die_id(void *pContext,
+                                                NFCSTATUS status, void *pInfo);
+
+static void phNxpNciHal_fw_dnld_write_cb(void *pContext, NFCSTATUS status,
+                                         void *pInfo);
+
+static NFCSTATUS phNxpNciHal_fw_dnld_write(void *pContext, NFCSTATUS status,
+                                           void *pInfo);
+
+static void phNxpNciHal_fw_dnld_chk_integrity_cb(void *pContext,
+                                                 NFCSTATUS status, void *pInfo);
+
+static NFCSTATUS phNxpNciHal_fw_dnld_chk_integrity(void *pContext,
+                                                   NFCSTATUS status,
+                                                   void *pInfo);
+
+static void phNxpNciHal_fw_dnld_send_ncicmd_cb(void *pContext, NFCSTATUS status,
+                                               void *pInfo);
+
+static NFCSTATUS phNxpNciHal_fw_dnld_send_ncicmd(void *pContext,
+                                                 NFCSTATUS status, void *pInfo);
+
+static NFCSTATUS phNxpNciHal_fw_dnld_complete(void *pContext, NFCSTATUS status,
+                                              void *pInfo,
+                                              bool bMinimalFw = false);
+
+/* Internal function to verify Crc Status byte received during CheckIntegrity */
+static NFCSTATUS phLibNfc_VerifyCrcStatus(uint8_t bCrcStatus);
+
+/* Internal function to verify pallas Crc info  received during CheckIntegrity
+ * response*/
+static NFCSTATUS phLibNfc_VerifyPN72xx_CrcStatus(uint8_t *bCrcStatus);
+
+static NFCSTATUS phNxpNciHal_fw_seq_handler(
+    NFCSTATUS (*seq_handler[])(void *pContext, NFCSTATUS status, void *pInfo));
+
+static NFCSTATUS phNxpNciHal_releasePendingRead();
+
+/* Array of pointers to start fw download seq */
+/* Note: FW dnld sequence for PN7220 FW */
+static NFCSTATUS (*phNxpNciHal_dwnld_seqhandler[])(void *pContext,
+                                                   NFCSTATUS status,
+                                                   void *pInfo) = {
+    phNxpNciHal_fw_dnld_get_sessn_state, phNxpNciHal_fw_dnld_get_version,
+    phNxpNciHal_fw_dnld_write,           phNxpNciHal_fw_dnld_get_sessn_state,
+    phNxpNciHal_fw_dnld_get_version,     phNxpNciHal_fw_dnld_chk_integrity,
+    phNxpNciHal_fw_dnld_get_die_id,      NULL};
+
+static NFCSTATUS (*phNxpNciHal_minimal_dwnld_seqhandler[])(void *pContext,
+                                                           NFCSTATUS status,
+                                                           void *pInfo) = {
+    phNxpNciHal_fw_dnld_write, NULL};
+
+/* Download Recovery Sequence */
+static NFCSTATUS (*phNxpNciHal_dwnld_rec_seqhandler[])(void *pContext,
+                                                       NFCSTATUS status,
+                                                       void *pInfo) = {
+    phNxpNciHal_fw_dnld_reset, phNxpNciHal_fw_dnld_force,
+    phNxpNciHal_fw_dnld_send_ncicmd, NULL};
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_reset_cb
+**
+** Description      Download Reset callback
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phNxpNciHal_fw_dnld_reset_cb(void *pContext, NFCSTATUS status,
+                                         void *pInfo) {
+  phNxpNciHal_Sem_t *p_cb_data = (phNxpNciHal_Sem_t *)pContext;
+  UNUSED_PROP(pInfo);
+  if (NFCSTATUS_SUCCESS == status) {
+    NXPLOG_FWDNLD_D("phNxpNciHal_fw_dnld_reset_cb - Request Successful");
+  } else {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_reset_cb - Request Failed!!");
+  }
+  p_cb_data->status = status;
+
+  SEM_POST(p_cb_data);
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_reset
+**
+** Description      Download Reset
+**
+** Returns          NFCSTATUS_SUCCESS if success
+**
+*******************************************************************************/
+static NFCSTATUS phNxpNciHal_fw_dnld_reset(void *pContext, NFCSTATUS status,
+                                           void *pInfo) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  phNxpNciHal_Sem_t cb_data;
+  UNUSED_PROP(pContext);
+  UNUSED_PROP(status);
+  UNUSED_PROP(pInfo);
+  if (((gphNxpNciHal_fw_IoctlCtx.bSkipSeq) == true) ||
+      ((gphNxpNciHal_fw_IoctlCtx.bSkipReset) == true)) {
+    if ((gphNxpNciHal_fw_IoctlCtx.bSkipReset) == true) {
+      (gphNxpNciHal_fw_IoctlCtx.bSkipReset) = false;
+    }
+    return NFCSTATUS_SUCCESS;
+  }
+
+  if (phNxpNciHal_init_cb_data(&cb_data, NULL) != NFCSTATUS_SUCCESS) {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_reset Create dnld_cb_data  failed");
+    return NFCSTATUS_FAILED;
+  }
+  wStatus = phDnldNfc_Reset((pphDnldNfc_RspCb_t)&phNxpNciHal_fw_dnld_reset_cb,
+                            (void *)&cb_data);
+
+  if (wStatus != NFCSTATUS_PENDING) {
+    NXPLOG_FWDNLD_E("phDnldNfc_Reset failed");
+    wStatus = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  /* Wait for callback response */
+  if (SEM_WAIT(cb_data)) {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_reset semaphore error");
+    wStatus = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  if (cb_data.status != NFCSTATUS_SUCCESS) {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_reset cb failed");
+    wStatus = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  wStatus = NFCSTATUS_SUCCESS;
+
+clean_and_return:
+  phNxpNciHal_cleanup_cb_data(&cb_data);
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_force_cb
+**
+** Description      Download Force callback
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phNxpNciHal_fw_dnld_force_cb(void *pContext, NFCSTATUS status,
+                                         void *pInfo) {
+  phNxpNciHal_Sem_t *p_cb_data = (phNxpNciHal_Sem_t *)pContext;
+  UNUSED_PROP(pInfo);
+  if (NFCSTATUS_SUCCESS == status) {
+    NXPLOG_FWDNLD_D("phLibNfc_DnldForceCb - Request Successful");
+    (gphNxpNciHal_fw_IoctlCtx.bDnldRecovery) = false;
+    (gphNxpNciHal_fw_IoctlCtx.bRetryDnld) = true;
+    (gphNxpNciHal_fw_IoctlCtx.bSkipReset) = true;
+  } else {
+    /* In this fail scenario trick the sequence handler to call next recover
+     * sequence */
+    status = NFCSTATUS_SUCCESS;
+    NXPLOG_FWDNLD_E("phLibNfc_DnldForceCb - Request Failed!!");
+  }
+  p_cb_data->status = status;
+
+  SEM_POST(p_cb_data);
+  usleep(1000 * 10);
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_force
+**
+** Description      Download Force
+**
+** Returns          NFCSTATUS_SUCCESS if success
+**
+*******************************************************************************/
+static NFCSTATUS phNxpNciHal_fw_dnld_force(void *pContext, NFCSTATUS status,
+                                           void *pInfo) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  uint8_t bClkVal[2];
+  phDnldNfc_Buff_t tData;
+  phNxpNciHal_Sem_t cb_data;
+  UNUSED_PROP(pContext);
+  UNUSED_PROP(status);
+  UNUSED_PROP(pInfo);
+  if ((gphNxpNciHal_fw_IoctlCtx.bSkipForce) == true) {
+    return NFCSTATUS_SUCCESS;
+  } else {
+    /*
+    bClkVal[0] = NXP_SYS_CLK_SRC_SEL;
+    bClkVal[1] = NXP_SYS_CLK_FREQ_SEL;
+    */
+    bClkVal[0] = gphNxpNciHal_fw_IoctlCtx.bClkSrcVal;
+    bClkVal[1] = gphNxpNciHal_fw_IoctlCtx.bClkFreqVal;
+
+    (tData.pBuff) = bClkVal;
+    (tData.wLen) = sizeof(bClkVal);
+
+    if ((gphNxpNciHal_fw_IoctlCtx.bDnldRecovery) == true) {
+      (gphNxpNciHal_fw_IoctlCtx.bDnldAttempts)++;
+    }
+
+    if (phNxpNciHal_init_cb_data(&cb_data, NULL) != NFCSTATUS_SUCCESS) {
+      NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_reset Create dnld_cb_data  failed");
+      return NFCSTATUS_FAILED;
+    }
+    wStatus = phDnldNfc_Force(&tData,
+                              (pphDnldNfc_RspCb_t)&phNxpNciHal_fw_dnld_force_cb,
+                              (void *)&cb_data);
+
+    if (NFCSTATUS_PENDING != wStatus) {
+      NXPLOG_FWDNLD_E("phDnldNfc_Force failed");
+      (gphNxpNciHal_fw_IoctlCtx.bSkipForce) = false;
+      (gphNxpNciHal_fw_IoctlCtx.bRetryDnld) = false;
+      goto clean_and_return;
+    }
+  }
+
+  /* Wait for callback response */
+  if (SEM_WAIT(cb_data)) {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_force semaphore error");
+    wStatus = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  if (cb_data.status != NFCSTATUS_SUCCESS) {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_force cb failed");
+    wStatus = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  wStatus = NFCSTATUS_SUCCESS;
+
+clean_and_return:
+  phNxpNciHal_cleanup_cb_data(&cb_data);
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_get_version_cb
+**
+** Description      Download Get version callback
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phNxpNciHal_fw_dnld_get_version_cb(void *pContext, NFCSTATUS status,
+                                               void *pInfo) {
+  phNxpNciHal_Sem_t *p_cb_data = (phNxpNciHal_Sem_t *)pContext;
+  NFCSTATUS wStatus = status;
+  pphDnldNfc_Buff_t pRespBuff;
+  uint16_t wFwVern = 0;
+  uint16_t wMwVern = 0;
+  uint8_t bHwVer = 0;
+  uint8_t bExpectedLen = 0;
+  uint8_t bNewVer[2];
+  uint8_t bCurrVer[2];
+
+  if ((NFCSTATUS_SUCCESS == wStatus) && (NULL != pInfo)) {
+    NXPLOG_FWDNLD_D("phNxpNciHal_fw_dnld_get_version_cb - Request Successful");
+
+    pRespBuff = (pphDnldNfc_Buff_t)pInfo;
+
+    if ((0 != pRespBuff->wLen) && (NULL != pRespBuff->pBuff)) {
+      bHwVer = (pRespBuff->pBuff[0]);
+      bHwVer &= 0x0F; /* 0x0F is the mask to extract chip version */
+      bool isChipTypeMatchedWithHwVersion =
+          ((PHDNLDNFC_HWVER_MRA2_1 == bHwVer) ||
+           (PHDNLDNFC_HWVER_MRA2_2 == bHwVer) ||
+#if (NXP_EXTNS == TRUE)
+           ((nfcFL.chipType >= pn7220) &&
+            (PHDNLDNFC_HWVER_PN7220_MRA1_0 == bHwVer))
+#endif
+          );
+
+      if (isChipTypeMatchedWithHwVersion) {
+        bExpectedLen = PHLIBNFC_IOCTL_DNLD_GETVERLEN_MRA2_1;
+        (gphNxpNciHal_fw_IoctlCtx.bChipVer) = bHwVer;
+      } else if ((bHwVer >= PHDNLDNFC_HWVER_MRA1_0) &&
+                 (bHwVer <= PHDNLDNFC_HWVER_MRA2_0)) {
+        bExpectedLen = PHLIBNFC_IOCTL_DNLD_GETVERLEN;
+        gphNxpNciHal_fw_IoctlCtx.bChipVer = bHwVer;
+      } else {
+        wStatus = NFCSTATUS_FAILED;
+        NXPLOG_FWDNLD_E(
+            "phNxpNciHal_fw_dnld_get_version_cb - Invalid ChipVersion!!");
+      }
+    } else {
+      wStatus = NFCSTATUS_FAILED;
+      NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_get_version_cb - Version Resp Buff "
+                      "Invalid...\n");
+    }
+
+    if ((NFCSTATUS_SUCCESS == wStatus) && (bExpectedLen == pRespBuff->wLen) &&
+        (NULL != pRespBuff->pBuff)) {
+      NXPLOG_FWDNLD_D("phNxpNciHal_fw_dnld_get_version_cb - Valid Version Resp "
+                      "Buff!!...\n");
+
+      /* Validate version details to confirm if continue with the next sequence
+       * of Operations. */
+      if (nfcFL.chipType >= sn100u) {
+        memcpy(bCurrVer, &(pRespBuff->pBuff[3]), sizeof(bCurrVer));
+      } else {
+        memcpy(bCurrVer, &(pRespBuff->pBuff[bExpectedLen - 2]),
+               sizeof(bCurrVer));
+      }
+      wFwVern = wFwVer;
+      wMwVern = wMwVer;
+
+      memcpy(bNewVer, &wFwVern, sizeof(bNewVer));
+
+      /* check if the ROM code version and FW Major version is valid for the
+       * chip*/
+      /* ES2.2 Rom Version - 0x7 and Valid FW Major Version - 0x1 */
+      if ((pRespBuff->pBuff[1] == 0x07) && (bNewVer[1] != 0x01)) {
+        NXPLOG_FWDNLD_E(
+            "C1 FW on C2 chip is not allowed - FW Major Version!= 1 on ES2.2");
+        wStatus = NFCSTATUS_NOT_ALLOWED;
+      }
+      /* Major Version number check */
+      else if ((FALSE == (gphNxpNciHal_fw_IoctlCtx.bDnldInitiated)) &&
+               (bNewVer[1] < bCurrVer[1])) {
+        NXPLOG_FWDNLD_E("Version Check Failed - MajorVerNum Mismatch\n");
+        NXPLOG_FWDNLD_E("NewVer %d != CurrVer %d\n", bNewVer[1], bCurrVer[1]);
+        wStatus = NFCSTATUS_NOT_ALLOWED;
+      }
+      /* Minor Version number check - before download.*/
+      else if ((FALSE == (gphNxpNciHal_fw_IoctlCtx.bDnldInitiated)) &&
+               ((bNewVer[0] == bCurrVer[0]) && (bNewVer[1] == bCurrVer[1]))) {
+        wStatus = NFCSTATUS_SUCCESS;
+#if (NXP_FORCE_FW_DOWNLOAD == 0)
+        NXPLOG_FWDNLD_D("Version Already UpToDate!!\n");
+        (gphNxpNciHal_fw_IoctlCtx.bSkipSeq) = TRUE;
+#else
+        (gphNxpNciHal_fw_IoctlCtx.bForceDnld) = TRUE;
+#endif
+
+      }
+      /* Minor Version number check - after download
+       * after download, we should get the same version information.*/
+      else if ((TRUE == (gphNxpNciHal_fw_IoctlCtx.bDnldInitiated)) &&
+               ((bNewVer[0] != bCurrVer[0]) || (bNewVer[1] != bCurrVer[1]))) {
+        NXPLOG_FWDNLD_E("Version Not Updated After Download!!\n");
+        wStatus = NFCSTATUS_FAILED;
+      } else {
+        NXPLOG_FWDNLD_D("Version Check Successful\n");
+        /* Store the Mw & Fw Version for updating in EEPROM Log Area after
+         * successful download */
+        if (TRUE == (gphNxpNciHal_fw_IoctlCtx.bDnldInitiated)) {
+          NXPLOG_FWDNLD_W("Updating Fw & Mw Versions..");
+          (gphNxpNciHal_fw_IoctlCtx.tLogParams.wCurrMwVer) = wMwVern;
+          (gphNxpNciHal_fw_IoctlCtx.tLogParams.wCurrFwVer) = wFwVern;
+        }
+      }
+    } else {
+      NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_get_version_cb - Version Resp Buff "
+                      "Invalid...\n");
+    }
+  } else {
+    wStatus = NFCSTATUS_FAILED;
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_get_version_cb - Request Failed!!");
+  }
+
+  p_cb_data->status = wStatus;
+  SEM_POST(p_cb_data);
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_get_version
+**
+** Description      Download Get version
+**
+** Returns          NFCSTATUS_SUCCESS if success
+**
+*******************************************************************************/
+static NFCSTATUS
+phNxpNciHal_fw_dnld_get_version(void *pContext, NFCSTATUS status, void *pInfo) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  phNxpNciHal_Sem_t cb_data;
+  static uint8_t bGetVerRes[MAX_GET_VER_RESP_LEN];
+  phDnldNfc_Buff_t tDnldBuff;
+  UNUSED_PROP(pContext);
+  UNUSED_PROP(status);
+  UNUSED_PROP(pInfo);
+  if (((gphNxpNciHal_fw_IoctlCtx.bSkipSeq) == true) ||
+      ((gphNxpNciHal_fw_IoctlCtx.bPrevSessnOpen) == true)) {
+    return NFCSTATUS_SUCCESS;
+  }
+
+  if (phNxpNciHal_init_cb_data(&cb_data, NULL) != NFCSTATUS_SUCCESS) {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_get_version cb_data creation failed");
+    return NFCSTATUS_FAILED;
+  }
+
+  tDnldBuff.pBuff = bGetVerRes;
+  tDnldBuff.wLen = sizeof(bGetVerRes);
+
+  wStatus = phDnldNfc_GetVersion(
+      &tDnldBuff, (pphDnldNfc_RspCb_t)&phNxpNciHal_fw_dnld_get_version_cb,
+      (void *)&cb_data);
+  if (wStatus != NFCSTATUS_PENDING) {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_get_version failed");
+    wStatus = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+  /* Wait for callback response */
+  if (SEM_WAIT(cb_data)) {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_get_version semaphore error");
+    wStatus = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  if (cb_data.status != NFCSTATUS_SUCCESS) {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_get_version cb failed");
+    wStatus = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  wStatus = NFCSTATUS_SUCCESS;
+
+clean_and_return:
+  phNxpNciHal_cleanup_cb_data(&cb_data);
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_get_sessn_state_cb
+**
+** Description      Download Get session state callback
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phNxpNciHal_fw_dnld_get_sessn_state_cb(void *pContext,
+                                                   NFCSTATUS status,
+                                                   void *pInfo) {
+  phNxpNciHal_Sem_t *p_cb_data = (phNxpNciHal_Sem_t *)pContext;
+  NFCSTATUS wStatus = status;
+  pphDnldNfc_Buff_t pRespBuff;
+  if ((NFCSTATUS_SUCCESS == wStatus) && (NULL != pInfo)) {
+    NXPLOG_FWDNLD_D(
+        "phNxpNciHal_fw_dnld_get_sessn_state_cb - Request Successful");
+
+    pRespBuff = (pphDnldNfc_Buff_t)pInfo;
+
+    if ((3 == (pRespBuff->wLen)) && (NULL != (pRespBuff->pBuff))) {
+      NXPLOG_FWDNLD_D(
+          "phNxpNciHal_fw_dnld_get_sessn_state_cb - Valid Session State Resp "
+          "Buff!!...");
+
+      if (phDnldNfc_LCOper == pRespBuff->pBuff[2] ||
+          0x00 == pRespBuff->pBuff[2]) {
+        if (PHLIBNFC_FWDNLD_SESSNOPEN == pRespBuff->pBuff[0]) {
+          NXPLOG_FWDNLD_E("Prev Fw Upgrade Session still Open..");
+          (gphNxpNciHal_fw_IoctlCtx.bPrevSessnOpen) = true;
+          if (nfcFL.chipType == sn100u)
+            gphNxpNciHal_fw_IoctlCtx.bVenReset = true;
+          if ((gphNxpNciHal_fw_IoctlCtx.bDnldInitiated) == true) {
+            NXPLOG_FWDNLD_D(
+                "Session still Open after Prev Fw Upgrade attempt!!");
+
+            if ((gphNxpNciHal_fw_IoctlCtx.bDnldAttempts) <
+                PHLIBNFC_IOCTL_DNLD_MAX_ATTEMPTS) {
+              NXPLOG_FWDNLD_W("Setting Dnld Retry ..");
+              (gphNxpNciHal_fw_IoctlCtx.bRetryDnld) = true;
+            } else {
+              NXPLOG_FWDNLD_E("Max Dnld Retry Counts Exceeded!!");
+              (gphNxpNciHal_fw_IoctlCtx.bRetryDnld) = false;
+            }
+            wStatus = NFCSTATUS_FAILED;
+          }
+        } else {
+          gphNxpNciHal_fw_IoctlCtx.bPrevSessnOpen = false;
+        }
+      } else {
+        wStatus = NFCSTATUS_FAILED;
+        NXPLOG_FWDNLD_E(
+            "NFCC not in Operational State..Fw Upgrade not allowed!!");
+      }
+    } else {
+      wStatus = NFCSTATUS_FAILED;
+      NXPLOG_FWDNLD_E(
+          "phNxpNciHal_fw_dnld_get_sessn_state_cb - Session State Resp Buff "
+          "Invalid...");
+    }
+  } else {
+    wStatus = NFCSTATUS_FAILED;
+    NXPLOG_FWDNLD_E(
+        "phNxpNciHal_fw_dnld_get_sessn_state_cb - Request Failed!!");
+  }
+
+  p_cb_data->status = wStatus;
+
+  SEM_POST(p_cb_data);
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_get_sessn_state
+**
+** Description      Download Get session state
+**
+** Returns          NFCSTATUS_SUCCESS if success
+**
+*******************************************************************************/
+static NFCSTATUS phNxpNciHal_fw_dnld_get_sessn_state(void *pContext,
+                                                     NFCSTATUS status,
+                                                     void *pInfo) {
+  phDnldNfc_Buff_t tDnldBuff;
+  static uint8_t bGSnStateRes[MAX_GET_DIE_ID_RESP_LEN];
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  phNxpNciHal_Sem_t cb_data;
+  UNUSED_PROP(pContext);
+  UNUSED_PROP(status);
+  UNUSED_PROP(pInfo);
+  if (gphNxpNciHal_fw_IoctlCtx.bSkipSeq == true) {
+    return NFCSTATUS_SUCCESS;
+  }
+
+  if (phNxpNciHal_init_cb_data(&cb_data, NULL) != NFCSTATUS_SUCCESS) {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_get_version cb_data creation failed");
+    return NFCSTATUS_FAILED;
+  }
+
+  tDnldBuff.pBuff = bGSnStateRes;
+  tDnldBuff.wLen = sizeof(bGSnStateRes);
+
+  wStatus = phDnldNfc_GetSessionState(
+      &tDnldBuff, &phNxpNciHal_fw_dnld_get_sessn_state_cb, (void *)&cb_data);
+  if (wStatus != NFCSTATUS_PENDING) {
+    NXPLOG_FWDNLD_E("phDnldNfc_GetSessionState failed");
+    wStatus = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  /* Wait for callback response */
+  if (SEM_WAIT(cb_data)) {
+    NXPLOG_FWDNLD_E("phDnldNfc_GetSessionState semaphore error");
+    wStatus = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  if (cb_data.status != NFCSTATUS_SUCCESS) {
+    NXPLOG_FWDNLD_E("phDnldNfc_GetSessionState cb failed");
+    wStatus = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  wStatus = NFCSTATUS_SUCCESS;
+
+clean_and_return:
+  phNxpNciHal_cleanup_cb_data(&cb_data);
+
+  return wStatus;
+}
+
+#if (NXP_EXTNS == TRUE)
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_get_die_id_cb
+**
+** Description      Download Get Die ID callback
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phNxpNciHal_fw_dnld_get_die_id_cb(void *pContext, NFCSTATUS status,
+                                              void *pInfo) {
+  phNxpNciHal_Sem_t *p_cb_data = (phNxpNciHal_Sem_t *)pContext;
+  p_cb_data->status = status;
+  UNUSED_PROP(pInfo);
+  SEM_POST(p_cb_data);
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_get_die_id
+**
+** Description      Download Get Die ID
+**
+** Returns          NFCSTATUS_SUCCESS if success
+**
+*******************************************************************************/
+static NFCSTATUS phNxpNciHal_fw_dnld_get_die_id(void *pContext,
+                                                NFCSTATUS status, void *pInfo) {
+  phDnldNfc_Buff_t tDnldBuff;
+  static uint8_t bgetDieId[3];
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  phNxpNciHal_Sem_t cb_data;
+  UNUSED_PROP(pContext);
+  UNUSED_PROP(status);
+  UNUSED_PROP(pInfo);
+  if (gphNxpNciHal_fw_IoctlCtx.bSkipSeq == true) {
+    return NFCSTATUS_SUCCESS;
+  }
+
+  if (phNxpNciHal_init_cb_data(&cb_data, NULL) != NFCSTATUS_SUCCESS) {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_get_die_id cb_data creation failed");
+    return NFCSTATUS_FAILED;
+  }
+
+  tDnldBuff.pBuff = bgetDieId;
+  tDnldBuff.wLen = sizeof(bgetDieId);
+
+  wStatus = phDnldNfc_GetDieId(&tDnldBuff, &phNxpNciHal_fw_dnld_get_die_id_cb,
+                               (void *)&cb_data);
+  if (wStatus != NFCSTATUS_PENDING) {
+    NXPLOG_FWDNLD_E("phDnldNfc_GetDieId failed");
+    wStatus = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  /* Wait for callback response */
+  if (SEM_WAIT(cb_data)) {
+    NXPLOG_FWDNLD_E("phDnldNfc_GetDieId semaphore error");
+    wStatus = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  if (cb_data.status != NFCSTATUS_SUCCESS) {
+    NXPLOG_FWDNLD_E("phDnldNfc_GetDieId cb failed");
+    wStatus = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  wStatus = NFCSTATUS_SUCCESS;
+
+clean_and_return:
+  phNxpNciHal_cleanup_cb_data(&cb_data);
+
+  return wStatus;
+}
+
+#endif
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_write_cb
+**
+** Description      Download Write callback
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phNxpNciHal_fw_dnld_write_cb(void *pContext, NFCSTATUS status,
+                                         void *pInfo) {
+  phNxpNciHal_Sem_t *p_cb_data = (phNxpNciHal_Sem_t *)pContext;
+  UNUSED_PROP(pInfo);
+  if (NFCSTATUS_SUCCESS == status) {
+    NXPLOG_FWDNLD_D("phNxpNciHal_fw_dnld_write_cb - Request Successful");
+    (gphNxpNciHal_fw_IoctlCtx.bDnldEepromWrite) = false;
+    if ((gphNxpNciHal_fw_IoctlCtx.bDnldInitiated) == true) {
+      (gphNxpNciHal_fw_IoctlCtx.tLogParams.wNumDnldSuccess) += 1;
+
+      if ((gphNxpNciHal_fw_IoctlCtx.tLogParams.wDnldFailCnt) > 0) {
+        NXPLOG_FWDNLD_D("phNxpNciHal_fw_dnld_write_cb - Resetting DnldFailCnt");
+        (gphNxpNciHal_fw_IoctlCtx.tLogParams.wDnldFailCnt) = 0;
+      }
+
+      if ((gphNxpNciHal_fw_IoctlCtx.tLogParams.bConfig) == false) {
+        NXPLOG_FWDNLD_D(
+            "phNxpNciHal_fw_dnld_write_cb - Setting bConfig for use by NCI "
+            "mode");
+        (gphNxpNciHal_fw_IoctlCtx.tLogParams.bConfig) = true;
+      }
+    }
+
+    /* Reset the previously set DnldAttemptFailed flag */
+    if ((gphNxpNciHal_fw_IoctlCtx.bDnldAttemptFailed) == true) {
+      (gphNxpNciHal_fw_IoctlCtx.bDnldAttemptFailed) = false;
+    }
+  } else {
+    if ((gphNxpNciHal_fw_IoctlCtx.bDnldInitiated) == true) {
+      (gphNxpNciHal_fw_IoctlCtx.tLogParams.wNumDnldFail) += 1;
+      (gphNxpNciHal_fw_IoctlCtx.tLogParams.wDnldFailCnt) += 1;
+      (gphNxpNciHal_fw_IoctlCtx.tLogParams.bConfig) = false;
+    }
+    if (NFCSTATUS_WRITE_FAILED == status) {
+      (gphNxpNciHal_fw_IoctlCtx.bSkipSeq) = true;
+      (gphNxpNciHal_fw_IoctlCtx.bDnldRecovery) = true;
+    }
+    // status = NFCSTATUS_FAILED;
+
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_write_cb - Request Failed!!");
+  }
+
+  p_cb_data->status = status;
+  SEM_POST(p_cb_data);
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_write
+**
+** Description      Download Write
+**
+** Returns          NFCSTATUS_SUCCESS if success
+**
+*******************************************************************************/
+static NFCSTATUS phNxpNciHal_fw_dnld_write(void *pContext, NFCSTATUS status,
+                                           void *pInfo) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  phNxpNciHal_Sem_t cb_data;
+  UNUSED_PROP(pContext);
+  UNUSED_PROP(status);
+  UNUSED_PROP(pInfo);
+  if ((gphNxpNciHal_fw_IoctlCtx.bRetryDnld) == true) {
+    (gphNxpNciHal_fw_IoctlCtx.bRetryDnld) = false;
+  }
+
+  if (((gphNxpNciHal_fw_IoctlCtx.bSkipSeq) == true) &&
+      ((gphNxpNciHal_fw_IoctlCtx.bPrevSessnOpen) == false)) {
+    return NFCSTATUS_SUCCESS;
+  }
+
+  if (phNxpNciHal_init_cb_data(&cb_data, NULL) != NFCSTATUS_SUCCESS) {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_write cb_data creation failed");
+    return NFCSTATUS_FAILED;
+  }
+
+  if ((nfcFL.nfccFL._NFCC_FORCE_FW_DOWNLOAD == false) &&
+      (false == (gphNxpNciHal_fw_IoctlCtx.bForceDnld))) {
+    NXPLOG_FWDNLD_D("phNxpNciHal_fw_dnld_write - Incrementing NumDnldTrig..");
+    (gphNxpNciHal_fw_IoctlCtx.bDnldAttempts)++;
+    (gphNxpNciHal_fw_IoctlCtx.tLogParams.wNumDnldTrig) += 1;
+  }
+  gphNxpNciHal_fw_IoctlCtx.bDnldInitiated = true;
+  wStatus = phDnldNfc_Write(false, NULL,
+                            (pphDnldNfc_RspCb_t)&phNxpNciHal_fw_dnld_write_cb,
+                            (void *)&cb_data);
+  if ((gphNxpNciHal_fw_IoctlCtx.bForceDnld) == false) {
+    if (wStatus != NFCSTATUS_PENDING) {
+      NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_write failed");
+      wStatus = NFCSTATUS_FAILED;
+      (gphNxpNciHal_fw_IoctlCtx.tLogParams.wNumDnldFail) += 1;
+      (gphNxpNciHal_fw_IoctlCtx.tLogParams.wDnldFailCnt) += 1;
+      (gphNxpNciHal_fw_IoctlCtx.tLogParams.bConfig) = false;
+      goto clean_and_return;
+    }
+  }
+  /* Wait for callback response */
+  if (SEM_WAIT(cb_data)) {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_write semaphore error");
+    wStatus = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  if (cb_data.status != NFCSTATUS_SUCCESS) {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_write cb failed");
+    wStatus = cb_data.status;
+    goto clean_and_return;
+  }
+
+  wStatus = NFCSTATUS_SUCCESS;
+
+clean_and_return:
+  phNxpNciHal_cleanup_cb_data(&cb_data);
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_chk_integrity_cb
+**
+** Description      Download Check Integrity callback
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phNxpNciHal_fw_dnld_chk_integrity_cb(void *pContext,
+                                                 NFCSTATUS status,
+                                                 void *pInfo) {
+  phNxpNciHal_Sem_t *p_cb_data = (phNxpNciHal_Sem_t *)pContext;
+  NFCSTATUS wStatus = status;
+  pphDnldNfc_Buff_t pRespBuff;
+  // uint8_t bUserDataCrc[4];
+
+  if ((NFCSTATUS_SUCCESS == wStatus) && (NULL != pInfo)) {
+    NXPLOG_FWDNLD_D(
+        "phNxpNciHal_fw_dnld_chk_integrity_cb - Request Successful");
+    pRespBuff = (pphDnldNfc_Buff_t)pInfo;
+    if ((nfcFL.chipType >= pn7220) && (NULL != (pRespBuff->pBuff))) {
+      NXPLOG_FWDNLD_D("pn72xx phNxpNciHal_fw_dnld_chk_integrity_cb - Valid "
+                      "Resp Buff!!...\n");
+      wStatus = phLibNfc_VerifyPN72xx_CrcStatus(&pRespBuff->pBuff[0]);
+    } else if ((PHLIBNFC_DNLD_CHECKINTEGRITYLEN == (pRespBuff->wLen)) &&
+               (NULL != (pRespBuff->pBuff))) {
+      NXPLOG_FWDNLD_D(
+          "phNxpNciHal_fw_dnld_chk_integrity_cb - Valid Resp Buff!!...\n");
+      wStatus = phLibNfc_VerifyCrcStatus(pRespBuff->pBuff[0]);
+      /*
+      memcpy(bUserDataCrc, &(pRespBuff->pBuff[27]),
+              sizeof(bUserDataCrc));*/
+    } else {
+      NXPLOG_FWDNLD_E(
+          "phNxpNciHal_fw_dnld_chk_integrity_cb - Resp Buff Invalid...\n");
+    }
+  } else {
+    wStatus = NFCSTATUS_FAILED;
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_chk_integrity_cb - Request Failed!!");
+  }
+
+  p_cb_data->status = wStatus;
+
+  SEM_POST(p_cb_data);
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_chk_integrity
+**
+** Description      Download Check Integrity
+**
+** Returns          NFCSTATUS_SUCCESS if success
+**
+*******************************************************************************/
+static NFCSTATUS phNxpNciHal_fw_dnld_chk_integrity(void *pContext,
+                                                   NFCSTATUS status,
+                                                   void *pInfo) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  phNxpNciHal_Sem_t cb_data;
+  phDnldNfc_Buff_t tDnldBuff;
+  static uint8_t bChkIntgRes[255];
+  UNUSED_PROP(pInfo);
+  UNUSED_PROP(pContext);
+  UNUSED_PROP(status);
+  if (gphNxpNciHal_fw_IoctlCtx.bPrevSessnOpen == true) {
+    NXPLOG_FWDNLD_D(
+        "Previous Upload session is open..Cannot issue ChkIntegrity Cmd!!");
+    return NFCSTATUS_SUCCESS;
+  }
+
+  if ((gphNxpNciHal_fw_IoctlCtx.bSkipSeq) == true) {
+    return NFCSTATUS_SUCCESS;
+  } else if (gphNxpNciHal_fw_IoctlCtx.bPrevSessnOpen == true) {
+    NXPLOG_FWDNLD_E(
+        "Previous Upload session is open..Cannot issue ChkIntegrity Cmd!!");
+    return NFCSTATUS_SUCCESS;
+  }
+
+  tDnldBuff.pBuff = bChkIntgRes;
+  tDnldBuff.wLen = sizeof(bChkIntgRes);
+
+  if (phNxpNciHal_init_cb_data(&cb_data, NULL) != NFCSTATUS_SUCCESS) {
+    NXPLOG_FWDNLD_E(
+        "phNxpNciHal_fw_dnld_chk_integrity cb_data creation failed");
+    return NFCSTATUS_FAILED;
+  }
+
+  wStatus = phDnldNfc_CheckIntegrity(
+      (gphNxpNciHal_fw_IoctlCtx.bChipVer), &tDnldBuff,
+      &phNxpNciHal_fw_dnld_chk_integrity_cb, (void *)&cb_data);
+  if (wStatus != NFCSTATUS_PENDING) {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_chk_integrity failed");
+    wStatus = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  /* Wait for callback response */
+  if (SEM_WAIT(cb_data)) {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_chk_integrity semaphore error");
+    wStatus = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+  if (cb_data.status != NFCSTATUS_SUCCESS) {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_chk_integrity cb failed");
+    wStatus = NFCSTATUS_FW_CHECK_INTEGRITY_FAILED;
+    goto clean_and_return;
+  }
+
+  wStatus = NFCSTATUS_SUCCESS;
+
+clean_and_return:
+  phNxpNciHal_cleanup_cb_data(&cb_data);
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_send_ncicmd_cb
+**
+** Description      Download Send NCI Command callback
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phNxpNciHal_fw_dnld_send_ncicmd_cb(void *pContext, NFCSTATUS status,
+                                               void *pInfo) {
+  phNxpNciHal_Sem_t *p_cb_data = (phNxpNciHal_Sem_t *)pContext;
+  NFCSTATUS wStatus = status;
+  pphDnldNfc_Buff_t pRespBuff;
+  UNUSED_PROP(pContext);
+
+  if (NFCSTATUS_SUCCESS == wStatus) {
+    NXPLOG_FWDNLD_D("phNxpNciHal_fw_dnld_send_ncicmdCb - Request Successful");
+    pRespBuff = (pphDnldNfc_Buff_t)pInfo;
+
+    if ((0 != (pRespBuff->wLen)) && (NULL != (pRespBuff->pBuff))) {
+      if (0 == (pRespBuff->pBuff[3])) {
+        NXPLOG_FWDNLD_D("Successful Response received for Nci Reset Cmd");
+      } else {
+        NXPLOG_FWDNLD_E("Nci Reset Request Failed!!");
+      }
+    } else {
+      NXPLOG_FWDNLD_E("Invalid Response received for Nci Reset Request!!");
+    }
+    /* Call Tml Ioctl to enable download mode */
+    wStatus = phTmlNfc_IoCtl(phTmlNfc_e_EnableDownloadMode);
+
+    if (NFCSTATUS_SUCCESS == wStatus) {
+      NXPLOG_FWDNLD_D("Switched Successfully to dnld mode..");
+      (gphNxpNciHal_fw_IoctlCtx.bRetryDnld) = true;
+    } else {
+      NXPLOG_FWDNLD_E("Switching back to dnld mode Failed!!");
+      (gphNxpNciHal_fw_IoctlCtx.bRetryDnld) = false;
+      wStatus = NFCSTATUS_FAILED;
+    }
+  } else {
+    NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_send_ncicmdCb - Request Failed!!");
+  }
+
+  (gphNxpNciHal_fw_IoctlCtx.bSendNciCmd) = false;
+  p_cb_data->status = wStatus;
+
+  SEM_POST(p_cb_data);
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_send_ncicmd
+**
+** Description      Download Send NCI Command
+**
+** Returns          NFCSTATUS_SUCCESS if success
+**
+*******************************************************************************/
+static NFCSTATUS
+phNxpNciHal_fw_dnld_send_ncicmd(void *pContext, NFCSTATUS status, void *pInfo) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  static uint8_t bNciCmd[4] = {0x20, 0x00, 0x01,
+                               0x00}; /* Nci Reset Cmd with KeepConfig option */
+  static uint8_t bNciResp[6];
+  phDnldNfc_Buff_t tsData;
+  phDnldNfc_Buff_t trData;
+  phNxpNciHal_Sem_t cb_data;
+
+  UNUSED_PROP(pInfo);
+  UNUSED_PROP(status);
+  UNUSED_PROP(pContext);
+  if ((gphNxpNciHal_fw_IoctlCtx.bSendNciCmd) == false) {
+    return NFCSTATUS_SUCCESS;
+  } else {
+    /* Call Tml Ioctl to enable/restore normal mode */
+    wStatus = phTmlNfc_IoCtl(phTmlNfc_e_EnableNormalMode);
+
+    if (NFCSTATUS_SUCCESS != wStatus) {
+      NXPLOG_FWDNLD_E("Switching to NormalMode Failed!!");
+      (gphNxpNciHal_fw_IoctlCtx.bRetryDnld) = false;
+      (gphNxpNciHal_fw_IoctlCtx.bSendNciCmd) = false;
+    } else {
+      if (phNxpNciHal_init_cb_data(&cb_data, NULL) != NFCSTATUS_SUCCESS) {
+        NXPLOG_FWDNLD_E(
+            "phNxpNciHal_fw_dnld_send_ncicmd cb_data creation failed");
+        return NFCSTATUS_FAILED;
+      }
+      (tsData.pBuff) = bNciCmd;
+      (tsData.wLen) = sizeof(bNciCmd);
+      (trData.pBuff) = bNciResp;
+      (trData.wLen) = sizeof(bNciResp);
+
+      wStatus = phDnldNfc_RawReq(
+          &tsData, &trData,
+          (pphDnldNfc_RspCb_t)&phNxpNciHal_fw_dnld_send_ncicmd_cb,
+          (void *)&cb_data);
+      if (NFCSTATUS_PENDING != wStatus) {
+        goto clean_and_return;
+      }
+      /* Wait for callback response */
+      if (SEM_WAIT(cb_data)) {
+        NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_send_ncicmd semaphore error");
+        wStatus = NFCSTATUS_FAILED;
+        goto clean_and_return;
+      }
+
+      if (cb_data.status != NFCSTATUS_SUCCESS) {
+        NXPLOG_FWDNLD_E("phNxpNciHal_fw_dnld_send_ncicmd cb failed");
+        wStatus = NFCSTATUS_FAILED;
+        goto clean_and_return;
+      }
+      wStatus = NFCSTATUS_SUCCESS;
+
+    clean_and_return:
+      phNxpNciHal_cleanup_cb_data(&cb_data);
+    }
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_seq_handler
+**
+** Description      Sequence Handler
+**
+** Returns          NFCSTATUS_SUCCESS if sequence completed uninterrupted
+**
+*******************************************************************************/
+static NFCSTATUS phNxpNciHal_fw_seq_handler(
+    NFCSTATUS (*seq_handler[])(void *pContext, NFCSTATUS status, void *pInfo)) {
+  const char *pContext = "FW-Download";
+  int16_t seq_counter = 0;
+  phDnldNfc_Buff_t pInfo;
+  NFCSTATUS status = NFCSTATUS_FAILED;
+
+  status = phTmlNfc_ReadAbort();
+  if (NFCSTATUS_SUCCESS != status) {
+    NXPLOG_FWDNLD_E("Tml Read Abort failed!!");
+    return status;
+  }
+
+  status = phNxpNciHal_releasePendingRead();
+  if (NFCSTATUS_SUCCESS != status) {
+    NXPLOG_FWDNLD_E("%s: Failed phNxpNciHal_releasePendingRead() !!", __func__);
+    return status;
+  }
+
+  while (seq_handler[seq_counter] != NULL) {
+    status = NFCSTATUS_FAILED;
+    status = (seq_handler[seq_counter])((void *)pContext, status, &pInfo);
+    if (NFCSTATUS_SUCCESS != status) {
+      NXPLOG_FWDNLD_E(" phNxpNciHal_fw_seq_handler : FAILED");
+      break;
+    }
+    seq_counter++;
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_switch_normal_mode
+**
+** Description      This function shall be called to switch NFCC to normal mode
+**
+** Returns          NFCSTATUS_SUCCESS if success
+**
+*******************************************************************************/
+NFCSTATUS phNxpNciHal_fw_dnld_switch_normal_mode() {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  if (nfcFL.nfccFL._NFCC_DWNLD_MODE == NFCC_DWNLD_WITH_NCI_CMD) {
+    phDnldNfc_SetDlRspTimeout((uint16_t)PHDNLDNFC_RESET_RSP_TIMEOUT);
+    wStatus = phNxpNciHal_fw_dnld_reset(nullptr, wStatus, nullptr);
+    phDnldNfc_SetDlRspTimeout((uint16_t)PHDNLDNFC_RSP_TIMEOUT);
+  }
+  if (NFCSTATUS_SUCCESS != wStatus) {
+    NXPLOG_FWDNLD_E("Switching to NormalMode Failed!!");
+  }
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_dnld_complete
+**
+** Description      Download Sequence Complete
+**
+** Returns          NFCSTATUS_SUCCESS if success
+**
+*******************************************************************************/
+static NFCSTATUS phNxpNciHal_fw_dnld_complete(void *pContext, NFCSTATUS status,
+                                              void *pInfo, bool bMinimalFw) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  NFCSTATUS fStatus = status;
+  UNUSED_PROP(pInfo);
+  UNUSED_PROP(pContext);
+
+  if (NFCSTATUS_WRITE_FAILED == status) {
+    if ((gphNxpNciHal_fw_IoctlCtx.bDnldAttempts) <
+        PHLIBNFC_IOCTL_DNLD_MAX_ATTEMPTS) {
+      (gphNxpNciHal_fw_IoctlCtx.bDnldRecovery) = !bMinimalFw;
+    } else {
+      NXPLOG_FWDNLD_E("Max Dnld Retry Counts Exceeded!!");
+      (gphNxpNciHal_fw_IoctlCtx.bDnldRecovery) = false;
+      (gphNxpNciHal_fw_IoctlCtx.bRetryDnld) = false;
+    }
+  } else if (NFCSTATUS_REJECTED == status) {
+    if ((gphNxpNciHal_fw_IoctlCtx.bDnldAttempts) <
+        PHLIBNFC_IOCTL_DNLD_MAX_ATTEMPTS) {
+      (gphNxpNciHal_fw_IoctlCtx.bDnldRecovery) = !bMinimalFw;
+
+      /* in case of signature error we need to try recover sequence directly
+       * bypassing the force cmd */
+      (gphNxpNciHal_fw_IoctlCtx.bSkipForce) = true;
+    } else {
+      NXPLOG_FWDNLD_E("Max Dnld Retry Counts Exceeded!!");
+      (gphNxpNciHal_fw_IoctlCtx.bDnldRecovery) = false;
+      (gphNxpNciHal_fw_IoctlCtx.bRetryDnld) = false;
+    }
+  }
+
+  if ((gphNxpNciHal_fw_IoctlCtx.bDnldInitiated) == true) {
+    (gphNxpNciHal_fw_IoctlCtx.bLastStatus) = status;
+    (gphNxpNciHal_fw_IoctlCtx.bDnldAttemptFailed) = true;
+    (gphNxpNciHal_fw_IoctlCtx.bDnldInitiated) = false;
+    /* Perform the Logging sequence */
+
+    if (NFCSTATUS_SUCCESS != gphNxpNciHal_fw_IoctlCtx.bLastStatus) {
+      /* update the previous Download Write status to upper layer and not the
+       * status of Log command */
+      wStatus = gphNxpNciHal_fw_IoctlCtx.bLastStatus;
+      NXPLOG_FWDNLD_E(
+          "phNxpNciHal_fw_dnld_complete: Last Download Write Status before Log "
+          "command bLastStatus = 0x%x",
+          gphNxpNciHal_fw_IoctlCtx.bLastStatus);
+    }
+    status =
+        phNxpNciHal_fw_dnld_complete(pContext, wStatus, &pInfo, bMinimalFw);
+    if (NFCSTATUS_SUCCESS == status) {
+      NXPLOG_FWDNLD_D(" phNxpNciHal_fw_dnld_complete : SUCCESS");
+    } else {
+      NXPLOG_FWDNLD_E(" phNxpNciHal_fw_dnld_complete : FAILED");
+    }
+  } else if ((gphNxpNciHal_fw_IoctlCtx.bDnldRecovery) == true) {
+    NXPLOG_FWDNLD_E("Invoking Download Recovery Sequence..");
+
+    if (NFCSTATUS_SUCCESS == wStatus) {
+      /* Perform the download Recovery sequence */
+      wStatus = phNxpNciHal_fw_seq_handler(phNxpNciHal_dwnld_rec_seqhandler);
+
+      status = phNxpNciHal_fw_dnld_complete(pContext, wStatus, &pInfo);
+      if (NFCSTATUS_SUCCESS == status) {
+        NXPLOG_FWDNLD_D(" phNxpNciHal_fw_dnld_complete : SUCCESS");
+      } else {
+        NXPLOG_FWDNLD_E(" phNxpNciHal_fw_dnld_complete : FAILED");
+      }
+    }
+  } else if ((gphNxpNciHal_fw_IoctlCtx.bRetryDnld) == true) {
+    (gphNxpNciHal_fw_IoctlCtx.bPrevSessnOpen) = false;
+    (gphNxpNciHal_fw_IoctlCtx.bDnldInitiated) = false;
+    (gphNxpNciHal_fw_IoctlCtx.bForceDnld) = false;
+    (gphNxpNciHal_fw_IoctlCtx.bSkipSeq) = false;
+    (gphNxpNciHal_fw_IoctlCtx.bSkipForce) = false;
+    (gphNxpNciHal_fw_IoctlCtx.bDnldRecovery) = false;
+    (gphNxpNciHal_fw_IoctlCtx.bSendNciCmd) = false;
+
+    /* Perform the download sequence ... after successful recover attempt */
+    wStatus = phNxpNciHal_fw_seq_handler(phNxpNciHal_dwnld_seqhandler);
+
+    status =
+        phNxpNciHal_fw_dnld_complete(pContext, wStatus, &pInfo, bMinimalFw);
+    if (NFCSTATUS_SUCCESS == status) {
+      NXPLOG_FWDNLD_D(" phNxpNciHal_fw_dnld_complete : SUCCESS");
+    } else {
+      NXPLOG_FWDNLD_E(" phNxpNciHal_fw_dnld_complete : FAILED");
+    }
+  } else {
+    NXPLOG_FWDNLD_D("phNxpNciHal_fw_dnld_complete: Download Status = 0x%x",
+                    status);
+    if ((gphNxpNciHal_fw_IoctlCtx.bSkipSeq) == false) {
+      if (NFCSTATUS_SUCCESS == status) {
+        if (NFC_FW_DOWNLOAD == gphNxpNciHal_fw_IoctlCtx.IoctlCode) {
+          NXPLOG_FWDNLD_E("Fw Download success.. ");
+        } else if (PHLIBNFC_DNLD_MEM_READ ==
+                   gphNxpNciHal_fw_IoctlCtx.IoctlCode) {
+          NXPLOG_FWDNLD_E("Read Request success.. ");
+        } else if (PHLIBNFC_DNLD_MEM_WRITE ==
+                   gphNxpNciHal_fw_IoctlCtx.IoctlCode) {
+          NXPLOG_FWDNLD_E("Write Request success.. ");
+        } else if (PHLIBNFC_DNLD_READ_LOG ==
+                   gphNxpNciHal_fw_IoctlCtx.IoctlCode) {
+          NXPLOG_FWDNLD_E("ReadLog Request success.. ");
+        } else {
+          NXPLOG_FWDNLD_E("Invalid Request!!");
+        }
+      } else {
+        if (NFC_FW_DOWNLOAD == gphNxpNciHal_fw_IoctlCtx.IoctlCode) {
+          NXPLOG_FWDNLD_E("Fw Download Failed!!");
+        } else if (NFC_MEM_READ == gphNxpNciHal_fw_IoctlCtx.IoctlCode) {
+          NXPLOG_FWDNLD_E("Read Request Failed!!");
+        } else if (NFC_MEM_WRITE == gphNxpNciHal_fw_IoctlCtx.IoctlCode) {
+          NXPLOG_FWDNLD_E("Write Request Failed!!");
+        } else if (PHLIBNFC_DNLD_READ_LOG ==
+                   gphNxpNciHal_fw_IoctlCtx.IoctlCode) {
+          NXPLOG_FWDNLD_E("ReadLog Request Failed!!");
+        } else {
+          NXPLOG_FWDNLD_E("Invalid Request!!");
+        }
+      }
+    }
+
+    if (gphNxpNciHal_fw_IoctlCtx.bSendNciCmd == false) {
+      /* Call Tml Ioctl to enable/restore normal mode */
+      if (NFCSTATUS_SUCCESS != (phTmlNfc_IoCtl(phTmlNfc_e_EnableNormalMode))) {
+        NXPLOG_FWDNLD_E("Switching to NormalMode Failed!!");
+      } else {
+        wStatus = fStatus;
+      }
+    }
+    if (status == NFCSTATUS_FW_CHECK_INTEGRITY_FAILED) {
+      wStatus = NFCSTATUS_FW_CHECK_INTEGRITY_FAILED;
+    }
+
+    if (gphNxpNciHal_fw_IoctlCtx.bVenReset == true) {
+      (gphNxpNciHal_fw_IoctlCtx.bVenReset) = false;
+      if (NFCSTATUS_SUCCESS != phTmlNfc_IoCtl(phTmlNfc_e_ResetDevice)) {
+        NXPLOG_FWDNLD_E("VEN_RESET failed");
+      }
+    }
+    (gphNxpNciHal_fw_IoctlCtx.bPrevSessnOpen) = false;
+    (gphNxpNciHal_fw_IoctlCtx.bDnldInitiated) = false;
+    (gphNxpNciHal_fw_IoctlCtx.bChipVer) = 0;
+    (gphNxpNciHal_fw_IoctlCtx.bSkipSeq) = false;
+    (gphNxpNciHal_fw_IoctlCtx.bForceDnld) = false;
+    (gphNxpNciHal_fw_IoctlCtx.bDnldRecovery) = false;
+    (gphNxpNciHal_fw_IoctlCtx.bRetryDnld) = false;
+    (gphNxpNciHal_fw_IoctlCtx.bSkipReset) = false;
+    (gphNxpNciHal_fw_IoctlCtx.bSkipForce) = false;
+    (gphNxpNciHal_fw_IoctlCtx.bSendNciCmd) = false;
+    (gphNxpNciHal_fw_IoctlCtx.bDnldAttempts) = 0;
+
+    if (gphNxpNciHal_fw_IoctlCtx.bDnldAttemptFailed == false) {
+    } else {
+      NXPLOG_FWDNLD_E("Returning Download Failed Status to Caller!!");
+
+      (gphNxpNciHal_fw_IoctlCtx.bLastStatus) = NFCSTATUS_SUCCESS;
+      (gphNxpNciHal_fw_IoctlCtx.bDnldAttemptFailed) = false;
+    }
+    phDnldNfc_CloseFwLibHandle();
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_fw_download_seq
+**
+** Description      Download Sequence
+**
+** Returns          NFCSTATUS_SUCCESS if success
+**
+*******************************************************************************/
+NFCSTATUS phNxpNciHal_fw_download_seq(uint8_t bClkSrcVal, uint8_t bClkFreqVal,
+                                      uint8_t seq_handler_offset,
+                                      bool bMinimalFw) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  phDnldNfc_Buff_t pInfo;
+  const char *pContext = "FW-Download";
+
+  /* reset the global flags */
+  gphNxpNciHal_fw_IoctlCtx.IoctlCode = NFC_FW_DOWNLOAD;
+  (gphNxpNciHal_fw_IoctlCtx.bPrevSessnOpen) = false;
+  (gphNxpNciHal_fw_IoctlCtx.bDnldInitiated) = false;
+  (gphNxpNciHal_fw_IoctlCtx.bChipVer) = 0;
+  (gphNxpNciHal_fw_IoctlCtx.bSkipSeq) = false;
+  (gphNxpNciHal_fw_IoctlCtx.bForceDnld) = false;
+  (gphNxpNciHal_fw_IoctlCtx.bDnldRecovery) = false;
+  (gphNxpNciHal_fw_IoctlCtx.bRetryDnld) = false;
+  (gphNxpNciHal_fw_IoctlCtx.bSkipReset) = false;
+  (gphNxpNciHal_fw_IoctlCtx.bSkipForce) = false;
+  (gphNxpNciHal_fw_IoctlCtx.bSendNciCmd) = false;
+  (gphNxpNciHal_fw_IoctlCtx.bDnldAttempts) = 0;
+  (gphNxpNciHal_fw_IoctlCtx.bClkSrcVal) = bClkSrcVal;
+  (gphNxpNciHal_fw_IoctlCtx.bClkFreqVal) = bClkFreqVal;
+  /* Get firmware version */
+  if (NFCSTATUS_SUCCESS == phDnldNfc_InitImgInfo(bMinimalFw)) {
+    NXPLOG_FWDNLD_D("phDnldNfc_InitImgInfo:SUCCESS");
+    if (bMinimalFw) {
+      status = phNxpNciHal_fw_seq_handler(phNxpNciHal_minimal_dwnld_seqhandler);
+    } else {
+      status = phNxpNciHal_fw_seq_handler(phNxpNciHal_dwnld_seqhandler +
+                                          seq_handler_offset);
+    }
+  } else {
+    NXPLOG_FWDNLD_E("phDnldNfc_InitImgInfo: FAILED");
+  }
+
+  /* Chage to normal mode */
+  status = phNxpNciHal_fw_dnld_complete((void *)pContext, status, &pInfo,
+                                        bMinimalFw);
+  /*if (NFCSTATUS_SUCCESS == status)
+  {
+      NXPLOG_FWDNLD_D(" phNxpNciHal_fw_dnld_complete : SUCCESS");
+  }
+  else
+  {
+      NXPLOG_FWDNLD_E(" phNxpNciHal_fw_dnld_complete : FAILED");
+  }*/
+
+  return status;
+}
+
+static NFCSTATUS phLibNfc_VerifyCrcStatus(uint8_t bCrcStatus) {
+  uint8_t bBitPos = 1;
+  uint8_t bShiftVal = 2;
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  while (bBitPos < 7) {
+    if (!(bCrcStatus & bShiftVal)) {
+      switch (bBitPos) {
+      case 0: {
+        NXPLOG_FWDNLD_E("User Data Crc is NOT OK!!");
+        wStatus = NFCSTATUS_FAILED;
+        break;
+      }
+      case 1: {
+        NXPLOG_FWDNLD_E("Trim Data Crc is NOT OK!!");
+        wStatus = NFCSTATUS_FAILED;
+        break;
+      }
+      case 2: {
+        NXPLOG_FWDNLD_E("Protected Data Crc is NOT OK!!");
+        wStatus = NFCSTATUS_FAILED;
+        break;
+      }
+      case 3: {
+        NXPLOG_FWDNLD_E("Patch Code Crc is NOT OK!!");
+        wStatus = NFCSTATUS_FAILED;
+        break;
+      }
+      case 4: {
+        NXPLOG_FWDNLD_E("Function Code Crc is NOT OK!!");
+        wStatus = NFCSTATUS_FAILED;
+        break;
+      }
+      case 5: {
+        NXPLOG_FWDNLD_E("Patch Table Crc is NOT OK!!");
+        wStatus = NFCSTATUS_FAILED;
+        break;
+      }
+      case 6: {
+        NXPLOG_FWDNLD_E("Function Table Crc is NOT OK!!");
+        wStatus = NFCSTATUS_FAILED;
+        break;
+      }
+      default: {
+        break;
+      }
+      }
+    }
+
+    bShiftVal <<= 1;
+    ++bBitPos;
+  }
+
+  return wStatus;
+}
+
+static NFCSTATUS phLibNfc_VerifyPN72xx_CrcStatus(uint8_t *bCrcStatus) {
+  uint8_t CODEINFO_LEN = 0x06;
+  uint8_t DATAINFO_LEN = 0x11;
+  uint8_t *crc_info_buf;
+  /*acceptable CRC values defined in little indian format
+   * Actual CRC values are 3F80FFFF
+   */
+  uint32_t acceptable_crc_values_devsample = 0xFFFF803F;
+
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  phDnldChkIntegrityRsp_Buff_t chkIntgRspBuf;
+
+  if (bCrcStatus == NULL)
+    return NFCSTATUS_FAILED;
+  chkIntgRspBuf.pBuff = bCrcStatus;
+  chkIntgRspBuf.data_len = chkIntgRspBuf.pBuff[0];
+  chkIntgRspBuf.code_len = chkIntgRspBuf.pBuff[1];
+  if (chkIntgRspBuf.data_len > DATAINFO_LEN ||
+      chkIntgRspBuf.code_len > CODEINFO_LEN)
+    return NFCSTATUS_FAILED;
+
+  /*Skip byte*/
+  crc_info_buf = bCrcStatus + 3;
+  STREAM_TO_UINT32(chkIntgRspBuf.crc_status, crc_info_buf);
+
+  NXPLOG_FWDNLD_D("crc status code area len 0x%x", chkIntgRspBuf.code_len);
+  NXPLOG_FWDNLD_D("crc status code data len 0x%x", chkIntgRspBuf.data_len);
+  NXPLOG_FWDNLD_D("crc status code area  0x%2x", chkIntgRspBuf.crc_status);
+
+  if ((chkIntgRspBuf.crc_status | MASK_MSB_BYTE) !=
+      acceptable_crc_values_devsample) {
+    NXPLOG_FWDNLD_D("Error : Integrity CRC check failed");
+    return NFCSTATUS_FAILED;
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_releasePendingRead
+**
+** Description      Release Pending Read in Kernel
+**
+** Returns          NFCSTATUS_SUCCESS if success
+**
+*******************************************************************************/
+static NFCSTATUS phNxpNciHal_releasePendingRead() {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  phTmlNfc_Config_t tTmlConfig;
+  const uint16_t max_len = 260;
+  char nfc_dev_node[max_len] = {};
+  if (!GetNxpStrValue(NAME_NXP_NFC_DEV_NODE, nfc_dev_node,
+                      sizeof(nfc_dev_node))) {
+    NXPLOG_FWDNLD_D(
+        "Invalid nfc device node name keeping the default device node "
+        "/dev/nxpnfc");
+    strlcpy(nfc_dev_node, "/dev/nxpnfc", (sizeof(nfc_dev_node)));
+  }
+  tTmlConfig.pDevName = (int8_t *)nfc_dev_node;
+  gpTransportObj->Close(gpphTmlNfc_Context->pDevHandle);
+  if (!gpTransportObj->Flushdata(&tTmlConfig)) {
+    NXPLOG_FWDNLD_E("Flushdata Failed");
+  }
+  status = gpTransportObj->OpenAndConfigure(&tTmlConfig,
+                                            &(gpphTmlNfc_Context->pDevHandle));
+  if (NFCSTATUS_SUCCESS != status) {
+    NXPLOG_FWDNLD_E("OpenAndConfigure failed!!");
+  }
+  return status;
+}
diff --git a/pn72xx/halimpl/dnld/phNxpNciHal_Dnld.h b/pn72xx/halimpl/dnld/phNxpNciHal_Dnld.h
new file mode 100644
index 00000000..94d824c9
--- /dev/null
+++ b/pn72xx/halimpl/dnld/phNxpNciHal_Dnld.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2012-2021,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef _PHNXPNCIHAL_DNLD_H_
+#define _PHNXPNCIHAL_DNLD_H_
+
+#include <phNfcStatus.h>
+#include <phNfcTypes.h>
+
+#define PHLIBNFC_DNLD_CHECKINTEGRITY_OFFSET (0x07)
+
+NFCSTATUS phNxpNciHal_fw_dnld_switch_normal_mode();
+NFCSTATUS phNxpNciHal_fw_download_seq(uint8_t bClkSrcVal, uint8_t bClkFreqVal,
+                                      uint8_t seq_handler_offset = 0,
+                                      bool bMinimalFw = false);
+#define STREAM_TO_UINT32(u32, p)                                               \
+  {                                                                            \
+    (u32) = (((uint32_t)(*(p))) + ((((uint32_t)(*((p) + 1)))) << 8) +          \
+             ((((uint32_t)(*((p) + 2)))) << 16) +                              \
+             ((((uint32_t)(*((p) + 3)))) << 24));                              \
+    (p) += 4;                                                                  \
+  }
+
+#endif /* _PHNXPNCIHAL_DNLD_H_ */
diff --git a/pn72xx/halimpl/hal/phNxpNciHal.cc b/pn72xx/halimpl/hal/phNxpNciHal.cc
new file mode 100644
index 00000000..a52aa7c9
--- /dev/null
+++ b/pn72xx/halimpl/hal/phNxpNciHal.cc
@@ -0,0 +1,2659 @@
+/*
+ * Copyright 2012-2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <android-base/file.h>
+#include <dlfcn.h>
+#include <log/log.h>
+#include <phDal4Nfc_messageQueueLib.h>
+#include <phDnldNfc.h>
+#include <phNxpConfig.h>
+#include <phNxpLog.h>
+#include <phNxpNciHal.h>
+#include <phNxpNciHal_Adaptation.h>
+#include <phNxpNciHal_Dnld.h>
+#include <phNxpNciHal_ext.h>
+#include <phTmlNfc.h>
+
+#include <android-base/stringprintf.h>
+#include <sys/stat.h>
+
+#include "NfccTransportFactory.h"
+#include "NxpNfcThreadMutex.h"
+#include "phNxpNciHal_IoctlOperations.h"
+#include "phNxpNciHal_extOperations.h"
+
+#include <sys/system_properties.h>
+
+using android::base::StringPrintf;
+using namespace android::hardware::nfc::V1_1;
+using namespace android::hardware::nfc::V1_2;
+using android::base::WriteStringToFile;
+using android::hardware::nfc::V1_1::NfcEvent;
+
+/*********************** Global Variables *************************************/
+#define PN547C2_CLOCK_SETTING
+#define CORE_RES_STATUS_BYTE 3
+#define MAX_NXP_HAL_EXTN_BYTES 10
+#define DEFAULT_MINIMAL_FW_VERSION 0x0110DE
+#define NFC_PROP_VALUE_MAX 2
+bool bEnableMfcExtns = false;
+bool bEnableMfcReader = false;
+bool bDisableLegacyMfcExtns = true;
+
+/* Processing of ISO 15693 EOF */
+extern uint8_t icode_send_eof;
+extern uint8_t icode_detected;
+static uint8_t cmd_icode_eof[] = {0x00, 0x00, 0x00};
+const char *rf_block_name = "NXP_RF_CONF_BLK_";
+/* FW download success flag */
+static uint8_t fw_download_success = 0;
+static uint8_t config_access = false;
+static uint8_t config_success = true;
+static NfcHalThreadMutex sHalFnLock;
+
+extern phNxpNciClock_t phNxpNciClock;
+
+/* NCI HAL Control structure */
+phNxpNciHal_Control_t nxpncihal_ctrl;
+
+/* NXP Poll Profile structure */
+phNxpNciProfile_Control_t nxpprofile_ctrl;
+
+/* TML Context */
+extern phTmlNfc_Context_t *gpphTmlNfc_Context;
+extern spTransport gpTransportObj;
+
+extern void
+phTmlNfc_set_fragmentation_enabled(phTmlNfc_i2cfragmentation_t result);
+
+extern NFCSTATUS phNxpNciHal_ext_send_sram_config_to_flash();
+extern NFCSTATUS phNxpNciHal_enableDefaultUICC2SWPline(uint8_t uicc2_sel);
+extern void phNxpNciHal_prop_conf_lpcd(bool enableLPCD);
+extern void phNxpNciHal_prop_conf_rssi();
+
+nfc_stack_callback_t *p_nfc_stack_cback_backup;
+phNxpNci_getCfg_info_t *mGetCfg_info = NULL;
+/* global variable to get FW version from NCI response or dl get version
+ * response*/
+uint32_t wFwVerRsp;
+#ifdef NXP_BOOTTIME_UPDATE
+ese_update_state_t ese_update = ESE_UPDATE_COMPLETED;
+#endif
+/* External global variable to get FW version */
+extern uint16_t wFwVer;
+extern uint8_t gRecFWDwnld;
+static uint8_t gRecFwRetryCount; // variable to hold recovery FW retry count
+static uint8_t write_unlocked_status = NFCSTATUS_SUCCESS;
+uint8_t wFwUpdateReq = false;
+uint8_t wRfUpdateReq = false;
+uint32_t timeoutTimerId = 0;
+// This flag will be used to update the EEPROM if FW DNLD completed successfully
+bool isFwDnldTriggered = false;
+#ifndef FW_DWNLD_FLAG
+uint8_t fw_dwnld_flag = false;
+#endif
+bool nfc_debug_enabled = true;
+
+/*  Used to send Callback Transceive data during Mifare Write.
+ *  If this flag is enabled, no need to send response to Upper layer */
+bool sendRspToUpperLayer = true;
+
+phNxpNciHal_Sem_t config_data;
+
+phNxpNciClock_t phNxpNciClock = {0, {0}, false};
+
+phNxpNciRfSetting_t phNxpNciRfSet = {false, {0}};
+
+phNxpNciMwEepromArea_t phNxpNciMwEepromArea = {false, {0}};
+
+volatile bool_t gsIsFirstHalMinOpen = true;
+volatile bool_t gsIsFwRecoveryRequired = false;
+const char *spIsFirstHalMinOpen = "nfc.is_first_hal_min_open";
+void *RfFwRegionDnld_handle = NULL;
+fpVerInfoStoreInEeprom_t fpVerInfoStoreInEeprom = NULL;
+fpRegRfFwDndl_t fpRegRfFwDndl = NULL;
+fpPropConfCover_t fpPropConfCover = NULL;
+void *phNxpNciHal_client_thread(void *arg);
+/**************** local methods used in this file only ************************/
+static void phNxpNciHal_open_complete(NFCSTATUS status);
+static void phNxpNciHal_MinOpen_complete(NFCSTATUS status);
+static void phNxpNciHal_write_complete(void *pContext,
+                                       phTmlNfc_TransactInfo_t *pInfo);
+static void phNxpNciHal_read_complete(void *pContext,
+                                      phTmlNfc_TransactInfo_t *pInfo);
+static void phNxpNciHal_close_complete(NFCSTATUS status);
+static void phNxpNciHal_core_initialized_complete(NFCSTATUS status);
+static void phNxpNciHal_power_cycle_complete(NFCSTATUS status);
+static void
+phNxpNciHal_kill_client_thread(phNxpNciHal_Control_t *p_nxpncihal_ctrl);
+static void phNxpNciHal_nfccClockCfgRead(void);
+static NFCSTATUS phNxpNciHal_nfccClockCfgApply(void);
+static void phNxpNciHal_print_res_status(uint8_t *p_rx_data, uint16_t *p_len);
+static NFCSTATUS phNxpNciHal_get_mw_eeprom(void);
+static NFCSTATUS phNxpNciHal_set_mw_eeprom(void);
+static void phNxpNciHal_initialize_debug_enabled_flag();
+static void phNxpNciHal_initialize_mifare_flag();
+static void phNxpNciHal_UpdateFwStatus(HalNfcFwUpdateStatus fwStatus);
+static NFCSTATUS phNxpNciHal_resetDefaultSettings(uint8_t fw_update_req,
+                                                  bool keep_config);
+static NFCSTATUS phNxpNciHal_force_fw_download(uint8_t seq_handler_offset = 0);
+static int phNxpNciHal_MinOpen_Clean(char *nfc_dev_node);
+static void phNxpNciHal_CheckAndHandleFwTearDown(void);
+static NFCSTATUS
+phNxpNciHal_getChipInfoInFwDnldMode(bool bIsVenResetReqd = false);
+static uint8_t phNxpNciHal_getSessionInfoInFwDnldMode();
+static NFCSTATUS phNxpNciHal_dlResetInFwDnldMode();
+static NFCSTATUS phNxpNciHal_enableTmlRead();
+/******************************************************************************
+ * Function         phNxpNciHal_initialize_debug_enabled_flag
+ *
+ * Description      This function gets the value for nfc_debug_enabled
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phNxpNciHal_initialize_debug_enabled_flag() {
+  unsigned long num = 0;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  if (GetNxpNumValue(NAME_NFC_DEBUG_ENABLED, &num, sizeof(num))) {
+    nfc_debug_enabled = (num == 0) ? false : true;
+  }
+
+  int len = property_get("nfc.debug_enabled", valueStr, "");
+  if (len > 0) {
+    // let Android property override .conf variable
+    unsigned debug_enabled = 0;
+    sscanf(valueStr, "%u", &debug_enabled);
+    nfc_debug_enabled = (debug_enabled == 0) ? false : true;
+  }
+  NXPLOG_NCIHAL_D("nfc_debug_enabled : %d", nfc_debug_enabled);
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_client_thread
+ *
+ * Description      This function is a thread handler which handles all TML and
+ *                  NCI messages.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+void *phNxpNciHal_client_thread(void *arg) {
+  phNxpNciHal_Control_t *p_nxpncihal_ctrl = (phNxpNciHal_Control_t *)arg;
+  phLibNfc_Message_t msg;
+
+  NXPLOG_NCIHAL_D("thread started");
+
+  p_nxpncihal_ctrl->thread_running = 1;
+
+  while (p_nxpncihal_ctrl->thread_running == 1) {
+    /* Fetch next message from the NFC stack message queue */
+    if (phDal4Nfc_msgrcv(p_nxpncihal_ctrl->gDrvCfg.nClientId, &msg, 0, 0) ==
+        -1) {
+      NXPLOG_NCIHAL_E("NFC client received bad message");
+      continue;
+    }
+
+    if (p_nxpncihal_ctrl->thread_running == 0) {
+      break;
+    }
+
+    switch (msg.eMsgType) {
+    case PH_LIBNFC_DEFERREDCALL_MSG: {
+      phLibNfc_DeferredCall_t *deferCall =
+          (phLibNfc_DeferredCall_t *)(msg.pMsgData);
+
+      REENTRANCE_LOCK();
+      deferCall->pCallback(deferCall->pParameter);
+      REENTRANCE_UNLOCK();
+
+      break;
+    }
+
+    case NCI_HAL_OPEN_CPLT_MSG: {
+      REENTRANCE_LOCK();
+      if (nxpncihal_ctrl.p_nfc_stack_cback != NULL) {
+        /* Send the event */
+        (*nxpncihal_ctrl.p_nfc_stack_cback)(HAL_NFC_OPEN_CPLT_EVT,
+                                            HAL_NFC_STATUS_OK);
+      }
+      REENTRANCE_UNLOCK();
+      break;
+    }
+
+    case NCI_HAL_CLOSE_CPLT_MSG: {
+      REENTRANCE_LOCK();
+      if (nxpncihal_ctrl.p_nfc_stack_cback != NULL) {
+        /* Send the event */
+        (*nxpncihal_ctrl.p_nfc_stack_cback)(HAL_NFC_CLOSE_CPLT_EVT,
+                                            HAL_NFC_STATUS_OK);
+      }
+      phNxpNciHal_kill_client_thread(&nxpncihal_ctrl);
+      REENTRANCE_UNLOCK();
+      break;
+    }
+
+    case NCI_HAL_POST_INIT_CPLT_MSG: {
+      REENTRANCE_LOCK();
+      if (nxpncihal_ctrl.p_nfc_stack_cback != NULL) {
+        /* Send the event */
+        (*nxpncihal_ctrl.p_nfc_stack_cback)(HAL_NFC_POST_INIT_CPLT_EVT,
+                                            HAL_NFC_STATUS_OK);
+      }
+      REENTRANCE_UNLOCK();
+      break;
+    }
+
+    case NCI_HAL_PRE_DISCOVER_CPLT_MSG: {
+      REENTRANCE_LOCK();
+      if (nxpncihal_ctrl.p_nfc_stack_cback != NULL) {
+        /* Send the event */
+        (*nxpncihal_ctrl.p_nfc_stack_cback)(HAL_NFC_PRE_DISCOVER_CPLT_EVT,
+                                            HAL_NFC_STATUS_OK);
+      }
+      REENTRANCE_UNLOCK();
+      break;
+    }
+
+    case NCI_HAL_HCI_NETWORK_RESET_MSG: {
+      REENTRANCE_LOCK();
+      if (nxpncihal_ctrl.p_nfc_stack_cback != NULL) {
+        /* Send the event */
+        (*nxpncihal_ctrl.p_nfc_stack_cback)(
+            (uint32_t)NfcEvent::HCI_NETWORK_RESET, HAL_NFC_STATUS_OK);
+      }
+      REENTRANCE_UNLOCK();
+      break;
+    }
+
+    case NCI_HAL_ERROR_MSG: {
+      REENTRANCE_LOCK();
+      if (nxpncihal_ctrl.p_nfc_stack_cback != NULL) {
+        /* Send the event */
+        (*nxpncihal_ctrl.p_nfc_stack_cback)(HAL_NFC_ERROR_EVT,
+                                            HAL_NFC_STATUS_FAILED);
+      }
+      REENTRANCE_UNLOCK();
+      break;
+    }
+
+    case NCI_HAL_RX_MSG: {
+      REENTRANCE_LOCK();
+      if (nxpncihal_ctrl.p_nfc_stack_data_cback != NULL) {
+        (*nxpncihal_ctrl.p_nfc_stack_data_cback)(nxpncihal_ctrl.rsp_len,
+                                                 nxpncihal_ctrl.p_rsp_data);
+      }
+      REENTRANCE_UNLOCK();
+      break;
+    }
+    case HAL_NFC_FW_UPDATE_STATUS_EVT: {
+      REENTRANCE_LOCK();
+      if (nxpncihal_ctrl.p_nfc_stack_cback != NULL) {
+        /* Send the event */
+        (*nxpncihal_ctrl.p_nfc_stack_cback)(msg.eMsgType,
+                                            *((uint8_t *)msg.pMsgData));
+      }
+      REENTRANCE_UNLOCK();
+      break;
+    }
+    }
+  }
+
+  NXPLOG_NCIHAL_D("NxpNciHal thread stopped");
+
+  return NULL;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_kill_client_thread
+ *
+ * Description      This function safely kill the client thread and clean all
+ *                  resources.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static void
+phNxpNciHal_kill_client_thread(phNxpNciHal_Control_t *p_nxpncihal_ctrl) {
+  NXPLOG_NCIHAL_D("Terminating phNxpNciHal client thread...");
+
+  p_nxpncihal_ctrl->p_nfc_stack_cback = NULL;
+  p_nxpncihal_ctrl->p_nfc_stack_data_cback = NULL;
+  p_nxpncihal_ctrl->thread_running = 0;
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_CheckIntegrityRecovery
+ *
+ * Description     This function to enter in recovery if FW download fails with
+ *                 check integrity.
+ *
+ * Returns         NFCSTATUS
+ *
+ ******************************************************************************/
+static NFCSTATUS phNxpNciHal_CheckIntegrityRecovery() {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  if (phNxpNciHal_nfcc_core_reset_init(false) == NFCSTATUS_SUCCESS) {
+    status = phNxpNciHal_fw_download();
+  } else {
+    status = NFCSTATUS_FW_CHECK_INTEGRITY_FAILED;
+  }
+  return status;
+}
+/******************************************************************************
+ * Function         phNxpNciHal_force_fw_download
+ *
+ * Description     This function, based on the offset provided, will trigger
+ *                 Secure FW download sequence.
+ *                 It will retry the FW download in case the Check Integrity
+ *                 has been failed.
+ *
+ * Parameters      Offset by which the FW dnld Seq handler shall be triggered.
+ *                 e.g. if we want to send only the Check Integrity command,
+ *                 then the offset shall be 7.
+ *
+ * Returns         SUCCESS if FW download is successful else FAIL.
+ *
+ ******************************************************************************/
+static NFCSTATUS phNxpNciHal_force_fw_download(uint8_t seq_handler_offset) {
+  NFCSTATUS wConfigStatus = NFCSTATUS_SUCCESS;
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  /*Get FW version from device*/
+  for (int retry = 1; retry >= 0; retry--) {
+    if (phDnldNfc_InitImgInfo() == NFCSTATUS_SUCCESS) {
+      break;
+    } else {
+      phDnldNfc_ReSetHwDevHandle();
+      NXPLOG_NCIHAL_E("Image information extraction Failed!!");
+      if (!retry)
+        return NFCSTATUS_FAILED;
+    }
+  }
+
+  NXPLOG_NCIHAL_D("FW version for FW file = 0x%x", wFwVer);
+  NXPLOG_NCIHAL_D("FW version from device = 0x%x", wFwVerRsp);
+  bool bIsNfccDlState = false;
+  if (wFwVerRsp == 0) {
+    status = phNxpNciHal_getChipInfoInFwDnldMode(true);
+    if (status != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("phNxpNciHal_getChipInfoInFwDnldMode Failed");
+    }
+    bIsNfccDlState = true;
+  }
+  if (NFCSTATUS_SUCCESS == phNxpNciHal_CheckValidFwVersion()) {
+    NXPLOG_NCIHAL_D("FW update required");
+    nxpncihal_ctrl.phNxpNciGpioInfo.state = GPIO_UNKNOWN;
+    fw_download_success = 0;
+    /*We are expecting NFC to be either in NFC or in the FW Download state*/
+    status = phNxpNciHal_fw_download(seq_handler_offset, bIsNfccDlState);
+    if (status == NFCSTATUS_FW_CHECK_INTEGRITY_FAILED) {
+      status = phNxpNciHal_CheckIntegrityRecovery();
+    }
+    property_set("nfc.fw.downloadmode_force", "0");
+    if (status == NFCSTATUS_SUCCESS) {
+      wConfigStatus = NFCSTATUS_SUCCESS;
+      fw_download_success = TRUE;
+    } else if (status == NFCSTATUS_FW_CHECK_INTEGRITY_FAILED ||
+               (phNxpNciHal_fw_mw_ver_check() != NFCSTATUS_SUCCESS)) {
+      phOsalNfc_Timer_Cleanup();
+      phTmlNfc_Shutdown_CleanUp();
+      return NFCSTATUS_CMD_ABORTED;
+    }
+
+    status = phNxpNciHal_nfcc_core_reset_init();
+  }
+  return wConfigStatus;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_fw_download
+ *
+ * Description      This function download the PN72xx secure firmware to IC. If
+ *                  firmware version in Android filesystem and firmware in the
+ *                  IC is same then firmware download will return with success
+ *                  without downloading the firmware.
+ *
+ * Returns          NFCSTATUS_SUCCESS if firmware download successful
+ *                  NFCSTATUS_FAILED in case of failure
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_fw_download(uint8_t seq_handler_offset,
+                                  bool bIsNfccDlState) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  phNxpNciHal_UpdateFwStatus(HAL_NFC_FW_UPDATE_START);
+  phNxpNciHal_nfccClockCfgRead();
+
+  if (!bIsNfccDlState) {
+    NXPLOG_NCIHAL_D("nfcFL.nfccFL._NFCC_DWNLD_MODE %x\n",
+                    nfcFL.nfccFL._NFCC_DWNLD_MODE);
+    status = phTmlNfc_IoCtl(phTmlNfc_e_EnableDownloadMode);
+    if (NFCSTATUS_SUCCESS != status) {
+      nxpncihal_ctrl.fwdnld_mode_reqd = FALSE;
+      phNxpNciHal_UpdateFwStatus(HAL_NFC_FW_UPDATE_FAILED);
+      return NFCSTATUS_FAILED;
+    }
+  }
+
+  /* Make sure read thread is pending before updating fwdnld_mode_reqd to true*/
+  NFCSTATUS readStatus = phNxpNciHal_enableTmlRead();
+  if (readStatus != PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_BUSY)) {
+    NXPLOG_NCIHAL_E("Read Thread is not pending already. status = 0x%x \n",
+                    readStatus);
+  }
+
+  nxpncihal_ctrl.fwdnld_mode_reqd = TRUE;
+  if (nfcFL.nfccFL._NFCC_DWNLD_MODE == NFCC_DWNLD_WITH_NCI_CMD &&
+      (!bIsNfccDlState)) {
+    /*NCI_RESET_CMD*/
+    static uint8_t cmd_reset_nci_dwnld[] = {0x20, 0x00, 0x01, 0x80};
+    status = phNxpNciHal_send_ext_cmd(sizeof(cmd_reset_nci_dwnld),
+                                      cmd_reset_nci_dwnld);
+    if (status != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("Core reset FW download command failed \n");
+    }
+  }
+
+  if (NFCSTATUS_SUCCESS == status) {
+    phTmlNfc_EnableFwDnldMode(true);
+    /* Set the obtained device handle to download module */
+
+    phDnldNfc_SetHwDevHandle();
+    if (nfcFL.chipType >= sn100u) {
+      phDnldNfc_SetI2CFragmentLength(NCI_CMDRESP_MAX_BUFF_SIZE_SNXXX);
+    } else {
+      phDnldNfc_SetI2CFragmentLength(NCI_CMDRESP_MAX_BUFF_SIZE_PN557);
+    }
+
+    NXPLOG_NCIHAL_D("Calling Seq handler for FW Download \n");
+    status = phNxpNciHal_fw_download_seq(nxpprofile_ctrl.bClkSrcVal,
+                                         nxpprofile_ctrl.bClkFreqVal,
+                                         seq_handler_offset);
+
+    if (phNxpNciHal_dlResetInFwDnldMode() != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("DL Reset failed in FW DN mode");
+    }
+
+    /* FW download done.Therefore if previous I2C write failed then we can
+     * change the state to NFCSTATUS_SUCCESS*/
+    write_unlocked_status = NFCSTATUS_SUCCESS;
+  } else {
+    nxpncihal_ctrl.fwdnld_mode_reqd = FALSE;
+    status = NFCSTATUS_FAILED;
+  }
+  if (NFCSTATUS_SUCCESS == status) {
+    isFwDnldTriggered = true;
+    phNxpNciHal_UpdateFwStatus(HAL_NFC_FW_UPDATE_SCUCCESS);
+  } else {
+    phNxpNciHal_UpdateFwStatus(HAL_NFC_FW_UPDATE_FAILED);
+  }
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_CheckValidFwVersion
+ *
+ * Description      This function checks the valid FW for Mobile device.
+ *                  If the FW doesn't belong the Mobile device it further
+ *                  checks nxp config file to override.
+ *
+ * Returns          NFCSTATUS_SUCCESS if valid fw version found
+ *                  NFCSTATUS_NOT_ALLOWED in case of FW not valid for mobile
+ *                  device
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_CheckValidFwVersion(void) {
+  NFCSTATUS status = NFCSTATUS_NOT_ALLOWED;
+  const unsigned char sfw_infra_major_no = 0x02;
+  unsigned char ufw_current_major_no = 0x00;
+  uint8_t rom_version = 0xFF & (wFwVerRsp >> 16);
+  uint8_t fw_maj_ver = 0xFF & (wFwVerRsp >> 8);
+
+  /* extract the firmware's major no */
+  ufw_current_major_no = ((0x00FF) & (wFwVer >> 8U));
+  NXPLOG_NCIHAL_D("HAL %s current_major_no = 0x%x", __func__,
+                  ufw_current_major_no);
+  NXPLOG_NCIHAL_D("%s fw_maj_ver = 0x%x", __func__, fw_maj_ver);
+  if (nfcFL.chipType >= pn7220) {
+    if (ufw_current_major_no >= fw_maj_ver) {
+      /* if file major version is grater than the one from the
+         Nfc init command allow FW download
+      */
+      status = NFCSTATUS_SUCCESS;
+    }
+    return status;
+  }
+
+  if (wFwVerRsp == 0) {
+    NXPLOG_NCIHAL_E(
+        "FW Version not received by NCI command >>> Force Firmware download");
+    status = NFCSTATUS_SUCCESS;
+  } else if (ufw_current_major_no == nfcFL._FW_MOBILE_MAJOR_NUMBER) {
+    NXPLOG_NCIHAL_E("FW Version 2");
+    status = NFCSTATUS_SUCCESS;
+  } else if (ufw_current_major_no == sfw_infra_major_no) {
+    if (rom_version == FW_MOBILE_ROM_VERSION_PN7720) {
+      NXPLOG_NCIHAL_D(" Pn72xx  allow Fw download with major number =  0x%x",
+                      ufw_current_major_no);
+      status = NFCSTATUS_SUCCESS;
+    } else {
+      status = NFCSTATUS_NOT_ALLOWED;
+    }
+  } else {
+    NXPLOG_NCIHAL_E("Wrong FW Version >>> Firmware download not allowed");
+  }
+
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_MinOpen_Clean
+ *
+ * Description      This function shall be called from phNxpNciHal_MinOpen when
+ *                  any unrecoverable error has encountered which needs to mark
+ *                  min open as failed, HAL status as closed & deallocate any
+ *                  memory if allocated.
+ *
+ * Returns          This function always returns Failure
+ *
+ ******************************************************************************/
+static int phNxpNciHal_MinOpen_Clean(char *nfc_dev_node) {
+  if (nfc_dev_node != NULL) {
+    free(nfc_dev_node);
+    nfc_dev_node = NULL;
+  }
+  if (mGetCfg_info != NULL) {
+    free(mGetCfg_info);
+    mGetCfg_info = NULL;
+  }
+  /* Report error status */
+  phNxpNciHal_cleanup_monitor();
+  nxpncihal_ctrl.halStatus = HAL_STATUS_CLOSE;
+  return NFCSTATUS_FAILED;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_MinOpen
+ *
+ * Description      This function initializes the least required resources to
+ *                  communicate to NFCC.This is mainly used to communicate to
+ *                  NFCC when NFC service is not available.
+ *
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS (0) in case of
+ *success In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+int phNxpNciHal_MinOpen() {
+  phOsalNfc_Config_t tOsalConfig;
+  phTmlNfc_Config_t tTmlConfig;
+  char *nfc_dev_node = NULL;
+  const uint16_t max_len = 260;
+  NFCSTATUS wConfigStatus = NFCSTATUS_SUCCESS;
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  int dnld_retry_cnt = 0;
+  NXPLOG_NCIHAL_D("phNxpNci_MinOpen(): enter");
+
+  NfcHalAutoThreadMutex a(sHalFnLock);
+  if (nxpncihal_ctrl.halStatus == HAL_STATUS_MIN_OPEN) {
+    NXPLOG_NCIHAL_D("phNxpNciHal_MinOpen(): already open");
+    return NFCSTATUS_SUCCESS;
+  }
+
+  int8_t ret_val = 0x00;
+
+  phNxpNciHal_initialize_debug_enabled_flag();
+  /* initialize trace level */
+  phNxpLog_InitializeLogLevel();
+
+  /* initialize Mifare flags*/
+  phNxpNciHal_initialize_mifare_flag();
+
+  /*Create the timer for extns write response*/
+  timeoutTimerId = phOsalNfc_Timer_Create();
+
+  if (phNxpNciHal_init_monitor() == NULL) {
+    NXPLOG_NCIHAL_E("Init monitor failed");
+    return NFCSTATUS_FAILED;
+  }
+
+  CONCURRENCY_LOCK();
+  memset(&tOsalConfig, 0x00, sizeof(tOsalConfig));
+  memset(&tTmlConfig, 0x00, sizeof(tTmlConfig));
+  memset(&nxpprofile_ctrl, 0, sizeof(phNxpNciProfile_Control_t));
+
+  /*Init binary semaphore for Spi Nfc synchronization*/
+  if (0 != sem_init(&nxpncihal_ctrl.syncSpiNfc, 0, 1)) {
+    NXPLOG_NCIHAL_E("sem_init() FAiled, errno = 0x%02X", errno);
+    CONCURRENCY_UNLOCK();
+    return phNxpNciHal_MinOpen_Clean(nfc_dev_node);
+  }
+
+  /* By default HAL status is HAL_STATUS_OPEN */
+  nxpncihal_ctrl.halStatus = HAL_STATUS_OPEN;
+
+  /*nci version NCI_VERSION_2_0 version by default for SN100 chip type*/
+  nxpncihal_ctrl.nci_info.nci_version = NCI_VERSION_2_0;
+  /* Read the nfc device node name */
+  nfc_dev_node = (char *)malloc(max_len * sizeof(char));
+  if (nfc_dev_node == NULL) {
+    NXPLOG_NCIHAL_D("malloc of nfc_dev_node failed ");
+    CONCURRENCY_UNLOCK();
+    return phNxpNciHal_MinOpen_Clean(nfc_dev_node);
+  } else if (!GetNxpStrValue(NAME_NXP_NFC_DEV_NODE, nfc_dev_node, max_len)) {
+    NXPLOG_NCIHAL_D(
+        "Invalid nfc device node name keeping the default device node "
+        "/dev/nxpnfc");
+    strlcpy(nfc_dev_node, "/dev/nxpnfc", (max_len * sizeof(char)));
+  }
+  /* Configure hardware link */
+  nxpncihal_ctrl.gDrvCfg.nClientId = phDal4Nfc_msgget(0, 0600);
+  nxpncihal_ctrl.gDrvCfg.nLinkType = ENUM_LINK_TYPE_I2C; /* For PN72xx */
+  tTmlConfig.pDevName = (int8_t *)nfc_dev_node;
+  tOsalConfig.dwCallbackThreadId = (uintptr_t)nxpncihal_ctrl.gDrvCfg.nClientId;
+  tOsalConfig.pLogFile = NULL;
+  tTmlConfig.dwGetMsgThreadId = (uintptr_t)nxpncihal_ctrl.gDrvCfg.nClientId;
+  mGetCfg_info = NULL;
+  mGetCfg_info =
+      (phNxpNci_getCfg_info_t *)nxp_malloc(sizeof(phNxpNci_getCfg_info_t));
+  if (mGetCfg_info == NULL) {
+    CONCURRENCY_UNLOCK();
+    return phNxpNciHal_MinOpen_Clean(nfc_dev_node);
+  }
+  memset(mGetCfg_info, 0x00, sizeof(phNxpNci_getCfg_info_t));
+
+  /* Set Default Fragment Length */
+  tTmlConfig.fragment_len = NCI_CMDRESP_MAX_BUFF_SIZE_PN557;
+
+  /* Initialize TML layer */
+  wConfigStatus = phTmlNfc_Init(&tTmlConfig);
+  if (wConfigStatus != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("phTmlNfc_Init Failed");
+    CONCURRENCY_UNLOCK();
+    return phNxpNciHal_MinOpen_Clean(nfc_dev_node);
+  } else {
+    if (nfc_dev_node != NULL) {
+      free(nfc_dev_node);
+      nfc_dev_node = NULL;
+    }
+  }
+
+  /* Create the client thread */
+  ret_val = pthread_create(&nxpncihal_ctrl.client_thread, NULL,
+                           phNxpNciHal_client_thread, &nxpncihal_ctrl);
+  if (ret_val != 0) {
+    NXPLOG_NCIHAL_E("pthread_create failed");
+    wConfigStatus = phTmlNfc_Shutdown_CleanUp();
+    CONCURRENCY_UNLOCK();
+    return phNxpNciHal_MinOpen_Clean(nfc_dev_node);
+  }
+
+  CONCURRENCY_UNLOCK();
+  /* call read pending */
+  status = phTmlNfc_Read(
+      nxpncihal_ctrl.p_rsp_data, NCI_MAX_DATA_LEN,
+      (pphTmlNfc_TransactCompletionCb_t)&phNxpNciHal_read_complete, NULL);
+  if (status != NFCSTATUS_PENDING) {
+    NXPLOG_NCIHAL_E("TML Read status error status = %x", status);
+    wConfigStatus = phTmlNfc_Shutdown_CleanUp();
+    wConfigStatus = NFCSTATUS_FAILED;
+    return phNxpNciHal_MinOpen_Clean(nfc_dev_node);
+  }
+
+  /* No need to check for download mode, if NFC Hal crashes and restarts */
+  char value[NFC_PROP_VALUE_MAX];
+  if (__system_property_get(spIsFirstHalMinOpen, value) <= 0) {
+    NXPLOG_NCIHAL_D("nfc.is_first_hal_min_open property not found. assigning "
+                    "default value");
+    std::strcpy(value, "0");
+  }
+
+  if (gsIsFirstHalMinOpen && (0 == std::strcmp("0", value))) {
+    phNxpNciHal_CheckAndHandleFwTearDown();
+  }
+
+  uint8_t seq_handler_offset = 0x00;
+  uint8_t fw_update_req = 1;
+  uint8_t rf_update_req;
+  phNxpNciHal_ext_init();
+
+  phTmlNfc_IoCtl(phTmlNfc_e_EnableVen);
+
+#if (NXP_EXTNS == TRUE)
+  /*mode switch gpio triggers core reset notification. Avoid core reset
+   * notification propagating to upper layer since it is initiated from HAL*/
+  nxpncihal_ctrl.nci_info.wait_for_ntf = TRUE;
+  HAL_ENABLE_EXT();
+  status = phTmlNfc_IoCtl(phTmlNfc_e_ModeSwitchOn);
+  if (NFCSTATUS_SUCCESS == status) {
+    NXPLOG_NCIHAL_D("phTmlNfc_e_ModeSwitchOn - SUCCESS\n");
+  } else {
+    NXPLOG_NCIHAL_D("phTmlNfc_e_ModeSwitchOn - FAILED\n");
+  }
+#endif
+  /* reset version info new version info will be fetch */
+  wFwVerRsp = 0x00;
+  wFwVer = 0x00;
+  if (NFCSTATUS_SUCCESS == phNxpNciHal_nfcc_core_reset_init(true)) {
+
+    setNxpFwConfigPath();
+    status = phNxpNciHal_CheckFwRegFlashRequired(&fw_update_req, &rf_update_req,
+                                                 false);
+    if (status != NFCSTATUS_OK) {
+      NXPLOG_NCIHAL_D(
+          "phNxpNciHal_CheckFwRegFlashRequired() failed:exit status = %x",
+          status);
+      fw_update_req = FALSE;
+      rf_update_req = FALSE;
+    }
+
+    if (!wFwUpdateReq) {
+      NXPLOG_NCIHAL_D("FW update not required");
+      property_set("nfc.fw.downloadmode_force", "0");
+      phDnldNfc_ReSetHwDevHandle();
+    }
+  } else {
+    phNxpNciHal_getChipInfoInFwDnldMode(true);
+  }
+
+  if (gsIsFirstHalMinOpen && gsIsFwRecoveryRequired) {
+    NXPLOG_NCIHAL_E("FW Recovery is required");
+    fw_update_req = true;
+  }
+
+  do {
+    if (fw_update_req && !fw_download_success) {
+      gsIsFwRecoveryRequired = false;
+      status = phNxpNciHal_force_fw_download(seq_handler_offset);
+      if (status == NFCSTATUS_CMD_ABORTED) {
+        return phNxpNciHal_MinOpen_Clean(nfc_dev_node);
+      } else if (fw_download_success) {
+        wConfigStatus = NFCSTATUS_SUCCESS;
+      }
+    }
+    status = phNxpNciHal_resetDefaultSettings(
+        fw_update_req, fw_download_success ? false : true);
+
+    if ((status != NFCSTATUS_SUCCESS && fw_download_success) ||
+        (gsIsFwRecoveryRequired && fw_update_req)) {
+      NXPLOG_NCIHAL_E("FW Recovery required, Perform Force FW Download "
+                      "gsIsFwRecoveryRequired %d",
+                      gsIsFwRecoveryRequired);
+      fw_update_req = 1;
+      dnld_retry_cnt++;
+    } else if (status != NFCSTATUS_SUCCESS) {
+      return phNxpNciHal_MinOpen_Clean(nfc_dev_node);
+    } else {
+      break;
+    }
+
+    if (dnld_retry_cnt > 1) {
+      wConfigStatus = NFCSTATUS_FAILED;
+      break;
+    }
+
+  } while (status != NFCSTATUS_SUCCESS || gsIsFwRecoveryRequired);
+
+  /* Update the EEPROM area if libnfc-nxp-eeprom.conf modified*/
+  if (isNxpEepromConfigModified() || (isFwDnldTriggered == true)) {
+    unsigned long num = 0;
+    int ret = 0;
+    isFwDnldTriggered = false;
+
+    if (phNxpNciHal_nfccClockCfgApply() != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("phNxpNciHal_nfccClockCfgApply failed");
+    }
+
+    ret = GetNxpNumValue(NAME_NXP_ENABLE_DISABLE_LPCD, &num, sizeof(num));
+    if (ret && num == 1) {
+      ret = GetNxpNumValue(NAME_NXP_ENABLE_DISABLE_STANBY, &num, sizeof(num));
+      if (ret && num == 1) {
+        phNxpNciHal_prop_conf_lpcd(true);
+      } else {
+        NXPLOG_NCIHAL_E(
+            "Failed to enable LPCD as Standby config is not enabled");
+      }
+    } else if (ret && num == 0) {
+      phNxpNciHal_prop_conf_lpcd(false);
+    }
+
+    /* VEN Reset is mandatory post EEPROM (0xA2 Config) update */
+    if (NFCSTATUS_SUCCESS == phTmlNfc_IoCtl(phTmlNfc_e_ResetDevice)) {
+      NXPLOG_NCIHAL_D("VEN Reset - SUCCESS\n");
+    } else {
+      NXPLOG_NCIHAL_D("VEN Reset - FAILED\n");
+    }
+    /* Core reset and core init must be perform post VEN reset */
+    if (NFCSTATUS_SUCCESS != phNxpNciHal_nfcc_core_reset_init(true)) {
+      NXPLOG_NCIHAL_E("Fail to perform core reset post ven reset\n");
+    }
+  }
+
+  /* Call open complete */
+  phNxpNciHal_MinOpen_complete(wConfigStatus);
+  NXPLOG_NCIHAL_D("phNxpNciHal_MinOpen(): exit");
+  return wConfigStatus;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_open
+ *
+ * Description      This function is called by libnfc-nci during the
+ *                  initialization of the NFCC. It opens the physical connection
+ *                  with NFCC (PN72xx) and creates required client thread for
+ *                  operation.
+ *                  After open is complete, status is informed to libnfc-nci
+ *                  through callback function.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS (0) in case of
+ *success In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+int phNxpNciHal_open(nfc_stack_callback_t *p_cback,
+                     nfc_stack_data_callback_t *p_data_cback) {
+  NFCSTATUS wConfigStatus = NFCSTATUS_SUCCESS;
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  NXPLOG_NCIHAL_E("HAL imple phNxpNciHal_open NFC HAL OPEN");
+  if (nxpncihal_ctrl.halStatus == HAL_STATUS_OPEN) {
+    NXPLOG_NCIHAL_D("phNxpNciHal_open already open");
+    return NFCSTATUS_SUCCESS;
+  } else if (nxpncihal_ctrl.halStatus == HAL_STATUS_CLOSE) {
+    memset(&nxpncihal_ctrl, 0x00, sizeof(nxpncihal_ctrl));
+    nxpncihal_ctrl.p_nfc_stack_cback = p_cback;
+    nxpncihal_ctrl.p_nfc_stack_data_cback = p_data_cback;
+    status = phNxpNciHal_MinOpen();
+    if (status != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("phNxpNciHal_MinOpen failed");
+      goto clean_and_return;
+    } /*else its already in MIN_OPEN state. continue with rest of
+         functionality*/
+  } else {
+    nxpncihal_ctrl.p_nfc_stack_cback = p_cback;
+    nxpncihal_ctrl.p_nfc_stack_data_cback = p_data_cback;
+  }
+  /* Call open complete */
+  phNxpNciHal_open_complete(wConfigStatus);
+
+  return wConfigStatus;
+
+clean_and_return:
+  CONCURRENCY_UNLOCK();
+  /* Report error status */
+  if (p_cback != NULL) {
+    (*p_cback)(HAL_NFC_OPEN_CPLT_EVT, HAL_NFC_STATUS_FAILED);
+  }
+
+  nxpncihal_ctrl.p_nfc_stack_cback = NULL;
+  nxpncihal_ctrl.p_nfc_stack_data_cback = NULL;
+  phNxpNciHal_cleanup_monitor();
+  nxpncihal_ctrl.halStatus = HAL_STATUS_CLOSE;
+  return NFCSTATUS_FAILED;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_fw_mw_check
+ *
+ * Description      This function inform the status of phNxpNciHal_fw_mw_check
+ *                  function to libnfc-nci.
+ *
+ * Returns          int.
+ *
+ ******************************************************************************/
+int phNxpNciHal_fw_mw_ver_check() {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  uint8_t rom_version = 0xFF & (wFwVerRsp >> 16);
+  uint8_t fw_maj_ver = 0xFF & (wFwVerRsp >> 8);
+
+  if ((nfcFL.chipType == sn100u) && (rom_version == SN1XX_ROM_VERSION) &&
+      (fw_maj_ver == SN1XX_FW_MAJOR_VERSION)) {
+    status = NFCSTATUS_SUCCESS;
+#if (NXP_EXTNS == TRUE)
+  } else if ((nfcFL.chipType >= pn7220) &&
+             (rom_version == FW_MOBILE_ROM_VERSION_PN7720) &&
+             (fw_maj_ver == 0x00)) {
+    status = NFCSTATUS_SUCCESS;
+#endif
+  } else if ((nfcFL.chipType == sn220u) && (rom_version == SN2XX_ROM_VERSION) &&
+             (fw_maj_ver == SN2XX_FW_MAJOR_VERSION)) {
+    status = NFCSTATUS_SUCCESS;
+  }
+  if (NFCSTATUS_SUCCESS != status) {
+    NXPLOG_NCIHAL_D("Chip Version Middleware Version mismatch!!!!");
+  }
+  return status;
+}
+/******************************************************************************
+ * Function         phNxpNciHal_MinOpen_complete
+ *
+ * Description      This function updates the status of
+ *phNxpNciHal_MinOpen_complete to halstatus.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static void phNxpNciHal_MinOpen_complete(NFCSTATUS status) {
+  gsIsFirstHalMinOpen = false;
+
+  if (__system_property_set(spIsFirstHalMinOpen, "1") != 0) {
+    NXPLOG_NCIHAL_E("Failed to set property nfc.is_first_hal_min_open");
+  }
+
+  if (status == NFCSTATUS_SUCCESS) {
+    nxpncihal_ctrl.halStatus = HAL_STATUS_MIN_OPEN;
+  }
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_open_complete
+ *
+ * Description      This function inform the status of phNxpNciHal_open
+ *                  function to libnfc-nci.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static void phNxpNciHal_open_complete(NFCSTATUS status) {
+  static phLibNfc_Message_t msg;
+
+  if (status == NFCSTATUS_SUCCESS) {
+    msg.eMsgType = NCI_HAL_OPEN_CPLT_MSG;
+    nxpncihal_ctrl.hal_open_status = true;
+    nxpncihal_ctrl.halStatus = HAL_STATUS_OPEN;
+  } else {
+    msg.eMsgType = NCI_HAL_ERROR_MSG;
+  }
+
+  msg.pMsgData = NULL;
+  msg.Size = 0;
+
+  phTmlNfc_DeferredCall(gpphTmlNfc_Context->dwCallbackThreadId,
+                        (phLibNfc_Message_t *)&msg);
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_write
+ *
+ * Description      This function write the data to NFCC through physical
+ *                  interface (e.g. I2C) using the PN72xx driver interface.
+ *                  Before sending the data to NFCC, phNxpNciHal_write_ext
+ *                  is called to check if there is any extension processing
+ *                  is required for the NCI packet being sent out.
+ *
+ * Returns          It returns number of bytes successfully written to NFCC.
+ *
+ ******************************************************************************/
+int phNxpNciHal_write(uint16_t data_len, const uint8_t *p_data) {
+  if (bDisableLegacyMfcExtns && bEnableMfcExtns && p_data[0] == 0x00) {
+    return NxpMfcReaderInstance.Write(data_len, p_data);
+  }
+  return phNxpNciHal_write_internal(data_len, p_data);
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_write_internal
+ *
+ * Description      This function write the data to NFCC through physical
+ *                  interface (e.g. I2C) using the PN72xx driver interface.
+ *                  Before sending the data to NFCC, phNxpNciHal_write_ext
+ *                  is called to check if there is any extension processing
+ *                  is required for the NCI packet being sent out.
+ *
+ * Returns          It returns number of bytes successfully written to NFCC.
+ *
+ ******************************************************************************/
+int phNxpNciHal_write_internal(uint16_t data_len, const uint8_t *p_data) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  static phLibNfc_Message_t msg;
+  if (nxpncihal_ctrl.halStatus != HAL_STATUS_OPEN) {
+    return NFCSTATUS_FAILED;
+  }
+  /* Create local copy of cmd_data */
+  memcpy(nxpncihal_ctrl.p_cmd_data, p_data, data_len);
+  nxpncihal_ctrl.cmd_len = data_len;
+  if ((nxpncihal_ctrl.cmd_len + MAX_NXP_HAL_EXTN_BYTES) > NCI_MAX_DATA_LEN) {
+    NXPLOG_NCIHAL_D("cmd_len exceeds limit NCI_MAX_DATA_LEN");
+    goto clean_and_return;
+  }
+#ifdef P2P_PRIO_LOGIC_HAL_IMP
+  /* Specific logic to block RF disable when P2P priority logic is busy */
+  if (p_data[0] == 0x21 && p_data[1] == 0x06 && p_data[2] == 0x01 &&
+      EnableP2P_PrioLogic == true) {
+    NXPLOG_NCIHAL_D("P2P priority logic busy: Disable it.");
+    phNxpNciHal_clean_P2P_Prio();
+  }
+#endif
+
+  /* Check for NXP ext before sending write */
+  status =
+      phNxpNciHal_write_ext(&nxpncihal_ctrl.cmd_len, nxpncihal_ctrl.p_cmd_data,
+                            &nxpncihal_ctrl.rsp_len, nxpncihal_ctrl.p_rsp_data);
+  if (status != NFCSTATUS_SUCCESS) {
+    /* Do not send packet to PN72xx, send response directly */
+    msg.eMsgType = NCI_HAL_RX_MSG;
+    msg.pMsgData = NULL;
+    msg.Size = 0;
+
+    phTmlNfc_DeferredCall(gpphTmlNfc_Context->dwCallbackThreadId,
+                          (phLibNfc_Message_t *)&msg);
+    goto clean_and_return;
+  }
+
+  CONCURRENCY_LOCK();
+  data_len = phNxpNciHal_write_unlocked(nxpncihal_ctrl.cmd_len,
+                                        nxpncihal_ctrl.p_cmd_data, ORIG_LIBNFC);
+  CONCURRENCY_UNLOCK();
+  if (nfcFL.chipType < sn100u && icode_send_eof == 1) {
+    usleep(10000);
+    icode_send_eof = 2;
+    status = phNxpNciHal_send_ext_cmd(3, cmd_icode_eof);
+    if (status != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("ICODE end of frame command failed");
+    }
+  }
+
+clean_and_return:
+  /* No data written */
+  return data_len;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_write_unlocked
+ *
+ * Description      This is the actual function which is being called by
+ *                  phNxpNciHal_write. This function writes the data to NFCC.
+ *                  It waits till write callback provide the result of write
+ *                  process.
+ *
+ * Returns          It returns number of bytes successfully written to NFCC.
+ *
+ ******************************************************************************/
+int phNxpNciHal_write_unlocked(uint16_t data_len, const uint8_t *p_data,
+                               int origin) {
+  NFCSTATUS status = NFCSTATUS_INVALID_PARAMETER;
+  phNxpNciHal_Sem_t cb_data;
+  nxpncihal_ctrl.retry_cnt = 0;
+  int sem_val = 0;
+  static uint8_t reset_ntf[] = {0x60, 0x00, 0x06, 0xA0, 0x00,
+                                0xC7, 0xD4, 0x00, 0x00};
+  /* Create the local semaphore */
+  if (phNxpNciHal_init_cb_data(&cb_data, NULL) != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_D("phNxpNciHal_write_unlocked Create cb data failed");
+    data_len = 0;
+    goto clean_and_return;
+  }
+
+  /* Create local copy of cmd_data */
+  memcpy(nxpncihal_ctrl.p_cmd_data, p_data, data_len);
+  nxpncihal_ctrl.cmd_len = data_len;
+  write_unlocked_status = NFCSTATUS_FAILED;
+  /* check for write synchronyztion */
+  if (phNxpNciHal_check_ncicmd_write_window(nxpncihal_ctrl.cmd_len,
+                                            nxpncihal_ctrl.p_cmd_data) !=
+      NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_D("phNxpNciHal_write_unlocked  CMD window  check failed");
+    data_len = 0;
+    goto clean_and_return;
+  }
+
+  if (origin == ORIG_NXPHAL)
+    HAL_ENABLE_EXT();
+
+retry:
+
+  data_len = nxpncihal_ctrl.cmd_len;
+
+  status = phTmlNfc_Write(
+      (uint8_t *)nxpncihal_ctrl.p_cmd_data, (uint16_t)nxpncihal_ctrl.cmd_len,
+      (pphTmlNfc_TransactCompletionCb_t)&phNxpNciHal_write_complete,
+      (void *)&cb_data);
+  if (status != NFCSTATUS_PENDING) {
+    NXPLOG_NCIHAL_E("write_unlocked status error");
+    data_len = 0;
+    goto clean_and_return;
+  }
+
+  /* Wait for callback response */
+  if (SEM_WAIT(cb_data)) {
+    NXPLOG_NCIHAL_E("write_unlocked semaphore error");
+    data_len = 0;
+    goto clean_and_return;
+  }
+
+  if (cb_data.status != NFCSTATUS_SUCCESS) {
+    data_len = 0;
+    if (nxpncihal_ctrl.retry_cnt++ < MAX_RETRY_COUNT) {
+      NXPLOG_NCIHAL_D(
+          "write_unlocked failed - PN72xx Maybe in Standby Mode - Retry");
+      /* 10ms delay to give NFCC wake up delay */
+      usleep(1000 * 10);
+      goto retry;
+    } else {
+      NXPLOG_NCIHAL_E(
+          "write_unlocked failed - PN72xx Maybe in Standby Mode (max count = "
+          "0x%x)",
+          nxpncihal_ctrl.retry_cnt);
+
+      status = phTmlNfc_IoCtl(phTmlNfc_e_ResetDevice);
+
+      if (NFCSTATUS_SUCCESS == status) {
+        NXPLOG_NCIHAL_D("PN72xx Reset - SUCCESS\n");
+      } else {
+        NXPLOG_NCIHAL_D("PN72xx Reset - FAILED\n");
+      }
+      if (nxpncihal_ctrl.p_nfc_stack_data_cback != NULL &&
+          nxpncihal_ctrl.hal_open_status == true) {
+        if (nxpncihal_ctrl.p_rx_data != NULL) {
+          NXPLOG_NCIHAL_D(
+              "Send the Core Reset NTF to upper layer, which will trigger the "
+              "recovery\n");
+          // Send the Core Reset NTF to upper layer, which will trigger the
+          // recovery.
+#if (NXP_EXTNS == TRUE)
+          abort();
+#endif
+          nxpncihal_ctrl.rx_data_len = sizeof(reset_ntf);
+          memcpy(nxpncihal_ctrl.p_rx_data, reset_ntf, sizeof(reset_ntf));
+          (*nxpncihal_ctrl.p_nfc_stack_data_cback)(nxpncihal_ctrl.rx_data_len,
+                                                   nxpncihal_ctrl.p_rx_data);
+        } else {
+          (*nxpncihal_ctrl.p_nfc_stack_data_cback)(0x00, NULL);
+        }
+        write_unlocked_status = NFCSTATUS_FAILED;
+      }
+    }
+  } else {
+    write_unlocked_status = NFCSTATUS_SUCCESS;
+  }
+
+clean_and_return:
+  if (write_unlocked_status == NFCSTATUS_FAILED) {
+    sem_getvalue(&(nxpncihal_ctrl.syncSpiNfc), &sem_val);
+    if (((nxpncihal_ctrl.p_cmd_data[0] & NCI_MT_MASK) == NCI_MT_CMD) &&
+        sem_val == 0) {
+      sem_post(&(nxpncihal_ctrl.syncSpiNfc));
+      NXPLOG_NCIHAL_D("HAL write  failed CMD window check releasing \n");
+    }
+  }
+  phNxpNciHal_cleanup_cb_data(&cb_data);
+  return data_len;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_write_complete
+ *
+ * Description      This function handles write callback.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static void phNxpNciHal_write_complete(void *pContext,
+                                       phTmlNfc_TransactInfo_t *pInfo) {
+  phNxpNciHal_Sem_t *p_cb_data = (phNxpNciHal_Sem_t *)pContext;
+  if (pInfo->wStatus == NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_D("write successful status = 0x%x", pInfo->wStatus);
+  } else {
+    NXPLOG_NCIHAL_D("write error status = 0x%x", pInfo->wStatus);
+  }
+
+  p_cb_data->status = pInfo->wStatus;
+
+  SEM_POST(p_cb_data);
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_read_complete
+ *
+ * Description      This function is called whenever there is an NCI packet
+ *                  received from NFCC. It could be RSP or NTF packet. This
+ *                  function provide the received NCI packet to libnfc-nci
+ *                  using data callback of libnfc-nci.
+ *                  There is a pending read called from each
+ *                  phNxpNciHal_read_complete so each a packet received from
+ *                  NFCC can be provide to libnfc-nci.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static void phNxpNciHal_read_complete(void *pContext,
+                                      phTmlNfc_TransactInfo_t *pInfo) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  int sem_val;
+  UNUSED_PROP(pContext);
+  if (nxpncihal_ctrl.read_retry_cnt == 1) {
+    nxpncihal_ctrl.read_retry_cnt = 0;
+  }
+  if (pInfo->wStatus == NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_D("read successful status = 0x%x", pInfo->wStatus);
+
+    /*Check the Omapi command response and store in dedicated buffer to solve
+     * sync issue*/
+    if (nfcFL.chipType <= sn100u && pInfo->pBuff[0] == 0x4F &&
+        pInfo->pBuff[1] == 0x01 && pInfo->pBuff[2] == 0x01) {
+      nxpncihal_ctrl.p_rx_ese_data = pInfo->pBuff;
+      nxpncihal_ctrl.rx_ese_data_len = pInfo->wLength;
+      SEM_POST(&(nxpncihal_ctrl.ext_cb_data));
+    } else {
+      nxpncihal_ctrl.p_rx_data = pInfo->pBuff;
+      nxpncihal_ctrl.rx_data_len = pInfo->wLength;
+      status = phNxpNciHal_process_ext_rsp(nxpncihal_ctrl.p_rx_data,
+                                           &nxpncihal_ctrl.rx_data_len);
+      if (nxpncihal_ctrl.hal_ext_enabled && phTmlNfc_IsFwDnldModeEnabled()) {
+        SEM_POST(&(nxpncihal_ctrl.ext_cb_data));
+      }
+    }
+    phNxpNciHal_print_res_status(pInfo->pBuff, &pInfo->wLength);
+
+    /* Check if response should go to hal module only */
+    if (nxpncihal_ctrl.hal_ext_enabled == TRUE &&
+        (nxpncihal_ctrl.p_rx_data[0x00] & NCI_MT_MASK) == NCI_MT_RSP) {
+      if (status == NFCSTATUS_FAILED) {
+        NXPLOG_NCIHAL_D("enter into NFCC init recovery");
+        nxpncihal_ctrl.ext_cb_data.status = status;
+      }
+      /* Unlock semaphore only for responses*/
+      if ((nxpncihal_ctrl.p_rx_data[0x00] & NCI_MT_MASK) == NCI_MT_RSP ||
+          ((nfcFL.chipType < sn100u) && (icode_detected == true) &&
+           (icode_send_eof == 3))) {
+        /* Unlock semaphore */
+        SEM_POST(&(nxpncihal_ctrl.ext_cb_data));
+      }
+    } // Notification Checking
+    else if ((nxpncihal_ctrl.hal_ext_enabled == TRUE) &&
+             ((nxpncihal_ctrl.p_rx_data[0x00] & NCI_MT_MASK) == NCI_MT_NTF) &&
+#if (NXP_EXTNS == TRUE)
+             ((nxpncihal_ctrl.p_cmd_data[0x00] & NCI_GID_MASK) ==
+              (nxpncihal_ctrl.p_rx_data[0x00] & NCI_GID_MASK)) &&
+             ((nxpncihal_ctrl.p_cmd_data[0x01] & NCI_OID_MASK) ==
+              (nxpncihal_ctrl.p_rx_data[0x01] & NCI_OID_MASK)) &&
+#endif
+             (nxpncihal_ctrl.nci_info.wait_for_ntf == TRUE)) {
+      /* Unlock semaphore waiting for only  ntf*/
+      nxpncihal_ctrl.nci_info.wait_for_ntf = FALSE;
+      SEM_POST(&(nxpncihal_ctrl.ext_cb_data));
+    } else if (bDisableLegacyMfcExtns && !sendRspToUpperLayer &&
+               (nxpncihal_ctrl.p_rx_data[0x00] == 0x00)) {
+      sendRspToUpperLayer = true;
+      NFCSTATUS mfcRspStatus = NxpMfcReaderInstance.CheckMfcResponse(
+          nxpncihal_ctrl.p_rx_data, nxpncihal_ctrl.rx_data_len);
+      NXPLOG_NCIHAL_D("Mfc Response Status = 0x%x", mfcRspStatus);
+      SEM_POST(&(nxpncihal_ctrl.ext_cb_data));
+    }
+    /* Read successful send the event to higher layer */
+    else if ((nxpncihal_ctrl.p_nfc_stack_data_cback != NULL) &&
+             (status == NFCSTATUS_SUCCESS)) {
+      NxpMfcReaderInstance.MfcNotifyOnAckReceived(nxpncihal_ctrl.p_rx_data);
+      (*nxpncihal_ctrl.p_nfc_stack_data_cback)(nxpncihal_ctrl.rx_data_len,
+                                               nxpncihal_ctrl.p_rx_data);
+    }
+    /* Unblock next Write Command Window */
+    sem_getvalue(&(nxpncihal_ctrl.syncSpiNfc), &sem_val);
+    if (((pInfo->pBuff[0] & NCI_MT_MASK) == NCI_MT_RSP) && sem_val == 0) {
+      sem_post(&(nxpncihal_ctrl.syncSpiNfc));
+    }
+  } else {
+    NXPLOG_NCIHAL_E("read error status = 0x%x", pInfo->wStatus);
+  }
+
+  if (nxpncihal_ctrl.halStatus == HAL_STATUS_CLOSE &&
+#if (NXP_EXTNS == TRUE)
+      (nxpncihal_ctrl.p_cmd_data[0x00] & NCI_GID_MASK) ==
+          (nxpncihal_ctrl.p_rx_data[0x00] & NCI_GID_MASK) &&
+      (nxpncihal_ctrl.p_cmd_data[0x01] & NCI_OID_MASK) ==
+          (nxpncihal_ctrl.p_rx_data[0x01] & NCI_OID_MASK) &&
+#endif
+      nxpncihal_ctrl.nci_info.wait_for_ntf == FALSE) {
+    NXPLOG_NCIHAL_D(" Ignoring read , HAL close triggered");
+    return;
+  }
+  /* Read again because read must be pending always except FWDNLD.*/
+  if (TRUE != nxpncihal_ctrl.fwdnld_mode_reqd) {
+    status = phTmlNfc_Read(
+        nxpncihal_ctrl.p_rsp_data, NCI_MAX_DATA_LEN,
+        (pphTmlNfc_TransactCompletionCb_t)&phNxpNciHal_read_complete, NULL);
+    if (status != NFCSTATUS_PENDING) {
+      NXPLOG_NCIHAL_E("read status error status = %x", status);
+      /* TODO: Not sure how to handle this ? */
+    }
+  }
+  return;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_enableTmlRead
+ *
+ * Description      Invokes TmlNfc Read to make sure always read thread is
+ *                  pending
+ *
+ * Returns          Returns read status
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_enableTmlRead() {
+  /* Read again because read must be pending always.*/
+  NFCSTATUS status = phTmlNfc_Read(
+      nxpncihal_ctrl.p_rsp_data, NCI_MAX_DATA_LEN,
+      (pphTmlNfc_TransactCompletionCb_t)&phNxpNciHal_read_complete, NULL);
+  if (status != NFCSTATUS_PENDING) {
+    NXPLOG_NCIHAL_E("read status error status = %x", status);
+  }
+  return status;
+}
+/******************************************************************************
+ * Function         phNxpNciHal_core_initialized
+ *
+ * Description      This function is called by libnfc-nci after successful open
+ *                  of NFCC. All proprietary setting for PN72xx are done here.
+ *                  After completion of proprietary settings notification is
+ *                  provided to libnfc-nci through callback function.
+ *
+ * Returns          Always returns NFCSTATUS_SUCCESS (0).
+ *
+ ******************************************************************************/
+int phNxpNciHal_core_initialized(uint16_t core_init_rsp_params_len,
+                                 uint8_t *p_core_init_rsp_params) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  core_init_rsp_params_len = 10;
+  p_core_init_rsp_params = NULL;
+  uint8_t *buffer = NULL;
+  long bufflen = 260;
+  uint8_t isfound = 0;
+  long retlen = 0;
+  unsigned long num = 0;
+  uint8_t setConfigAlways = false;
+
+#if (NXP_EXTNS != TRUE)
+  /*NCI_INIT_CMD*/
+  static uint8_t cmd_init_nci[] = {0x20, 0x01, 0x00};
+  /*NCI_RESET_CMD*/
+  static uint8_t cmd_reset_nci[] = {0x20, 0x00, 0x01,
+                                    0x00}; // keep configuration
+  static uint8_t cmd_init_nci2_0[] = {0x20, 0x01, 0x02, 0x00, 0x00};
+  /* reset config cache */
+  uint8_t retry_core_init_cnt = 0;
+
+retry_core_init:
+  if (retry_core_init_cnt > 3) {
+    return NFCSTATUS_FAILED;
+  }
+  status = phNxpNciHal_send_ext_cmd(sizeof(cmd_reset_nci), cmd_reset_nci);
+  if ((status != NFCSTATUS_SUCCESS) &&
+      (nxpncihal_ctrl.retry_cnt >= MAX_RETRY_COUNT)) {
+    NXPLOG_NCIHAL_E("Force FW Download, NFCC not coming out from Standby");
+    retry_core_init_cnt++;
+    goto retry_core_init;
+  } else if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("NCI_CORE_RESET: Failed");
+    retry_core_init_cnt++;
+    goto retry_core_init;
+  }
+
+  if (nxpncihal_ctrl.nci_info.nci_version == NCI_VERSION_2_0) {
+    status = phNxpNciHal_send_ext_cmd(sizeof(cmd_init_nci2_0), cmd_init_nci2_0);
+  } else {
+    status = phNxpNciHal_send_ext_cmd(sizeof(cmd_init_nci), cmd_init_nci);
+  }
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("NCI_CORE_INIT : Failed");
+    retry_core_init_cnt++;
+    goto retry_core_init;
+  }
+  config_access = false;
+  status = phNxpNciHal_read_fw_dw_status(fw_dwnld_flag);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("%s: NXP get FW DW Flag failed", __FUNCTION__);
+  }
+#endif
+
+  buffer = (uint8_t *)malloc(bufflen * sizeof(uint8_t));
+  if (NULL == buffer) {
+    return NFCSTATUS_FAILED;
+  }
+
+  setConfigAlways = false;
+  isfound = GetNxpNumValue(NAME_NXP_SET_CONFIG_ALWAYS, &num, sizeof(num));
+  if (isfound > 0) {
+    setConfigAlways = num;
+  }
+
+  fw_dwnld_flag |= (bool)fw_download_success;
+
+  if (isNxpConfigModified() || (fw_dwnld_flag == true)) {
+    fw_download_success = 0;
+  }
+
+  if (GetNxpNumValue(NAME_NXP_ENABLE_DISABLE_STANBY, &num, sizeof(num))) {
+    if (num == 0 || num == 1) {
+      uint8_t coreStandBy[] = {0x2F, 0x00, 0x01, 0x00};
+      coreStandBy[3] = num;
+      status = phNxpNciHal_send_ext_cmd(sizeof(coreStandBy), coreStandBy);
+      if (status != NFCSTATUS_SUCCESS) {
+        NXPLOG_NCIHAL_E("Failed to enable/disable NFCC Standby");
+      }
+    }
+  }
+
+  // Update eeprom value
+  status = phNxpNciHal_get_mw_eeprom();
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("NXP GET MW EEPROM failed");
+  } else {
+    for (int i = 0; i < nxpncihal_ctrl.p_rx_data[7]; i++) {
+      if (nxpncihal_ctrl.p_rx_data[8 + i] != 0x00) {
+        status = phNxpNciHal_set_mw_eeprom();
+        if (status != NFCSTATUS_SUCCESS) {
+          NXPLOG_NCIHAL_E("NXP Update MW EEPROM Proprietary Ext failed");
+        }
+        break;
+      }
+    }
+  }
+
+  if ((true == fw_dwnld_flag) || (true == setConfigAlways) ||
+      isNxpConfigModified() || (wRfUpdateReq == true)) {
+    retlen = 0;
+    NXPLOG_NCIHAL_D("Performing NAME_NXP_CORE_CONF_EXTN Settings");
+    isfound = GetNxpByteArrayValue(NAME_NXP_CORE_CONF_EXTN, (char *)buffer,
+                                   bufflen, &retlen);
+    if (isfound > 0 && retlen > 0) {
+      /* NXP ACT Proprietary Ext */
+      status = phNxpNciHal_send_ext_cmd(retlen, buffer);
+      if (status != NFCSTATUS_SUCCESS) {
+        NXPLOG_NCIHAL_E("NXP Core configuration failed");
+      }
+    }
+
+    retlen = 0;
+    NXPLOG_NCIHAL_D("Performing NAME_NXP_CORE_CONF Settings");
+    isfound = GetNxpByteArrayValue(NAME_NXP_CORE_CONF, (char *)buffer, bufflen,
+                                   &retlen);
+    if (isfound > 0 && retlen > 0) {
+      /* NXP ACT Proprietary Ext */
+      status = phNxpNciHal_send_ext_cmd(retlen, buffer);
+      if (status != NFCSTATUS_SUCCESS) {
+        NXPLOG_NCIHAL_E("Core Set Config failed");
+      }
+    }
+  }
+
+  if (buffer) {
+    free(buffer);
+    buffer = NULL;
+  }
+
+  // initialize recovery FW variables
+  gRecFWDwnld = 0;
+  gRecFwRetryCount = 0;
+
+  phNxpNciHal_core_initialized_complete(status);
+
+  if (nfcFL.chipType >= pn7220) {
+    status = phTmlNfc_IoCtl(phTmlNfc_e_RedLedOn);
+    if (NFCSTATUS_SUCCESS == status) {
+      NXPLOG_NCIHAL_D("phTmlNfc_e_RedLedOn - SUCCESS\n");
+    } else {
+      NXPLOG_NCIHAL_D("phTmlNfc_e_RedLedOn - FAILED\n");
+    }
+  }
+  if (isNxpConfigModified()) {
+    updateNxpConfigTimestamp();
+  }
+  if (isNxpEepromConfigModified()) {
+    updateNxpEepromConfigTimestamp();
+  }
+  return NFCSTATUS_SUCCESS;
+}
+/******************************************************************************
+ * Function         phNxpNciHal_core_initialized_complete
+ *
+ * Description      This function is called when phNxpNciHal_core_initialized
+ *                  complete all proprietary command exchanges. This function
+ *                  informs libnfc-nci about completion of core initialize
+ *                  and result of that through callback.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static void phNxpNciHal_core_initialized_complete(NFCSTATUS status) {
+  static phLibNfc_Message_t msg;
+
+  if (status == NFCSTATUS_SUCCESS) {
+    msg.eMsgType = NCI_HAL_POST_INIT_CPLT_MSG;
+  } else {
+    msg.eMsgType = NCI_HAL_ERROR_MSG;
+  }
+  msg.pMsgData = NULL;
+  msg.Size = 0;
+
+  phTmlNfc_DeferredCall(gpphTmlNfc_Context->dwCallbackThreadId,
+                        (phLibNfc_Message_t *)&msg);
+  return;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_pre_discover
+ *
+ * Description      This function is called by libnfc-nci to perform any
+ *                  proprietary exchange before RF discovery.
+ *
+ * Returns          It always returns NFCSTATUS_SUCCESS (0).
+ *
+ ******************************************************************************/
+int phNxpNciHal_pre_discover(void) {
+  /* Nothing to do here for initial version */
+  return NFCSTATUS_SUCCESS;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_release_info
+ *
+ * Description      This function frees allocated memory for mGetCfg_info
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static void phNxpNciHal_release_info(void) {
+  NXPLOG_NCIHAL_D("phNxpNciHal_release_info mGetCfg_info");
+  if (mGetCfg_info != NULL) {
+    free(mGetCfg_info);
+    mGetCfg_info = NULL;
+  }
+}
+/******************************************************************************
+ * Function         phNxpNciHal_close
+ *
+ * Description      This function close the NFCC interface and free all
+ *                  resources.This is called by libnfc-nci on NFC service stop.
+ *
+ * Returns          Always return NFCSTATUS_SUCCESS (0).
+ *
+ ******************************************************************************/
+int phNxpNciHal_close(bool bShutdown) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+
+  uint8_t cmd_reset_nci[] = {0x20, 0x00, 0x01, 0x00};
+  uint8_t dummyGetConfig[] = {0x20, 0x03, 0x03, 0x01, 0xA0, 0x0F};
+  uint8_t retry = 0;
+
+  NfcHalAutoThreadMutex a(sHalFnLock);
+  if (nxpncihal_ctrl.halStatus == HAL_STATUS_CLOSE) {
+    NXPLOG_NCIHAL_D("phNxpNciHal_close is already closed, ignoring close");
+    return NFCSTATUS_FAILED;
+  }
+
+  CONCURRENCY_LOCK();
+  int sem_val;
+  sem_getvalue(&(nxpncihal_ctrl.syncSpiNfc), &sem_val);
+  if (sem_val == 0) {
+    sem_post(&(nxpncihal_ctrl.syncSpiNfc));
+  }
+
+  if (write_unlocked_status == NFCSTATUS_FAILED) {
+    NXPLOG_NCIHAL_D("phNxpNciHal_close i2c write failed .Clean and Return");
+    goto close_and_return;
+  }
+
+close_and_return:
+  /* Send a dummy get config cmd to prevent the abrupt HAL close before reading
+     all pending data from i2c line  */
+  status = phNxpNciHal_send_ext_cmd(sizeof(dummyGetConfig), dummyGetConfig);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("Get config failed ");
+  }
+
+  if ((nfcFL.chipType < sn220u) || (nfcFL.chipType >= pn7220) || bShutdown) {
+    nxpncihal_ctrl.halStatus = HAL_STATUS_CLOSE;
+  }
+  do { /*This is NXP_EXTNS code for retry*/
+    status = phNxpNciHal_send_ext_cmd(sizeof(cmd_reset_nci), cmd_reset_nci);
+
+    if (status == NFCSTATUS_SUCCESS) {
+      break;
+    } else {
+      NXPLOG_NCIHAL_E("NCI_CORE_RESET: Failed, perform retry after delay");
+      usleep(1000 * 1000);
+      retry++;
+      if (retry > 3) {
+        NXPLOG_NCIHAL_E(
+            "Maximum retries performed, shall restart HAL to recover");
+        abort();
+      }
+    }
+  } while (retry < 3);
+
+#if (NXP_EXTNS == TRUE)
+  if (nfcFL.chipType >= pn7220) {
+    status = phTmlNfc_IoCtl(phTmlNfc_e_RedLedOff);
+    if (NFCSTATUS_SUCCESS == status) {
+      NXPLOG_NCIHAL_D("phTmlNfc_e_RedLedOn - SUCCESS\n");
+    } else {
+      NXPLOG_NCIHAL_D("phTmlNfc_e_RedLedOn- FAILED\n");
+    }
+  }
+#endif
+
+  sem_destroy(&nxpncihal_ctrl.syncSpiNfc);
+
+  if (NULL != gpphTmlNfc_Context->pDevHandle) {
+    phNxpNciHal_close_complete(NFCSTATUS_SUCCESS);
+    /* Abort any pending read and write */
+    status = phTmlNfc_ReadAbort();
+    status = phTmlNfc_WriteAbort();
+
+    phOsalNfc_Timer_Cleanup();
+
+    status = phTmlNfc_Shutdown();
+
+    if (0 != pthread_join(nxpncihal_ctrl.client_thread, (void **)NULL)) {
+      NXPLOG_TML_E("Fail to kill client thread!");
+    }
+
+    phTmlNfc_CleanUp();
+
+    phDal4Nfc_msgrelease(nxpncihal_ctrl.gDrvCfg.nClientId);
+
+    memset(&nxpncihal_ctrl, 0x00, sizeof(nxpncihal_ctrl));
+
+    NXPLOG_NCIHAL_D("phNxpNciHal_close - phOsalNfc_DeInit completed");
+  }
+
+  CONCURRENCY_UNLOCK();
+
+  phNxpNciHal_cleanup_monitor();
+  write_unlocked_status = NFCSTATUS_SUCCESS;
+  phNxpNciHal_release_info();
+  /* reset config cache */
+  resetNxpConfig();
+  /* Return success always */
+  return NFCSTATUS_SUCCESS;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_close_complete
+ *
+ * Description      This function inform libnfc-nci about result of
+ *                  phNxpNciHal_close.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+void phNxpNciHal_close_complete(NFCSTATUS status) {
+  static phLibNfc_Message_t msg;
+
+  if (status == NFCSTATUS_SUCCESS) {
+    msg.eMsgType = NCI_HAL_CLOSE_CPLT_MSG;
+  } else {
+    msg.eMsgType = NCI_HAL_ERROR_MSG;
+  }
+  msg.pMsgData = NULL;
+  msg.Size = 0;
+  nxpncihal_ctrl.hal_open_status = false;
+  phTmlNfc_DeferredCall(gpphTmlNfc_Context->dwCallbackThreadId, &msg);
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_configDiscShutdown
+ *
+ * Description      Enable the CE and VEN config during shutdown.
+ *
+ * Returns          Always return NFCSTATUS_SUCCESS (0).
+ *
+ ******************************************************************************/
+int phNxpNciHal_configDiscShutdown(void) {
+  NFCSTATUS status;
+  /*NCI_RESET_CMD*/
+
+  uint8_t cmd_disable_disc[] = {0x21, 0x06, 0x01, 0x00};
+
+  uint8_t cmd_ce_disc_nci[] = {0x21, 0x03, 0x07, 0x03, 0x80,
+                               0x01, 0x81, 0x01, 0x82, 0x01};
+
+  /* Discover map - PROTOCOL_ISO_DEP, PROTOCOL_T3T and MIFARE Classic*/
+  uint8_t cmd_disc_map[] = {0x21, 0x00, 0x0A, 0x03, 0x04, 0x03, 0x02,
+                            0x03, 0x02, 0x01, 0x80, 0x01, 0x80};
+  CONCURRENCY_LOCK();
+
+  status = phNxpNciHal_send_ext_cmd(sizeof(cmd_disable_disc), cmd_disable_disc);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("CMD_DISABLE_DISCOVERY: Failed");
+  }
+
+  if (nfcFL.chipType >= sn100u) {
+    status = phNxpNciHal_send_ext_cmd(sizeof(cmd_disc_map), cmd_disc_map);
+    if (status != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("Discovery Map command: Failed");
+    }
+    status = phNxpNciHal_ext_send_sram_config_to_flash();
+    if (status != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("Updation of the SRAM contents failed");
+    }
+  }
+  status = phNxpNciHal_send_ext_cmd(sizeof(cmd_ce_disc_nci), cmd_ce_disc_nci);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("CMD_CE_DISC_NCI: Failed");
+  }
+
+  CONCURRENCY_UNLOCK();
+
+  status = phNxpNciHal_close(true);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("NCI_HAL_CLOSE: Failed");
+  }
+
+  /* Return success always */
+  return NFCSTATUS_SUCCESS;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_getVendorConfig
+ *
+ * Description      This function can be used by HAL to inform
+ *                 to update vendor configuration parametres
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+
+void phNxpNciHal_getVendorConfig(
+    android::hardware::nfc::V1_1::NfcConfig &config) {
+  unsigned long num = 0;
+  std::array<uint8_t, NXP_MAX_CONFIG_STRING_LEN> buffer;
+  buffer.fill(0);
+  long retlen = 0;
+  memset(&config, 0x00, sizeof(android::hardware::nfc::V1_1::NfcConfig));
+  memset(&config_ext, 0x00, sizeof(nxp_nfc_config_ext_t));
+
+  if ((GetNxpNumValue(NAME_NXP_AUTONOMOUS_ENABLE, &num, sizeof(num)))) {
+    config_ext.autonomous_mode = (uint8_t)num;
+  }
+  if ((GetNxpNumValue(NAME_NXP_GUARD_TIMER_VALUE, &num, sizeof(num)))) {
+    config_ext.guard_timer_value = (uint8_t)num;
+  }
+  if (GetNxpNumValue(NAME_NFA_POLL_BAIL_OUT_MODE, &num, sizeof(num))) {
+    config.nfaPollBailOutMode = (bool)num;
+  }
+  if (GetNxpNumValue(NAME_ISO_DEP_MAX_TRANSCEIVE, &num, sizeof(num))) {
+    config.maxIsoDepTransceiveLength = (uint32_t)num;
+  }
+  if (GetNxpNumValue(NAME_DEFAULT_OFFHOST_ROUTE, &num, sizeof(num))) {
+    config.defaultOffHostRoute = (uint8_t)num;
+  }
+  if (GetNxpNumValue(NAME_DEFAULT_NFCF_ROUTE, &num, sizeof(num))) {
+    config.defaultOffHostRouteFelica = (uint8_t)num;
+  }
+  if (GetNxpNumValue(NAME_DEFAULT_SYS_CODE_ROUTE, &num, sizeof(num))) {
+    config.defaultSystemCodeRoute = (uint8_t)num;
+  }
+  if (GetNxpNumValue(NAME_DEFAULT_SYS_CODE_PWR_STATE, &num, sizeof(num))) {
+    config.defaultSystemCodePowerState =
+        phNxpNciHal_updateAutonomousPwrState((uint8_t)num);
+  }
+  if (GetNxpNumValue(NAME_DEFAULT_ROUTE, &num, sizeof(num))) {
+    config.defaultRoute = (uint8_t)num;
+  }
+  if (GetNxpByteArrayValue(NAME_DEVICE_HOST_WHITE_LIST, (char *)buffer.data(),
+                           buffer.size(), &retlen)) {
+    config.hostWhitelist.resize(retlen);
+    for (long i = 0; i < retlen; i++)
+      config.hostWhitelist[i] = buffer[i];
+  }
+  if (GetNxpNumValue(NAME_OFF_HOST_ESE_PIPE_ID, &num, sizeof(num))) {
+    config.offHostESEPipeId = (uint8_t)num;
+  }
+  if (GetNxpNumValue(NAME_OFF_HOST_SIM_PIPE_ID, &num, sizeof(num))) {
+    config.offHostSIMPipeId = (uint8_t)num;
+  }
+  if ((GetNxpByteArrayValue(NAME_NFA_PROPRIETARY_CFG, (char *)buffer.data(),
+                            buffer.size(), &retlen)) &&
+      (retlen == 9)) {
+    config.nfaProprietaryCfg.protocol18092Active = (uint8_t)buffer[0];
+    config.nfaProprietaryCfg.protocolBPrime = (uint8_t)buffer[1];
+    config.nfaProprietaryCfg.protocolDual = (uint8_t)buffer[2];
+    config.nfaProprietaryCfg.protocol15693 = (uint8_t)buffer[3];
+    config.nfaProprietaryCfg.protocolKovio = (uint8_t)buffer[4];
+    config.nfaProprietaryCfg.protocolMifare = (uint8_t)buffer[5];
+    config.nfaProprietaryCfg.discoveryPollKovio = (uint8_t)buffer[6];
+    config.nfaProprietaryCfg.discoveryPollBPrime = (uint8_t)buffer[7];
+    config.nfaProprietaryCfg.discoveryListenBPrime = (uint8_t)buffer[8];
+  } else {
+    memset(&config.nfaProprietaryCfg, 0xFF, sizeof(ProtocolDiscoveryConfig));
+  }
+  if ((GetNxpNumValue(NAME_PRESENCE_CHECK_ALGORITHM, &num, sizeof(num))) &&
+      (num <= 2)) {
+    config.presenceCheckAlgorithm = (PresenceCheckAlgorithm)num;
+  }
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_getVendorConfig_1_2
+ *
+ * Description      This function can be used by HAL to inform
+ *                 to update vendor configuration parametres
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+
+void phNxpNciHal_getVendorConfig_1_2(
+    android::hardware::nfc::V1_2::NfcConfig &config) {
+  unsigned long num = 0;
+  std::array<uint8_t, NXP_MAX_CONFIG_STRING_LEN> buffer;
+  buffer.fill(0);
+  long retlen = 0;
+  memset(&config, 0x00, sizeof(android::hardware::nfc::V1_2::NfcConfig));
+  phNxpNciHal_getVendorConfig(config.v1_1);
+
+  if (GetNxpByteArrayValue(NAME_OFFHOST_ROUTE_UICC, (char *)buffer.data(),
+                           buffer.size(), &retlen)) {
+    config.offHostRouteUicc.resize(retlen);
+    for (long i = 0; i < retlen; i++)
+      config.offHostRouteUicc[i] = buffer[i];
+  }
+
+  if (GetNxpByteArrayValue(NAME_OFFHOST_ROUTE_ESE, (char *)buffer.data(),
+                           buffer.size(), &retlen)) {
+    config.offHostRouteEse.resize(retlen);
+    for (long i = 0; i < retlen; i++)
+      config.offHostRouteEse[i] = buffer[i];
+  }
+
+  if (GetNxpNumValue(NAME_DEFAULT_ISODEP_ROUTE, &num, sizeof(num))) {
+    config.defaultIsoDepRoute = num;
+  }
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_notify_i2c_fragmentation
+ *
+ * Description      This function can be used by HAL to inform
+ *                 libnfc-nci that i2c fragmentation is enabled/disabled
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+void phNxpNciHal_notify_i2c_fragmentation(void) {
+  if (nxpncihal_ctrl.p_nfc_stack_cback != NULL) {
+    /*inform libnfc-nci that i2c fragmentation is enabled/disabled */
+    (*nxpncihal_ctrl.p_nfc_stack_cback)(HAL_NFC_ENABLE_I2C_FRAGMENTATION_EVT,
+                                        HAL_NFC_STATUS_OK);
+  }
+}
+/******************************************************************************
+ * Function         phNxpNciHal_control_granted
+ *
+ * Description      Called by libnfc-nci when NFCC control is granted to HAL.
+ *
+ * Returns          Always returns NFCSTATUS_SUCCESS (0).
+ *
+ ******************************************************************************/
+int phNxpNciHal_control_granted(void) {
+  /* Take the concurrency lock so no other calls from upper layer
+   * will be allowed
+   */
+  CONCURRENCY_LOCK();
+
+  if (NULL != nxpncihal_ctrl.p_control_granted_cback) {
+    (*nxpncihal_ctrl.p_control_granted_cback)();
+  }
+  /* At the end concurrency unlock so calls from upper layer will
+   * be allowed
+   */
+  CONCURRENCY_UNLOCK();
+  return NFCSTATUS_SUCCESS;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_request_control
+ *
+ * Description      This function can be used by HAL to request control of
+ *                  NFCC to libnfc-nci. When control is provided to HAL it is
+ *                  notified through phNxpNciHal_control_granted.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+void phNxpNciHal_request_control(void) {
+  if (nxpncihal_ctrl.p_nfc_stack_cback != NULL) {
+    /* Request Control of NCI Controller from NCI NFC Stack */
+    (*nxpncihal_ctrl.p_nfc_stack_cback)(HAL_NFC_REQUEST_CONTROL_EVT,
+                                        HAL_NFC_STATUS_OK);
+  }
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_release_control
+ *
+ * Description      This function can be used by HAL to release the control of
+ *                  NFCC back to libnfc-nci.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+void phNxpNciHal_release_control(void) {
+  if (nxpncihal_ctrl.p_nfc_stack_cback != NULL) {
+    /* Release Control of NCI Controller to NCI NFC Stack */
+    (*nxpncihal_ctrl.p_nfc_stack_cback)(HAL_NFC_RELEASE_CONTROL_EVT,
+                                        HAL_NFC_STATUS_OK);
+  }
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_power_cycle
+ *
+ * Description      This function is called by libnfc-nci when power cycling is
+ *                  performed. When processing is complete it is notified to
+ *                  libnfc-nci through phNxpNciHal_power_cycle_complete.
+ *
+ * Returns          Always return NFCSTATUS_SUCCESS (0).
+ *
+ ******************************************************************************/
+int phNxpNciHal_power_cycle(void) {
+  NXPLOG_NCIHAL_D("Power Cycle");
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  if (nxpncihal_ctrl.halStatus != HAL_STATUS_OPEN) {
+    NXPLOG_NCIHAL_D("Power Cycle failed due to hal status not open");
+    return NFCSTATUS_FAILED;
+  }
+  status = phTmlNfc_IoCtl(phTmlNfc_e_ResetDevice);
+
+  if (NFCSTATUS_SUCCESS == status) {
+    NXPLOG_NCIHAL_D("PN72xx Reset - SUCCESS\n");
+  } else {
+    NXPLOG_NCIHAL_D("PN72xx Reset - FAILED\n");
+  }
+
+  phNxpNciHal_power_cycle_complete(NFCSTATUS_SUCCESS);
+  return NFCSTATUS_SUCCESS;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_power_cycle_complete
+ *
+ * Description      This function is called to provide the status of
+ *                  phNxpNciHal_power_cycle to libnfc-nci through callback.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static void phNxpNciHal_power_cycle_complete(NFCSTATUS status) {
+  static phLibNfc_Message_t msg;
+
+  if (status == NFCSTATUS_SUCCESS) {
+    msg.eMsgType = NCI_HAL_OPEN_CPLT_MSG;
+  } else {
+    msg.eMsgType = NCI_HAL_ERROR_MSG;
+  }
+  msg.pMsgData = NULL;
+  msg.Size = 0;
+
+  phTmlNfc_DeferredCall(gpphTmlNfc_Context->dwCallbackThreadId, &msg);
+
+  return;
+}
+/******************************************************************************
+ * Function         phNxpNciHal_check_ncicmd_write_window
+ *
+ * Description      This function is called to check the write synchroniztion
+ *                  status if write already acquired then wait for corresponding
+                    read to complete.
+ *
+ * Returns          return 0 on success and -1 on fail.
+ *
+ ******************************************************************************/
+
+int phNxpNciHal_check_ncicmd_write_window(uint16_t cmd_len, uint8_t *p_cmd) {
+  UNUSED_PROP(cmd_len);
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  int sem_timedout = 2, s;
+  struct timespec ts;
+
+  if (cmd_len < 1) {
+    android_errorWriteLog(0x534e4554, "153880357");
+    return NFCSTATUS_FAILED;
+  }
+
+  if ((p_cmd[0] & 0xF0) == 0x20) {
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    ts.tv_sec += sem_timedout;
+    while ((s = sem_timedwait_monotonic_np(&nxpncihal_ctrl.syncSpiNfc, &ts)) ==
+               -1 &&
+           errno == EINTR) {
+      continue; /* Restart if interrupted by handler */
+    }
+    if (s != -1) {
+      status = NFCSTATUS_SUCCESS;
+    }
+  } else {
+    /* cmd window check not required for writing data packet */
+    status = NFCSTATUS_SUCCESS;
+  }
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_nfccClockCfgRead
+ *
+ * Description      This function is called for loading a data strcuture from
+ *                  the config file with clock source and clock frequency values
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static void phNxpNciHal_nfccClockCfgRead(void) {
+  unsigned long num = 0;
+  int isfound = 0;
+
+  nxpprofile_ctrl.bClkSrcVal = 0;
+  nxpprofile_ctrl.bClkFreqVal = 0;
+
+  isfound = GetNxpNumValue(NAME_NXP_SYS_CLK_SRC_SEL, &num, sizeof(num));
+  if (isfound > 0) {
+    nxpprofile_ctrl.bClkSrcVal = num;
+  }
+
+  num = 0;
+  isfound = 0;
+  isfound = GetNxpNumValue(NAME_NXP_SYS_CLK_FREQ_SEL, &num, sizeof(num));
+  if (isfound > 0) {
+    nxpprofile_ctrl.bClkFreqVal = num;
+  }
+
+  NXPLOG_FWDNLD_D("gphNxpNciHal_fw_IoctlCtx.bClkSrcVal = 0x%x",
+                  nxpprofile_ctrl.bClkSrcVal);
+  NXPLOG_FWDNLD_D("gphNxpNciHal_fw_IoctlCtx.bClkFreqVal = 0x%x",
+                  nxpprofile_ctrl.bClkFreqVal);
+
+  if ((nxpprofile_ctrl.bClkSrcVal < CLK_SRC_XTAL) ||
+      (nxpprofile_ctrl.bClkSrcVal > CLK_SRC_PLL)) {
+    NXPLOG_FWDNLD_E("Clock source value is wrong in config file, setting it as "
+                    "default XTAL");
+    nxpprofile_ctrl.bClkSrcVal = NXP_SYS_CLK_SRC_SEL;
+  }
+  if ((nxpprofile_ctrl.bClkFreqVal > CLK_FREQ_XTAL) ||
+      (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_RFU)) {
+    NXPLOG_FWDNLD_E(
+        "Clock frequency value is wrong in config file, setting it as default");
+    nxpprofile_ctrl.bClkFreqVal = NXP_SYS_CLK_FREQ_SEL;
+  }
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_nfccClockCfgApply
+ *
+ * Description      This function is called after successful download
+ *                  to check if clock settings in config file and chip
+ *                  is same
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static NFCSTATUS phNxpNciHal_nfccClockCfgApply(void) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  uint8_t get_clck_cmd[] = {0x20, 0x03, 0x03, 0x01, 0xA2, 0x02};
+  uint8_t set_clck_cmd[] = {0x20, 0x02, 0x0C, 0x01, 0xA2, 0x02, 0x08, 0x00,
+                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+  phNxpNciHal_nfccClockCfgRead();
+  phNxpNciClock.isClockSet = true;
+  status = phNxpNciHal_send_ext_cmd(sizeof(get_clck_cmd), get_clck_cmd);
+  phNxpNciClock.isClockSet = false;
+
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("unable to retrieve get_clk_src_sel");
+    return status;
+  }
+
+  /* Set the system frequency only if, it's missmatch with current sys clk */
+  if (nxpprofile_ctrl.bClkFreqVal != phNxpNciClock.p_rx_data[9]) {
+    /*Read the preset value from FW*/
+    memcpy(&set_clck_cmd[7], &phNxpNciClock.p_rx_data[8],
+           phNxpNciClock.p_rx_data[7]);
+    /*Update clock source and frequency as per DH configuration*/
+    set_clck_cmd[8] = nxpprofile_ctrl.bClkFreqVal;
+    status = phNxpNciHal_send_ext_cmd(sizeof(set_clck_cmd), set_clck_cmd);
+    if (status != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("Failed to set system Frequency");
+      return status;
+    }
+  }
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_get_mw_eeprom
+ *
+ * Description      This function is called to retrieve data in mw eeprom area
+ *
+ * Returns          NFCSTATUS.
+ *
+ ******************************************************************************/
+static NFCSTATUS phNxpNciHal_get_mw_eeprom(void) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  uint8_t retry_cnt = 0;
+  static uint8_t get_mw_eeprom_cmd[] = {0x20, 0x03, 0x03, 0x01, 0xA0, 0x0F};
+
+retry_send_ext:
+  if (retry_cnt > 3) {
+    return NFCSTATUS_FAILED;
+  }
+
+  phNxpNciMwEepromArea.isGetEepromArea = true;
+  status =
+      phNxpNciHal_send_ext_cmd(sizeof(get_mw_eeprom_cmd), get_mw_eeprom_cmd);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_D("unable to get the mw eeprom data");
+    phNxpNciMwEepromArea.isGetEepromArea = false;
+    retry_cnt++;
+    goto retry_send_ext;
+  }
+  phNxpNciMwEepromArea.isGetEepromArea = false;
+
+  if (phNxpNciMwEepromArea.p_rx_data[12]) {
+    fw_download_success = 1;
+  }
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_set_mw_eeprom
+ *
+ * Description      This function is called to update data in mw eeprom area
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static NFCSTATUS phNxpNciHal_set_mw_eeprom(void) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  uint8_t retry_cnt = 0;
+  uint8_t set_mw_eeprom_cmd[39] = {0};
+  uint8_t cmd_header[] = {0x20, 0x02, 0x24, 0x01, 0xA0, 0x0F, 0x20};
+
+  memcpy(set_mw_eeprom_cmd, cmd_header, sizeof(cmd_header));
+  phNxpNciMwEepromArea.p_rx_data[12] = 0;
+  memcpy(set_mw_eeprom_cmd + sizeof(cmd_header), phNxpNciMwEepromArea.p_rx_data,
+         sizeof(phNxpNciMwEepromArea.p_rx_data));
+
+retry_send_ext:
+  if (retry_cnt > 3) {
+    return NFCSTATUS_FAILED;
+  }
+
+  status =
+      phNxpNciHal_send_ext_cmd(sizeof(set_mw_eeprom_cmd), set_mw_eeprom_cmd);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_D("unable to update the mw eeprom data");
+    retry_cnt++;
+    goto retry_send_ext;
+  }
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_CheckAndHandleFwTearDown
+ *
+ * Description      Check Whether chip is in FW download mode, If chip is in
+ *                  Download mode and previous session is not complete, then
+ *                  Do force FW update.
+ *
+ * Returns          Status
+ *
+ ******************************************************************************/
+void phNxpNciHal_CheckAndHandleFwTearDown() {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  uint8_t session_state = -1;
+  unsigned long minimal_fw_version = DEFAULT_MINIMAL_FW_VERSION;
+#if (NXP_EXTNS == TRUE)
+  status = phNxpNciHal_getChipInfoInFwDnldMode(true);
+#else
+  status = phNxpNciHal_getChipInfoInFwDnldMode();
+#endif
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("Get Chip Info Failed");
+    usleep(150 * 1000);
+    return;
+  }
+  if (!GetNxpNumValue(NAME_NXP_MINIMAL_FW_VERSION, &minimal_fw_version,
+                      sizeof(minimal_fw_version))) {
+    /* If config file doesn't contain the info use default */
+    minimal_fw_version = DEFAULT_MINIMAL_FW_VERSION;
+  }
+  if (wFwVerRsp != minimal_fw_version) {
+    session_state = phNxpNciHal_getSessionInfoInFwDnldMode();
+    if (session_state == 0) {
+      NXPLOG_NCIHAL_E("NFC not in the teared state, boot NFCC in NCI mode");
+      return;
+    }
+  }
+  phTmlNfc_IoCtl(phTmlNfc_e_EnableDownloadMode);
+  if (wFwVerRsp == minimal_fw_version) {
+    /* since minimal fw required dlreset
+     * to boot in Download mode */
+    status = phNxpNciHal_dlResetInFwDnldMode();
+    if (status != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("DL Reset failed for minimal fw");
+    }
+  }
+  phTmlNfc_EnableFwDnldMode(true);
+  nxpncihal_ctrl.fwdnld_mode_reqd = TRUE;
+
+  /* Set the obtained device handle to download module */
+  phDnldNfc_SetHwDevHandle();
+  NXPLOG_NCIHAL_D("Calling Seq handler for FW Download \n");
+  status = phNxpNciHal_fw_download_seq(nxpprofile_ctrl.bClkSrcVal,
+                                       nxpprofile_ctrl.bClkFreqVal);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("FW Download Sequence Handler Failed.");
+  } else {
+    property_set("nfc.fw.force_download", "0");
+    fw_download_success = 1;
+    isFwDnldTriggered = true;
+  }
+
+  status = phNxpNciHal_dlResetInFwDnldMode();
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("DL Reset failed in FW DN mode");
+  }
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_getChipInfoInFwDnldMode
+ *
+ * Description      Helper function to get the chip info in download mode
+ *
+ * Returns          Status
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_getChipInfoInFwDnldMode(bool bIsVenResetReqd) {
+
+  uint8_t get_chip_info_cmd[] = {0x00, 0x04, 0xE1, 0x00,
+                                 0x00, 0x00, 0x75, 0x48};
+
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  int retry_cnt = 0;
+  if (bIsVenResetReqd) {
+    status = phTmlNfc_IoCtl(phTmlNfc_e_EnableVen);
+    if (status != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("Enable Download mode failed");
+      return status;
+    }
+  }
+  phTmlNfc_EnableFwDnldMode(true);
+  nxpncihal_ctrl.fwdnld_mode_reqd = TRUE;
+  do {
+    status =
+        phNxpNciHal_send_ext_cmd(sizeof(get_chip_info_cmd), get_chip_info_cmd);
+    if (status != NFCSTATUS_SUCCESS) {
+      /* break the loop if HAL write failed or response Timeout */
+      break;
+    } else {
+      /* Check FW getResponse command response status byte */
+      if (nxpncihal_ctrl.p_rx_data[0] == 0x00) {
+        if (nxpncihal_ctrl.p_rx_data[2] != 0x00) {
+          status = NFCSTATUS_FAILED;
+          if (retry_cnt < MAX_RETRY_COUNT) {
+            retry_cnt++;
+            /*reset NFCC state to avoid any failures
+             *such as DL_PROTOCOL_ERROR
+             */
+            status = phNxpNciHal_dlResetInFwDnldMode();
+            if (status != NFCSTATUS_SUCCESS) {
+              NXPLOG_NCIHAL_E("DL Reset failed in FW DN mode");
+            }
+          }
+        }
+      } else {
+        status = NFCSTATUS_FAILED;
+        break;
+      }
+    }
+  } while ((status != NFCSTATUS_SUCCESS) && (retry_cnt < MAX_RETRY_COUNT));
+
+  nxpncihal_ctrl.fwdnld_mode_reqd = FALSE;
+  phTmlNfc_EnableFwDnldMode(false);
+  if (phNxpNciHal_enableTmlRead() != NFCSTATUS_PENDING) {
+    NXPLOG_NCIHAL_E("%s read status error status", __FUNCTION__);
+  }
+  if (status == NFCSTATUS_SUCCESS) {
+    phNxpNciHal_configFeatureList(nxpncihal_ctrl.p_rx_data,
+                                  nxpncihal_ctrl.rx_data_len);
+    setNxpFwConfigPath();
+  }
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_getSessionInfoInFwDnldMode
+ *
+ * Description      Helper function to get the session info in download mode
+ *
+ * Returns          0 means session closed
+ *
+ ******************************************************************************/
+uint8_t phNxpNciHal_getSessionInfoInFwDnldMode() {
+  uint8_t session_status = -1;
+#if (NXP_EXTNS == TRUE)
+  uint8_t get_session_info_cmd[] = {0x00, 0x04, 0xDB, 0x00,
+                                    0x00, 0x00, 0x31, 0x0A};
+#else
+  uint8_t get_session_info_cmd[] = {0x00, 0x04, 0xF2, 0x00,
+                                    0x00, 0x00, 0xF5, 0x33};
+#endif
+  phTmlNfc_EnableFwDnldMode(true);
+  nxpncihal_ctrl.fwdnld_mode_reqd = TRUE;
+  NFCSTATUS status = phNxpNciHal_send_ext_cmd(sizeof(get_session_info_cmd),
+                                              get_session_info_cmd);
+  if (status == NFCSTATUS_SUCCESS) {
+    /* Check FW getResponse command response status byte */
+    if (nxpncihal_ctrl.p_rx_data[2] == 0x00 &&
+        nxpncihal_ctrl.p_rx_data[0] == 0x00) {
+      if (nxpncihal_ctrl.p_rx_data[3] == 0x00) {
+        session_status = 0;
+      }
+    } else {
+      NXPLOG_NCIHAL_D("get session info Failed !!!");
+      usleep(150 * 1000);
+    }
+  }
+  status = phNxpNciHal_dlResetInFwDnldMode();
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("DL Reset failed in FW DN mode");
+  }
+  return session_status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_dlResetInFwDnldMode
+ *
+ * Description      Helper function to change the mode from FW to NCI
+ *
+ * Returns          Status
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_dlResetInFwDnldMode() {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  phTmlNfc_EnableFwDnldMode(true);
+  nxpncihal_ctrl.fwdnld_mode_reqd = TRUE;
+  NXPLOG_NCIHAL_D("Sending DL Reset for NFCC soft reboot");
+  phDnldNfc_SetHwDevHandle();
+  if (nfcFL.chipType >= sn100u) {
+    phDnldNfc_SetI2CFragmentLength(NCI_CMDRESP_MAX_BUFF_SIZE_SNXXX);
+  } else {
+    phDnldNfc_SetI2CFragmentLength(NCI_CMDRESP_MAX_BUFF_SIZE_PN557);
+  }
+
+  status = phNxpNciHal_fw_dnld_switch_normal_mode();
+
+  nxpncihal_ctrl.fwdnld_mode_reqd = FALSE;
+  phTmlNfc_EnableFwDnldMode(false);
+  phDnldNfc_ReSetHwDevHandle();
+  if (phNxpNciHal_enableTmlRead() != NFCSTATUS_PENDING) {
+    NXPLOG_NCIHAL_E("%s read status error status", __FUNCTION__);
+    status = NFCSTATUS_FAILED;
+  }
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_nfcc_core_reset_init
+ *
+ * Description      Helper function to do nfcc core reset & core init
+ *
+ * Returns          Status
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_nfcc_core_reset_init(bool keep_config) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  uint8_t retry_cnt = 0;
+  uint8_t cmd_reset_nci[] = {0x20, 0x00, 0x01, 0x01};
+
+  if (keep_config) {
+    cmd_reset_nci[3] = 0x00;
+  }
+retry_core_reset:
+  status = phNxpNciHal_send_ext_cmd(sizeof(cmd_reset_nci), cmd_reset_nci);
+  if ((status != NFCSTATUS_SUCCESS) && (retry_cnt < 3)) {
+    NXPLOG_NCIHAL_D("Retry: NCI_CORE_RESET");
+    retry_cnt++;
+    goto retry_core_reset;
+  } else if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("NCI_CORE_RESET failed!!!\n");
+    return status;
+  }
+
+  retry_cnt = 0;
+  uint8_t cmd_init_nci[] = {0x20, 0x01, 0x00};
+  uint8_t cmd_init_nci2_0[] = {0x20, 0x01, 0x02, 0x00, 0x00};
+retry_core_init:
+  if (nxpncihal_ctrl.nci_info.nci_version == NCI_VERSION_2_0) {
+    status = phNxpNciHal_send_ext_cmd(sizeof(cmd_init_nci2_0), cmd_init_nci2_0);
+  } else {
+    status = phNxpNciHal_send_ext_cmd(sizeof(cmd_init_nci), cmd_init_nci);
+  }
+
+  if ((status != NFCSTATUS_SUCCESS) && (retry_cnt < 3)) {
+    NXPLOG_NCIHAL_D("Retry: NCI_CORE_INIT\n");
+    retry_cnt++;
+    goto retry_core_init;
+  } else if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("NCI_CORE_INIT failed!!!\n");
+    return status;
+  }
+
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_resetDefaultSettings
+ *
+ * Description      Helper function to do nfcc core reset, core init
+ *                  (if previously firmware update was triggered) and
+ *                  apply default NFC settings
+ *
+ * Returns          Status
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_resetDefaultSettings(uint8_t fw_update_req,
+                                           bool keep_config) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  if (fw_update_req) {
+    status = phNxpNciHal_nfcc_core_reset_init(keep_config);
+  }
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_do_factory_reset
+ *
+ * Description      This function is called during factory reset to clear/reset
+ *                  nfc sub-system persistent data.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+void phNxpNciHal_do_factory_reset(void) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  if (nxpncihal_ctrl.halStatus == HAL_STATUS_CLOSE) {
+    status = phNxpNciHal_MinOpen();
+    if (status != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("%s: NXP Nfc Open failed", __func__);
+      return;
+    }
+  }
+}
+/******************************************************************************
+ * Function         phNxpNciHal_print_res_status
+ *
+ * Description      This function is called to process the response status
+ *                  and print the status byte.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static void phNxpNciHal_print_res_status(uint8_t *p_rx_data, uint16_t *p_len) {
+  static uint8_t response_buf[][30] = {"STATUS_OK",
+                                       "STATUS_REJECTED",
+                                       "STATUS_RF_FRAME_CORRUPTED",
+                                       "STATUS_FAILED",
+                                       "STATUS_NOT_INITIALIZED",
+                                       "STATUS_SYNTAX_ERROR",
+                                       "STATUS_SEMANTIC_ERROR",
+                                       "RFU",
+                                       "RFU",
+                                       "STATUS_INVALID_PARAM",
+                                       "STATUS_MESSAGE_SIZE_EXCEEDED",
+                                       "STATUS_UNDEFINED"};
+  int status_byte;
+  if (p_rx_data[0] == 0x40 && (p_rx_data[1] == 0x02 || p_rx_data[1] == 0x03)) {
+    if (p_rx_data[2] && p_rx_data[3] <= 10) {
+      status_byte = p_rx_data[CORE_RES_STATUS_BYTE];
+      NXPLOG_NCIHAL_D("%s: response status =%s", __func__,
+                      response_buf[status_byte]);
+    } else {
+      NXPLOG_NCIHAL_D("%s: response status =%s", __func__, response_buf[11]);
+    }
+    if (phNxpNciClock.isClockSet) {
+      int i, len = sizeof(phNxpNciClock.p_rx_data);
+      if (*p_len > len) {
+        android_errorWriteLog(0x534e4554, "169257710");
+      } else {
+        len = *p_len;
+      }
+      for (i = 0; i < len; i++) {
+        phNxpNciClock.p_rx_data[i] = p_rx_data[i];
+      }
+    }
+
+    else if (phNxpNciRfSet.isGetRfSetting) {
+      int i, len = sizeof(phNxpNciRfSet.p_rx_data);
+      if (*p_len > len) {
+        android_errorWriteLog(0x534e4554, "169258733");
+      } else {
+        len = *p_len;
+      }
+      for (i = 0; i < len; i++) {
+        phNxpNciRfSet.p_rx_data[i] = p_rx_data[i];
+        // NXPLOG_NCIHAL_D("%s: response status =0x%x",__func__,p_rx_data[i]);
+      }
+    } else if (phNxpNciMwEepromArea.isGetEepromArea) {
+      int i, len = sizeof(phNxpNciMwEepromArea.p_rx_data) + 8;
+      if (*p_len > len) {
+        android_errorWriteLog(0x534e4554, "169258884");
+      } else {
+        len = *p_len;
+      }
+      for (i = 8; i < len; i++) {
+        phNxpNciMwEepromArea.p_rx_data[i - 8] = p_rx_data[i];
+      }
+    } else if (nxpncihal_ctrl.phNxpNciGpioInfo.state == GPIO_STORE) {
+      NXPLOG_NCIHAL_D("%s: Storing GPIO Values...", __func__);
+      nxpncihal_ctrl.phNxpNciGpioInfo.values[0] = p_rx_data[9];
+      nxpncihal_ctrl.phNxpNciGpioInfo.values[1] = p_rx_data[8];
+    } else if (nxpncihal_ctrl.phNxpNciGpioInfo.state == GPIO_RESTORE) {
+      NXPLOG_NCIHAL_D("%s: Restoring GPIO Values...", __func__);
+      nxpncihal_ctrl.phNxpNciGpioInfo.values[0] = p_rx_data[9];
+      nxpncihal_ctrl.phNxpNciGpioInfo.values[1] = p_rx_data[8];
+    }
+  }
+
+  if (p_rx_data[2] && (config_access == true)) {
+    if (p_rx_data[3] != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_W("Invalid Data from config file.");
+      config_success = false;
+    }
+  }
+}
+/******************************************************************************
+ * Function         phNxpNciHal_initialize_mifare_flag
+ *
+ * Description      This function gets the value for Mfc flags.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phNxpNciHal_initialize_mifare_flag() {
+  unsigned long num = 0;
+  bEnableMfcReader = false;
+  bDisableLegacyMfcExtns = true;
+  // 1: Enable Mifare Classic protocol in RF Discovery.
+  // 0: Remove Mifare Classic protocol in RF Discovery.
+  if (GetNxpNumValue(NAME_MIFARE_READER_ENABLE, &num, sizeof(num))) {
+    bEnableMfcReader = (num == 0) ? false : true;
+  }
+  // 1: Use legacy JNI MFC extns.
+  // 0: Disable legacy JNI MFC extns, use hal MFC Extns instead.
+  if (GetNxpNumValue(NAME_LEGACY_MIFARE_READER, &num, sizeof(num))) {
+    bDisableLegacyMfcExtns = (num == 0) ? true : false;
+  }
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_configFeatureList
+**
+** Description      Configures the featureList based on chip type &
+**                  Configure fragmentation length based on chip type.
+**                  HW Version information number will provide chipType.
+**                  HW Version can be obtained from CORE_INIT_RESPONSE(NCI 1.0)
+**                  or CORE_RST_NTF(NCI 2.0)
+**
+** Parameters       CORE_INIT_RESPONSE/CORE_RST_NTF, len
+**
+** Returns          none
+*******************************************************************************/
+void phNxpNciHal_configFeatureList(uint8_t *init_rsp, uint16_t rsp_len) {
+  nxpncihal_ctrl.chipType = pConfigFL->processChipType(init_rsp, rsp_len);
+  tNFC_chipType chipType = nxpncihal_ctrl.chipType;
+  NXPLOG_NCIHAL_D("phNxpNciHal_configFeatureList ()chipType = %d", chipType);
+  CONFIGURE_FEATURELIST(chipType);
+  /* update fragment len based on the chip type.*/
+  phTmlNfc_IoCtl(phTmlNfc_e_setFragmentSize);
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_UpdateFwStatus
+**
+** Description      It shall be called to update the FW download status to the
+**                  libnfc-nci.
+**
+** Parameters       fwStatus: FW update status
+**
+** Returns          void
+*******************************************************************************/
+static void phNxpNciHal_UpdateFwStatus(HalNfcFwUpdateStatus fwStatus) {
+  static phLibNfc_Message_t msg;
+  static uint8_t status;
+  NXPLOG_NCIHAL_D("phNxpNciHal_UpdateFwStatus Enter");
+
+  status = (uint8_t)fwStatus;
+  msg.eMsgType = HAL_NFC_FW_UPDATE_STATUS_EVT;
+  msg.pMsgData = &status;
+  msg.Size = sizeof(status);
+  phTmlNfc_DeferredCall(gpphTmlNfc_Context->dwCallbackThreadId,
+                        (phLibNfc_Message_t *)&msg);
+  return;
+}
diff --git a/pn72xx/halimpl/hal/phNxpNciHal.h b/pn72xx/halimpl/hal/phNxpNciHal.h
new file mode 100644
index 00000000..c1f59857
--- /dev/null
+++ b/pn72xx/halimpl/hal/phNxpNciHal.h
@@ -0,0 +1,414 @@
+/*
+ * Copyright 2010-2021,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef _PHNXPNCIHAL_H_
+#define _PHNXPNCIHAL_H_
+
+#include "NxpMfcReader.h"
+#include "NxpNfcCapability.h"
+#include "phNxpNciHal_IoctlOperations.h"
+#include <hardware/nfc.h>
+#include <phNxpNciHal_utils.h>
+
+#include <vendor/nxp/nxpnfc/2.0/types.h>
+
+/********************* Definitions and structures *****************************/
+#define MAX_RETRY_COUNT 5
+#define NCI_MAX_DATA_LEN 300
+#define NCI_POLL_DURATION 500
+#define HAL_NFC_ENABLE_I2C_FRAGMENTATION_EVT 0x07
+#undef P2P_PRIO_LOGIC_HAL_IMP
+#define NCI_VERSION_2_0 0x20
+#define NCI_VERSION_1_1 0x11
+#define NCI_VERSION_1_0 0x10
+#define NCI_VERSION_UNKNOWN 0x00
+#define NXP_AUTH_TIMEOUT_BUF_LEN 0x04
+#define SN1XX_ROM_VERSION 0x01
+#define SN1XX_FW_MAJOR_VERSION 0x10
+#define SN2XX_ROM_VERSION 0x01
+#define SN2XX_FW_MAJOR_VERSION 0x01
+
+/*Mem alloc with 8 byte alignment*/
+#define size_align(sz) ((((sz)-1) | 7) + 1)
+#define nxp_malloc(size) malloc(size_align((size)))
+
+typedef void(phNxpNciHal_control_granted_callback_t)();
+
+/*ROM CODE VERSION FW*/
+#define FW_MOBILE_ROM_VERSION_PN551 0x10
+#define FW_MOBILE_ROM_VERSION_PN553 0x11
+#define FW_MOBILE_ROM_VERSION_PN557 0x12
+#define FW_MOBILE_ROM_VERSION_PN7720 0x03
+#define NCI_CMDRESP_MAX_BUFF_SIZE_SNXXX (0x22AU)
+#define NCI_CMDRESP_MAX_BUFF_SIZE_PN557 (0x102U)
+
+#define FW_DBG_REASON_AVAILABLE (0xA3)
+
+#define HOST_ID 0x00
+#define ESE_ID 0x01
+#define UICC1_ID 0x02
+#define UICC2_ID 0x04
+#define UICC3_ID 0x08
+/* NCI Data */
+
+//#define NCI_MT_CMD 0x20
+//#define NCI_MT_RSP 0x40
+//#define NCI_MT_NTF 0x60
+
+#define CORE_RESET_TRIGGER_TYPE_CORE_RESET_CMD_RECEIVED 0x02
+#define CORE_RESET_TRIGGER_TYPE_POWERED_ON 0x01
+#define CORE_RESET_TRIGGER_TYPE_MODE_SWITCH_TO_NFC_FORUM 0xA8
+#define CORE_RESET_TRIGGER_TYPE_MODE_SWITCH_TO_EMVCO 0xA9
+#define NCI2_0_CORE_RESET_TRIGGER_TYPE_OVER_TEMPERATURE ((uint8_t)0xA1)
+#define CORE_RESET_TRIGGER_TYPE_UNRECOVERABLE_ERROR 0x00
+#define CORE_RESET_TRIGGER_TYPE_FW_ASSERT ((uint8_t)0xA0)
+#define CORE_RESET_TRIGGER_TYPE_WATCHDOG_RESET ((uint8_t)0xA3)
+#define CORE_RESET_TRIGGER_TYPE_INPUT_CLOCK_LOST ((uint8_t)0xA4)
+//#define NCI_MSG_CORE_RESET           0x00
+//#define NCI_MSG_CORE_INIT            0x01
+#define NCI_MT_MASK 0xE0
+#define NCI_OID_MASK 0x3F
+#if (NXP_EXTNS == TRUE)
+/* GID: Group Identifier (byte 0) */
+#define NCI_GID_MASK 0x0F
+#define ORIG_NXPHAL 0x01
+#define ORIG_LIBNFC 0x02
+#endif
+#define NXP_PROPCMD_GID 0x2F
+#define NXP_FLUSH_SRAM_AO_TO_FLASH 0x21
+#define NXP_CORE_GET_CONFIG_CMD 0x03
+#define NXP_CORE_SET_CONFIG_CMD 0x02
+#define NXP_MAX_CONFIG_STRING_LEN 260
+#define NCI_HEADER_SIZE 3
+
+typedef struct nci_data {
+  uint16_t len;
+  uint8_t p_data[NCI_MAX_DATA_LEN];
+} nci_data_t;
+
+typedef enum {
+  HAL_STATUS_CLOSE = 0,
+  HAL_STATUS_OPEN,
+  HAL_STATUS_MIN_OPEN
+} phNxpNci_HalStatus;
+
+typedef enum {
+  HAL_NFC_FW_UPDATE_INVALID = 0x00,
+  HAL_NFC_FW_UPDATE_START,
+  HAL_NFC_FW_UPDATE_SCUCCESS,
+  HAL_NFC_FW_UPDATE_FAILED,
+} HalNfcFwUpdateStatus;
+
+typedef enum {
+  GPIO_UNKNOWN = 0x00,
+  GPIO_STORE = 0x01,
+  GPIO_STORE_DONE = 0x02,
+  GPIO_RESTORE = 0x10,
+  GPIO_RESTORE_DONE = 0x20,
+  GPIO_CLEAR = 0xFF
+} phNxpNciHal_GpioInfoState;
+#ifdef NXP_BOOTTIME_UPDATE
+extern ese_update_state_t ese_update;
+#endif
+typedef struct phNxpNciGpioInfo {
+  phNxpNciHal_GpioInfoState state;
+  uint8_t values[2];
+} phNxpNciGpioInfo_t;
+
+/* Macros to enable and disable extensions */
+#define HAL_ENABLE_EXT() (nxpncihal_ctrl.hal_ext_enabled = 1)
+#define HAL_DISABLE_EXT() (nxpncihal_ctrl.hal_ext_enabled = 0)
+typedef struct phNxpNciInfo {
+  uint8_t nci_version;
+  bool_t wait_for_ntf;
+  uint8_t lastResetNtfReason;
+} phNxpNciInfo_t;
+/* NCI Control structure */
+typedef struct phNxpNciHal_Control {
+  phNxpNci_HalStatus halStatus; /* Indicate if hal is open or closed */
+  pthread_t client_thread;      /* Integration thread handle */
+  uint8_t thread_running;       /* Thread running if set to 1, else set to 0 */
+  phLibNfc_sConfig_t gDrvCfg;   /* Driver config data */
+
+  /* Rx data */
+  uint8_t *p_rx_data;
+  uint16_t rx_data_len;
+
+  /* Rx data */
+  uint8_t *p_rx_ese_data;
+  uint16_t rx_ese_data_len;
+
+  /* libnfc-nci callbacks */
+  nfc_stack_callback_t *p_nfc_stack_cback;
+  nfc_stack_data_callback_t *p_nfc_stack_data_cback;
+
+  /* control granted callback */
+  phNxpNciHal_control_granted_callback_t *p_control_granted_cback;
+
+  /* HAL open status */
+  bool_t hal_open_status;
+
+  /* HAL extensions */
+  uint8_t hal_ext_enabled;
+
+  /* Waiting semaphore */
+  phNxpNciHal_Sem_t ext_cb_data;
+  sem_t syncSpiNfc;
+
+  uint16_t cmd_len;
+  uint8_t p_cmd_data[NCI_MAX_DATA_LEN];
+  uint16_t rsp_len;
+  uint8_t p_rsp_data[NCI_MAX_DATA_LEN];
+
+  /* retry count used to force download */
+  uint16_t retry_cnt;
+  uint8_t read_retry_cnt;
+  phNxpNciInfo_t nci_info;
+  uint8_t hal_boot_mode;
+  bool_t fwdnld_mode_reqd;
+  /* to store and restore gpio values */
+  phNxpNciGpioInfo_t phNxpNciGpioInfo;
+  tNFC_chipType chipType;
+} phNxpNciHal_Control_t;
+
+typedef struct {
+  uint8_t fw_update_reqd;
+  uint8_t rf_update_reqd;
+} phNxpNciHal_FwRfupdateInfo_t;
+
+typedef struct phNxpNciClock {
+  bool_t isClockSet;
+  uint8_t p_rx_data[20];
+  bool_t issetConfig;
+} phNxpNciClock_t;
+
+typedef struct phNxpNciRfSetting {
+  bool_t isGetRfSetting;
+  uint8_t p_rx_data[20];
+} phNxpNciRfSetting_t;
+
+typedef struct phNxpNciMwEepromArea {
+  bool_t isGetEepromArea;
+  uint8_t p_rx_data[32];
+} phNxpNciMwEepromArea_t;
+
+enum { SE_TYPE_ESE, SE_TYPE_UICC, SE_TYPE_UICC2, NUM_SE_TYPES };
+
+typedef void (*fpVerInfoStoreInEeprom_t)();
+typedef int (*fpVerifyCscEfsTest_t)(char *nfcc_csc, char *rffilepath,
+                                    char *fwfilepath);
+typedef int (*fpRegRfFwDndl_t)(uint8_t *fw_update_req, uint8_t *rf_update_req,
+                               uint8_t skipEEPROMRead);
+typedef int (*fpPropConfCover_t)(bool attached, int type);
+void phNxpNciHal_initializeRegRfFwDnld();
+void phNxpNciHal_deinitializeRegRfFwDnld();
+/*set config management*/
+
+#define TOTAL_DURATION 0x00
+#define ATR_REQ_GEN_BYTES_POLL 0x29
+#define ATR_REQ_GEN_BYTES_LIS 0x61
+#define LEN_WT 0x60
+
+/*PN557 Ven Pin Configuration*/
+
+#define PN557_VEN_CFG_VALUE 0x01
+#define PN557_VEN_CFG_PULLDOWN 0x02
+#define PN557_VEN_CFG_DEFAULT 0x03
+
+/*Whenever a new get cfg need to be sent,
+ * array must be updated with defined config type*/
+static const uint8_t get_cfg_arr[] = {TOTAL_DURATION, ATR_REQ_GEN_BYTES_POLL,
+                                      ATR_REQ_GEN_BYTES_LIS, LEN_WT};
+
+//#define NXP_NFC_SET_CONFIG_PARAM_EXT 0xA0
+//#define NXP_NFC_PARAM_ID_SWP2        0xD4
+//#define NXP_NFC_PARAM_ID_SWPUICC3    0xDC
+typedef enum {
+  EEPROM_RF_CFG,
+  EEPROM_FW_DWNLD,
+  EEPROM_WIREDMODE_RESUME_TIMEOUT,
+  EEPROM_ESE_SVDD_POWER,
+  EEPROM_ESE_POWER_EXT_PMU,
+  EEPROM_PROP_ROUTING,
+  EEPROM_ESE_SESSION_ID,
+  EEPROM_SWP1_INTF,
+  EEPROM_SWP1A_INTF,
+  EEPROM_SWP2_INTF,
+  EEPROM_FLASH_UPDATE,
+  EEPROM_AUTH_CMD_TIMEOUT,
+  EEPROM_GUARD_TIMER,
+  EEPROM_T4T_NFCEE_ENABLE,
+  EEPROM_AUTONOMOUS_MODE,
+  EEPROM_CE_PHONE_OFF_CFG,
+  EEPROM_ENABLE_VEN_CFG,
+  EEPROM_ISODEP_MERGE_SAK,
+  EEPROM_SRD_TIMEOUT,
+  EEPROM_UICC1_SESSION_ID,
+  EEPROM_UICC2_SESSION_ID,
+  EEPROM_CE_ACT_NTF,
+  EEPROM_UICC_HCI_CE_STATE,
+  EEPROM_EXT_FIELD_DETECT_MODE
+} phNxpNci_EEPROM_request_type_t;
+
+typedef struct phNxpNci_EEPROM_info {
+  uint8_t request_mode;
+  phNxpNci_EEPROM_request_type_t request_type;
+  uint8_t update_mode;
+  uint8_t *buffer;
+  uint8_t bufflen;
+} phNxpNci_EEPROM_info_t;
+
+typedef struct phNxpNci_getCfg_info {
+  bool_t isGetcfg;
+  uint8_t total_duration[4];
+  uint8_t total_duration_len;
+  uint8_t atr_req_gen_bytes[48];
+  uint8_t atr_req_gen_bytes_len;
+  uint8_t atr_res_gen_bytes[48];
+  uint8_t atr_res_gen_bytes_len;
+  uint8_t pmid_wt[3];
+  uint8_t pmid_wt_len;
+  uint8_t auth_cmd_timeout[NXP_AUTH_TIMEOUT_BUF_LEN];
+  uint8_t auth_cmd_timeoutlen;
+} phNxpNci_getCfg_info_t;
+typedef enum {
+  NFC_FORUM_PROFILE,
+  EMV_CO_PROFILE,
+  SRD_PROFILE,
+  INVALID_PROFILe
+} phNxpNciProfile_t;
+/* NXP Poll Profile control structure */
+typedef struct phNxpNciProfile_Control {
+  phNxpNciProfile_t profile_type;
+  uint8_t bClkSrcVal; /* Holds the System clock source read from config file */
+  uint8_t
+      bClkFreqVal; /* Holds the System clock frequency read from config file */
+} phNxpNciProfile_Control_t;
+
+/* Internal messages to handle callbacks */
+#define NCI_HAL_OPEN_CPLT_MSG 0x411
+#define NCI_HAL_CLOSE_CPLT_MSG 0x412
+#define NCI_HAL_POST_INIT_CPLT_MSG 0x413
+#define NCI_HAL_PRE_DISCOVER_CPLT_MSG 0x414
+#define NCI_HAL_ERROR_MSG 0x415
+#define NCI_HAL_HCI_NETWORK_RESET_MSG 0x416
+#define NCI_HAL_RX_MSG 0xF01
+#define HAL_NFC_FW_UPDATE_STATUS_EVT 0x0A
+
+#define NCIHAL_CMD_CODE_LEN_BYTE_OFFSET (2U)
+#define NCIHAL_CMD_CODE_BYTE_LEN (3U)
+
+/******************** NCI HAL exposed functions *******************************/
+int phNxpNciHal_check_ncicmd_write_window(uint16_t cmd_len, uint8_t *p_cmd);
+void phNxpNciHal_request_control(void);
+void phNxpNciHal_release_control(void);
+int phNxpNciHal_write_unlocked(uint16_t data_len, const uint8_t *p_data,
+                               int origin);
+NFCSTATUS request_EEPROM(phNxpNci_EEPROM_info_t *mEEPROM_info);
+int phNxpNciHal_check_config_parameter();
+NFCSTATUS phNxpNciHal_fw_download(uint8_t seq_handler_offset = 0,
+                                  bool bIsNfccDlState = false);
+NFCSTATUS phNxpNciHal_nfcc_core_reset_init(bool keep_config = false);
+int phNxpNciHal_fw_mw_ver_check();
+NFCSTATUS phNxpNciHal_check_clock_config(void);
+NFCSTATUS phNxpNciHal_CheckValidFwVersion(void);
+
+NFCSTATUS phNxpNciHal_send_nfcee_pwr_cntl_cmd(uint8_t type);
+/*******************************************************************************
+**
+** Function         phNxpNciHal_configFeatureList
+**
+** Description      Configures the featureList based on chip type
+**                  HW Version information number will provide chipType.
+**                  HW Version can be obtained from CORE_INIT_RESPONSE(NCI 1.0)
+**                  or CORE_RST_NTF(NCI 2.0)
+**
+** Parameters       CORE_INIT_RESPONSE/CORE_RST_NTF, len
+**
+** Returns          none
+*******************************************************************************/
+void phNxpNciHal_configFeatureList(uint8_t *init_rsp, uint16_t rsp_len);
+
+/******************************************************************************
+ * Function         phNxpNciHal_read_and_update_se_state
+ *
+ * Description      This will read NFCEE status from system properties
+ *                  and update to NFCC to enable/disable.
+ *
+ * Returns          none
+ *
+ ******************************************************************************/
+void phNxpNciHal_read_and_update_se_state();
+
+/******************************************************************************
+ * Function         phNxpNciHal_Abort
+ *
+ * Description      This will post the message to the upper layer
+ *                  using the callback p_nfc_stack_cback_backup.
+ *
+ * Returns          none
+ *
+ ******************************************************************************/
+extern bool phNxpNciHal_Abort();
+/******************************************************************************
+ * Function         phNxpNciHal_read_fw_dw_status
+ *
+ * Description      This will read the value of fw download status flag
+ *                  from eeprom
+ *
+ * Parameters       value - this parameter will be updated with the flag
+ *                  value from eeprom.
+ *
+ * Returns          status of the read
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_read_fw_dw_status(uint8_t &value);
+
+/******************************************************************************
+ * Function         phNxpNciHal_write_fw_dw_status
+ *
+ * Description      This will update value of fw download status flag
+ *                  to eeprom
+ *
+ * Parameters       value - this value will be updated to eeprom flag.
+ *
+ * Returns          status of the write
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_write_fw_dw_status(uint8_t value);
+
+/******************************************************************************
+ * Function         phNxpNciHal_save_uicc_params
+ *
+ * Description      This will read the UICC HCI param values
+ *                  from eeprom and store in global variable
+ *
+ * Returns          status of the read
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_save_uicc_params();
+
+/******************************************************************************
+ * Function         phNxpNciHal_restore_uicc_params
+ *
+ * Description      This will set the UICC HCI param values
+ *                  back to eeprom from global variable
+ *
+ * Returns          status of the read
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_restore_uicc_params();
+
+#endif /* _PHNXPNCIHAL_H_ */
diff --git a/pn72xx/halimpl/hal/phNxpNciHal_IoctlOperations.cc b/pn72xx/halimpl/hal/phNxpNciHal_IoctlOperations.cc
new file mode 100755
index 00000000..31dbe39b
--- /dev/null
+++ b/pn72xx/halimpl/hal/phNxpNciHal_IoctlOperations.cc
@@ -0,0 +1,661 @@
+/*
+ * Copyright 2019-2021,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "phNxpNciHal_IoctlOperations.h"
+#include "NfccTransport.h"
+#include "NfccTransportFactory.h"
+#include "phDnldNfc_Internal.h"
+#include "phNfcCommon.h"
+#include "phNxpNciHal_Adaptation.h"
+#include "phNxpNciHal_ext.h"
+#include "phNxpNciHal_extOperations.h"
+#include "phNxpNciHal_utils.h"
+#include <android-base/file.h>
+#include <android-base/parseint.h>
+#include <android-base/strings.h>
+#include <map>
+#include <set>
+
+using android::base::WriteStringToFile;
+using namespace ::std;
+using namespace ::android::base;
+
+#define TERMINAL_LEN 5
+/* HAL_NFC_STATUS_REFUSED sent to restart NFC service */
+#define HAL_NFC_STATUS_RESTART HAL_NFC_STATUS_REFUSED
+
+/****************************************************************
+ * Global Variables Declaration
+ ***************************************************************/
+/* External global variable to get FW version from NCI response*/
+extern uint32_t wFwVerRsp;
+/* External global variable to get FW version from FW file*/
+extern uint16_t wFwVer;
+/* NCI HAL Control structure */
+extern phNxpNciHal_Control_t nxpncihal_ctrl;
+extern phNxpNci_getCfg_info_t *mGetCfg_info;
+extern nfc_stack_callback_t *p_nfc_stack_cback_backup;
+#ifndef FW_DWNLD_FLAG
+extern uint8_t fw_dwnld_flag;
+#endif
+
+/* TML Context */
+extern phTmlNfc_Context_t *gpphTmlNfc_Context;
+extern bool nfc_debug_enabled;
+extern NFCSTATUS phNxpLog_EnableDisableLogLevel(uint8_t enable);
+extern phNxpNciClock_t phNxpNciClock;
+
+/*******************************************************************************
+ **
+ ** Function:        property_get_intf()
+ **
+ ** Description:     Gets property value for the input property name
+ **
+ ** Parameters       propName:   Name of the property whichs value need to get
+ **                  valueStr:   output value of the property.
+ **                  defaultStr: default value of the property if value is not
+ **                              there this will be set to output value.
+ **
+ ** Returns:         actual length of the property value
+ **
+ ********************************************************************************/
+int property_get_intf(const char *propName, char *valueStr,
+                      const char *defaultStr) {
+  string paramPropName = propName;
+  string propValue;
+  string propValueDefault = defaultStr;
+  int len = 0;
+
+  propValue = phNxpNciHal_getSystemProperty(paramPropName);
+  if (propValue.length() > 0) {
+    NXPLOG_NCIHAL_D("property_get_intf , key[%s], propValue[%s], length[%zu]",
+                    propName, propValue.c_str(), propValue.length());
+    len = propValue.length();
+    strlcpy(valueStr, propValue.c_str(), PROPERTY_VALUE_MAX);
+  } else {
+    if (propValueDefault.length() > 0) {
+      len = propValueDefault.length();
+      strlcpy(valueStr, propValueDefault.c_str(), PROPERTY_VALUE_MAX);
+    }
+  }
+
+  return len;
+}
+
+/*******************************************************************************
+ **
+ ** Function:        property_set_intf()
+ **
+ ** Description:     Sets property value for the input property name
+ **
+ ** Parameters       propName:   Name of the property whichs value need to set
+ **                  valueStr:   value of the property.
+ **
+ ** Returns:        returns 0 on success, < 0 on failure
+ **
+ ********************************************************************************/
+int property_set_intf(const char *propName, const char *valueStr) {
+  string paramPropName = propName;
+  string propValue = valueStr;
+  NXPLOG_NCIHAL_D("property_set_intf, key[%s], value[%s]", propName, valueStr);
+  if (phNxpNciHal_setSystemProperty(paramPropName, propValue))
+    return NFCSTATUS_SUCCESS;
+  else
+    return NFCSTATUS_FAILED;
+}
+
+extern size_t readConfigFile(const char *fileName, uint8_t **p_data);
+
+static string phNxpNciHal_parseBytesString(string in);
+static bool phNxpNciHal_parseValueFromString(string &in);
+static bool phNxpNciHal_CheckKeyNeeded(string key);
+static string phNxpNciHal_UpdatePwrStateConfigs(string &config);
+static bool phNxpNciHal_IsAutonmousModeSet(string config);
+static string phNxpNciHal_extractConfig(string &config);
+static void phNxpNciHal_getFilteredConfig(string &config);
+
+typedef std::map<std::string, std::string> systemProperty;
+systemProperty gsystemProperty = {
+    {"nfc.nxp_log_level_global", ""},
+    {"nfc.nxp_log_level_extns", ""},
+    {"nfc.nxp_log_level_hal", ""},
+    {"nfc.nxp_log_level_nci", ""},
+    {"nfc.nxp_log_level_dnld", ""},
+    {"nfc.nxp_log_level_tml", ""},
+    {"nfc.fw.dfl", ""},
+    {"nfc.fw.downloadmode_force", ""},
+    {"nfc.debug_enabled", ""},
+    {"nfc.product.support.ese", ""},
+    {"nfc.product.support.uicc", ""},
+    {"nfc.product.support.uicc2", ""},
+    {"nfc.fw.rfreg_ver", ""},
+    {"nfc.fw.rfreg_display_ver", ""},
+    {"nfc.fw.dfl_areacode", ""},
+    {"nfc.cover.cover_id", ""},
+    {"nfc.cover.state", ""},
+};
+const char default_nxp_config_path[] = "/vendor/etc/libnfc-nxp.conf";
+std::set<string> gNciConfigs = {"NXP_SE_COLD_TEMP_ERROR_DELAY",
+                                "NXP_SWP_RD_TAG_OP_TIMEOUT",
+                                "NXP_DUAL_UICC_ENABLE",
+                                "DEFAULT_AID_ROUTE",
+                                "DEFAULT_MIFARE_CLT_ROUTE",
+                                "DEFAULT_FELICA_CLT_ROUTE",
+                                "DEFAULT_AID_PWR_STATE",
+                                "DEFAULT_DESFIRE_PWR_STATE",
+                                "DEFAULT_MIFARE_CLT_PWR_STATE",
+                                "DEFAULT_FELICA_CLT_PWR_STATE",
+                                "HOST_LISTEN_TECH_MASK",
+                                "FORWARD_FUNCTIONALITY_ENABLE",
+                                "DEFAULT_GSMA_PWR_STATE",
+                                "NXP_DEFAULT_UICC2_SELECT",
+                                "NXP_SMB_TRANSCEIVE_TIMEOUT",
+                                "NXP_SMB_ERROR_RETRY",
+                                "NXP_CHECK_DEFAULT_PROTO_SE_ID",
+                                "NXPLOG_NCIHAL_LOGLEVEL",
+                                "NXPLOG_EXTNS_LOGLEVEL",
+                                "NXPLOG_TML_LOGLEVEL",
+                                "NXPLOG_FWDNLD_LOGLEVEL",
+                                "NXPLOG_NCIX_LOGLEVEL",
+                                "NXPLOG_NCIR_LOGLEVEL",
+                                "NXP_NFC_SE_TERMINAL_NUM",
+                                "NXP_POLL_FOR_EFD_TIMEDELAY",
+                                "NXP_NFCC_MERGE_SAK_ENABLE",
+                                "NXP_STAG_TIMEOUT_CFG",
+                                "DEFAULT_T4TNFCEE_AID_POWER_STATE",
+                                "RF_STORAGE",
+                                "FW_STORAGE",
+                                "NXP_CORE_CONF",
+                                "NXP_RF_FILE_VERSION_INFO",
+                                "NXP_AUTONOMOUS_ENABLE",
+                                "NXP_PROP_RESET_EMVCO_CMD",
+                                "NFA_CONFIG_FORMAT",
+                                "NXP_T4T_NFCEE_ENABLE",
+                                "NXP_DISCONNECT_TAG_IN_SCRN_OFF",
+                                "NXP_RDR_REQ_GUARD_TIME",
+                                "OFF_HOST_SIM2_PIPE_ID",
+                                "NXP_ENABLE_DISABLE_LOGS",
+                                "NXP_RDR_DISABLE_ENABLE_LPCD",
+                                "NXP_SUPPORT_NON_STD_CARD",
+                                "NXP_GET_HW_INFO_LOG",
+                                "NXP_WLC_MODE",
+                                "NXP_T4T_NDEF_NFCEE_AID",
+                                "NXP_NON_STD_CARD_TIMEDIFF",
+                                "NXP_SRD_TIMEOUT",
+                                "NXP_UICC_ETSI_SUPPORT",
+                                "NXP_MINIMAL_FW_VERSION",
+                                "NXP_P2P_DISC_NTF_TIMEOUT",
+                                "NXP_RESTART_RF_FOR_NFCEE_RECOVERY",
+                                "NXP_NFCC_RECOVERY_SUPPORT",
+                                "NXP_AGC_DEBUG_ENABLE",
+                                "NXP_EXTENDED_FIELD_DETECT_MODE"};
+
+/****************************************************************
+ * Local Functions
+ ***************************************************************/
+
+/*******************************************************************************
+ **
+ ** Function         phNxpNciHal_getSystemProperty
+ **
+ ** Description      It shall be used to get property value of the given Key
+ **
+ ** Parameters       string key
+ **
+ ** Returns          If Key is found, returns the respective property values
+ **                  else returns the null/empty string
+ *******************************************************************************/
+string phNxpNciHal_getSystemProperty(string key) {
+  string propValue;
+  std::map<std::string, std::string>::iterator prop;
+
+  if (key == "libnfc-nxp.conf") {
+    return phNxpNciHal_getNxpConfigIf();
+  } else {
+    prop = gsystemProperty.find(key);
+    if (prop != gsystemProperty.end()) {
+      propValue = prop->second;
+    } else {
+      /* else Pass a null string */
+    }
+  }
+  return propValue;
+}
+/*******************************************************************************
+ **
+ ** Function         phNxpNciHal_setSystemProperty
+ **
+ ** Description      It shall be used to save/change value to system property
+ **                  based on provided key.
+ **
+ ** Parameters       string key, string value
+ **
+ ** Returns          true if success, false if fail
+ *******************************************************************************/
+bool phNxpNciHal_setSystemProperty(string key, string value) {
+  bool stat = true;
+  if (strcmp(key.c_str(), "nfc.debug_enabled") != 0)
+    NXPLOG_NCIHAL_D("%s : Enter Key = %s, value = %s", __func__, key.c_str(),
+                    value.c_str());
+
+  unsigned tmp = 0;
+  if (strcmp(key.c_str(), "nfc.debug_enabled") == 0) {
+    if (ParseUint(value.c_str(), &tmp)) {
+      if (phNxpLog_EnableDisableLogLevel((uint8_t)tmp) != NFCSTATUS_SUCCESS) {
+        stat = false;
+      }
+    } else {
+      NXPLOG_NCIHAL_W("%s : Failed to parse the string to uint. "
+                      "nfc.debug_enabled string : %s",
+                      __func__, value.c_str());
+    }
+  } else if (strcmp(key.c_str(), "nfc.cover.state") == 0) {
+    unsigned cid, cstate;
+    string strtmp;
+    if (ParseUint(value.c_str(), &cstate)) {
+      strtmp = phNxpNciHal_getSystemProperty("nfc.cover.cover_id");
+      if (ParseUint(strtmp.c_str(), &cid)) {
+        if (fpPropConfCover != NULL) {
+          stat = (fpPropConfCover(cstate, cid) == NFCSTATUS_SUCCESS) ? true
+                                                                     : false;
+        }
+      } else {
+        NXPLOG_NCIHAL_W("%s : Failed to parse the string to uint. "
+                        "nfc.cover.cover_id string : %s",
+                        __func__, value.c_str());
+      }
+    } else {
+      NXPLOG_NCIHAL_W("%s : Failed to parse the string to uint. "
+                      "nfc.cover.state string : %s",
+                      __func__, value.c_str());
+    }
+  } else if (strcmp(key.c_str(), "nfc.cmd_timeout") == 0) {
+    NXPLOG_NCIHAL_E("%s : nci_timeout, sem post", __func__);
+    sem_post(&(nxpncihal_ctrl.syncSpiNfc));
+  }
+  gsystemProperty[key] = value;
+  return stat;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_getNxpConfig
+**
+** Description      It shall be used to read config values from the
+*libnfc-nxp.conf
+**
+** Parameters       nxpConfigs config
+**
+** Returns          void
+*******************************************************************************/
+string phNxpNciHal_getNxpConfigIf() {
+  std::string config;
+  uint8_t *p_config = nullptr;
+  size_t config_size = readConfigFile(default_nxp_config_path, &p_config);
+  if (config_size) {
+    config.assign((char *)p_config, config_size);
+    free(p_config);
+    phNxpNciHal_getFilteredConfig(config);
+  }
+  return config;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_getFilteredConfig
+**
+** Description      It reads only configs needed for libnfc from
+*                   libnfc-nxp.conf
+**
+** Parameters       string config
+**
+** Returns          void
+*******************************************************************************/
+static void phNxpNciHal_getFilteredConfig(string &config) {
+  config = phNxpNciHal_extractConfig(config);
+
+  if (phNxpNciHal_IsAutonmousModeSet(config)) {
+    config = phNxpNciHal_UpdatePwrStateConfigs(config);
+  }
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_extractConfig
+**
+** Description      It parses complete config file and extracts only
+*                   enabled options ignores comments etc.
+**
+** Parameters       string config
+**
+** Returns          Resultant string
+*******************************************************************************/
+static string phNxpNciHal_extractConfig(string &config) {
+  stringstream ss(config);
+  string line;
+  string result;
+  bool apduGate = false;
+  while (getline(ss, line)) {
+    line = Trim(line);
+    if (line.empty())
+      continue;
+    if (line.at(0) == '#')
+      continue;
+    if (line.at(0) == 0)
+      continue;
+
+    auto search = line.find('=');
+    if (search == string::npos)
+      continue;
+
+    string key(Trim(line.substr(0, search)));
+    if (!phNxpNciHal_CheckKeyNeeded(key))
+      continue;
+    if (key == "NXP_NFC_SE_TERMINAL_NUM" && !apduGate) {
+      line = "NXP_SE_APDU_GATE_SUPPORT=0x01\n";
+      result += line;
+      apduGate = true;
+      continue;
+    }
+    string value_string(Trim(line.substr(search + 1, string::npos)));
+
+    if (!phNxpNciHal_parseValueFromString(value_string))
+      continue;
+
+    line = key + "=" + value_string + "\n";
+    result += line;
+    if (key == "NXP_GET_HW_INFO_LOG" &&
+        (value_string == "1" || value_string == "0x01")) {
+      if (!apduGate) {
+        line = "NXP_SE_APDU_GATE_SUPPORT=0x01\n";
+        result += line;
+        apduGate = true;
+      }
+    }
+  }
+
+  return result;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_IsAutonmousModeSet
+**
+** Description      It check whether autonomous mode is enabled
+*                   in config file
+**
+** Parameters       string config
+**
+** Returns          boolean(TRUE/FALSE)
+*******************************************************************************/
+static bool phNxpNciHal_IsAutonmousModeSet(string config) {
+  stringstream ss(config);
+  string line;
+  unsigned tmp = 0;
+  while (getline(ss, line)) {
+    auto search = line.find('=');
+    if (search == string::npos)
+      continue;
+
+    string key(Trim(line.substr(0, search)));
+    if (key == "NXP_AUTONOMOUS_ENABLE") {
+      string value(Trim(line.substr(search + 1, string::npos)));
+      if (ParseUint(value.c_str(), &tmp)) {
+        if (tmp == 1) {
+          return true;
+        } else {
+          NXPLOG_NCIHAL_D("Autonomous flag disabled");
+          return false;
+        }
+      }
+    } else {
+      continue;
+    }
+  }
+  NXPLOG_NCIHAL_D("Autonomous flag disabled");
+  return false;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_UpdatePwrStateConfigs
+**
+** Description      Updates default pwr state accordingly if autonomous mode
+*                   is enabled
+**
+** Parameters       string config
+**
+** Returns          Resultant string
+*******************************************************************************/
+static string phNxpNciHal_UpdatePwrStateConfigs(string &config) {
+  stringstream ss(config);
+  string line;
+  string result;
+  unsigned tmp = 0;
+  while (getline(ss, line)) {
+    auto search = line.find('=');
+    if (search == string::npos)
+      continue;
+
+    string key(Trim(line.substr(0, search)));
+    if ((key == "DEFAULT_AID_PWR_STATE" || key == "DEFAULT_DESFIRE_PWR_STATE" ||
+         key == "DEFAULT_MIFARE_CLT_PWR_STATE" ||
+         key == "DEFAULT_FELICA_CLT_PWR_STATE")) {
+      string value(Trim(line.substr(search + 1, string::npos)));
+      if (ParseUint(value.c_str(), &tmp)) {
+        tmp = phNxpNciHal_updateAutonomousPwrState(tmp);
+        value = to_string(tmp);
+        line = key + "=" + value + "\n";
+        result += line;
+      }
+    } else {
+      result += (line + "\n");
+      continue;
+    }
+  }
+  return result;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_CheckKeyNeeded
+**
+** Description      Check if the config needed for libnfc as per gNciConfigs
+*                   list
+**
+** Parameters       string config
+**
+** Returns          bool(true/false)
+*******************************************************************************/
+static bool phNxpNciHal_CheckKeyNeeded(string key) {
+  return ((gNciConfigs.find(key) != gNciConfigs.end()) ? true : false);
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_parseValueFromString
+**
+** Description      Parse value determine data type of config option
+**
+** Parameters       string config
+**
+** Returns          bool(true/false)
+*******************************************************************************/
+static bool phNxpNciHal_parseValueFromString(string &in) {
+  unsigned tmp = 0;
+  bool stat = false;
+  if (in.length() >= 1) {
+    switch (in[0]) {
+    case '"':
+      if (in[in.length() - 1] == '"' && in.length() > 2)
+        stat = true;
+      break;
+    case '{':
+      if (in[in.length() - 1] == '}' && in.length() >= 3) {
+        in = phNxpNciHal_parseBytesString(in);
+        stat = true;
+      }
+      break;
+    default:
+      if (ParseUint(in.c_str(), &tmp))
+        stat = true;
+      break;
+    }
+  } else {
+    NXPLOG_NCIHAL_E("%s : Invalid config string ", __func__);
+  }
+  return stat;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_parseBytesString
+**
+** Description      Parse bytes from string
+**
+** Parameters       string config
+**
+** Returns          Resultant string
+*******************************************************************************/
+static string phNxpNciHal_parseBytesString(string in) {
+  size_t pos;
+  in.erase(remove(in.begin(), in.end(), ' '), in.end());
+  pos = in.find(",");
+  while (pos != string::npos) {
+    in = in.replace(pos, 1, ":");
+    pos = in.find(",", pos);
+  }
+  return in;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_setNxpTransitConfig
+ *
+ * Description      This function overwrite libnfc-nxpTransit.conf file
+ *                  with transitConfValue.
+ *
+ * Returns          bool.
+ *
+ ******************************************************************************/
+bool phNxpNciHal_setNxpTransitConfig(char *transitConfValue) {
+  bool status = true;
+  NXPLOG_NCIHAL_D("%s : Enter", __func__);
+  std::string transitConfFileName = "/data/vendor/nfc/libnfc-nxpTransit.conf";
+  long transitConfValueLen = strlen(transitConfValue) + 1;
+
+  if (transitConfValueLen > 1) {
+    if (!WriteStringToFile(transitConfValue, transitConfFileName)) {
+      NXPLOG_NCIHAL_E("WriteStringToFile: Failed");
+      status = false;
+    }
+  } else {
+    if (!WriteStringToFile("", transitConfFileName)) {
+      NXPLOG_NCIHAL_E("WriteStringToFile: Failed");
+      status = false;
+    }
+    if (remove(transitConfFileName.c_str())) {
+      NXPLOG_NCIHAL_E("Unable to remove file");
+      status = false;
+    }
+  }
+  NXPLOG_NCIHAL_D("%s : Exit", __func__);
+  return status;
+}
+
+/******************************************************************************
+** Function         phNxpNciHal_Abort
+**
+** Description      This function shall be used to trigger the abort in libnfc
+**
+** Parameters       None
+**
+** Returns          bool.
+**
+*******************************************************************************/
+bool phNxpNciHal_Abort() {
+  bool ret = true;
+
+  NXPLOG_NCIHAL_D("phNxpNciHal_Abort aborting. \n");
+  /* When JCOP download is triggered phNxpNciHal_open is blocked, in this case
+     only we need to abort the libnfc , this can be done only by check the
+     p_nfc_stack_cback_backup pointer which is assigned before the JCOP
+     download.*/
+  if (p_nfc_stack_cback_backup != NULL) {
+    (*p_nfc_stack_cback_backup)(HAL_NFC_OPEN_CPLT_EVT, HAL_NFC_STATUS_RESTART);
+  } else {
+    ret = false;
+    NXPLOG_NCIHAL_D("phNxpNciHal_Abort not triggered\n");
+  }
+  return ret;
+}
+
+/*******************************************************************************
+ **
+ ** Function:        phNxpNciHal_CheckFwRegFlashRequired()
+ **
+ ** Description:     Updates FW and Reg configurations if required
+ **
+ ** Returns:         status
+ **
+ ********************************************************************************/
+int phNxpNciHal_CheckFwRegFlashRequired(uint8_t *fw_update_req,
+                                        uint8_t *rf_update_req,
+                                        uint8_t skipEEPROMRead) {
+  NXPLOG_NCIHAL_D("phNxpNciHal_CheckFwRegFlashRequired() : enter");
+  int status = NFCSTATUS_OK;
+  long option;
+  if (fpRegRfFwDndl != NULL) {
+    status = fpRegRfFwDndl(fw_update_req, rf_update_req, skipEEPROMRead);
+  } else {
+    status = phDnldNfc_InitImgInfo();
+    NXPLOG_NCIHAL_D("FW version from the binary(.so/bin) = 0x%x", wFwVer);
+    NXPLOG_NCIHAL_D("FW version found on the device = 0x%x", wFwVerRsp);
+
+    if (!GetNxpNumValue(NAME_NXP_FLASH_CONFIG, &option,
+                        sizeof(unsigned long))) {
+      NXPLOG_NCIHAL_D("Flash option not found; giving default value");
+      option = FLASH_DIFFERENT_VERSION;
+    }
+    switch (option) {
+    case FLASH_UPPER_VERSION:
+      wFwUpdateReq = (utf8_t)wFwVer > (utf8_t)wFwVerRsp ? true : false;
+      break;
+    case FLASH_DIFFERENT_VERSION:
+      wFwUpdateReq = ((wFwVerRsp & 0x0000FFFF) != wFwVer) ? true : false;
+      break;
+    case FLASH_ALWAYS:
+      wFwUpdateReq = true;
+      break;
+    default:
+      NXPLOG_NCIHAL_D("Invalid flash option selected");
+      status = NFCSTATUS_INVALID_PARAMETER;
+      break;
+    }
+  }
+  *fw_update_req = wFwUpdateReq;
+
+  if (false == wFwUpdateReq) {
+    NXPLOG_NCIHAL_D("FW update not required");
+    phDnldNfc_ReSetHwDevHandle();
+  } else {
+    property_set("nfc.fw.downloadmode_force", "1");
+  }
+
+  NXPLOG_NCIHAL_D("phNxpNciHal_CheckFwRegFlashRequired() : exit - status = %x "
+                  "wFwUpdateReq=%u, wRfUpdateReq=%u",
+                  status, *fw_update_req, *rf_update_req);
+  return status;
+}
diff --git a/pn72xx/halimpl/hal/phNxpNciHal_IoctlOperations.h b/pn72xx/halimpl/hal/phNxpNciHal_IoctlOperations.h
new file mode 100755
index 00000000..2f3757ad
--- /dev/null
+++ b/pn72xx/halimpl/hal/phNxpNciHal_IoctlOperations.h
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2019-2021,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "NxpNfc.h"
+#include "phNfcStatus.h"
+#include "phNxpConfig.h"
+#include "phNxpLog.h"
+#include <hardware/nfc.h>
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_getSystemProperty
+**
+** Description      It shall be used to get property value of the given Key
+**
+** Parameters       string key
+**
+** Returns          It returns the property value of the key
+*******************************************************************************/
+string phNxpNciHal_getSystemProperty(string key);
+
+/*******************************************************************************
+ **
+ ** Function         phNxpNciHal_setSystemProperty
+ **
+ ** Description      It shall be used to save/chage value to system property
+ **                  based on provided key.
+ **
+ ** Parameters       string key, string value
+ **
+ ** Returns          true if success, false if fail
+ *******************************************************************************/
+bool phNxpNciHal_setSystemProperty(string key, string value);
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_getNxpConfig
+**
+** Description      It shall be used to read config values from the
+*libnfc-nxp.conf
+**
+** Parameters       nxpConfigs config
+**
+** Returns          void
+*******************************************************************************/
+string phNxpNciHal_getNxpConfigIf();
+
+/******************************************************************************
+** Function         phNxpNciHal_setNxpTransitConfig
+**
+** Description      This function overwrite libnfc-nxpTransit.conf file
+**                  with transitConfValue.
+**
+** Returns          bool.
+**
+*******************************************************************************/
+bool phNxpNciHal_setNxpTransitConfig(char *transitConfValue);
+
+/*******************************************************************************
+ **
+ ** Function:        phNxpNciHal_CheckFwRegFlashRequired()
+ **
+ ** Description:     Updates FW and Reg configurations if required
+ **
+ ** Returns:         status
+ **
+ ********************************************************************************/
+int phNxpNciHal_CheckFwRegFlashRequired(uint8_t *fw_update_req,
+                                        uint8_t *rf_update_req,
+                                        uint8_t skipEEPROMRead);
+
+/*******************************************************************************
+ **
+ ** Function:        property_get_intf()
+ **
+ ** Description:     Gets property value for the input property name
+ **
+ ** Parameters       propName:   Name of the property whichs value need to get
+ **                  valueStr:   output value of the property.
+ **                  defaultStr: default value of the property if value is not
+ **                              there this will be set to output value.
+ **
+ ** Returns:         actual length of the property value
+ **
+ ********************************************************************************/
+int property_get_intf(const char *propName, char *valueStr,
+                      const char *defaultStr);
+
+/*******************************************************************************
+ **
+ ** Function:        property_set_intf()
+ **
+ ** Description:     Sets property value for the input property name
+ **
+ ** Parameters       propName:   Name of the property whichs value need to set
+ **                  valueStr:   value of the property.
+ **
+ ** Returns:        returns 0 on success, < 0 on failure
+ **
+ ********************************************************************************/
+int property_set_intf(const char *propName, const char *valueStr);
+
+/*******************************************************************************
+ **
+ ** Function:        phNxpNciHal_Abort()
+ **
+ ** Description:     This function shall be used to trigger the abort
+ **
+ ** Parameters       None
+ **
+ ** Returns:        returns 0 on success, < 0 on failure
+ **
+ ********************************************************************************/
+bool phNxpNciHal_Abort();
+
+#undef PROPERTY_VALUE_MAX
+#define PROPERTY_VALUE_MAX 92
+#define property_get(a, b, c) property_get_intf(a, b, c)
+#define property_set(a, b) property_set_intf(a, b)
diff --git a/pn72xx/halimpl/hal/phNxpNciHal_dta.cc b/pn72xx/halimpl/hal/phNxpNciHal_dta.cc
new file mode 100644
index 00000000..9039eca9
--- /dev/null
+++ b/pn72xx/halimpl/hal/phNxpNciHal_dta.cc
@@ -0,0 +1,232 @@
+/*
+ * Copyright 2012-2014,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <phNxpConfig.h>
+#include <phNxpLog.h>
+#include <phNxpNciHal_dta.h>
+
+/*********************** Global Variables *************************************/
+static phNxpDta_Control_t nxpdta_ctrl = {0, 0, 0};
+extern bool nfc_debug_enabled;
+/*******************************************************************************
+**
+** Function         phNxpEnable_DtaMode
+**
+** Description      This function configures
+**                  HAL in DTA mode
+**
+*******************************************************************************/
+void phNxpEnable_DtaMode(uint16_t pattern_no) {
+  nxpdta_ctrl.dta_ctrl_flag = false;
+  nxpdta_ctrl.dta_t1t_flag = false;
+  nxpdta_ctrl.dta_pattern_no = pattern_no;
+  NXPLOG_NCIHAL_D(">>>>DTA - Mode is enabled");
+  nxpdta_ctrl.dta_ctrl_flag = true;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpDisable_DtaMode
+**
+** Description      This function disable DTA mode
+**
+*******************************************************************************/
+void phNxpDisable_DtaMode(void) {
+  nxpdta_ctrl.dta_ctrl_flag = false;
+  nxpdta_ctrl.dta_t1t_flag = false;
+  NXPLOG_NCIHAL_D(">>>>DTA - Mode is Disabled");
+}
+
+/******************************************************************************
+ * Function         phNxpDta_IsEnable
+ *
+ * Description      This function checks the DTA mode is enable or not.
+ *
+ * Returns          It returns TRUE if DTA enabled otherwise FALSE
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpDta_IsEnable(void) { return nxpdta_ctrl.dta_ctrl_flag; }
+
+/******************************************************************************
+ * Function         phNxpDta_T1TEnable
+ *
+ * Description      This function  enables  DTA mode for T1T tag.
+ *
+ *
+ ******************************************************************************/
+void phNxpDta_T1TEnable(void) { nxpdta_ctrl.dta_t1t_flag = true; }
+/******************************************************************************
+ * Function         phNxpNHal_DtaUpdate
+ *
+ * Description      This function changes the command and responses specific
+ *                  to make DTA application success
+ *
+ * Returns          It return NFCSTATUS_SUCCESS then continue with send else
+ *                  sends NFCSTATUS_FAILED direct response is prepared and
+ *                  do not send anything to NFCC.
+ *
+ ******************************************************************************/
+
+NFCSTATUS phNxpNHal_DtaUpdate(uint16_t *cmd_len, uint8_t *p_cmd_data,
+                              uint16_t *rsp_len, uint8_t *p_rsp_data) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  if (nxpdta_ctrl.dta_ctrl_flag == true) {
+    // Workaround for DTA, block the set config command with general bytes */
+    if (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02 &&
+        p_cmd_data[2] == 0x17 && p_cmd_data[3] == 0x01 &&
+        p_cmd_data[4] == 0x29 && p_cmd_data[5] == 0x14) {
+      *rsp_len = 5;
+      NXPLOG_NCIHAL_D(">>>>DTA - Block set config command");
+      phNxpNciHal_print_packet("DTASEND", p_cmd_data, *cmd_len);
+
+      p_rsp_data[0] = 0x40;
+      p_rsp_data[1] = 0x02;
+      p_rsp_data[2] = 0x02;
+      p_rsp_data[3] = 0x00;
+      p_rsp_data[4] = 0x00;
+
+      phNxpNciHal_print_packet("DTARECV", p_rsp_data, 5);
+
+      status = NFCSTATUS_FAILED;
+      NXPLOG_NCIHAL_D(
+          "Going through DTA workaround - Block set config command END");
+
+    } else if (p_cmd_data[0] == 0x21 && p_cmd_data[1] == 0x08 &&
+               p_cmd_data[2] == 0x04 && p_cmd_data[3] == 0xFF &&
+               p_cmd_data[4] == 0xFF) {
+      NXPLOG_NCIHAL_D(">>>>DTA Change Felica system code");
+      *rsp_len = 4;
+      p_rsp_data[0] = 0x41;
+      p_rsp_data[1] = 0x08;
+      p_rsp_data[2] = 0x01;
+      p_rsp_data[3] = 0x00;
+      status = NFCSTATUS_FAILED;
+
+      phNxpNciHal_print_packet("DTARECV", p_rsp_data, 4);
+    } else if (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02 &&
+               p_cmd_data[2] == 0x10 && p_cmd_data[3] == 0x05 &&
+               p_cmd_data[10] == 0x32 && p_cmd_data[12] == 0x00) {
+      NXPLOG_NCIHAL_D(">>>>DTA Update LA_SEL_INFO param");
+
+      p_cmd_data[12] = 0x40;
+      p_cmd_data[18] = 0x02;
+      status = NFCSTATUS_SUCCESS;
+    } else if (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02 &&
+               p_cmd_data[2] == 0x0D && p_cmd_data[3] == 0x04 &&
+               p_cmd_data[10] == 0x32 && p_cmd_data[12] == 0x00) {
+      NXPLOG_NCIHAL_D(">>>>DTA Blocking dirty set config");
+      *rsp_len = 5;
+      p_rsp_data[0] = 0x40;
+      p_rsp_data[1] = 0x02;
+      p_rsp_data[2] = 0x02;
+      p_rsp_data[3] = 0x00;
+      p_rsp_data[4] = 0x00;
+      status = NFCSTATUS_FAILED;
+      phNxpNciHal_print_packet("DTARECV", p_rsp_data, 5);
+    } else if (p_cmd_data[0] == 0x21 && p_cmd_data[1] == 0x03) {
+      NXPLOG_NCIHAL_D(">>>>DTA Add NFC-F listen tech params");
+      p_cmd_data[2] += 6;
+      p_cmd_data[3] += 3;
+      p_cmd_data[*cmd_len] = 0x80;
+      p_cmd_data[*cmd_len + 1] = 0x01;
+      p_cmd_data[*cmd_len + 2] = 0x82;
+      p_cmd_data[*cmd_len + 3] = 0x01;
+      p_cmd_data[*cmd_len + 4] = 0x85;
+      p_cmd_data[*cmd_len + 5] = 0x01;
+
+      *cmd_len += 6;
+      status = NFCSTATUS_SUCCESS;
+    } else if (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02 &&
+               p_cmd_data[2] == 0x0D && p_cmd_data[3] == 0x04 &&
+               p_cmd_data[10] == 0x32 && p_cmd_data[12] == 0x20 &&
+               nxpdta_ctrl.dta_pattern_no == 0x1000) {
+      NXPLOG_NCIHAL_D(">>>>DTA Blocking dirty set config for analog testing");
+      *rsp_len = 5;
+      p_rsp_data[0] = 0x40;
+      p_rsp_data[1] = 0x02;
+      p_rsp_data[2] = 0x02;
+      p_rsp_data[3] = 0x00;
+      p_rsp_data[4] = 0x00;
+      status = NFCSTATUS_FAILED;
+      phNxpNciHal_print_packet("DTARECV", p_rsp_data, 5);
+    } else if (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02 &&
+               p_cmd_data[2] == 0x0D && p_cmd_data[3] == 0x04 &&
+               p_cmd_data[4] == 0x32 && p_cmd_data[5] == 0x01 &&
+               p_cmd_data[6] == 0x00) {
+      NXPLOG_NCIHAL_D(">>>>DTA Blocking dirty set config");
+      *rsp_len = 5;
+      p_rsp_data[0] = 0x40;
+      p_rsp_data[1] = 0x02;
+      p_rsp_data[2] = 0x02;
+      p_rsp_data[3] = 0x00;
+      p_rsp_data[4] = 0x00;
+      status = NFCSTATUS_FAILED;
+      phNxpNciHal_print_packet("DTARECV", p_rsp_data, 5);
+    } else if (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02 &&
+               p_cmd_data[2] == 0x04 && p_cmd_data[3] == 0x01 &&
+               p_cmd_data[4] == 0x50 && p_cmd_data[5] == 0x01 &&
+               p_cmd_data[6] == 0x00 && nxpdta_ctrl.dta_pattern_no == 0x1000) {
+      NXPLOG_NCIHAL_D(">>>>DTA Blocking dirty set config for analog testing");
+      *rsp_len = 5;
+      p_rsp_data[0] = 0x40;
+      p_rsp_data[1] = 0x02;
+      p_rsp_data[2] = 0x02;
+      p_rsp_data[3] = 0x00;
+      p_rsp_data[4] = 0x00;
+      status = NFCSTATUS_FAILED;
+      phNxpNciHal_print_packet("DTARECV", p_rsp_data, 5);
+    } else {
+    }
+    if (nxpdta_ctrl.dta_t1t_flag == true) {
+      if (p_cmd_data[2] == 0x07 && p_cmd_data[3] == 0x78 &&
+          p_cmd_data[4] == 0x00 && p_cmd_data[5] == 0x00) {
+        /*if (nxpdta_ctrl.dta_pattern_no == 0)
+        {
+          NXPLOG_NCIHAL_D(">>>>DTA - T1T modification block RID command Custom
+        Response (pattern 0)");
+          phNxpNciHal_print_packet("DTASEND", p_cmd_data, *cmd_len);
+          *rsp_len = 10;
+          p_rsp_data[0] = 0x00;
+          p_rsp_data[1] = 0x00;
+          p_rsp_data[2] = 0x07;
+          p_rsp_data[3] = 0x12;
+          p_rsp_data[4] = 0x49;
+          p_rsp_data[5] = 0x00;
+          p_rsp_data[6] = 0x00;
+          p_rsp_data[7] = 0x00;
+          p_rsp_data[8] = 0x00;
+          p_rsp_data[9] = 0x00;
+
+          status = NFCSTATUS_FAILED;
+
+          phNxpNciHal_print_packet("DTARECV", p_rsp_data, *rsp_len);
+        }
+        else
+        {*/
+        NXPLOG_NCIHAL_D("Change RID command's UID echo bytes to 0");
+
+        nxpdta_ctrl.dta_t1t_flag = false;
+        p_cmd_data[6] = 0x00;
+        p_cmd_data[7] = 0x00;
+        p_cmd_data[8] = 0x00;
+        p_cmd_data[9] = 0x00;
+        status = NFCSTATUS_SUCCESS;
+        /*}*/
+      }
+    }
+  }
+  return status;
+}
diff --git a/pn72xx/halimpl/hal/phNxpNciHal_dta.h b/pn72xx/halimpl/hal/phNxpNciHal_dta.h
new file mode 100644
index 00000000..28c6654a
--- /dev/null
+++ b/pn72xx/halimpl/hal/phNxpNciHal_dta.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2012-2014,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _PHNXPNCIHAL_DTA_H_
+#define _PHNXPNCIHAL_DTA_H_
+
+#include <phNxpNciHal_utils.h>
+/* DTA Control structure */
+typedef struct phNxpDta_Control {
+  uint8_t dta_ctrl_flag;
+  uint16_t dta_pattern_no;
+  uint8_t dta_t1t_flag;
+} phNxpDta_Control_t;
+
+void phNxpEnable_DtaMode(uint16_t pattern_no);
+void phNxpDisable_DtaMode(void);
+NFCSTATUS phNxpDta_IsEnable(void);
+void phNxpDta_T1TEnable(void);
+NFCSTATUS phNxpNHal_DtaUpdate(uint16_t *cmd_len, uint8_t *p_cmd_data,
+                              uint16_t *rsp_len, uint8_t *p_rsp_data);
+
+#endif /* _PHNXPNICHAL_DTA_H_ */
diff --git a/pn72xx/halimpl/hal/phNxpNciHal_ext.cc b/pn72xx/halimpl/hal/phNxpNciHal_ext.cc
new file mode 100755
index 00000000..c71379c3
--- /dev/null
+++ b/pn72xx/halimpl/hal/phNxpNciHal_ext.cc
@@ -0,0 +1,1613 @@
+/*
+ * Copyright 2012-2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <log/log.h>
+#include <phDal4Nfc_messageQueueLib.h>
+#include <phDnldNfc.h>
+#include <phNxpConfig.h>
+#include <phNxpLog.h>
+#include <phNxpNciHal.h>
+#include <phNxpNciHal_Adaptation.h>
+#include <phNxpNciHal_ext.h>
+#include <phTmlNfc.h>
+#if (NXP_EXTNS == TRUE)
+#include "phNxpNciHal.h"
+#include "phNxpNciHal_IoctlOperations.h"
+#endif
+/* Timeout value to wait for response from PN548AD */
+#define HAL_EXTNS_WRITE_RSP_TIMEOUT (1000)
+#define NCI_NFC_DEP_RF_INTF 0x03
+#define NCI_STATUS_OK 0x00
+#define NCI_MODE_HEADER_LEN 3
+
+#undef P2P_PRIO_LOGIC_HAL_IMP
+
+/******************* Global variables *****************************************/
+extern phNxpNciHal_Control_t nxpncihal_ctrl;
+extern phNxpNciProfile_Control_t nxpprofile_ctrl;
+extern phNxpNci_getCfg_info_t *mGetCfg_info;
+
+extern bool_t gsIsFwRecoveryRequired;
+
+extern bool nfc_debug_enabled;
+uint8_t icode_detected = 0x00;
+uint8_t icode_send_eof = 0x00;
+static uint8_t ee_disc_done = 0x00;
+uint8_t EnableP2P_PrioLogic = false;
+extern bool bEnableMfcExtns;
+extern bool bEnableMfcReader;
+extern bool bDisableLegacyMfcExtns;
+/* NFCEE Set mode */
+static uint8_t setEEModeDone = 0x00;
+/* External global variable to get FW version from NCI response*/
+extern uint32_t wFwVerRsp;
+/* External global variable to get FW version from FW file*/
+extern uint16_t wFwVer;
+/* local buffer to store CORE_INIT response */
+static uint32_t bCoreInitRsp[40];
+static uint32_t iCoreInitRspLen;
+
+extern uint32_t timeoutTimerId;
+
+/************** HAL extension functions ***************************************/
+static void hal_extns_write_rsp_timeout_cb(uint32_t TimerId, void *pContext);
+
+/*Proprietary cmd sent to HAL to send reader mode flag
+ * Last byte of 4 byte proprietary cmd data contains ReaderMode flag
+ * If this flag is enabled, NFC-DEP protocol is modified to T3T protocol
+ * if FrameRF interface is selected. This needs to be done as the FW
+ * always sends Ntf for FrameRF with NFC-DEP even though FrameRF with T3T is
+ * previously selected with DISCOVER_SELECT_CMD
+ */
+#define PROPRIETARY_CMD_FELICA_READER_MODE 0xFE
+static uint8_t gFelicaReaderMode;
+static bool mfc_mode = false;
+
+static NFCSTATUS phNxpNciHal_ext_process_nfc_init_rsp(uint8_t *p_ntf,
+                                                      uint16_t *p_len);
+static void RemoveNfcDepIntfFromInitResp(uint8_t *coreInitResp,
+                                         uint16_t *coreInitRespLen);
+/*******************************************************************************
+**
+** Function         phNxpNciHal_ext_init
+**
+** Description      initialize extension function
+**
+*******************************************************************************/
+void phNxpNciHal_ext_init(void) {
+  icode_detected = 0x00;
+  if (nfcFL.chipType < sn100u) {
+    icode_send_eof = 0x00;
+  }
+  setEEModeDone = 0x00;
+  EnableP2P_PrioLogic = false;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_ext_send_sram_config_to_flash
+**
+** Description      This function is called to update the SRAM contents such as
+**                  set config to FLASH for permanent storage.
+**                  Note: This function has to be called after set config and
+**                  before sending  core_reset command again.
+**
+*******************************************************************************/
+NFCSTATUS phNxpNciHal_ext_send_sram_config_to_flash() {
+  NXPLOG_NCIHAL_D("phNxpNciHal_ext_send_sram_config_to_flash  send");
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  uint8_t send_sram_flash[] = {NXP_PROPCMD_GID, NXP_FLUSH_SRAM_AO_TO_FLASH,
+                               0x00};
+  status = phNxpNciHal_send_ext_cmd(sizeof(send_sram_flash), send_sram_flash);
+  return status;
+}
+/*******************************************************************************
+**
+** Function         phNxpNciHal_process_ext_rsp
+**
+** Description      Process extension function response
+**
+** Returns          NFCSTATUS_SUCCESS if success
+**
+*******************************************************************************/
+NFCSTATUS phNxpNciHal_process_ext_rsp(uint8_t *p_ntf, uint16_t *p_len) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+#if (NXP_SRD == TRUE)
+  if (p_ntf[0] == 0x01 && p_ntf[1] == 0x00 && p_ntf[5] == 0x81 &&
+      p_ntf[23] == 0x82 && p_ntf[26] == 0xA0 && p_ntf[27] == 0xFE) {
+    if (p_ntf[29] == 0x01) {
+      nxpprofile_ctrl.profile_type = SRD_PROFILE;
+    } else if (p_ntf[29] == 0x00) {
+      nxpprofile_ctrl.profile_type = NFC_FORUM_PROFILE;
+    }
+  } else if (p_ntf[0] == 0x60 && p_ntf[1] == 0x07 && p_ntf[2] == 0x01 &&
+             p_ntf[3] == 0xE2) {
+    nxpprofile_ctrl.profile_type = NFC_FORUM_PROFILE;
+  }
+#endif
+
+  if (p_ntf[0] == 0x61 && p_ntf[1] == 0x05 && *p_len < 14) {
+    if (*p_len <= 6) {
+      android_errorWriteLog(0x534e4554, "118152591");
+    }
+    NXPLOG_NCIHAL_E("RF_INTF_ACTIVATED_NTF length error!");
+    status = NFCSTATUS_FAILED;
+    return status;
+  }
+
+  if (p_ntf[0] == 0x61 && p_ntf[1] == 0x05 && p_ntf[4] == 0x03 &&
+      p_ntf[5] == 0x05 && nxpprofile_ctrl.profile_type == EMV_CO_PROFILE) {
+    p_ntf[4] = 0xFF;
+    p_ntf[5] = 0xFF;
+    p_ntf[6] = 0xFF;
+    NXPLOG_NCIHAL_D("Nfc-Dep Detect in EmvCo profile - Restart polling");
+  }
+
+  if (p_ntf[0] == 0x61 && p_ntf[1] == 0x05 && p_ntf[4] == 0x01 &&
+      p_ntf[5] == 0x05 && p_ntf[6] == 0x02 && gFelicaReaderMode) {
+    /*If FelicaReaderMode is enabled,Change Protocol to T3T from NFC-DEP
+     * when FrameRF interface is selected*/
+    p_ntf[5] = 0x03;
+    NXPLOG_NCIHAL_D("FelicaReaderMode:Activity 1.1");
+  }
+
+#ifdef P2P_PRIO_LOGIC_HAL_IMP
+  if (p_ntf[0] == 0x61 && p_ntf[1] == 0x05 && p_ntf[4] == 0x02 &&
+      p_ntf[5] == 0x04 && nxpprofile_ctrl.profile_type == NFC_FORUM_PROFILE) {
+    EnableP2P_PrioLogic = true;
+  }
+
+  NXPLOG_NCIHAL_D("Is EnableP2P_PrioLogic: 0x0%X", EnableP2P_PrioLogic);
+  if (phNxpDta_IsEnable() == false) {
+    if ((icode_detected != 1) && (EnableP2P_PrioLogic == true)) {
+      if (phNxpNciHal_NfcDep_comapre_ntf(p_ntf, *p_len) == NFCSTATUS_FAILED) {
+        status = phNxpNciHal_NfcDep_rsp_ext(p_ntf, p_len);
+        if (status != NFCSTATUS_INVALID_PARAMETER) {
+          return status;
+        }
+      }
+    }
+  }
+#endif
+
+  status = NFCSTATUS_SUCCESS;
+
+  if (bDisableLegacyMfcExtns && bEnableMfcExtns && p_ntf[0] == 0) {
+    if (*p_len < NCI_HEADER_SIZE) {
+      android_errorWriteLog(0x534e4554, "169258743");
+      return NFCSTATUS_FAILED;
+    }
+    uint16_t extlen;
+    extlen = *p_len - NCI_HEADER_SIZE;
+    NxpMfcReaderInstance.AnalyzeMfcResp(&p_ntf[3], &extlen);
+    p_ntf[2] = extlen;
+    *p_len = extlen + NCI_HEADER_SIZE;
+  }
+
+  if (p_ntf[0] == 0x61 && p_ntf[1] == 0x05) {
+    bEnableMfcExtns = false;
+    if (bDisableLegacyMfcExtns && p_ntf[4] == 0x80 && p_ntf[5] == 0x80) {
+      bEnableMfcExtns = true;
+      NXPLOG_NCIHAL_D("NxpNci: RF Interface = Mifare Enable MifareExtns");
+    }
+    switch (p_ntf[4]) {
+    case 0x00:
+      NXPLOG_NCIHAL_D("NxpNci: RF Interface = NFCEE Direct RF");
+      break;
+    case 0x01:
+      NXPLOG_NCIHAL_D("NxpNci: RF Interface = Frame RF");
+      break;
+    case 0x02:
+      NXPLOG_NCIHAL_D("NxpNci: RF Interface = ISO-DEP");
+      break;
+    case 0x03:
+      NXPLOG_NCIHAL_D("NxpNci: RF Interface = NFC-DEP");
+      break;
+    case 0x80:
+      NXPLOG_NCIHAL_D("NxpNci: RF Interface = MIFARE");
+      break;
+    default:
+      NXPLOG_NCIHAL_D("NxpNci: RF Interface = Unknown");
+      break;
+    }
+
+    switch (p_ntf[5]) {
+    case 0x01:
+      NXPLOG_NCIHAL_D("NxpNci: Protocol = T1T");
+      phNxpDta_T1TEnable();
+      break;
+    case 0x02:
+      NXPLOG_NCIHAL_D("NxpNci: Protocol = T2T");
+      break;
+    case 0x03:
+      NXPLOG_NCIHAL_D("NxpNci: Protocol = T3T");
+      break;
+    case 0x04:
+      NXPLOG_NCIHAL_D("NxpNci: Protocol = ISO-DEP");
+      break;
+    case 0x05:
+      NXPLOG_NCIHAL_D("NxpNci: Protocol = NFC-DEP");
+      break;
+    case 0x06:
+      NXPLOG_NCIHAL_D("NxpNci: Protocol = 15693");
+      break;
+    case 0x80:
+      NXPLOG_NCIHAL_D("NxpNci: Protocol = MIFARE");
+      break;
+    case 0x81:
+      NXPLOG_NCIHAL_D("NxpNci: Protocol = Kovio");
+      break;
+    default:
+      NXPLOG_NCIHAL_D("NxpNci: Protocol = Unknown");
+      break;
+    }
+
+    switch (p_ntf[6]) {
+    case 0x00:
+      NXPLOG_NCIHAL_D("NxpNci: Mode = A Passive Poll");
+      break;
+    case 0x01:
+      NXPLOG_NCIHAL_D("NxpNci: Mode = B Passive Poll");
+      break;
+    case 0x02:
+      NXPLOG_NCIHAL_D("NxpNci: Mode = F Passive Poll");
+      break;
+    case 0x03:
+      NXPLOG_NCIHAL_D("NxpNci: Mode = A Active Poll");
+      break;
+    case 0x05:
+      NXPLOG_NCIHAL_D("NxpNci: Mode = F Active Poll");
+      break;
+    case 0x06:
+      NXPLOG_NCIHAL_D("NxpNci: Mode = 15693 Passive Poll");
+      break;
+    case 0x70:
+      NXPLOG_NCIHAL_D("NxpNci: Mode = Kovio");
+      break;
+#if (NXP_QTAG == TRUE)
+    case 0x71:
+      NXPLOG_NCIHAL_D("NxpNci: Mode = Q Passive Poll");
+      break;
+#endif
+    case 0x80:
+      NXPLOG_NCIHAL_D("NxpNci: Mode = A Passive Listen");
+      break;
+    case 0x81:
+      NXPLOG_NCIHAL_D("NxpNci: Mode = B Passive Listen");
+      break;
+    case 0x82:
+      NXPLOG_NCIHAL_D("NxpNci: Mode = F Passive Listen");
+      break;
+    case 0x83:
+      NXPLOG_NCIHAL_D("NxpNci: Mode = A Active Listen");
+      break;
+    case 0x85:
+      NXPLOG_NCIHAL_D("NxpNci: Mode = F Active Listen");
+      break;
+    case 0x86:
+      NXPLOG_NCIHAL_D("NxpNci: Mode = 15693 Passive Listen");
+      break;
+    default:
+      NXPLOG_NCIHAL_D("NxpNci: Mode = Unknown");
+      break;
+    }
+  }
+  phNxpNciHal_ext_process_nfc_init_rsp(p_ntf, p_len);
+  if (p_ntf[0] == NCI_MT_NTF &&
+      ((p_ntf[1] & NCI_OID_MASK) == NCI_MSG_CORE_RESET) &&
+      p_ntf[3] == CORE_RESET_TRIGGER_TYPE_POWERED_ON) {
+    status = NFCSTATUS_FAILED;
+    NXPLOG_NCIHAL_D("Skipping power on reset notification!!:");
+    return status;
+  }
+  if (p_ntf[0] == 0x42 && p_ntf[1] == 0x01 && p_ntf[2] == 0x01 &&
+      p_ntf[3] == 0x00) {
+    if (nxpncihal_ctrl.hal_ext_enabled == TRUE && nfcFL.chipType >= sn100u) {
+      nxpncihal_ctrl.nci_info.wait_for_ntf = TRUE;
+      NXPLOG_NCIHAL_D(" Mode set received");
+    }
+  } else if (p_ntf[0] == 0x61 && p_ntf[1] == 0x05 && p_ntf[2] == 0x15 &&
+             p_ntf[4] == 0x01 && p_ntf[5] == 0x06 && p_ntf[6] == 0x06) {
+    NXPLOG_NCIHAL_D("> Going through workaround - notification of ISO 15693");
+    icode_detected = 0x01;
+    p_ntf[21] = 0x01;
+    p_ntf[22] = 0x01;
+  } else if (nfcFL.chipType < sn100u && icode_detected == 1 &&
+             icode_send_eof == 2) {
+    icode_send_eof = 3;
+  } else if (nfcFL.chipType < sn100u && p_ntf[0] == 0x00 && p_ntf[1] == 0x00 &&
+             icode_detected == 1) {
+    if (icode_send_eof == 3) {
+      icode_send_eof = 0;
+    }
+    if (nxpncihal_ctrl.nci_info.nci_version != NCI_VERSION_2_0) {
+      if (*p_len <= (p_ntf[2] + 2)) {
+        android_errorWriteLog(0x534e4554, "181660091");
+        NXPLOG_NCIHAL_E("length error!");
+        return NFCSTATUS_FAILED;
+      }
+      if (p_ntf[p_ntf[2] + 2] == 0x00) {
+        NXPLOG_NCIHAL_D("> Going through workaround - data of ISO 15693");
+        p_ntf[2]--;
+        (*p_len)--;
+      } else {
+        p_ntf[p_ntf[2] + 2] |= 0x01;
+      }
+    }
+  } else if (nfcFL.chipType < sn100u && p_ntf[2] == 0x02 && p_ntf[1] == 0x00 &&
+             icode_detected == 1) {
+    NXPLOG_NCIHAL_D("> ICODE EOF response do not send to upper layer");
+  } else if (p_ntf[0] == 0x61 && p_ntf[1] == 0x06 && icode_detected == 1) {
+    NXPLOG_NCIHAL_D("> Polling Loop Re-Started");
+    icode_detected = 0;
+    if (nfcFL.chipType < sn100u)
+      icode_send_eof = 0;
+  } else if (*p_len == 4 && p_ntf[0] == 0x40 && p_ntf[1] == 0x02 &&
+             p_ntf[2] == 0x01 && p_ntf[3] == 0x06) {
+    /* NXPLOG_NCIHAL_D("> Deinit workaround for LLCP set_config 0x%x 0x%x 0x%x",
+                    p_ntf[21], p_ntf[22], p_ntf[23]); */
+    p_ntf[0] = 0x40;
+    p_ntf[1] = 0x02;
+    p_ntf[2] = 0x02;
+    p_ntf[3] = 0x00;
+    p_ntf[4] = 0x00;
+    *p_len = 5;
+  }
+
+  if (p_ntf[0] == 0x60 && p_ntf[1] == 0x07 && p_ntf[2] == 0x01) {
+    if (p_ntf[3] == 0xEA) {
+      gsIsFwRecoveryRequired = true;
+      NXPLOG_NCIHAL_D("FW update required");
+      status = NFCSTATUS_FAILED;
+    } else if ((p_ntf[3] == 0xE5) || (p_ntf[3] == 0x60)) {
+      NXPLOG_NCIHAL_D("ignore core generic error");
+      status = NFCSTATUS_FAILED;
+    }
+    return status;
+  } else if (p_ntf[0] == 0x61 && p_ntf[1] == 0x21 && p_ntf[2] == 0x00) {
+    status = NFCSTATUS_FAILED;
+    NXPLOG_NCIHAL_D("ignore core generic error");
+    return status;
+  }
+  // 4200 02 00 01
+  else if (p_ntf[0] == 0x42 && p_ntf[1] == 0x00 && ee_disc_done == 0x01) {
+    NXPLOG_NCIHAL_D("Going through workaround - NFCEE_DISCOVER_RSP");
+    if (p_ntf[4] == 0x01) {
+      p_ntf[4] = 0x00;
+
+      ee_disc_done = 0x00;
+    }
+    NXPLOG_NCIHAL_D("Going through workaround - NFCEE_DISCOVER_RSP - END");
+
+  } else if (*p_len == 4 && p_ntf[0] == 0x4F && p_ntf[1] == 0x11 &&
+             p_ntf[2] == 0x01) {
+    if (p_ntf[3] == 0x00) {
+      NXPLOG_NCIHAL_D(
+          ">  Workaround for ISO-DEP Presence Check, ignore response and wait "
+          "for notification");
+      p_ntf[0] = 0x60;
+      p_ntf[1] = 0x06;
+      p_ntf[2] = 0x03;
+      p_ntf[3] = 0x01;
+      p_ntf[4] = 0x00;
+      p_ntf[5] = 0x01;
+      *p_len = 6;
+    } else {
+      NXPLOG_NCIHAL_D(
+          ">  Workaround for ISO-DEP Presence Check, presence check return "
+          "failed");
+      p_ntf[0] = 0x60;
+      p_ntf[1] = 0x08;
+      p_ntf[2] = 0x02;
+      p_ntf[3] = 0xB2;
+      p_ntf[4] = 0x00;
+      *p_len = 5;
+    }
+  } else if (*p_len == 4 && p_ntf[0] == 0x6F && p_ntf[1] == 0x11 &&
+             p_ntf[2] == 0x01) {
+    if (p_ntf[3] == 0x01) {
+      NXPLOG_NCIHAL_D(
+          ">  Workaround for ISO-DEP Presence Check - Card still in field");
+      p_ntf[0] = 0x00;
+      p_ntf[1] = 0x00;
+      p_ntf[2] = 0x01;
+      p_ntf[3] = 0x7E;
+    } else {
+      NXPLOG_NCIHAL_D(
+          ">  Workaround for ISO-DEP Presence Check - Card not in field");
+      p_ntf[0] = 0x60;
+      p_ntf[1] = 0x08;
+      p_ntf[2] = 0x02;
+      p_ntf[3] = 0xB2;
+      p_ntf[4] = 0x00;
+      *p_len = 5;
+    }
+  }
+
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_ext_process_nfc_init_rsp
+ *
+ * Description      This function is used to process the HAL NFC core reset rsp
+ *                  and ntf and core init rsp of NCI 1.0 or NCI2.0 and update
+ *                  NCI version.
+ *                  It also handles error response such as core_reset_ntf with
+ *                  error status in both NCI2.0 and NCI1.0.
+ *
+ * Returns          Returns NFCSTATUS_SUCCESS if parsing response is successful
+ *                  or returns failure.
+ *
+ ******************************************************************************/
+static NFCSTATUS phNxpNciHal_ext_process_nfc_init_rsp(uint8_t *p_ntf,
+                                                      uint16_t *p_len) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  /* Parsing CORE_RESET_RSP and CORE_RESET_NTF to update NCI version.*/
+  if (p_ntf == NULL || *p_len < 2) {
+    return NFCSTATUS_FAILED;
+  }
+  if (p_ntf[0] == NCI_MT_RSP &&
+      ((p_ntf[1] & NCI_OID_MASK) == NCI_MSG_CORE_RESET)) {
+    if (*p_len < 4) {
+      android_errorWriteLog(0x534e4554, "169258455");
+      return NFCSTATUS_FAILED;
+    }
+    if (p_ntf[2] == 0x01 && p_ntf[3] == 0x00) {
+      NXPLOG_NCIHAL_D("CORE_RESET_RSP NCI2.0");
+      if (nxpncihal_ctrl.hal_ext_enabled == TRUE &&
+          nxpncihal_ctrl.fwdnld_mode_reqd != TRUE) {
+        nxpncihal_ctrl.nci_info.wait_for_ntf = TRUE;
+      }
+    } else if (p_ntf[2] == 0x03 && p_ntf[3] == 0x00) {
+      if (*p_len < 5) {
+        android_errorWriteLog(0x534e4554, "169258455");
+        return NFCSTATUS_FAILED;
+      }
+      NXPLOG_NCIHAL_D("CORE_RESET_RSP NCI1.0");
+      nxpncihal_ctrl.nci_info.nci_version = p_ntf[4];
+    } else
+      status = NFCSTATUS_FAILED;
+  } else if (p_ntf[0] == NCI_MT_NTF &&
+             ((p_ntf[1] & NCI_OID_MASK) == NCI_MSG_CORE_RESET)) {
+    if (*p_len < 4) {
+      android_errorWriteLog(0x534e4554, "169258455");
+      return NFCSTATUS_FAILED;
+    }
+    if (p_ntf[3] == CORE_RESET_TRIGGER_TYPE_CORE_RESET_CMD_RECEIVED ||
+        p_ntf[3] == CORE_RESET_TRIGGER_TYPE_MODE_SWITCH_TO_NFC_FORUM ||
+        p_ntf[3] == CORE_RESET_TRIGGER_TYPE_MODE_SWITCH_TO_EMVCO) {
+      if (*p_len < 6) {
+        android_errorWriteLog(0x534e4554, "169258455");
+        return NFCSTATUS_FAILED;
+      }
+      NXPLOG_NCIHAL_D("CORE_RESET_NTF NCI2.0 reason CORE_RESET_CMD received !");
+      nxpncihal_ctrl.nci_info.nci_version = p_ntf[5];
+      if (!nxpncihal_ctrl.hal_open_status)
+        phNxpNciHal_configFeatureList(p_ntf, *p_len);
+      int len = p_ntf[2] + 2; /*include 2 byte header*/
+      if (len != *p_len - 1) {
+        NXPLOG_NCIHAL_E(
+            "phNxpNciHal_ext_process_nfc_init_rsp invalid NTF length");
+        android_errorWriteLog(0x534e4554, "121263487");
+        return NFCSTATUS_FAILED;
+      }
+      wFwVerRsp = (((uint32_t)p_ntf[len - 2]) << 16U) |
+                  (((uint32_t)p_ntf[len - 1]) << 8U) | p_ntf[len];
+      NXPLOG_NCIHAL_D("NxpNci> FW Version: %x.%x.%x", p_ntf[len - 2],
+                      p_ntf[len - 1], p_ntf[len]);
+    } else {
+      uint32_t i;
+      char print_buffer[*p_len * 3 + 1];
+
+      memset(print_buffer, 0, sizeof(print_buffer));
+      for (i = 0; i < *p_len; i++) {
+        snprintf(&print_buffer[i * 2], 3, "%02X", p_ntf[i]);
+      }
+      NXPLOG_NCIHAL_D("CORE_RESET_NTF received !");
+      NXPLOG_NCIR_E("len = %3d > %s", *p_len, print_buffer);
+      phNxpNciHal_emergency_recovery(p_ntf[3]);
+      status = NFCSTATUS_FAILED;
+    } /* Parsing CORE_INIT_RSP*/
+  } else if (p_ntf[0] == NCI_MT_RSP &&
+             ((p_ntf[1] & NCI_OID_MASK) == NCI_MSG_CORE_INIT)) {
+    if (nxpncihal_ctrl.nci_info.nci_version == NCI_VERSION_2_0) {
+      NXPLOG_NCIHAL_D("CORE_INIT_RSP NCI2.0 received !");
+      if (nfcFL.chipType >= sn220u) {
+        /* Remove NFC-DEP interface support from INIT RESP */
+        RemoveNfcDepIntfFromInitResp(p_ntf, p_len);
+      }
+    } else {
+      NXPLOG_NCIHAL_D("CORE_INIT_RSP NCI1.0 received !");
+      if (!nxpncihal_ctrl.hal_open_status &&
+          nxpncihal_ctrl.nci_info.nci_version != NCI_VERSION_2_0) {
+        phNxpNciHal_configFeatureList(p_ntf, *p_len);
+      }
+      if (*p_len < 3) {
+        android_errorWriteLog(0x534e4554, "169258455");
+        return NFCSTATUS_FAILED;
+      }
+      int len = p_ntf[2] + 2; /*include 2 byte header*/
+      if (len != *p_len - 1) {
+        NXPLOG_NCIHAL_E(
+            "phNxpNciHal_ext_process_nfc_init_rsp invalid NTF length");
+        android_errorWriteLog(0x534e4554, "121263487");
+        return NFCSTATUS_FAILED;
+      }
+      wFwVerRsp = (((uint32_t)p_ntf[len - 2]) << 16U) |
+                  (((uint32_t)p_ntf[len - 1]) << 8U) | p_ntf[len];
+      if (wFwVerRsp == 0)
+        status = NFCSTATUS_FAILED;
+      iCoreInitRspLen = *p_len;
+      memcpy(bCoreInitRsp, p_ntf, *p_len);
+      NXPLOG_NCIHAL_D("NxpNci> FW Version: %x.%x.%x", p_ntf[len - 2],
+                      p_ntf[len - 1], p_ntf[len]);
+    }
+  }
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_process_ext_cmd_rsp
+ *
+ * Description      This function process the extension command response. It
+ *                  also checks the received response to expected response.
+ *
+ * Returns          returns NFCSTATUS_SUCCESS if response is as expected else
+ *                  returns failure.
+ *
+ ******************************************************************************/
+static NFCSTATUS phNxpNciHal_process_ext_cmd_rsp(uint16_t cmd_len,
+                                                 uint8_t *p_cmd) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  uint16_t data_written = 0;
+
+  /* Check NCI Command is well formed */
+  if (!phTmlNfc_IsFwDnldModeEnabled() &&
+      (cmd_len != (p_cmd[2] + NCI_MODE_HEADER_LEN))) {
+    NXPLOG_NCIHAL_E("NCI command not well formed");
+    return NFCSTATUS_FAILED;
+  }
+
+  /* Create the local semaphore */
+  if (phNxpNciHal_init_cb_data(&nxpncihal_ctrl.ext_cb_data, NULL) !=
+      NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_D("Create ext_cb_data failed");
+    return NFCSTATUS_FAILED;
+  }
+
+  nxpncihal_ctrl.ext_cb_data.status = NFCSTATUS_SUCCESS;
+
+  /* Send ext command */
+  data_written = phNxpNciHal_write_unlocked(cmd_len, p_cmd, ORIG_NXPHAL);
+  if (data_written != cmd_len) {
+    NXPLOG_NCIHAL_D("phNxpNciHal_write failed for hal ext");
+    goto clean_and_return;
+  }
+
+  /* Start timer */
+  status = phOsalNfc_Timer_Start(timeoutTimerId, HAL_EXTNS_WRITE_RSP_TIMEOUT,
+                                 &hal_extns_write_rsp_timeout_cb, NULL);
+  if (NFCSTATUS_SUCCESS == status) {
+    NXPLOG_NCIHAL_D("Response timer started");
+  } else {
+    NXPLOG_NCIHAL_E("Response timer not started!!!");
+    status = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  /* Wait for rsp */
+  NXPLOG_NCIHAL_D("Waiting after ext cmd sent");
+  if (SEM_WAIT(nxpncihal_ctrl.ext_cb_data)) {
+    NXPLOG_NCIHAL_E("p_hal_ext->ext_cb_data.sem semaphore error");
+    goto clean_and_return;
+  }
+
+  /* Stop Timer */
+  status = phOsalNfc_Timer_Stop(timeoutTimerId);
+  if (NFCSTATUS_SUCCESS == status) {
+    NXPLOG_NCIHAL_D("Response timer stopped");
+  } else {
+    NXPLOG_NCIHAL_E("Response timer stop ERROR!!!");
+    status = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  if (cmd_len < 3) {
+    android_errorWriteLog(0x534e4554, "153880630");
+    status = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  /* No NTF expected for OMAPI command */
+  if (p_cmd[0] == 0x2F && p_cmd[1] == 0x1 && p_cmd[2] == 0x01) {
+    nxpncihal_ctrl.nci_info.wait_for_ntf = FALSE;
+  }
+  /* Start timer to wait for NTF*/
+  if (nxpncihal_ctrl.nci_info.wait_for_ntf == TRUE) {
+    status = phOsalNfc_Timer_Start(timeoutTimerId, HAL_EXTNS_WRITE_RSP_TIMEOUT,
+                                   &hal_extns_write_rsp_timeout_cb, NULL);
+    if (NFCSTATUS_SUCCESS == status) {
+      NXPLOG_NCIHAL_D("Response timer started");
+    } else {
+      NXPLOG_NCIHAL_E("Response timer not started!!!");
+      status = NFCSTATUS_FAILED;
+      goto clean_and_return;
+    }
+    if (SEM_WAIT(nxpncihal_ctrl.ext_cb_data)) {
+      NXPLOG_NCIHAL_E("p_hal_ext->ext_cb_data.sem semaphore error");
+      /* Stop Timer */
+      status = phOsalNfc_Timer_Stop(timeoutTimerId);
+      goto clean_and_return;
+    }
+    status = phOsalNfc_Timer_Stop(timeoutTimerId);
+    if (NFCSTATUS_SUCCESS == status) {
+      NXPLOG_NCIHAL_D("Response timer stopped");
+    } else {
+      NXPLOG_NCIHAL_E("Response timer stop ERROR!!!");
+      status = NFCSTATUS_FAILED;
+      goto clean_and_return;
+    }
+  }
+
+  if (nxpncihal_ctrl.ext_cb_data.status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E(
+        "Callback Status is failed!! Timer Expired!! Couldn't read it! 0x%x",
+        nxpncihal_ctrl.ext_cb_data.status);
+    status = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  NXPLOG_NCIHAL_D("Checking response");
+  status = NFCSTATUS_SUCCESS;
+
+  /*Response check for Set config, Core Reset & Core init command sent part of
+   * HAL_EXT*/
+  if (nxpncihal_ctrl.p_rx_data[0] == 0x40 &&
+      nxpncihal_ctrl.p_rx_data[1] <= 0x02 &&
+      nxpncihal_ctrl.p_rx_data[2] != 0x00) {
+    status = nxpncihal_ctrl.p_rx_data[3];
+    if (status != NCI_STATUS_OK) {
+      /*Add 500ms delay for FW to flush circular buffer */
+      usleep(500 * 1000);
+      NXPLOG_NCIHAL_D("Status Failed. Status = 0x%02x", status);
+    }
+  }
+
+  /*Response check for SYSTEM SET SERVICE STATUS command sent as part of
+   * HAL_EXT*/
+  if (nfcFL.chipType >= sn220u && nxpncihal_ctrl.p_rx_data[0] == 0x4F &&
+      nxpncihal_ctrl.p_rx_data[1] == 0x01 &&
+      nxpncihal_ctrl.p_rx_data[2] != 0x00) {
+    status = nxpncihal_ctrl.p_rx_data[3];
+  }
+
+clean_and_return:
+  phNxpNciHal_cleanup_cb_data(&nxpncihal_ctrl.ext_cb_data);
+  nxpncihal_ctrl.nci_info.wait_for_ntf = FALSE;
+  HAL_DISABLE_EXT();
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_write_ext
+ *
+ * Description      This function inform the status of phNxpNciHal_open
+ *                  function to libnfc-nci.
+ *
+ * Returns          It return NFCSTATUS_SUCCESS then continue with send else
+ *                  sends NFCSTATUS_FAILED direct response is prepared and
+ *                  do not send anything to NFCC.
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_write_ext(uint16_t *cmd_len, uint8_t *p_cmd_data,
+                                uint16_t *rsp_len, uint8_t *p_rsp_data) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  if (phNxpDta_IsEnable() == true) {
+    status = phNxpNHal_DtaUpdate(cmd_len, p_cmd_data, rsp_len, p_rsp_data);
+  }
+
+  if (p_cmd_data[0] == PROPRIETARY_CMD_FELICA_READER_MODE &&
+      p_cmd_data[1] == PROPRIETARY_CMD_FELICA_READER_MODE &&
+      p_cmd_data[2] == PROPRIETARY_CMD_FELICA_READER_MODE) {
+    NXPLOG_NCIHAL_D("Received proprietary command to set Felica Reader mode:%d",
+                    p_cmd_data[3]);
+    gFelicaReaderMode = p_cmd_data[3];
+    /* frame the fake response */
+    *rsp_len = 4;
+    p_rsp_data[0] = 0x00;
+    p_rsp_data[1] = 0x00;
+    p_rsp_data[2] = 0x00;
+    p_rsp_data[3] = 0x00;
+    status = NFCSTATUS_FAILED;
+  } else if (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02 &&
+             (p_cmd_data[2] == 0x05 || p_cmd_data[2] == 0x32) &&
+             (p_cmd_data[3] == 0x01 || p_cmd_data[3] == 0x02) &&
+             p_cmd_data[4] == 0xA0 && p_cmd_data[5] == 0x44 &&
+             p_cmd_data[6] == 0x01 && p_cmd_data[7] == 0x01) {
+    nxpprofile_ctrl.profile_type = EMV_CO_PROFILE;
+    NXPLOG_NCIHAL_D("EMV_CO_PROFILE mode - Enabled");
+    status = NFCSTATUS_SUCCESS;
+  } else if (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02 &&
+             (p_cmd_data[2] == 0x05 || p_cmd_data[2] == 0x32) &&
+             (p_cmd_data[3] == 0x01 || p_cmd_data[3] == 0x02) &&
+             p_cmd_data[4] == 0xA0 && p_cmd_data[5] == 0x44 &&
+             p_cmd_data[6] == 0x01 && p_cmd_data[7] == 0x00) {
+    NXPLOG_NCIHAL_D("NFC_FORUM_PROFILE mode - Enabled");
+    nxpprofile_ctrl.profile_type = NFC_FORUM_PROFILE;
+    status = NFCSTATUS_SUCCESS;
+  }
+
+  if (nxpprofile_ctrl.profile_type == EMV_CO_PROFILE) {
+    if (p_cmd_data[0] == 0x21 && p_cmd_data[1] == 0x06 &&
+        p_cmd_data[2] == 0x01 && p_cmd_data[3] == 0x03) {
+#if 0
+            //Needs clarification whether to keep it or not
+            NXPLOG_NCIHAL_D ("EmvCo Poll mode - RF Deactivate discard");
+            phNxpNciHal_print_packet("SEND", p_cmd_data, *cmd_len);
+            *rsp_len = 4;
+            p_rsp_data[0] = 0x41;
+            p_rsp_data[1] = 0x06;
+            p_rsp_data[2] = 0x01;
+            p_rsp_data[3] = 0x00;
+            phNxpNciHal_print_packet("RECV", p_rsp_data, 4);
+            status = NFCSTATUS_FAILED;
+#endif
+    } else if (p_cmd_data[0] == 0x21 && p_cmd_data[1] == 0x03) {
+      NXPLOG_NCIHAL_D("EmvCo Poll mode - Discover map only for A and B");
+      p_cmd_data[2] = 0x05;
+      p_cmd_data[3] = 0x02;
+      p_cmd_data[4] = 0x00;
+      p_cmd_data[5] = 0x01;
+      p_cmd_data[6] = 0x01;
+      p_cmd_data[7] = 0x01;
+      *cmd_len = 8;
+    }
+  }
+
+  if (mfc_mode == true && p_cmd_data[0] == 0x21 && p_cmd_data[1] == 0x03) {
+    NXPLOG_NCIHAL_D("EmvCo Poll mode - Discover map only for A and B");
+    p_cmd_data[2] = 0x03;
+    p_cmd_data[3] = 0x01;
+    p_cmd_data[4] = 0x00;
+    p_cmd_data[5] = 0x01;
+    *cmd_len = 6;
+    mfc_mode = false;
+  }
+
+  if (*cmd_len <= (NCI_MAX_DATA_LEN - 3) && bEnableMfcReader &&
+      (p_cmd_data[0] == 0x21 && p_cmd_data[1] == 0x00) &&
+      (nxpprofile_ctrl.profile_type == NFC_FORUM_PROFILE)) {
+    unsigned long retval = 0;
+    if (p_cmd_data[2] == 0x04 && p_cmd_data[3] == 0x01 &&
+        p_cmd_data[4] == 0x80 && p_cmd_data[5] == 0x01 &&
+        p_cmd_data[6] == 0x83) {
+      mfc_mode = true;
+    } else {
+      if (!GetNxpNumValue(NAME_MIFARE_READER_ENABLE, &retval,
+                          sizeof(unsigned long))) {
+        NXPLOG_NCIHAL_E(
+            "Reading of MIFARE_READER_ENABLE failed. Default retval = %lu",
+            retval);
+      }
+      if (retval == 0x01) {
+        NXPLOG_NCIHAL_D("Going through extns - Adding Mifare in RF Discovery");
+        p_cmd_data[2] += 3;
+        p_cmd_data[3] += 1;
+        p_cmd_data[*cmd_len] = 0x80;
+        p_cmd_data[*cmd_len + 1] = 0x01;
+        p_cmd_data[*cmd_len + 2] = 0x80;
+        *cmd_len += 3;
+        status = NFCSTATUS_SUCCESS;
+        NXPLOG_NCIHAL_D(
+            "Going through extns - Adding Mifare in RF Discovery - END");
+      }
+    }
+  } else if ((*cmd_len >= 6) &&
+             (p_cmd_data[3] == 0x81 && p_cmd_data[4] == 0x01 &&
+              p_cmd_data[5] == 0x03)) {
+    NXPLOG_NCIHAL_D("> Going through the set host list");
+    if (nfcFL.chipType >= sn100u) {
+      *cmd_len = 10;
+
+      p_cmd_data[2] = 0x07;
+
+      p_cmd_data[6] = 0x02;
+      p_cmd_data[7] = 0x80;
+      p_cmd_data[8] = 0x81;
+      p_cmd_data[9] = 0xC0;
+    } else {
+      *cmd_len = 8;
+
+      p_cmd_data[2] = 0x05;
+      p_cmd_data[6] = 0x02;
+      p_cmd_data[7] = 0xC0;
+    }
+    status = NFCSTATUS_SUCCESS;
+  } else if (icode_detected) {
+    if (nfcFL.chipType < sn100u && (p_cmd_data[3] & 0x40) == 0x40 &&
+        (p_cmd_data[4] == 0x21 || p_cmd_data[4] == 0x22 ||
+         p_cmd_data[4] == 0x24 || p_cmd_data[4] == 0x27 ||
+         p_cmd_data[4] == 0x28 || p_cmd_data[4] == 0x29 ||
+         p_cmd_data[4] == 0x2a)) {
+      NXPLOG_NCIHAL_D("> Send EOF set");
+      icode_send_eof = 1;
+    }
+
+    if (p_cmd_data[3] == 0x20 || p_cmd_data[3] == 0x24 ||
+        p_cmd_data[3] == 0x60) {
+      NXPLOG_NCIHAL_D("> NFC ISO_15693 Proprietary CMD ");
+      p_cmd_data[3] += 0x02;
+    }
+  } else if (p_cmd_data[0] == 0x21 && p_cmd_data[1] == 0x03) {
+    NXPLOG_NCIHAL_D("> Polling Loop Started");
+    icode_detected = 0;
+    if (nfcFL.chipType < sn100u) {
+      icode_send_eof = 0;
+    }
+  }
+  // 22000100
+  else if (p_cmd_data[0] == 0x22 && p_cmd_data[1] == 0x00 &&
+           p_cmd_data[2] == 0x01 && p_cmd_data[3] == 0x00) {
+    // ee_disc_done = 0x01;//Reader Over SWP event getting
+    *rsp_len = 0x05;
+    p_rsp_data[0] = 0x42;
+    p_rsp_data[1] = 0x00;
+    p_rsp_data[2] = 0x02;
+    p_rsp_data[3] = 0x00;
+    p_rsp_data[4] = 0x00;
+    phNxpNciHal_print_packet("RECV", p_rsp_data, 5);
+    status = NFCSTATUS_FAILED;
+  }
+  // 2002 0904 3000 3100 3200 5000
+  else if ((p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02) &&
+           ((p_cmd_data[2] == 0x09 && p_cmd_data[3] == 0x04) /*||
+            (p_cmd_data[2] == 0x0D && p_cmd_data[3] == 0x04)*/
+            )) {
+    *cmd_len += 0x01;
+    p_cmd_data[2] += 0x01;
+    p_cmd_data[9] = 0x01;
+    p_cmd_data[10] = 0x40;
+    p_cmd_data[11] = 0x50;
+    p_cmd_data[12] = 0x00;
+
+    NXPLOG_NCIHAL_D("> Going through workaround - Dirty Set Config ");
+    //        phNxpNciHal_print_packet("SEND", p_cmd_data, *cmd_len);
+    NXPLOG_NCIHAL_D("> Going through workaround - Dirty Set Config - End ");
+  }
+  //    20020703300031003200
+  //    2002 0301 3200
+  else if ((p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02) &&
+           ((p_cmd_data[2] == 0x07 && p_cmd_data[3] == 0x03) ||
+            (p_cmd_data[2] == 0x03 && p_cmd_data[3] == 0x01 &&
+             p_cmd_data[4] == 0x32))) {
+    NXPLOG_NCIHAL_D("> Going through workaround - Dirty Set Config ");
+    phNxpNciHal_print_packet("SEND", p_cmd_data, *cmd_len);
+    *rsp_len = 5;
+    p_rsp_data[0] = 0x40;
+    p_rsp_data[1] = 0x02;
+    p_rsp_data[2] = 0x02;
+    p_rsp_data[3] = 0x00;
+    p_rsp_data[4] = 0x00;
+
+    phNxpNciHal_print_packet("RECV", p_rsp_data, 5);
+    status = NFCSTATUS_FAILED;
+    NXPLOG_NCIHAL_D("> Going through workaround - Dirty Set Config - End ");
+  }
+
+  // 2002 0D04 300104 310100 320100 500100
+  // 2002 0401 320100
+  else if ((p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02) &&
+           (
+               /*(p_cmd_data[2] == 0x0D && p_cmd_data[3] == 0x04)*/
+               (p_cmd_data[2] == 0x04 && p_cmd_data[3] == 0x01 &&
+                p_cmd_data[4] == 0x32 && p_cmd_data[5] == 0x00))) {
+    //        p_cmd_data[12] = 0x40;
+
+    NXPLOG_NCIHAL_D("> Going through workaround - Dirty Set Config ");
+    phNxpNciHal_print_packet("SEND", p_cmd_data, *cmd_len);
+    p_cmd_data[6] = 0x60;
+
+    phNxpNciHal_print_packet("RECV", p_rsp_data, 5);
+    //        status = NFCSTATUS_FAILED;
+    NXPLOG_NCIHAL_D("> Going through workaround - Dirty Set Config - End ");
+  }
+#if 0
+    else if ( (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02 ) &&
+                 ((p_cmd_data[2] == 0x09 && p_cmd_data[3] == 0x04) ||
+                     (p_cmd_data[2] == 0x0B && p_cmd_data[3] == 0x05) ||
+                     (p_cmd_data[2] == 0x07 && p_cmd_data[3] == 0x02) ||
+                     (p_cmd_data[2] == 0x0A && p_cmd_data[3] == 0x03) ||
+                     (p_cmd_data[2] == 0x0A && p_cmd_data[3] == 0x04) ||
+                     (p_cmd_data[2] == 0x05 && p_cmd_data[3] == 0x02))
+             )
+    {
+        NXPLOG_NCIHAL_D ("> Going through workaround - Dirty Set Config ");
+        phNxpNciHal_print_packet("SEND", p_cmd_data, *cmd_len);
+        *rsp_len = 5;
+        p_rsp_data[0] = 0x40;
+        p_rsp_data[1] = 0x02;
+        p_rsp_data[2] = 0x02;
+        p_rsp_data[3] = 0x00;
+        p_rsp_data[4] = 0x00;
+
+        phNxpNciHal_print_packet("RECV", p_rsp_data, 5);
+        status = NFCSTATUS_FAILED;
+        NXPLOG_NCIHAL_D ("> Going through workaround - Dirty Set Config - End ");
+    }
+
+    else if((p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02) &&
+           ((p_cmd_data[3] == 0x00) ||
+           ((*cmd_len >= 0x06) && (p_cmd_data[5] == 0x00)))) /*If the length of the first param id is zero don't allow*/
+    {
+        NXPLOG_NCIHAL_D ("> Going through workaround - Dirty Set Config ");
+        phNxpNciHal_print_packet("SEND", p_cmd_data, *cmd_len);
+        *rsp_len = 5;
+        p_rsp_data[0] = 0x40;
+        p_rsp_data[1] = 0x02;
+        p_rsp_data[2] = 0x02;
+        p_rsp_data[3] = 0x00;
+        p_rsp_data[4] = 0x00;
+
+        phNxpNciHal_print_packet("RECV", p_rsp_data, 5);
+        status = NFCSTATUS_FAILED;
+        NXPLOG_NCIHAL_D ("> Going through workaround - Dirty Set Config - End ");
+    }
+#endif
+  else if ((wFwVerRsp & 0x0000FFFF) == wFwVer) {
+    /* skip CORE_RESET and CORE_INIT from Brcm */
+    if (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x00 &&
+        p_cmd_data[2] == 0x01 && p_cmd_data[3] == 0x01) {
+      //            *rsp_len = 6;
+      //
+      //            NXPLOG_NCIHAL_D("> Going - core reset optimization");
+      //
+      //            p_rsp_data[0] = 0x40;
+      //            p_rsp_data[1] = 0x00;
+      //            p_rsp_data[2] = 0x03;
+      //            p_rsp_data[3] = 0x00;
+      //            p_rsp_data[4] = 0x10;
+      //            p_rsp_data[5] = 0x01;
+      //
+      //            status = NFCSTATUS_FAILED;
+      //            NXPLOG_NCIHAL_D("> Going - core reset optimization - END");
+    }
+    /* CORE_INIT */
+    else if (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x01 &&
+             p_cmd_data[2] == 0x00) {
+      //            NXPLOG_NCIHAL_D("> Going - core init optimization");
+      //            *rsp_len = iCoreInitRspLen;
+      //            memcpy(p_rsp_data, bCoreInitRsp, iCoreInitRspLen);
+      //            status = NFCSTATUS_FAILED;
+      //            NXPLOG_NCIHAL_D("> Going - core init optimization - END");
+    }
+  }
+
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_send_ext_cmd
+ *
+ * Description      This function send the extension command to NFCC. No
+ *                  response is checked by this function but it waits for
+ *                  the response to come.
+ *
+ * Returns          Returns NFCSTATUS_SUCCESS if sending cmd is successful and
+ *                  response is received.
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_send_ext_cmd(uint16_t cmd_len, uint8_t *p_cmd) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  nxpncihal_ctrl.cmd_len = cmd_len;
+  memcpy(nxpncihal_ctrl.p_cmd_data, p_cmd, cmd_len);
+  status = phNxpNciHal_process_ext_cmd_rsp(nxpncihal_ctrl.cmd_len,
+                                           nxpncihal_ctrl.p_cmd_data);
+
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_send_ese_hal_cmd
+ *
+ * Description      This function send the extension command to NFCC. No
+ *                  response is checked by this function but it waits for
+ *                  the response to come.
+ *
+ * Returns          Returns NFCSTATUS_SUCCESS if sending cmd is successful and
+ *                  response is received.
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_send_ese_hal_cmd(uint16_t cmd_len, uint8_t *p_cmd) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  if (cmd_len > NCI_MAX_DATA_LEN) {
+    NXPLOG_NCIHAL_E("cmd_len exceeds limit NCI_MAX_DATA_LEN");
+    return status;
+  }
+  nxpncihal_ctrl.cmd_len = cmd_len;
+  memcpy(nxpncihal_ctrl.p_cmd_data, p_cmd, cmd_len);
+  status = phNxpNciHal_process_ext_cmd_rsp(nxpncihal_ctrl.cmd_len,
+                                           nxpncihal_ctrl.p_cmd_data);
+  return status;
+}
+
+/******************************************************************************
+ * Function         hal_extns_write_rsp_timeout_cb
+ *
+ * Description      Timer call back function
+ *
+ * Returns          None
+ *
+ ******************************************************************************/
+static void hal_extns_write_rsp_timeout_cb(uint32_t timerId, void *pContext) {
+  UNUSED_PROP(timerId);
+  UNUSED_PROP(pContext);
+  NXPLOG_NCIHAL_D("hal_extns_write_rsp_timeout_cb - write timeout!!!");
+  nxpncihal_ctrl.ext_cb_data.status = NFCSTATUS_FAILED;
+  usleep(1);
+  sem_post(&(nxpncihal_ctrl.syncSpiNfc));
+  SEM_POST(&(nxpncihal_ctrl.ext_cb_data));
+
+  return;
+}
+
+/*******************************************************************************
+ **
+ ** Function:        request_EEPROM()
+ **
+ ** Description:     get and set EEPROM data
+ **                  In case of request_modes GET_EEPROM_DATA or
+ *SET_EEPROM_DATA,
+ **                   1.caller has to pass the buffer and the length of data
+ *required
+ **                     to be read/written.
+ **                   2.Type of information required to be read/written
+ **                     (Example - EEPROM_RF_CFG)
+ **
+ ** Returns:         Returns NFCSTATUS_SUCCESS if sending cmd is successful and
+ **                  status failed if not successful
+ **
+ *******************************************************************************/
+NFCSTATUS request_EEPROM(phNxpNci_EEPROM_info_t *mEEPROM_info) {
+  NXPLOG_NCIHAL_D(
+      "%s Enter  request_type : 0x%02x,  request_mode : 0x%02x,  bufflen : "
+      "0x%02x",
+      __func__, mEEPROM_info->request_type, mEEPROM_info->request_mode,
+      mEEPROM_info->bufflen);
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  uint8_t retry_cnt = 0;
+  uint8_t getCfgStartIndex = 0x08;
+  uint8_t setCfgStartIndex = 0x07;
+  uint8_t memIndex = 0x00;
+  uint8_t fieldLen = 0x01; // Memory field len 1bytes
+  char addr[2] = {0};
+  uint8_t cur_value = 0, len = 5;
+  uint8_t b_position = 0;
+  bool_t update_req = false;
+  uint16_t set_cfg_cmd_len = 0;
+  uint8_t *set_cfg_eeprom, *base_addr;
+
+  mEEPROM_info->update_mode = BITWISE;
+
+  switch (mEEPROM_info->request_type) {
+  case EEPROM_RF_CFG:
+    memIndex = 0x00;
+    fieldLen = 0x20;
+    len = fieldLen + 4; // 4 - numParam+2add+val
+    addr[0] = 0xA0;
+    addr[1] = 0x14;
+    mEEPROM_info->update_mode = BYTEWISE;
+    break;
+
+  case EEPROM_FW_DWNLD:
+    fieldLen = 0x20;
+    memIndex = 0x0C;
+    len = fieldLen + 4;
+    addr[0] = 0xA0;
+    addr[1] = 0x0F;
+    mEEPROM_info->update_mode = BYTEWISE;
+    break;
+
+  case EEPROM_WIREDMODE_RESUME_TIMEOUT:
+    mEEPROM_info->update_mode = BYTEWISE;
+    memIndex = 0x00;
+    fieldLen = 0x04;
+    len = fieldLen + 4;
+    addr[0] = 0xA0;
+    addr[1] = 0xFC;
+    break;
+
+  case EEPROM_ESE_SVDD_POWER:
+    b_position = 0;
+    memIndex = 0x00;
+    addr[0] = 0xA0;
+    addr[1] = 0xF2;
+    break;
+  case EEPROM_ESE_POWER_EXT_PMU:
+    mEEPROM_info->update_mode = BYTEWISE;
+    memIndex = 0x00;
+    addr[0] = 0xA0;
+    addr[1] = 0xD7;
+    break;
+
+  case EEPROM_PROP_ROUTING:
+    b_position = 7;
+    memIndex = 0x00;
+    addr[0] = 0xA0;
+    addr[1] = 0x98;
+    break;
+
+  case EEPROM_ESE_SESSION_ID:
+    b_position = 0;
+    memIndex = 0x00;
+    addr[0] = 0xA0;
+    addr[1] = 0xEB;
+    break;
+
+  case EEPROM_SWP1_INTF:
+    b_position = 0;
+    memIndex = 0x00;
+    addr[0] = 0xA0;
+    addr[1] = 0xEC;
+    break;
+
+  case EEPROM_SWP1A_INTF:
+    b_position = 0;
+    memIndex = 0x00;
+    addr[0] = 0xA0;
+    addr[1] = 0xD4;
+    break;
+  case EEPROM_SWP2_INTF:
+    b_position = 0;
+    memIndex = 0x00;
+    addr[0] = 0xA0;
+    addr[1] = 0xED;
+    break;
+  case EEPROM_FLASH_UPDATE:
+    /* This flag is no more used in MW */
+    fieldLen = 0x20;
+    memIndex = 0x00;
+    len = fieldLen + 4;
+    addr[0] = 0xA0;
+    addr[1] = 0x0F;
+    break;
+  case EEPROM_AUTH_CMD_TIMEOUT:
+    mEEPROM_info->update_mode = BYTEWISE;
+    memIndex = 0x00;
+    fieldLen = 0x05;
+    len = fieldLen + 4;
+    addr[0] = 0xA0;
+    addr[1] = 0xF7;
+    break;
+  case EEPROM_GUARD_TIMER:
+    mEEPROM_info->update_mode = BYTEWISE;
+    memIndex = 0x00;
+    addr[0] = 0xA1;
+    addr[1] = 0x0B;
+    break;
+  case EEPROM_AUTONOMOUS_MODE:
+    mEEPROM_info->update_mode = BYTEWISE;
+    memIndex = 0x00;
+    addr[0] = 0xA0;
+    addr[1] = 0x15;
+    break;
+  case EEPROM_T4T_NFCEE_ENABLE:
+    mEEPROM_info->update_mode = BYTEWISE;
+    b_position = 0;
+    memIndex = 0x00;
+    addr[0] = 0xA0;
+    addr[1] = 0x95;
+    break;
+  case EEPROM_CE_PHONE_OFF_CFG:
+    mEEPROM_info->update_mode = BYTEWISE;
+    b_position = 0;
+    memIndex = 0x00;
+    addr[0] = 0xA0;
+    addr[1] = 0x8E;
+    break;
+  case EEPROM_ENABLE_VEN_CFG:
+    mEEPROM_info->update_mode = BYTEWISE;
+    b_position = 0;
+    memIndex = 0x00;
+    addr[0] = 0xA0;
+    addr[1] = 0x07;
+    break;
+  case EEPROM_ISODEP_MERGE_SAK:
+    mEEPROM_info->update_mode = BYTEWISE;
+    b_position = 0;
+    memIndex = 0x00;
+    addr[0] = 0xA1;
+    addr[1] = 0x1B;
+    break;
+  case EEPROM_SRD_TIMEOUT:
+    mEEPROM_info->update_mode = BYTEWISE;
+    memIndex = 0x00;
+    fieldLen = 0x02;
+    len = fieldLen + 4;
+    addr[0] = 0xA1;
+    addr[1] = 0x17;
+    break;
+  case EEPROM_UICC1_SESSION_ID:
+    fieldLen = mEEPROM_info->bufflen;
+    len = fieldLen + 4;
+    memIndex = 0x00;
+    addr[0] = 0xA0;
+    addr[1] = 0xE4;
+    mEEPROM_info->update_mode = BYTEWISE;
+    break;
+  case EEPROM_UICC2_SESSION_ID:
+    fieldLen = mEEPROM_info->bufflen;
+    len = fieldLen + 4;
+    memIndex = 0x00;
+    addr[0] = 0xA0;
+    addr[1] = 0xE5;
+    mEEPROM_info->update_mode = BYTEWISE;
+    break;
+  case EEPROM_CE_ACT_NTF:
+    mEEPROM_info->update_mode = BYTEWISE;
+    b_position = 0;
+    memIndex = 0x00;
+    addr[0] = 0xA0;
+    addr[1] = 0x96;
+    break;
+  case EEPROM_UICC_HCI_CE_STATE:
+    fieldLen = mEEPROM_info->bufflen;
+    len = fieldLen + 4;
+    memIndex = 0x00;
+    addr[0] = 0xA0;
+    addr[1] = 0xE6;
+    mEEPROM_info->update_mode = BYTEWISE;
+    break;
+  case EEPROM_EXT_FIELD_DETECT_MODE:
+    mEEPROM_info->update_mode = BYTEWISE;
+    b_position = 0;
+    memIndex = 0x00;
+    addr[0] = 0xA1;
+    addr[1] = 0x36;
+    break;
+  default:
+    ALOGE("No valid request information found");
+    break;
+  }
+
+  uint8_t get_cfg_eeprom[6] = {
+      0x20,             // get_cfg header
+      0x03,             // get_cfg header
+      0x03,             // len of following value
+      0x01,             // Num Parameters
+      (uint8_t)addr[0], // First byte of Address
+      (uint8_t)addr[1]  // Second byte of Address
+  };
+  uint8_t set_cfg_cmd_hdr[7] = {
+      0x20,             // set_cfg header
+      0x02,             // set_cfg header
+      len,              // len of following value
+      0x01,             // Num Param
+      (uint8_t)addr[0], // First byte of Address
+      (uint8_t)addr[1], // Second byte of Address
+      fieldLen          // Data len
+  };
+
+  set_cfg_cmd_len = sizeof(set_cfg_cmd_hdr) + fieldLen;
+  set_cfg_eeprom = (uint8_t *)malloc(set_cfg_cmd_len);
+  if (set_cfg_eeprom == NULL) {
+    ALOGE("memory allocation failed");
+    return status;
+  }
+  base_addr = set_cfg_eeprom;
+  memset(set_cfg_eeprom, 0, set_cfg_cmd_len);
+  memcpy(set_cfg_eeprom, set_cfg_cmd_hdr, sizeof(set_cfg_cmd_hdr));
+
+retryget:
+  status = phNxpNciHal_send_ext_cmd(sizeof(get_cfg_eeprom), get_cfg_eeprom);
+  if (status == NFCSTATUS_SUCCESS) {
+    status = nxpncihal_ctrl.p_rx_data[3];
+    if (status != NFCSTATUS_SUCCESS) {
+      ALOGE("failed to get requested memory address");
+    } else if (mEEPROM_info->request_mode == GET_EEPROM_DATA) {
+      if (mEEPROM_info->bufflen == 0xFF) {
+        /* Max bufferlenth for single Get Config Command is 0xFF.
+         * If buffer length set to max value, reassign buffer value
+         * depends on response from Get Config command */
+        mEEPROM_info->bufflen =
+            *(nxpncihal_ctrl.p_rx_data + getCfgStartIndex + memIndex - 1);
+      }
+      memcpy(mEEPROM_info->buffer,
+             nxpncihal_ctrl.p_rx_data + getCfgStartIndex + memIndex,
+             mEEPROM_info->bufflen);
+    } else if (mEEPROM_info->request_mode == SET_EEPROM_DATA) {
+      // Clear the buffer first
+      memset(set_cfg_eeprom + setCfgStartIndex, 0x00,
+             (set_cfg_cmd_len - setCfgStartIndex));
+
+      // copy get config data into set_cfg_eeprom
+      memcpy(set_cfg_eeprom + setCfgStartIndex,
+             nxpncihal_ctrl.p_rx_data + getCfgStartIndex, fieldLen);
+      if (mEEPROM_info->update_mode == BITWISE) {
+        cur_value =
+            (set_cfg_eeprom[setCfgStartIndex + memIndex] >> b_position) & 0x01;
+        if (cur_value != mEEPROM_info->buffer[0]) {
+          update_req = true;
+          if (mEEPROM_info->buffer[0] == 1) {
+            set_cfg_eeprom[setCfgStartIndex + memIndex] |= (1 << b_position);
+          } else if (mEEPROM_info->buffer[0] == 0) {
+            set_cfg_eeprom[setCfgStartIndex + memIndex] &= (~(1 << b_position));
+          }
+        }
+      } else if (mEEPROM_info->update_mode == BYTEWISE) {
+        if (memcmp(set_cfg_eeprom + setCfgStartIndex + memIndex,
+                   mEEPROM_info->buffer, mEEPROM_info->bufflen)) {
+          update_req = true;
+          memcpy(set_cfg_eeprom + setCfgStartIndex + memIndex,
+                 mEEPROM_info->buffer, mEEPROM_info->bufflen);
+        }
+      } else {
+        ALOGE("%s, invalid update mode", __func__);
+      }
+
+      if (update_req) {
+      // do set config
+      retryset:
+        status = phNxpNciHal_send_ext_cmd(set_cfg_cmd_len, set_cfg_eeprom);
+        if (status != NFCSTATUS_SUCCESS && retry_cnt < 3) {
+          retry_cnt++;
+          ALOGE("Set Cfg Retry cnt=%x", retry_cnt);
+          goto retryset;
+        }
+      } else {
+        ALOGD("%s: values are same no update required", __func__);
+      }
+    }
+  } else if (retry_cnt < 3) {
+    retry_cnt++;
+    ALOGE("Get Cfg Retry cnt=%x", retry_cnt);
+    goto retryget;
+  }
+
+  if (base_addr != NULL) {
+    free(base_addr);
+    base_addr = NULL;
+  }
+  retry_cnt = 0;
+  return status;
+}
+
+/*******************************************************************************
+ **
+ ** Function:        phNxpNciHal_enableDefaultUICC2SWPline()
+ **
+ ** Description:     Select UICC2 or UICC3
+ **
+ ** Returns:         status
+ **
+ ********************************************************************************/
+NFCSTATUS phNxpNciHal_enableDefaultUICC2SWPline(uint8_t uicc2_sel) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  uint8_t p_data[255] = {NCI_MT_CMD, NXP_CORE_SET_CONFIG_CMD};
+  uint8_t LEN_INDEX = 2, PARAM_INDEX = 3;
+  uint8_t *p = p_data;
+  NXPLOG_NCIHAL_D("phNxpNciHal_enableDefaultUICC2SWPline %d", uicc2_sel);
+  p_data[LEN_INDEX] = 1;
+  p += 4;
+  if (uicc2_sel == 0x03) {
+    UINT8_TO_STREAM(p, NXP_NFC_SET_CONFIG_PARAM_EXT);
+    UINT8_TO_STREAM(p, NXP_NFC_PARAM_ID_SWP2);
+    UINT8_TO_STREAM(p, 0x01);
+    UINT8_TO_STREAM(p, 0x01);
+    p_data[LEN_INDEX] += 4;
+    p_data[PARAM_INDEX] += 1;
+  }
+  if (uicc2_sel == 0x04) {
+    UINT8_TO_STREAM(p, NXP_NFC_SET_CONFIG_PARAM_EXT);
+    UINT8_TO_STREAM(p, NXP_NFC_PARAM_ID_SWPUICC3);
+    UINT8_TO_STREAM(p, 0x01);
+    UINT8_TO_STREAM(p, 0x01);
+    p_data[LEN_INDEX] += 4;
+    p_data[PARAM_INDEX] += 1;
+  }
+  if (p_data[PARAM_INDEX] > 0x00)
+    status = phNxpNciHal_send_ext_cmd(p - p_data, p_data);
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_prop_conf_lpcd
+ *
+ * Description      If NFCC is not in Nfc Forum mode, then this function will
+ *                  configure it back to the Nfc Forum mode.
+ *
+ * Returns          none
+ *
+ ******************************************************************************/
+void phNxpNciHal_prop_conf_lpcd(bool enableLPCD) {
+  uint8_t cmd_get_lpcdval[] = {0x20, 0x03, 0x03, 0x01, 0xA2, 0x7C};
+  vector<uint8_t> cmd_set_lpcdval{0x20, 0x02, 0x0C};
+  uint8_t coreStandBy[] = {0x2F, 0x00, 0x01, 0x01};
+
+  if (NFCSTATUS_SUCCESS ==
+      phNxpNciHal_send_ext_cmd(sizeof(cmd_get_lpcdval), cmd_get_lpcdval)) {
+    if (NFCSTATUS_SUCCESS == nxpncihal_ctrl.p_rx_data[3]) {
+      if (!(nxpncihal_ctrl.p_rx_data[11] & (1 << 7)) && enableLPCD) {
+        if (NFCSTATUS_SUCCESS !=
+            phNxpNciHal_send_ext_cmd(sizeof(coreStandBy), coreStandBy)) {
+          NXPLOG_NCIHAL_E("Failed to enable NFCC Standby while enabling LPCD");
+        }
+        nxpncihal_ctrl.p_rx_data[11] |= (1 << 7);
+        cmd_set_lpcdval.insert(
+            cmd_set_lpcdval.end(), &nxpncihal_ctrl.p_rx_data[4],
+            (&nxpncihal_ctrl.p_rx_data[4] + cmd_set_lpcdval[2]));
+        if (NFCSTATUS_SUCCESS ==
+            phNxpNciHal_send_ext_cmd(cmd_set_lpcdval.size(),
+                                     &cmd_set_lpcdval[0])) {
+          return;
+        }
+      } else if (!enableLPCD && (nxpncihal_ctrl.p_rx_data[11] & (1 << 7))) {
+        nxpncihal_ctrl.p_rx_data[11] &= ~(1 << 7);
+        cmd_set_lpcdval.insert(
+            cmd_set_lpcdval.end(), &nxpncihal_ctrl.p_rx_data[4],
+            (&nxpncihal_ctrl.p_rx_data[4] + cmd_set_lpcdval[2]));
+        if (NFCSTATUS_SUCCESS ==
+            phNxpNciHal_send_ext_cmd(cmd_set_lpcdval.size(),
+                                     &cmd_set_lpcdval[0])) {
+          return;
+        }
+      } else {
+        return;
+      }
+    }
+  }
+  NXPLOG_NCIHAL_E("%s: failed!!", __func__);
+  return;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_prop_conf_rssi
+ *
+ * Description      It resets RSSI param to default value.
+ *
+ * Returns          none
+ *
+ ******************************************************************************/
+void phNxpNciHal_prop_conf_rssi() {
+  if (nfcFL.chipType < sn220u) {
+    NXPLOG_NCIHAL_D("%s: feature is not supported", __func__);
+    return;
+  }
+  vector<uint8_t> cmd_get_rssival = {0x20, 0x03, 0x03, 0x01, 0xA1, 0x55};
+  vector<uint8_t> cmd_set_rssival = {0x20, 0x02, 0x06, 0x01, 0xA1,
+                                     0x55, 0x02, 0x00, 0x00};
+
+  if (NFCSTATUS_SUCCESS !=
+      phNxpNciHal_send_ext_cmd(cmd_get_rssival.size(), &cmd_get_rssival[0])) {
+    NXPLOG_NCIHAL_E("%s: failed!! Line:%d", __func__, __LINE__);
+    return;
+  }
+  if ((nxpncihal_ctrl.rx_data_len <= 9) ||
+      (NFCSTATUS_SUCCESS != nxpncihal_ctrl.p_rx_data[3])) {
+    NXPLOG_NCIHAL_E("%s: failed!! Line:%d", __func__, __LINE__);
+    return;
+  }
+  if ((nxpncihal_ctrl.p_rx_data[8] != 0x00) ||
+      (nxpncihal_ctrl.p_rx_data[9] != 0x00)) {
+    if (NFCSTATUS_SUCCESS !=
+        phNxpNciHal_send_ext_cmd(cmd_set_rssival.size(), &cmd_set_rssival[0])) {
+      NXPLOG_NCIHAL_E("%s: failed!! Line:%d", __func__, __LINE__);
+      return;
+    }
+  }
+
+  return;
+}
+#if (NXP_EXTNS != TRUE)
+/******************************************************************************
+ * Function         phNxpNciHal_conf_nfc_forum_mode
+ *
+ * Description      If NFCC is not in Nfc Forum mode, then this function will
+ *                  configure it back to the Nfc Forum mode.
+ *
+ * Returns          none
+ *
+ ******************************************************************************/
+void phNxpNciHal_conf_nfc_forum_mode() {
+  uint8_t cmd_get_emvcocfg[] = {0x20, 0x03, 0x03, 0x01, 0xA0, 0x44};
+  uint8_t cmd_reset_emvcocfg[8];
+  long cmdlen = 8;
+  long retlen = 0;
+
+  if (GetNxpByteArrayValue(NAME_NXP_PROP_RESET_EMVCO_CMD,
+                           (char *)cmd_reset_emvcocfg, cmdlen, &retlen)) {
+  }
+  if (retlen != 0x08) {
+    NXPLOG_NCIHAL_E("%s: command is not provided", __func__);
+    return;
+  }
+  /* Update the flag address from the Nxp config file */
+  cmd_get_emvcocfg[4] = cmd_reset_emvcocfg[4];
+  cmd_get_emvcocfg[5] = cmd_reset_emvcocfg[5];
+
+  if (NFCSTATUS_SUCCESS ==
+      phNxpNciHal_send_ext_cmd(sizeof(cmd_get_emvcocfg), cmd_get_emvcocfg)) {
+    if (NFCSTATUS_SUCCESS == nxpncihal_ctrl.p_rx_data[3]) {
+      if (0x01 & nxpncihal_ctrl.p_rx_data[8]) {
+        if (NFCSTATUS_SUCCESS ==
+            phNxpNciHal_send_ext_cmd(sizeof(cmd_reset_emvcocfg),
+                                     cmd_reset_emvcocfg)) {
+          return;
+        }
+      } else {
+        return;
+      }
+    }
+  }
+  NXPLOG_NCIHAL_E("%s: failed!!", __func__);
+  return;
+}
+#endif
+/******************************************************************************
+ * Function         RemoveNfcDepIntfFromInitResp
+ *
+ * Description      This function process the NCI_CORE_INIT_RESP & removes
+ *                  remove the NFC_DEP interface support and modify the
+ *                  CORE_INIT_RESP accordingly.
+ *
+ * Returns          None
+ *
+ ******************************************************************************/
+void RemoveNfcDepIntfFromInitResp(uint8_t *coreInitResp,
+                                  uint16_t *coreInitRespLen) {
+  /* As per NCI 2.0 index Number of Supported RF interfaces is 13 */
+  uint8_t indexOfSupportedRfIntf = 13;
+  /* as per NCI 2.0 Number of Supported RF Interfaces Payload field index is 13
+   * & 3 bytes for NCI_MSG_HEADER */
+  uint8_t noOfSupportedInterface =
+      *(coreInitResp + indexOfSupportedRfIntf + NCI_HEADER_SIZE);
+  uint8_t rfInterfacesLength =
+      *coreInitRespLen - (indexOfSupportedRfIntf + 1 + NCI_HEADER_SIZE);
+  uint8_t *supportedRfInterfaces = NULL;
+
+  if (noOfSupportedInterface) {
+    supportedRfInterfaces =
+        coreInitResp + indexOfSupportedRfIntf + 1 + NCI_HEADER_SIZE;
+  }
+  uint8_t *supportedRfInterfacesDetails = supportedRfInterfaces;
+  /* Get the index of Supported RF Interface for NFC-DEP interface in CORE_INIT
+   * Response*/
+  for (int i = 0; i < noOfSupportedInterface; i++) {
+    if (*supportedRfInterfaces == NCI_NFC_DEP_RF_INTF) {
+      break;
+    }
+    uint8_t noOfExtensions = *(supportedRfInterfaces + 1);
+    /* 2 bytes for RF interface type & length of Extensions */
+    supportedRfInterfaces += (2 + noOfExtensions);
+  }
+  /* If NFC-DEP is found in response then remove NFC-DEP from init response and
+   * frame new CORE_INIT_RESP and send to upper layer*/
+  if (supportedRfInterfaces && *supportedRfInterfaces == NCI_NFC_DEP_RF_INTF) {
+    coreInitResp[16] = noOfSupportedInterface - 1;
+    uint8_t noBytesToSkipForNfcDep = 2 + *(supportedRfInterfaces + 1);
+    memcpy(supportedRfInterfaces,
+           supportedRfInterfaces + noBytesToSkipForNfcDep,
+           (rfInterfacesLength -
+            ((supportedRfInterfaces - supportedRfInterfacesDetails) +
+             noBytesToSkipForNfcDep)));
+    *coreInitRespLen -= noBytesToSkipForNfcDep;
+    coreInitResp[2] -= noBytesToSkipForNfcDep;
+
+    /* Print updated CORE_INIT_RESP for debug purpose*/
+    phNxpNciHal_print_packet("DEBUG", coreInitResp, *coreInitRespLen);
+  }
+}
diff --git a/pn72xx/halimpl/hal/phNxpNciHal_ext.h b/pn72xx/halimpl/hal/phNxpNciHal_ext.h
new file mode 100644
index 00000000..5e44f203
--- /dev/null
+++ b/pn72xx/halimpl/hal/phNxpNciHal_ext.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2012-2020,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef _PHNXPNCIHAL_EXT_H_
+#define _PHNXPNCIHAL_EXT_H_
+
+#include <phNxpNciHal.h>
+#include <phNxpNciHal_dta.h>
+#include <string.h>
+#define NCI_MT_CMD 0x20
+#define NCI_MT_RSP 0x40
+#define NCI_MT_NTF 0x60
+#define NCI_MSG_CORE_RESET 0x00
+#define NCI_MSG_CORE_INIT 0x01
+
+#define NXP_NFC_SET_CONFIG_PARAM_EXT 0xA0
+#define NXP_NFC_PARAM_ID_SWP2 0xD4
+#define NXP_NFC_PARAM_ID_SWPUICC3 0xDC
+
+void phNxpNciHal_ext_init(void);
+NFCSTATUS phNxpNciHal_process_ext_rsp(uint8_t *p_ntf, uint16_t *p_len);
+NFCSTATUS phNxpNciHal_send_ext_cmd(uint16_t cmd_len, uint8_t *p_cmd);
+NFCSTATUS phNxpNciHal_send_ese_hal_cmd(uint16_t cmd_len, uint8_t *p_cmd);
+NFCSTATUS phNxpNciHal_write_ext(uint16_t *cmd_len, uint8_t *p_cmd_data,
+                                uint16_t *rsp_len, uint8_t *p_rsp_data);
+
+extern bool_t wFwUpdateReq;
+extern bool_t wRfUpdateReq;
+extern fpRegRfFwDndl_t fpRegRfFwDndl;
+extern fpPropConfCover_t fpPropConfCover;
+#define UINT8_TO_STREAM(p, u8)                                                 \
+  { *(p)++ = (uint8_t)(u8); }
+
+#endif /* _PHNXPNICHAL_EXT_H_ */
diff --git a/pn72xx/halimpl/hal/phNxpNciHal_extOperations.cc b/pn72xx/halimpl/hal/phNxpNciHal_extOperations.cc
new file mode 100755
index 00000000..cacd4476
--- /dev/null
+++ b/pn72xx/halimpl/hal/phNxpNciHal_extOperations.cc
@@ -0,0 +1,560 @@
+/*
+ * Copyright 2019-2021,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "phNxpNciHal_extOperations.h"
+#include "phNfcCommon.h"
+#include "phNxpNciHal_IoctlOperations.h"
+#include <phNxpLog.h>
+
+#define NCI_HEADER_SIZE 3
+#define NCI_SE_CMD_LEN 4
+nxp_nfc_config_ext_t config_ext;
+static std::vector<uint8_t> uicc1HciParams(0);
+static std::vector<uint8_t> uicc2HciParams(0);
+static std::vector<uint8_t> uiccHciCeParams(0);
+
+/******************************************************************************
+ * Function         phNxpNciHal_updateAutonomousPwrState
+ *
+ * Description      This function can be used to update autonomous pwr state.
+ *                  num: value to check  switch off bit is set or not.
+ *
+ * Returns          uint8_t
+ *
+ ******************************************************************************/
+uint8_t phNxpNciHal_updateAutonomousPwrState(uint8_t num) {
+  if ((config_ext.autonomous_mode == true) &&
+      ((num & SWITCH_OFF_MASK) == SWITCH_OFF_MASK)) {
+    num = (num | AUTONOMOUS_SCREEN_OFF_LOCK_MASK);
+  }
+  return num;
+}
+/******************************************************************************
+ * Function         phNxpNciHal_setAutonomousMode
+ *
+ * Description      This function can be used to set NFCC in autonomous mode
+ *
+ * Returns          NFCSTATUS_FAILED or NFCSTATUS_SUCCESS
+ *                  or NFCSTATUS_FEATURE_NOT_SUPPORTED
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_setAutonomousMode() {
+  if (nfcFL.chipType < sn100u) {
+    NXPLOG_NCIHAL_D("%s : Not applicable for chipType %d", __func__,
+                    nfcFL.chipType);
+    return NFCSTATUS_SUCCESS;
+  }
+  phNxpNci_EEPROM_info_t mEEPROM_info = {.request_mode = 0};
+  uint8_t autonomous_mode_value = 0x01;
+  if (config_ext.autonomous_mode == true)
+    autonomous_mode_value = 0x02;
+
+  mEEPROM_info.request_mode = SET_EEPROM_DATA;
+  mEEPROM_info.buffer = (uint8_t *)&autonomous_mode_value;
+  mEEPROM_info.bufflen = sizeof(autonomous_mode_value);
+  mEEPROM_info.request_type = EEPROM_AUTONOMOUS_MODE;
+
+  return request_EEPROM(&mEEPROM_info);
+}
+/******************************************************************************
+ * Function         phNxpNciHal_setGuardTimer
+ *
+ * Description      This function can be used to set nfcc Guard timer
+ *
+ * Returns          NFCSTATUS_FAILED or NFCSTATUS_SUCCESS
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_setGuardTimer() {
+  phNxpNci_EEPROM_info_t mEEPROM_info = {.request_mode = 0};
+  NFCSTATUS status = NFCSTATUS_FEATURE_NOT_SUPPORTED;
+
+  if (nfcFL.chipType >= sn100u) {
+    if (config_ext.autonomous_mode != true)
+      config_ext.guard_timer_value = 0x00;
+
+    mEEPROM_info.request_mode = SET_EEPROM_DATA;
+    mEEPROM_info.buffer = &config_ext.guard_timer_value;
+    mEEPROM_info.bufflen = sizeof(config_ext.guard_timer_value);
+    mEEPROM_info.request_type = EEPROM_GUARD_TIMER;
+
+    status = request_EEPROM(&mEEPROM_info);
+  }
+  return status;
+}
+
+/******************************************************************************
+ * Function         get_system_property_se_type
+ *
+ * Description      This will read NFCEE status from system properties
+ *                  and returns status.
+ *
+ * Returns          NFCEE enabled(0x01)/disabled(0x00)
+ *
+ ******************************************************************************/
+static int8_t get_system_property_se_type(uint8_t se_type) {
+  int8_t retVal = -1;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  if (se_type >= NUM_SE_TYPES)
+    return retVal;
+  int len = 0;
+  switch (se_type) {
+  case SE_TYPE_ESE:
+    len = property_get("nfc.product.support.ese", valueStr, "");
+    break;
+  case SE_TYPE_UICC:
+    len = property_get("nfc.product.support.uicc", valueStr, "");
+    break;
+  case SE_TYPE_UICC2:
+    len = property_get("nfc.product.support.uicc2", valueStr, "");
+    break;
+  }
+  if (strlen(valueStr) == 0 || len <= 0) {
+    return retVal;
+  }
+  retVal = atoi(valueStr);
+  return retVal;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_read_and_update_se_state
+ *
+ * Description      This will read NFCEE status from system properties
+ *                  and update to NFCC to enable/disable.
+ *
+ * Returns          none
+ *
+ ******************************************************************************/
+void phNxpNciHal_read_and_update_se_state() {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  int16_t i = 0;
+  int8_t val = -1;
+  int16_t num_se = 0;
+  uint8_t retry_cnt = 0;
+  int8_t values[NUM_SE_TYPES];
+
+  for (i = 0; i < NUM_SE_TYPES; i++) {
+    val = get_system_property_se_type(i);
+    switch (i) {
+    case SE_TYPE_ESE:
+      NXPLOG_NCIHAL_D("Get property : SUPPORT_ESE %d", val);
+      values[SE_TYPE_ESE] = val;
+      if (val > -1) {
+        num_se++;
+      }
+      break;
+    case SE_TYPE_UICC:
+      NXPLOG_NCIHAL_D("Get property : SUPPORT_UICC %d", val);
+      values[SE_TYPE_UICC] = val;
+      if (val > -1) {
+        num_se++;
+      }
+      break;
+    case SE_TYPE_UICC2:
+      values[SE_TYPE_UICC2] = val;
+      if (val > -1) {
+        num_se++;
+      }
+      NXPLOG_NCIHAL_D("Get property : SUPPORT_UICC2 %d", val);
+      break;
+    }
+  }
+  if (num_se < 1) {
+    return;
+  }
+  uint8_t set_cfg_cmd[NCI_HEADER_SIZE + 1 +
+                      (num_se * NCI_SE_CMD_LEN)]; // 1 for Number of Argument
+  uint8_t *index = &set_cfg_cmd[0];
+  *index++ = NCI_MT_CMD;
+  *index++ = NXP_CORE_SET_CONFIG_CMD;
+  *index++ = (num_se * NCI_SE_CMD_LEN) + 1;
+  *index++ = num_se;
+  for (i = 0; i < NUM_SE_TYPES; i++) {
+    switch (i) {
+    case SE_TYPE_ESE:
+      if (values[SE_TYPE_ESE] > -1) {
+        *index++ = 0xA0;
+        *index++ = 0xED;
+        *index++ = 0x01;
+        *index++ = values[SE_TYPE_ESE];
+      }
+      break;
+    case SE_TYPE_UICC:
+      if (values[SE_TYPE_UICC] > -1) {
+        *index++ = 0xA0;
+        *index++ = 0xEC;
+        *index++ = 0x01;
+        *index++ = values[SE_TYPE_UICC];
+      }
+      break;
+    case SE_TYPE_UICC2:
+      if (values[SE_TYPE_UICC2] > -1) {
+        *index++ = 0xA0;
+        *index++ = 0xD4;
+        *index++ = 0x01;
+        *index++ = values[SE_TYPE_UICC2];
+      }
+      break;
+    }
+  }
+
+  while (status != NFCSTATUS_SUCCESS && retry_cnt < 3) {
+    status = phNxpNciHal_send_ext_cmd(sizeof(set_cfg_cmd), set_cfg_cmd);
+    retry_cnt++;
+    NXPLOG_NCIHAL_E("Get Cfg Retry cnt=%x", retry_cnt);
+  }
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_read_fw_dw_status
+ *
+ * Description      This will read the value of fw download status flag
+ *                  from eeprom
+ *
+ * Parameters       value - this parameter will be updated with the flag
+ *                  value from eeprom.
+ *
+ * Returns          status of the read
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_read_fw_dw_status(uint8_t &value) {
+  phNxpNci_EEPROM_info_t mEEPROM_info = {.request_mode = 0};
+  mEEPROM_info.buffer = &value;
+  mEEPROM_info.bufflen = sizeof(value);
+  mEEPROM_info.request_type = EEPROM_FW_DWNLD;
+  mEEPROM_info.request_mode = GET_EEPROM_DATA;
+  return request_EEPROM(&mEEPROM_info);
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_write_fw_dw_status
+ *
+ * Description      This will update value of fw download status flag
+ *                  to eeprom
+ *
+ * Parameters       value - this value will be updated to eeprom flag.
+ *
+ * Returns          status of the write
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_write_fw_dw_status(uint8_t value) {
+  phNxpNci_EEPROM_info_t mEEPROM_info = {.request_mode = 0};
+  mEEPROM_info.buffer = &value;
+  mEEPROM_info.bufflen = sizeof(value);
+  mEEPROM_info.request_type = EEPROM_FW_DWNLD;
+  mEEPROM_info.request_mode = SET_EEPROM_DATA;
+  return request_EEPROM(&mEEPROM_info);
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_save_uicc_params
+ *
+ * Description      This will read the UICC HCI param values
+ *                  from eeprom and store in global variable
+ *
+ * Returns          status of the read
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_save_uicc_params() {
+  if (nfcFL.chipType < sn220u) {
+    NXPLOG_NCIHAL_E("%s Not supported", __func__);
+    return NFCSTATUS_SUCCESS;
+  }
+
+  NFCSTATUS status = NFCSTATUS_FAILED;
+
+  /* Getting UICC2 CL params */
+  uicc1HciParams.resize(0xFF);
+  status = phNxpNciHal_get_uicc_hci_params(
+      uicc1HciParams, uicc1HciParams.size(), EEPROM_UICC1_SESSION_ID);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("%s: Save UICC1 CLPP failed .", __func__);
+  }
+
+  /* Getting UICC2 CL params */
+  uicc2HciParams.resize(0xFF);
+  status = phNxpNciHal_get_uicc_hci_params(
+      uicc2HciParams, uicc2HciParams.size(), EEPROM_UICC2_SESSION_ID);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("%s: Save UICC2 CLPP failed .", __func__);
+  }
+
+  /* Get UICC CE HCI State */
+  uiccHciCeParams.resize(0xFF);
+  status = phNxpNciHal_get_uicc_hci_params(
+      uiccHciCeParams, uiccHciCeParams.size(), EEPROM_UICC_HCI_CE_STATE);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("%s: Save UICC_HCI_CE_STATE failed .", __func__);
+  }
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_restore_uicc_params
+ *
+ * Description      This will set the UICC HCI param values
+ *                  back to eeprom from global variable
+ *
+ * Returns          status of the read
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_restore_uicc_params() {
+  if (nfcFL.chipType < sn220u) {
+    NXPLOG_NCIHAL_E("%s Not supported", __func__);
+    return NFCSTATUS_SUCCESS;
+  }
+
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  if (uicc1HciParams.size() > 0) {
+    status = phNxpNciHal_set_uicc_hci_params(
+        uicc1HciParams, uicc1HciParams.size(), EEPROM_UICC1_SESSION_ID);
+    if (status != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("%s: Restore UICC1 CLPP failed .", __func__);
+    } else {
+      uicc1HciParams.resize(0);
+    }
+  }
+  if (uicc2HciParams.size() > 0) {
+    status = phNxpNciHal_set_uicc_hci_params(
+        uicc2HciParams, uicc2HciParams.size(), EEPROM_UICC2_SESSION_ID);
+    if (status != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("%s: Restore UICC2 CLPP failed .", __func__);
+    } else {
+      uicc2HciParams.resize(0);
+    }
+  }
+  if (uiccHciCeParams.size() > 0) {
+    status = phNxpNciHal_set_uicc_hci_params(
+        uiccHciCeParams, uiccHciCeParams.size(), EEPROM_UICC_HCI_CE_STATE);
+    if (status != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("%s: Restore UICC_HCI_CE_STATE failed .", __func__);
+    } else {
+      uiccHciCeParams.resize(0);
+    }
+  }
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_get_uicc_hci_params
+ *
+ * Description      This will read the UICC HCI param values
+ *                  from eeprom
+ *
+ * Parameters       value - this parameter will be updated with the flag
+ *                  value from eeprom.
+ *
+ * Returns          status of the read
+ *
+ ******************************************************************************/
+NFCSTATUS
+phNxpNciHal_get_uicc_hci_params(std::vector<uint8_t> &ptr, uint8_t bufflen,
+                                phNxpNci_EEPROM_request_type_t uiccType) {
+  if (nfcFL.chipType < sn220u) {
+    NXPLOG_NCIHAL_E("%s Not supported", __func__);
+    return NFCSTATUS_SUCCESS;
+  }
+  phNxpNci_EEPROM_info_t mEEPROM_info = {.request_mode = 0};
+  mEEPROM_info.buffer = &ptr[0];
+  mEEPROM_info.bufflen = bufflen;
+  mEEPROM_info.request_type = uiccType;
+  mEEPROM_info.request_mode = GET_EEPROM_DATA;
+  NFCSTATUS status = request_EEPROM(&mEEPROM_info);
+  ptr.resize(mEEPROM_info.bufflen);
+  return status;
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_set_uicc_hci_params
+ *
+ * Description      This will update the UICC HCI param values
+ *                  to eeprom
+ *
+ * Parameters       value - this value will be updated to eeprom flag.
+ *
+ * Returns          status of the write
+ *
+ *****************************************************************************/
+NFCSTATUS
+phNxpNciHal_set_uicc_hci_params(std::vector<uint8_t> &ptr, uint8_t bufflen,
+                                phNxpNci_EEPROM_request_type_t uiccType) {
+  if (nfcFL.chipType < sn220u) {
+    NXPLOG_NCIHAL_E("%s Not supported", __func__);
+    return NFCSTATUS_SUCCESS;
+  }
+  phNxpNci_EEPROM_info_t mEEPROM_info = {.request_mode = 0};
+  mEEPROM_info.buffer = &ptr[0];
+  mEEPROM_info.bufflen = bufflen;
+  mEEPROM_info.request_type = uiccType;
+  mEEPROM_info.request_mode = SET_EEPROM_DATA;
+  return request_EEPROM(&mEEPROM_info);
+}
+
+/*****************************************************************************
+ * Function         phNxpNciHal_send_get_cfg
+ *
+ * Description      This function is called to get the configurations from
+ * EEPROM
+ *
+ * Params           cmd_get_cfg, Buffer to get the get command
+ *                  cmd_len,     Length of the command
+ * Returns          SUCCESS/FAILURE
+ *
+ *
+ *****************************************************************************/
+NFCSTATUS phNxpNciHal_send_get_cfg(const uint8_t *cmd_get_cfg, long cmd_len) {
+  NXPLOG_NCIHAL_D("%s Enter", __func__);
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  uint8_t retry_cnt = 0;
+
+  if (cmd_get_cfg == NULL || cmd_len <= NCI_GET_CONFI_MIN_LEN) {
+    NXPLOG_NCIHAL_E("%s invalid command..! returning... ", __func__);
+    return status;
+  }
+
+  do {
+    status = phNxpNciHal_send_ext_cmd(cmd_len, (uint8_t *)cmd_get_cfg);
+  } while ((status != NFCSTATUS_SUCCESS) &&
+           (retry_cnt++ < NXP_MAX_RETRY_COUNT));
+
+  NXPLOG_NCIHAL_D("%s status : 0x%02X", __func__, status);
+  return status;
+}
+
+/*****************************************************************************
+ * Function         phNxpNciHal_configure_merge_sak
+ *
+ * Description      This function is called to apply iso_dep sak merge settings
+ *                  as per the config option NAME_NXP_ISO_DEP_MERGE_SAK
+ *
+ * Params           None
+
+ * Returns          NFCSTATUS_FAILED or NFCSTATUS_SUCCESS
+ *
+ *****************************************************************************/
+NFCSTATUS phNxpNciHal_configure_merge_sak() {
+  if (nfcFL.chipType < sn100u) {
+    NXPLOG_NCIHAL_D("%s : Not applicable for chipType %d", __func__,
+                    nfcFL.chipType);
+    return NFCSTATUS_SUCCESS;
+  }
+  long retlen = 0;
+  phNxpNci_EEPROM_info_t mEEPROM_info = {.request_mode = 0};
+  NXPLOG_NCIHAL_D("Performing ISODEP sak merge settings");
+  uint8_t val = 0;
+
+  if (!GetNxpNumValue(NAME_NXP_ISO_DEP_MERGE_SAK, (void *)&retlen,
+                      sizeof(retlen))) {
+    retlen = 0x01;
+    NXPLOG_NCIHAL_D(
+        "ISO_DEP_MERGE_SAK not found. default shall be enabled : 0x%02lx",
+        retlen);
+  }
+  val = (uint8_t)retlen;
+  mEEPROM_info.buffer = &val;
+  mEEPROM_info.bufflen = sizeof(val);
+  mEEPROM_info.request_type = EEPROM_ISODEP_MERGE_SAK;
+  mEEPROM_info.request_mode = SET_EEPROM_DATA;
+  return request_EEPROM(&mEEPROM_info);
+}
+#if (NXP_EXTNS == TRUE && NXP_SRD == TRUE)
+/******************************************************************************
+ * Function         phNxpNciHal_setSrdtimeout
+ *
+ * Description      This function can be used to set srd SRD Timeout.
+ *
+ * Returns          NFCSTATUS_FAILED or NFCSTATUS_SUCCESS or
+ *                  NFCSTATUS_FEATURE_NOT_SUPPORTED
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_setSrdtimeout() {
+  long retlen = 0;
+  uint8_t *buffer = nullptr;
+  long bufflen = 260;
+  const int NXP_SRD_TIMEOUT_BUF_LEN = 2;
+  const uint16_t TIMEOUT_MASK = 0xFFFF;
+  const uint16_t MAX_TIMEOUT_VALUE = 0xFD70;
+  uint16_t isValid_timeout;
+  uint8_t timeout_buffer[NXP_SRD_TIMEOUT_BUF_LEN];
+  NFCSTATUS status = NFCSTATUS_FEATURE_NOT_SUPPORTED;
+  phNxpNci_EEPROM_info_t mEEPROM_info = {.request_mode = 0};
+
+  NXPLOG_NCIHAL_D("Performing SRD Timeout settings");
+
+  buffer = (uint8_t *)malloc(bufflen * sizeof(uint8_t));
+  if (NULL == buffer) {
+    return NFCSTATUS_FAILED;
+  }
+  memset(buffer, 0x00, bufflen);
+  if (GetNxpByteArrayValue(NAME_NXP_SRD_TIMEOUT, (char *)buffer, bufflen,
+                           &retlen)) {
+    if (retlen == NXP_SRD_TIMEOUT_BUF_LEN) {
+      isValid_timeout = ((buffer[1] << 8) & TIMEOUT_MASK);
+      isValid_timeout = (isValid_timeout | buffer[0]);
+      if (isValid_timeout > MAX_TIMEOUT_VALUE) {
+        /*if timeout is setting more than 18hrs
+         * than setting to MAX limit 0xFD70*/
+        buffer[0] = 0x70;
+        buffer[1] = 0xFD;
+      }
+      memcpy(&timeout_buffer, buffer, NXP_SRD_TIMEOUT_BUF_LEN);
+      mEEPROM_info.buffer = timeout_buffer;
+      mEEPROM_info.bufflen = sizeof(timeout_buffer);
+      mEEPROM_info.request_type = EEPROM_SRD_TIMEOUT;
+      mEEPROM_info.request_mode = SET_EEPROM_DATA;
+      status = request_EEPROM(&mEEPROM_info);
+    }
+  }
+  if (buffer != NULL) {
+    free(buffer);
+    buffer = NULL;
+  }
+
+  return status;
+}
+#endif
+
+/******************************************************************************
+ * Function         phNxpNciHal_setExtendedFieldMode
+ *
+ * Description      This function can be used to set nfcc extended field mode
+ *
+ * Returns          NFCSTATUS_FAILED or NFCSTATUS_SUCCESS or
+ *                  NFCSTATUS_FEATURE_NOT_SUPPORTED
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_setExtendedFieldMode() {
+  const uint8_t enable_val = 0x01;
+  const uint8_t disable_val = 0x00;
+  uint8_t extended_field_mode = disable_val;
+  phNxpNci_EEPROM_info_t mEEPROM_info = {.request_mode = 0};
+  NFCSTATUS status = NFCSTATUS_FEATURE_NOT_SUPPORTED;
+
+  if (nfcFL.chipType >= sn100u &&
+      GetNxpNumValue(NAME_NXP_EXTENDED_FIELD_DETECT_MODE, &extended_field_mode,
+                     sizeof(extended_field_mode))) {
+    if (extended_field_mode == enable_val ||
+        extended_field_mode == disable_val) {
+      mEEPROM_info.buffer = &extended_field_mode;
+      mEEPROM_info.bufflen = sizeof(extended_field_mode);
+      mEEPROM_info.request_type = EEPROM_EXT_FIELD_DETECT_MODE;
+      mEEPROM_info.request_mode = SET_EEPROM_DATA;
+      status = request_EEPROM(&mEEPROM_info);
+    } else {
+      NXPLOG_NCIHAL_E("Invalid Extended Field Mode in config");
+    }
+  }
+  return status;
+}
diff --git a/pn72xx/halimpl/hal/phNxpNciHal_extOperations.h b/pn72xx/halimpl/hal/phNxpNciHal_extOperations.h
new file mode 100755
index 00000000..8deb49d5
--- /dev/null
+++ b/pn72xx/halimpl/hal/phNxpNciHal_extOperations.h
@@ -0,0 +1,138 @@
+/*
+ * Copyright 2019-2021,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <phNxpNciHal_ext.h>
+
+#include "phNfcStatus.h"
+
+#define AUTONOMOUS_SCREEN_OFF_LOCK_MASK 0x20
+#define SWITCH_OFF_MASK 0x02
+#define NCI_GET_CONFI_MIN_LEN 0x04
+#define NXP_MAX_RETRY_COUNT 0x03
+typedef struct {
+  uint8_t autonomous_mode;
+  uint8_t guard_timer_value;
+} nxp_nfc_config_ext_t;
+extern nxp_nfc_config_ext_t config_ext;
+
+/******************************************************************************
+ * Function         phNxpNciHal_updateAutonomousPwrState
+ *
+ * Description      This function can be used to update autonomous pwr state.
+ *                  num: value to check  switch off bit is set or not.
+ *
+ * Returns          uint8_t
+ *
+ ******************************************************************************/
+uint8_t phNxpNciHal_updateAutonomousPwrState(uint8_t num);
+/******************************************************************************
+ * Function         phNxpNciHal_setAutonomousMode
+ *
+ * Description      This function can be used to set NFCC in autonomous mode
+ *
+ * Returns          NFCSTATUS_FAILED or NFCSTATUS_SUCCESS
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_setAutonomousMode();
+
+/******************************************************************************
+ * Function         phNxpNciHal_setGuardTimer
+ *
+ * Description      This function can be used to set Guard timer
+ *
+ * Returns          NFCSTATUS_FAILED or NFCSTATUS_SUCCESS
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_setGuardTimer();
+
+/*****************************************************************************
+ * Function         phNxpNciHal_send_get_cfg
+ *
+ * Description      This function is called to get the configurations from
+ * EEPROM
+ *
+ * Params           cmd_get_cfg, Buffer to GET command
+ *                  cmd_len,     Length of the command
+ * Returns          SUCCESS/FAILURE
+ *
+ *
+ *****************************************************************************/
+NFCSTATUS phNxpNciHal_send_get_cfg(const uint8_t *cmd_get_cfg, long cmd_len);
+
+/*****************************************************************************
+ * Function         phNxpNciHal_configure_merge_sak
+ *
+ * Description      This function is called to apply iso_dep sak merge settings
+ *                  as per the config option NAME_NXP_ISO_DEP_MERGE_SAK
+ *
+ * Params           None
+
+ * Returns          NFCSTATUS_FAILED or NFCSTATUS_SUCCESS
+ *
+ *****************************************************************************/
+NFCSTATUS phNxpNciHal_configure_merge_sak();
+/******************************************************************************
+ * Function         phNxpNciHal_setSrdtimeout
+ *
+ * Description      This function can be used to set srd SRD Timeout.
+ *
+ * Returns          NFCSTATUS_FAILED or NFCSTATUS_SUCCESS or
+ *                  NFCSTATUS_FEATURE_NOT_SUPPORTED
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_setSrdtimeout();
+/******************************************************************************
+ * Function         phNxpNciHal_set_uicc_hci_params
+ *
+ * Description      This will update value of uicc session status to store flag
+ *                  to eeprom
+ *
+ * Parameters       value - this value will be updated to eeprom flag.
+ *
+ * Returns          status of the write
+ *
+ ******************************************************************************/
+NFCSTATUS
+phNxpNciHal_set_uicc_hci_params(std::vector<uint8_t> &ptr, uint8_t bufflen,
+                                phNxpNci_EEPROM_request_type_t uiccType);
+/******************************************************************************
+ * Function         phNxpNciHal_get_uicc_hci_params
+ *
+ * Description      This will read the value of fw download status flag
+ *                  from eeprom
+ *
+ * Parameters       value - this parameter will be updated with the flag
+ *                  value from eeprom.
+ *
+ * Returns          status of the read
+ *
+ ******************************************************************************/
+NFCSTATUS
+phNxpNciHal_get_uicc_hci_params(std::vector<uint8_t> &ptr, uint8_t bufflen,
+                                phNxpNci_EEPROM_request_type_t uiccType);
+
+/******************************************************************************
+ * Function         phNxpNciHal_setExtendedFieldMode
+ *
+ * Description      This function can be used to set nfcc extended field mode
+ *
+ * Returns          NFCSTATUS_FAILED or NFCSTATUS_SUCCESS or
+ *                  NFCSTATUS_FEATURE_NOT_SUPPORTED
+ *
+ ******************************************************************************/
+NFCSTATUS phNxpNciHal_setExtendedFieldMode();
diff --git a/pn72xx/halimpl/inc/phNxpNciHal_Adaptation.h b/pn72xx/halimpl/inc/phNxpNciHal_Adaptation.h
new file mode 100755
index 00000000..14838387
--- /dev/null
+++ b/pn72xx/halimpl/inc/phNxpNciHal_Adaptation.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2012-2020,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _PHNXPNCIHAL_ADAPTATION_H_
+#define _PHNXPNCIHAL_ADAPTATION_H_
+
+#include <android/hardware/nfc/1.2/INfc.h>
+#include <android/hardware/nfc/1.2/types.h>
+#include <hardware/nfc.h>
+
+using ::android::hardware::nfc::V1_2::NfcConfig;
+
+typedef struct {
+  struct nfc_nci_device nci_device;
+
+  /* Local definitions */
+} pn547_dev_t;
+
+/* NXP HAL functions */
+int phNxpNciHal_open(nfc_stack_callback_t *p_cback,
+                     nfc_stack_data_callback_t *p_data_cback);
+int phNxpNciHal_MinOpen();
+int phNxpNciHal_write(uint16_t data_len, const uint8_t *p_data);
+int phNxpNciHal_write_internal(uint16_t data_len, const uint8_t *p_data);
+int phNxpNciHal_core_initialized(uint16_t core_init_rsp_len,
+                                 uint8_t *p_core_init_rsp_params);
+int phNxpNciHal_pre_discover(void);
+int phNxpNciHal_close(bool);
+int phNxpNciHal_configDiscShutdown(void);
+int phNxpNciHal_control_granted(void);
+int phNxpNciHal_power_cycle(void);
+void phNxpNciHal_do_factory_reset(void);
+void phNxpNciHal_getVendorConfig(
+    android::hardware::nfc::V1_1::NfcConfig &config);
+void phNxpNciHal_getVendorConfig_1_2(NfcConfig &config);
+#endif /* _PHNXPNCIHAL_ADAPTATION_H_ */
diff --git a/pn72xx/halimpl/inc/phNxpNciHal_Api.h b/pn72xx/halimpl/inc/phNxpNciHal_Api.h
new file mode 100644
index 00000000..0a70e6a2
--- /dev/null
+++ b/pn72xx/halimpl/inc/phNxpNciHal_Api.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2012-2014,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef _PHNXPNCIHAL_API_H_
+#define _PHNXPNCIHAL_API_H_
+
+#include <phNfcStatus.h>
+#include <phNxpNciHal.h>
+#include <phTmlNfc.h>
+
+/*******************************************************************************
+ **
+ ** Function         phNxpNciHal_get_version
+ **
+ ** Description      Function to get the HW, FW and SW versions.
+ **
+ ** Returns          NFCSTATUS_SUCCESS if successful,otherwise NFCSTATUS_FAILED.
+ **
+ ******************************************************************************/
+
+NFCSTATUS phNxpNciHal_get_version(uint32_t *hw_ver, uint32_t *fw_ver,
+                                  uint32_t *sw_ver);
+
+#endif /* _PHNXPNCIHAL_API_H_ */
diff --git a/pn72xx/halimpl/log/phNxpLog.cc b/pn72xx/halimpl/log/phNxpLog.cc
new file mode 100644
index 00000000..e7b140fc
--- /dev/null
+++ b/pn72xx/halimpl/log/phNxpLog.cc
@@ -0,0 +1,302 @@
+/*
+ * Copyright 2010-2019,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define LOG_TAG "NxpNfcHal"
+#include <stdio.h>
+#include <string.h>
+#if !defined(NXPLOG__H_INCLUDED)
+#include "phNxpConfig.h"
+#include "phNxpLog.h"
+#endif
+#include "phNxpNciHal_IoctlOperations.h"
+#include <log/log.h>
+
+const char *NXPLOG_ITEM_EXTNS = "NxpExtns";
+const char *NXPLOG_ITEM_NCIHAL = "NxpHal";
+const char *NXPLOG_ITEM_NCIX = "NxpNciX";
+const char *NXPLOG_ITEM_NCIR = "NxpNciR";
+const char *NXPLOG_ITEM_FWDNLD = "NxpFwDnld";
+const char *NXPLOG_ITEM_TML = "NxpTml";
+
+#ifdef NXP_HCI_REQ
+const char *NXPLOG_ITEM_HCPX = "NxpHcpX";
+const char *NXPLOG_ITEM_HCPR = "NxpHcpR";
+#endif /*NXP_HCI_REQ*/
+
+/* global log level structure */
+nci_log_level_t gLog_level;
+
+extern bool nfc_debug_enabled;
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetGlobalLogLevel
+ *
+ * Description      Sets the global log level for all modules.
+ *                  This value is set by Android property
+ *nfc.nxp_log_level_global.
+ *                  If value can be overridden by module log level.
+ *
+ * Returns          The value of global log level
+ *
+ ******************************************************************************/
+static uint8_t phNxpLog_SetGlobalLogLevel(void) {
+  uint8_t level = NXPLOG_DEFAULT_LOGLEVEL;
+  unsigned long num = 0;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+
+  int len = property_get(PROP_NAME_NXPLOG_GLOBAL_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    level = (unsigned char)num;
+  }
+  memset(&gLog_level, level, sizeof(nci_log_level_t));
+  return level;
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetHALLogLevel
+ *
+ * Description      Sets the HAL layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phNxpLog_SetHALLogLevel(uint8_t level) {
+  unsigned long num = 0;
+  int len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+
+  if (GetNxpNumValue(NAME_NXPLOG_NCIHAL_LOGLEVEL, &num, sizeof(num))) {
+    gLog_level.hal_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+    ;
+  }
+
+  len = property_get(PROP_NAME_NXPLOG_NCIHAL_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.hal_log_level = (unsigned char)num;
+  }
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetExtnsLogLevel
+ *
+ * Description      Sets the Extensions layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phNxpLog_SetExtnsLogLevel(uint8_t level) {
+  unsigned long num = 0;
+  int len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  if (GetNxpNumValue(NAME_NXPLOG_EXTNS_LOGLEVEL, &num, sizeof(num))) {
+    gLog_level.extns_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+    ;
+  }
+
+  len = property_get(PROP_NAME_NXPLOG_EXTNS_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.extns_log_level = (unsigned char)num;
+  }
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetTmlLogLevel
+ *
+ * Description      Sets the Tml layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phNxpLog_SetTmlLogLevel(uint8_t level) {
+  unsigned long num = 0;
+  int len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  if (GetNxpNumValue(NAME_NXPLOG_TML_LOGLEVEL, &num, sizeof(num))) {
+    gLog_level.tml_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+    ;
+  }
+
+  len = property_get(PROP_NAME_NXPLOG_TML_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.tml_log_level = (unsigned char)num;
+  }
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetDnldLogLevel
+ *
+ * Description      Sets the FW download layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phNxpLog_SetDnldLogLevel(uint8_t level) {
+  unsigned long num = 0;
+  int len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  if (GetNxpNumValue(NAME_NXPLOG_FWDNLD_LOGLEVEL, &num, sizeof(num))) {
+    gLog_level.dnld_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+    ;
+  }
+
+  len = property_get(PROP_NAME_NXPLOG_FWDNLD_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.dnld_log_level = (unsigned char)num;
+  }
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetNciTxLogLevel
+ *
+ * Description      Sets the NCI transaction layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phNxpLog_SetNciTxLogLevel(uint8_t level) {
+  unsigned long num = 0;
+  int len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  if (GetNxpNumValue(NAME_NXPLOG_NCIX_LOGLEVEL, &num, sizeof(num))) {
+    gLog_level.ncix_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+  }
+  if (GetNxpNumValue(NAME_NXPLOG_NCIR_LOGLEVEL, &num, sizeof(num))) {
+    gLog_level.ncir_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+    ;
+  }
+
+  len = property_get(PROP_NAME_NXPLOG_NCI_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.ncix_log_level = (unsigned char)num;
+    gLog_level.ncir_log_level = (unsigned char)num;
+  }
+}
+
+/******************************************************************************
+ * Function         phNxpLog_InitializeLogLevel
+ *
+ * Description      Initialize and get log level of module from libnfc-nxp.conf
+ *or
+ *                  Android runtime properties.
+ *                  The Android property nfc.nxp_global_log_level is to
+ *                  define log level for all modules. Modules log level will
+ *overwide global level.
+ *                  The Android property will overwide the level
+ *                  in libnfc-nxp.conf
+ *
+ *                  Android property names:
+ *                      nfc.nxp_log_level_global    * defines log level for all
+ *modules
+ *                      nfc.nxp_log_level_extns     * extensions module log
+ *                      nfc.nxp_log_level_hal       * Hal module log
+ *                      nfc.nxp_log_level_dnld      * firmware download module
+ *log
+ *                      nfc.nxp_log_level_tml       * TML module log
+ *                      nfc.nxp_log_level_nci       * NCI transaction log
+ *
+ *                  Log Level values:
+ *                      NXPLOG_LOG_SILENT_LOGLEVEL  0        * No trace to show
+ *                      NXPLOG_LOG_ERROR_LOGLEVEL   1        * Show Error trace
+ *only
+ *                      NXPLOG_LOG_WARN_LOGLEVEL    2        * Show Warning
+ *trace and Error trace
+ *                      NXPLOG_LOG_DEBUG_LOGLEVEL   3        * Show all traces
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+void phNxpLog_InitializeLogLevel(void) {
+  uint8_t level = phNxpLog_SetGlobalLogLevel();
+  phNxpLog_SetHALLogLevel(level);
+  phNxpLog_SetExtnsLogLevel(level);
+  phNxpLog_SetTmlLogLevel(level);
+  phNxpLog_SetDnldLogLevel(level);
+  phNxpLog_SetNciTxLogLevel(level);
+
+  ALOGD_IF(nfc_debug_enabled, "%s: global =%u, Fwdnld =%u, extns =%u, \
+                hal =%u, tml =%u, ncir =%u, \
+                ncix =%u",
+           __func__, gLog_level.global_log_level, gLog_level.dnld_log_level,
+           gLog_level.extns_log_level, gLog_level.hal_log_level,
+           gLog_level.tml_log_level, gLog_level.ncir_log_level,
+           gLog_level.ncix_log_level);
+}
+/******************************************************************************
+ * Function         phNxpLog_EnableDisableLogLevel
+ *
+ * Description      This function can be called to enable/disable the log levels
+ *
+ *
+ *                  Log Level values:
+ *                      NXPLOG_LOG_SILENT_LOGLEVEL  0        * No trace to show
+ *                      NXPLOG_LOG_ERROR_LOGLEVEL   1        * Show Error trace
+ *only
+ *                      NXPLOG_LOG_WARN_LOGLEVEL    2        * Show Warning
+ *trace and Error trace
+ *                      NXPLOG_LOG_DEBUG_LOGLEVEL   3        * Show all traces
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+uint8_t phNxpLog_EnableDisableLogLevel(uint8_t enable) {
+  static nci_log_level_t prevTraceLevel = {0, 0, 0, 0, 0, 0, 0};
+  static uint8_t currState = 0x01;
+  static bool prev_debug_enabled = true;
+  uint8_t status = NFCSTATUS_FAILED;
+
+  if (0x01 == enable && currState != 0x01) {
+    memcpy(&gLog_level, &prevTraceLevel, sizeof(nci_log_level_t));
+    nfc_debug_enabled = prev_debug_enabled;
+    currState = 0x01;
+    status = NFCSTATUS_SUCCESS;
+  } else if (0x00 == enable && currState != 0x00) {
+    prev_debug_enabled = nfc_debug_enabled;
+    memcpy(&prevTraceLevel, &gLog_level, sizeof(nci_log_level_t));
+    gLog_level.hal_log_level = 0;
+    gLog_level.extns_log_level = 0;
+    gLog_level.tml_log_level = 0;
+    gLog_level.ncix_log_level = 0;
+    gLog_level.ncir_log_level = 0;
+    nfc_debug_enabled = false;
+    currState = 0x00;
+    status = NFCSTATUS_SUCCESS;
+  }
+
+  return status;
+}
diff --git a/pn72xx/halimpl/log/phNxpLog.h b/pn72xx/halimpl/log/phNxpLog.h
new file mode 100644
index 00000000..7afee443
--- /dev/null
+++ b/pn72xx/halimpl/log/phNxpLog.h
@@ -0,0 +1,368 @@
+/*
+ * Copyright 2010-2014,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#if !defined(NXPLOG__H_INCLUDED)
+#define NXPLOG__H_INCLUDED
+#include <log/log.h>
+#include <phNfcStatus.h>
+
+typedef struct nci_log_level {
+  uint8_t global_log_level;
+  uint8_t extns_log_level;
+  uint8_t hal_log_level;
+  uint8_t dnld_log_level;
+  uint8_t tml_log_level;
+  uint8_t ncix_log_level;
+  uint8_t ncir_log_level;
+} nci_log_level_t;
+
+/* global log level Ref */
+extern nci_log_level_t gLog_level;
+extern bool nfc_debug_enabled;
+/* define log module included when compile */
+#define ENABLE_EXTNS_TRACES TRUE
+#define ENABLE_HAL_TRACES TRUE
+#define ENABLE_TML_TRACES TRUE
+#define ENABLE_FWDNLD_TRACES TRUE
+#define ENABLE_NCIX_TRACES TRUE
+#define ENABLE_NCIR_TRACES TRUE
+
+#define ENABLE_HCPX_TRACES FALSE
+#define ENABLE_HCPR_TRACES FALSE
+
+/* ####################### Set the log module name in .conf file
+ * ########################## */
+#define NAME_NXPLOG_EXTNS_LOGLEVEL "NXPLOG_EXTNS_LOGLEVEL"
+#define NAME_NXPLOG_NCIHAL_LOGLEVEL "NXPLOG_NCIHAL_LOGLEVEL"
+#define NAME_NXPLOG_NCIX_LOGLEVEL "NXPLOG_NCIX_LOGLEVEL"
+#define NAME_NXPLOG_NCIR_LOGLEVEL "NXPLOG_NCIR_LOGLEVEL"
+#define NAME_NXPLOG_FWDNLD_LOGLEVEL "NXPLOG_FWDNLD_LOGLEVEL"
+#define NAME_NXPLOG_TML_LOGLEVEL "NXPLOG_TML_LOGLEVEL"
+
+/* ####################### Set the log module name by Android property
+ * ########################## */
+#define PROP_NAME_NXPLOG_GLOBAL_LOGLEVEL "nfc.nxp_log_level_global"
+#define PROP_NAME_NXPLOG_EXTNS_LOGLEVEL "nfc.nxp_log_level_extns"
+#define PROP_NAME_NXPLOG_NCIHAL_LOGLEVEL "nfc.nxp_log_level_hal"
+#define PROP_NAME_NXPLOG_NCI_LOGLEVEL "nfc.nxp_log_level_nci"
+#define PROP_NAME_NXPLOG_FWDNLD_LOGLEVEL "nfc.nxp_log_level_dnld"
+#define PROP_NAME_NXPLOG_TML_LOGLEVEL "nfc.nxp_log_level_tml"
+
+/* ####################### Set the logging level for EVERY COMPONENT here
+ * ######################## :START: */
+#define NXPLOG_LOG_SILENT_LOGLEVEL 0x00
+#define NXPLOG_LOG_ERROR_LOGLEVEL 0x01
+#define NXPLOG_LOG_WARN_LOGLEVEL 0x02
+#define NXPLOG_LOG_DEBUG_LOGLEVEL 0x03
+/* ####################### Set the default logging level for EVERY COMPONENT
+ * here ########################## :END: */
+
+/* The Default log level for all the modules. */
+#define NXPLOG_DEFAULT_LOGLEVEL NXPLOG_LOG_ERROR_LOGLEVEL
+
+/* ################################################################################################################
+ */
+/* ############################################### Component Names
+ * ################################################ */
+/* ################################################################################################################
+ */
+
+extern const char *NXPLOG_ITEM_EXTNS;  /* Android logging tag for NxpExtns  */
+extern const char *NXPLOG_ITEM_NCIHAL; /* Android logging tag for NxpNciHal */
+extern const char *NXPLOG_ITEM_NCIX;   /* Android logging tag for NxpNciX   */
+extern const char *NXPLOG_ITEM_NCIR;   /* Android logging tag for NxpNciR   */
+extern const char *NXPLOG_ITEM_FWDNLD; /* Android logging tag for NxpFwDnld */
+extern const char *NXPLOG_ITEM_TML;    /* Android logging tag for NxpTml    */
+
+#ifdef NXP_HCI_REQ
+extern const char *NXPLOG_ITEM_HCPX; /* Android logging tag for NxpHcpX   */
+extern const char *NXPLOG_ITEM_HCPR; /* Android logging tag for NxpHcpR   */
+#endif                               /*NXP_HCI_REQ*/
+
+/* ######################################## Defines used for Logging data
+ * ######################################### */
+#ifdef NXP_VRBS_REQ
+#define NXPLOG_FUNC_ENTRY(COMP)                                                \
+  LOG_PRI(ANDROID_LOG_VERBOSE, (COMP), "+:%s", (__func__))
+#define NXPLOG_FUNC_EXIT(COMP)                                                 \
+  LOG_PRI(ANDROID_LOG_VERBOSE, (COMP), "-:%s", (__func__))
+#endif /*NXP_VRBS_REQ*/
+
+/* ################################################################################################################
+ */
+/* ######################################## Logging APIs of actual modules
+ * ######################################## */
+/* ################################################################################################################
+ */
+/* Logging APIs used by NxpExtns module */
+#if (ENABLE_EXTNS_TRACES == TRUE)
+#define NXPLOG_EXTNS_D(...)                                                    \
+  {                                                                            \
+    if ((nfc_debug_enabled) ||                                                 \
+        (gLog_level.extns_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL))             \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_EXTNS, __VA_ARGS__);              \
+  }
+#define NXPLOG_EXTNS_W(...)                                                    \
+  {                                                                            \
+    if ((nfc_debug_enabled) ||                                                 \
+        (gLog_level.extns_log_level >= NXPLOG_LOG_WARN_LOGLEVEL))              \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_EXTNS, __VA_ARGS__);               \
+  }
+#define NXPLOG_EXTNS_E(...)                                                    \
+  {                                                                            \
+    if (gLog_level.extns_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)               \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_EXTNS, __VA_ARGS__);              \
+  }
+#else
+#define NXPLOG_EXTNS_D(...)
+#define NXPLOG_EXTNS_W(...)
+#define NXPLOG_EXTNS_E(...)
+#endif /* Logging APIs used by NxpExtns module */
+
+/* Logging APIs used by NxpNciHal module */
+#if (ENABLE_HAL_TRACES == TRUE)
+#define NXPLOG_NCIHAL_D(...)                                                   \
+  {                                                                            \
+    if ((nfc_debug_enabled) ||                                                 \
+        (gLog_level.hal_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL))               \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_NCIHAL, __VA_ARGS__);             \
+  }
+#define NXPLOG_NCIHAL_W(...)                                                   \
+  {                                                                            \
+    if ((nfc_debug_enabled) ||                                                 \
+        (gLog_level.hal_log_level >= NXPLOG_LOG_WARN_LOGLEVEL))                \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_NCIHAL, __VA_ARGS__);              \
+  }
+#define NXPLOG_NCIHAL_E(...)                                                   \
+  {                                                                            \
+    if (gLog_level.hal_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)                 \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_NCIHAL, __VA_ARGS__);             \
+  }
+#else
+#define NXPLOG_NCIHAL_D(...)
+#define NXPLOG_NCIHAL_W(...)
+#define NXPLOG_NCIHAL_E(...)
+#endif /* Logging APIs used by HAL module */
+
+/* Logging APIs used by NxpNciX module */
+#if (ENABLE_NCIX_TRACES == TRUE)
+#define NXPLOG_NCIX_D(...)                                                     \
+  {                                                                            \
+    if ((nfc_debug_enabled) ||                                                 \
+        (gLog_level.ncix_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL))              \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_NCIX, __VA_ARGS__);               \
+  }
+#define NXPLOG_NCIX_W(...)                                                     \
+  {                                                                            \
+    if ((nfc_debug_enabled) ||                                                 \
+        (gLog_level.ncix_log_level >= NXPLOG_LOG_WARN_LOGLEVEL))               \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_NCIX, __VA_ARGS__);                \
+  }
+#define NXPLOG_NCIX_E(...)                                                     \
+  {                                                                            \
+    if (gLog_level.ncix_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)                \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_NCIX, __VA_ARGS__);               \
+  }
+#else
+#define NXPLOG_NCIX_D(...)
+#define NXPLOG_NCIX_W(...)
+#define NXPLOG_NCIX_E(...)
+#endif /* Logging APIs used by NCIx module */
+
+/* Logging APIs used by NxpNciR module */
+#if (ENABLE_NCIR_TRACES == TRUE)
+#define NXPLOG_NCIR_D(...)                                                     \
+  {                                                                            \
+    if ((nfc_debug_enabled) ||                                                 \
+        (gLog_level.ncir_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL))              \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_NCIR, __VA_ARGS__);               \
+  }
+#define NXPLOG_NCIR_W(...)                                                     \
+  {                                                                            \
+    if ((nfc_debug_enabled) ||                                                 \
+        (gLog_level.ncir_log_level >= NXPLOG_LOG_WARN_LOGLEVEL))               \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_NCIR, __VA_ARGS__);                \
+  }
+#define NXPLOG_NCIR_E(...)                                                     \
+  {                                                                            \
+    if (gLog_level.ncir_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)                \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_NCIR, __VA_ARGS__);               \
+  }
+#else
+#define NXPLOG_NCIR_D(...)
+#define NXPLOG_NCIR_W(...)
+#define NXPLOG_NCIR_E(...)
+#endif /* Logging APIs used by NCIR module */
+
+/* Logging APIs used by NxpFwDnld module */
+#if (ENABLE_FWDNLD_TRACES == TRUE)
+#define NXPLOG_FWDNLD_D(...)                                                   \
+  {                                                                            \
+    if ((nfc_debug_enabled) ||                                                 \
+        (gLog_level.dnld_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL))              \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);             \
+  }
+#define NXPLOG_FWDNLD_W(...)                                                   \
+  {                                                                            \
+    if ((nfc_debug_enabled) ||                                                 \
+        (gLog_level.dnld_log_level >= NXPLOG_LOG_WARN_LOGLEVEL))               \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);              \
+  }
+#define NXPLOG_FWDNLD_E(...)                                                   \
+  {                                                                            \
+    if (gLog_level.dnld_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)                \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);             \
+  }
+#else
+#define NXPLOG_FWDNLD_D(...)
+#define NXPLOG_FWDNLD_W(...)
+#define NXPLOG_FWDNLD_E(...)
+#endif /* Logging APIs used by NxpFwDnld module */
+
+/* Logging APIs used by NxpTml module */
+#if (ENABLE_TML_TRACES == TRUE)
+#define NXPLOG_TML_D(...)                                                      \
+  {                                                                            \
+    if ((nfc_debug_enabled) ||                                                 \
+        (gLog_level.tml_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL))               \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_TML, __VA_ARGS__);                \
+  }
+#define NXPLOG_TML_W(...)                                                      \
+  {                                                                            \
+    if ((nfc_debug_enabled) ||                                                 \
+        (gLog_level.tml_log_level >= NXPLOG_LOG_WARN_LOGLEVEL))                \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_TML, __VA_ARGS__);                 \
+  }
+#define NXPLOG_TML_E(...)                                                      \
+  {                                                                            \
+    if (gLog_level.tml_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)                 \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_TML, __VA_ARGS__);                \
+  }
+#else
+#define NXPLOG_TML_D(...)
+#define NXPLOG_TML_W(...)
+#define NXPLOG_TML_E(...)
+#endif /* Logging APIs used by NxpTml module */
+
+#ifdef NXP_HCI_REQ
+/* Logging APIs used by NxpHcpX module */
+#if (ENABLE_HCPX_TRACES == TRUE)
+#define NXPLOG_HCPX_D(...)                                                     \
+  {                                                                            \
+    if ((nfc_debug_enabled) ||                                                 \
+        (gLog_level.dnld_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL))              \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);             \
+  }
+#define NXPLOG_HCPX_W(...)                                                     \
+  {                                                                            \
+    if ((nfc_debug_enabled) ||                                                 \
+        (gLog_level.dnld_log_level >= NXPLOG_LOG_WARN_LOGLEVEL))               \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);              \
+  }
+#define NXPLOG_HCPX_E(...)                                                     \
+  {                                                                            \
+    if (gLog_level.dnld_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)                \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);             \
+  }
+#else
+#define NXPLOG_HCPX_D(...)
+#define NXPLOG_HCPX_W(...)
+#define NXPLOG_HCPX_E(...)
+#endif /* Logging APIs used by NxpHcpX module */
+
+/* Logging APIs used by NxpHcpR module */
+#if (ENABLE_HCPR_TRACES == TRUE)
+#define NXPLOG_HCPR_D(...)                                                     \
+  {                                                                            \
+    if ((nfc_debug_enabled) ||                                                 \
+        (gLog_level.dnld_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL))              \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);             \
+  }
+#define NXPLOG_HCPR_W(...)                                                     \
+  {                                                                            \
+    if ((nfc_debug_enabled) ||                                                 \
+        (gLog_level.dnld_log_level >= NXPLOG_LOG_WARN_LOGLEVEL))               \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);              \
+  }
+#define NXPLOG_HCPR_E(...)                                                     \
+  {                                                                            \
+    if (gLog_level.dnld_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)                \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);             \
+  }
+#else
+#define NXPLOG_HCPR_D(...)
+#define NXPLOG_HCPR_W(...)
+#define NXPLOG_HCPR_E(...)
+#endif /* Logging APIs used by NxpHcpR module */
+#endif /* NXP_HCI_REQ */
+
+#ifdef NXP_VRBS_REQ
+#if (ENABLE_EXTNS_TRACES == TRUE)
+#define NXPLOG_EXTNS_ENTRY() NXPLOG_FUNC_ENTRY(NXPLOG_ITEM_EXTNS)
+#define NXPLOG_EXTNS_EXIT() NXPLOG_FUNC_EXIT(NXPLOG_ITEM_EXTNS)
+#else
+#define NXPLOG_EXTNS_ENTRY()
+#define NXPLOG_EXTNS_EXIT()
+#endif
+
+#if (ENABLE_HAL_TRACES == TRUE)
+#define NXPLOG_NCIHAL_ENTRY() NXPLOG_FUNC_ENTRY(NXPLOG_ITEM_NCIHAL)
+#define NXPLOG_NCIHAL_EXIT() NXPLOG_FUNC_EXIT(NXPLOG_ITEM_NCIHAL)
+#else
+#define NXPLOG_NCIHAL_ENTRY()
+#define NXPLOG_NCIHAL_EXIT()
+#endif
+
+#if (ENABLE_NCIX_TRACES == TRUE)
+#define NXPLOG_NCIX_ENTRY() NXPLOG_FUNC_ENTRY(NXPLOG_ITEM_NCIX)
+#define NXPLOG_NCIX_EXIT() NXPLOG_FUNC_EXIT(NXPLOG_ITEM_NCIX)
+#else
+#define NXPLOG_NCIX_ENTRY()
+#define NXPLOG_NCIX_EXIT()
+#endif
+
+#if (ENABLE_NCIR_TRACES == TRUE)
+#define NXPLOG_NCIR_ENTRY() NXPLOG_FUNC_ENTRY(NXPLOG_ITEM_NCIR)
+#define NXPLOG_NCIR_EXIT() NXPLOG_FUNC_EXIT(NXPLOG_ITEM_NCIR)
+#else
+#define NXPLOG_NCIR_ENTRY()
+#define NXPLOG_NCIR_EXIT()
+#endif
+
+#ifdef NXP_HCI_REQ
+
+#if (ENABLE_HCPX_TRACES == TRUE)
+#define NXPLOG_HCPX_ENTRY() NXPLOG_FUNC_ENTRY(NXPLOG_ITEM_HCPX)
+#define NXPLOG_HCPX_EXIT() NXPLOG_FUNC_EXIT(NXPLOG_ITEM_HCPX)
+#else
+#define NXPLOG_HCPX_ENTRY()
+#define NXPLOG_HCPX_EXIT()
+#endif
+
+#if (ENABLE_HCPR_TRACES == TRUE)
+#define NXPLOG_HCPR_ENTRY() NXPLOG_FUNC_ENTRY(NXPLOG_ITEM_HCPR)
+#define NXPLOG_HCPR_EXIT() NXPLOG_FUNC_EXIT(NXPLOG_ITEM_HCPR)
+#else
+#define NXPLOG_HCPR_ENTRY()
+#define NXPLOG_HCPR_EXIT()
+#endif
+#endif /* NXP_HCI_REQ */
+
+#endif /* NXP_VRBS_REQ */
+
+void phNxpLog_InitializeLogLevel(void);
+
+#endif /* NXPLOG__H_INCLUDED */
diff --git a/pn72xx/halimpl/mifare/NxpMfcReader.cc b/pn72xx/halimpl/mifare/NxpMfcReader.cc
new file mode 100644
index 00000000..c7ac6a57
--- /dev/null
+++ b/pn72xx/halimpl/mifare/NxpMfcReader.cc
@@ -0,0 +1,520 @@
+/******************************************************************************
+ *
+ *  Copyright 2019-2021,2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#include "NxpMfcReader.h"
+
+#include "phNxpNciHal.h"
+#include <log/log.h>
+#include <phNfcCompId.h>
+#include <phNxpLog.h>
+#include <phNxpNciHal_Adaptation.h>
+#include <phNxpNciHal_ext.h>
+
+extern bool sendRspToUpperLayer;
+extern bool bEnableMfcExtns;
+extern bool bDisableLegacyMfcExtns;
+
+NxpMfcReader &NxpMfcReader::getInstance() {
+  static NxpMfcReader msNxpMfcReader;
+  return msNxpMfcReader;
+}
+
+/*******************************************************************************
+**
+** Function         Write
+**
+** Description      Wrapper API to handle Mifare Transceive to TAG_CMD interface
+**                  RAW read write.
+**
+** Returns          It returns number of bytes successfully written to NFCC.
+**
+*******************************************************************************/
+int NxpMfcReader::Write(uint16_t mfcDataLen, const uint8_t *pMfcData) {
+  // Eg:- From the App pMfcData- {|PART1-00 00 06 C1 04| PART2-01 00 00 00|}
+  uint16_t mfcTagCmdBuffLen = 0;
+  uint8_t mfcTagCmdBuff[MAX_MFC_BUFF_SIZE] = {0};
+  uint16_t mfcTagCmdRemaingCmdLen = mfcDataLen;
+
+  if (mfcDataLen > MAX_MFC_BUFF_SIZE) {
+    android_errorWriteLog(0x534e4554, "169259605");
+    mfcDataLen = MAX_MFC_BUFF_SIZE;
+  }
+  memcpy(mfcTagCmdBuff, pMfcData, mfcDataLen);
+  if (mfcDataLen >= 3)
+    mfcTagCmdBuffLen = mfcDataLen - NCI_HEADER_SIZE;
+  BuildMfcCmd(&mfcTagCmdBuff[3], &mfcTagCmdBuffLen);
+
+  mfcTagCmdBuff[2] = mfcTagCmdBuffLen;
+  mfcDataLen = mfcTagCmdBuffLen + NCI_HEADER_SIZE;
+
+  if (checkIsMFCIncDecRestore(pMfcData[3])) {
+    if (sem_init(&mNacksem, 0, 0) != 0) {
+      NXPLOG_NCIHAL_E("%s : sem_init failed", __func__);
+      return 0;
+    }
+  }
+  int writtenDataLen = phNxpNciHal_write_internal(mfcDataLen, mfcTagCmdBuff);
+
+  /* send TAG_CMD part 2 for Mifare increment ,decrement and restore commands */
+  if (checkIsMFCIncDecRestore(pMfcData[3])) {
+    MfcWaitForAck();
+    if (isAck) {
+      NXPLOG_NCIHAL_D("part 1 command Acked");
+      SendIncDecRestoreCmdPart2(mfcTagCmdRemaingCmdLen -
+                                    MFC_TAG_INCR_DECR_CMD_PART1_LEN,
+                                &pMfcData[0]);
+    } else {
+      NXPLOG_NCIHAL_E("part 1 command NACK");
+    }
+    sem_destroy(&mNacksem);
+  }
+  return writtenDataLen;
+}
+
+/*******************************************************************************
+**
+** Function         BuildMfcCmd
+**
+** Description      builds the TAG CMD for Mifare Classic Tag.
+**
+** Returns          None
+**
+*******************************************************************************/
+void NxpMfcReader::BuildMfcCmd(uint8_t *pData, uint16_t *pLength) {
+  uint16_t cmdBuffLen = *pLength;
+  memcpy(mMfcTagCmdIntfData.sendBuf, pData, cmdBuffLen);
+  mMfcTagCmdIntfData.sendBufLen = cmdBuffLen;
+
+  switch (pData[0]) {
+  case eMifareAuthentA:
+  case eMifareAuthentB:
+    BuildAuthCmd();
+    break;
+  case eMifareRead16:
+    BuildReadCmd();
+    break;
+  case eMifareWrite16:
+    AuthForWrite();
+    BuildWrite16Cmd();
+    break;
+  case eMifareInc:
+  case eMifareDec:
+    BuildIncDecCmd();
+    break;
+  default:
+    BuildRawCmd();
+    break;
+  }
+
+  memcpy(pData, mMfcTagCmdIntfData.sendBuf, (mMfcTagCmdIntfData.sendBufLen));
+  *pLength = (mMfcTagCmdIntfData.sendBufLen);
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         BuildAuthCmd
+**
+** Description      builds the TAG CMD for Mifare Auth.
+**
+** Returns          None
+**
+*******************************************************************************/
+void NxpMfcReader::BuildAuthCmd() {
+  uint8_t byKey = 0x00, noOfKeys = 0x00;
+  bool isPreloadedKey = false;
+
+  if (mMfcTagCmdIntfData.sendBuf[0] == eMifareAuthentB) {
+    byKey |= MFC_ENABLE_KEY_B;
+  }
+  uint8_t aMfckeys[MFC_NUM_OF_KEYS][MFC_KEY_SIZE] = MFC_KEYS;
+  noOfKeys = sizeof(aMfckeys) / MFC_KEY_SIZE;
+  for (uint8_t byIndex = 0; byIndex < noOfKeys; byIndex++) {
+    if ((memcmp(aMfckeys[byIndex], &mMfcTagCmdIntfData.sendBuf[6],
+                MFC_AUTHKEYLEN) == 0x00)) {
+      byKey = byKey | byIndex;
+      isPreloadedKey = true;
+      break;
+    }
+  }
+  CalcSectorAddress();
+  mMfcTagCmdIntfData.sendBufLen = 0x03;
+  if (!isPreloadedKey) {
+    byKey |= MFC_EMBEDDED_KEY;
+    memmove(&mMfcTagCmdIntfData.sendBuf[3], &mMfcTagCmdIntfData.sendBuf[6],
+            MFC_AUTHKEYLEN);
+    mMfcTagCmdIntfData.sendBufLen += MFC_AUTHKEYLEN;
+  }
+
+  mMfcTagCmdIntfData.sendBuf[0] = eMfcAuthReq;
+  mMfcTagCmdIntfData.sendBuf[1] = mMfcTagCmdIntfData.byAddr;
+  mMfcTagCmdIntfData.sendBuf[2] = byKey;
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         CalcSectorAddress
+**
+** Description      This function update the sector address for Mifare classic
+**
+** Returns          None
+**
+*******************************************************************************/
+void NxpMfcReader::CalcSectorAddress() {
+  uint8_t BlockNumber = mMfcTagCmdIntfData.sendBuf[1];
+  if (BlockNumber >= MFC_4K_BLK128) {
+    mMfcTagCmdIntfData.byAddr =
+        (uint8_t)(MFC_SECTOR_NO32 +
+                  ((BlockNumber - MFC_4K_BLK128) / MFC_BYTES_PER_BLOCK));
+  } else {
+    mMfcTagCmdIntfData.byAddr = BlockNumber / MFC_BLKS_PER_SECTOR;
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         BuildReadCmd
+**
+** Description      builds the TAG CMD for Mifare Read.
+**
+** Returns          None
+**
+*******************************************************************************/
+void NxpMfcReader::BuildReadCmd() { BuildRawCmd(); }
+
+/*******************************************************************************
+**
+** Function         checkIsMFCIncDecRestore
+**
+** Description      Check command is MF Increment/Decrement or Restore.
+**
+** Returns          True/False
+**
+*******************************************************************************/
+bool NxpMfcReader::checkIsMFCIncDecRestore(uint8_t cmdInst) {
+  return (cmdInst == eMifareDec || cmdInst == eMifareInc ||
+          cmdInst == eMifareRestore);
+}
+
+/*******************************************************************************
+**
+** Function         BuildWrite16Cmd
+**
+** Description      builds the TAG CMD for Mifare write part 2.
+**
+** Returns          None
+**
+*******************************************************************************/
+void NxpMfcReader::BuildWrite16Cmd() {
+  mMfcTagCmdIntfData.sendBuf[0] = eMfRawDataXchgHdr;
+  mMfcTagCmdIntfData.sendBufLen = mMfcTagCmdIntfData.sendBufLen - 1;
+  uint8_t buff[mMfcTagCmdIntfData.sendBufLen];
+  memset(buff, 0, mMfcTagCmdIntfData.sendBufLen);
+  memcpy(buff, mMfcTagCmdIntfData.sendBuf + 2,
+         (mMfcTagCmdIntfData.sendBufLen - 1));
+  memcpy(mMfcTagCmdIntfData.sendBuf + 1, buff,
+         (mMfcTagCmdIntfData.sendBufLen - 1));
+}
+
+/*******************************************************************************
+**
+** Function         BuildRawCmd
+**
+** Description      builds the TAG CMD for Raw transceive.
+**
+** Returns          None
+**
+*******************************************************************************/
+void NxpMfcReader::BuildRawCmd() {
+  mMfcTagCmdIntfData.sendBufLen = mMfcTagCmdIntfData.sendBufLen + 1;
+  uint8_t buff[mMfcTagCmdIntfData.sendBufLen];
+  memset(buff, 0, mMfcTagCmdIntfData.sendBufLen);
+  memcpy(buff, mMfcTagCmdIntfData.sendBuf, mMfcTagCmdIntfData.sendBufLen);
+  memcpy(mMfcTagCmdIntfData.sendBuf + 1, buff, mMfcTagCmdIntfData.sendBufLen);
+  mMfcTagCmdIntfData.sendBuf[0] = eMfRawDataXchgHdr;
+}
+
+/*******************************************************************************
+**
+** Function         BuildIncDecCmd
+**
+** Description      builds the TAG CMD for Mifare Inc/Dec.
+**
+** Returns          None
+**
+*******************************************************************************/
+void NxpMfcReader::BuildIncDecCmd() {
+  mMfcTagCmdIntfData.sendBufLen = 0x03; // eMfRawDataXchgHdr + cmd +
+                                        // blockaddress
+  uint8_t buff[mMfcTagCmdIntfData.sendBufLen];
+  memset(buff, 0, mMfcTagCmdIntfData.sendBufLen);
+  memcpy(buff, mMfcTagCmdIntfData.sendBuf, mMfcTagCmdIntfData.sendBufLen);
+  memcpy(mMfcTagCmdIntfData.sendBuf + 1, buff, mMfcTagCmdIntfData.sendBufLen);
+  mMfcTagCmdIntfData.sendBuf[0] = eMfRawDataXchgHdr;
+}
+
+/*******************************************************************************
+**
+** Function         AuthForWrite
+**
+** Description      send Mifare write Part 1.
+**
+** Returns          None
+**
+*******************************************************************************/
+void NxpMfcReader::AuthForWrite() {
+  sendRspToUpperLayer = false;
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  uint8_t authForWriteBuff[] = {0x00,
+                                0x00,
+                                0x03,
+                                (uint8_t)eMfRawDataXchgHdr,
+                                (uint8_t)mMfcTagCmdIntfData.sendBuf[0],
+                                (uint8_t)mMfcTagCmdIntfData.sendBuf[1]};
+
+  status = phNxpNciHal_send_ext_cmd(
+      sizeof(authForWriteBuff) / sizeof(authForWriteBuff[0]), authForWriteBuff);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("Mifare Auth for Transceive failed");
+  }
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         SendIncDecRestoreCmdPart2
+**
+** Description      send Mifare Inc/Dec/Restore Command Part 2.
+**
+** Returns          None
+**
+*******************************************************************************/
+void NxpMfcReader::SendIncDecRestoreCmdPart2(uint16_t mfcDataLen,
+                                             const uint8_t *mfcData) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  bool isError = false;
+  /* Build TAG_CMD part 2 for Mifare increment ,decrement and restore commands*/
+  uint8_t incDecRestorePart2[] = {0x00, 0x00, 0x05, (uint8_t)eMfRawDataXchgHdr,
+                                  0x00, 0x00, 0x00, 0x00};
+  uint8_t incDecRestorePart2Size =
+      (sizeof(incDecRestorePart2) / sizeof(incDecRestorePart2[0]));
+
+  if (mfcData[3] == eMifareInc || mfcData[3] == eMifareDec) {
+    if (mfcDataLen > MFC_TAG_INCR_DECR_CMD_PART2_LEN) {
+      isError = true;
+      incDecRestorePart2Size = MFC_TAG_INCR_DECR_CMD_PART2_LEN;
+    } else if (mfcDataLen < MFC_TAG_INCR_DECR_CMD_PART2_LEN) {
+      isError = true;
+      incDecRestorePart2Size = mfcDataLen;
+    }
+  }
+  if (isError) {
+    android_errorWriteLog(0x534e4554, "238177877");
+  }
+  for (int i = 4; i < incDecRestorePart2Size; i++) {
+    incDecRestorePart2[i] = mfcData[i + 1];
+  }
+  sendRspToUpperLayer = false;
+  status = phNxpNciHal_send_ext_cmd(incDecRestorePart2Size, incDecRestorePart2);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("Mifare Cmd for inc/dec/Restore part 2 failed");
+  }
+  return;
+}
+
+/*******************************************************************************
+**
+** Function          AnalyzeMfcResp
+**
+** Description      Analyze type of MFC response and build MFC response from
+**                  Tag cmd Intf response?
+**
+** Returns          NFCSTATUS_SUCCESS - Data Reception is successful
+**                  NFCSTATUS_FAILED  - Data Reception failed
+**
+*******************************************************************************/
+NFCSTATUS NxpMfcReader::AnalyzeMfcResp(uint8_t *pBuff, uint16_t *pBufflen) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  uint16_t wPldDataSize = 0;
+  MfcRespId_t RecvdExtnRspId = eInvalidRsp;
+
+  if (0 == (*pBufflen)) {
+    status = NFCSTATUS_FAILED;
+  } else {
+    RecvdExtnRspId = (MfcRespId_t)pBuff[0];
+    NXPLOG_NCIHAL_E("%s: RecvdExtnRspId=%d", __func__, RecvdExtnRspId);
+    switch (RecvdExtnRspId) {
+    case eMfXchgDataRsp: {
+      NFCSTATUS writeRespStatus = NFCSTATUS_SUCCESS;
+      /* check the status byte */
+      if (*pBufflen == 3) {
+        if ((pBuff[0] == 0x10) && (pBuff[1] != 0x0A)) {
+          NXPLOG_NCIHAL_E("Mifare Error in payload response");
+          *pBufflen = 0x1;
+          pBuff[0] = NFCSTATUS_FAILED;
+          return NFCSTATUS_FAILED;
+        } else {
+          pBuff[0] = NFCSTATUS_SUCCESS;
+          return NFCSTATUS_SUCCESS;
+        }
+      }
+      writeRespStatus = pBuff[*pBufflen - 1];
+
+      if (NFCSTATUS_SUCCESS == writeRespStatus) {
+        status = NFCSTATUS_SUCCESS;
+        uint16_t wRecvDataSz = 0;
+
+        wPldDataSize =
+            ((*pBufflen) - (MFC_EXTN_ID_SIZE + MFC_EXTN_STATUS_SIZE));
+        wRecvDataSz = MAX_MFC_BUFF_SIZE;
+        if ((wPldDataSize) <= wRecvDataSz) {
+          /* Extract the data part from pBuff[2] & fill it to be sent to
+           * upper layer */
+          memcpy(&(pBuff[0]), &(pBuff[1]), wPldDataSize);
+          /* update the number of bytes received from lower layer,excluding
+           * the status byte */
+          *pBufflen = wPldDataSize;
+        } else {
+          status = NFCSTATUS_FAILED;
+        }
+      } else {
+        status = NFCSTATUS_FAILED;
+      }
+    } break;
+
+    case eMfcAuthRsp: {
+      /* check the status byte */
+      if (NFCSTATUS_SUCCESS == pBuff[1]) {
+        status = NFCSTATUS_SUCCESS;
+        /* DataLen = TotalRecvdLen - (sizeof(RspId) + sizeof(Status)) */
+        wPldDataSize =
+            ((*pBufflen) - (MFC_EXTN_ID_SIZE + MFC_EXTN_STATUS_SIZE));
+        /* Extract the data part from pBuff[2] & fill it to be sent to upper
+         * layer */
+        pBuff[0] = pBuff[1];
+        /* update the number of bytes received from lower layer,excluding
+         * the status byte */
+        *pBufflen = wPldDataSize + 1;
+      } else {
+        pBuff[0] = pBuff[1];
+        *pBufflen = 1;
+        status = NFCSTATUS_FAILED;
+      }
+    } break;
+    default: {
+      status = NFCSTATUS_FAILED;
+    } break;
+    }
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         CheckMfcResponse
+**
+** Description      This function is called to check if it's a valid Mfc
+**                  response data
+**
+** Returns          NFCSTATUS_SUCCESS
+**                  NFCSTATUS_FAILED
+**
+*******************************************************************************/
+NFCSTATUS NxpMfcReader::CheckMfcResponse(uint8_t *pTransceiveData,
+                                         uint16_t transceiveDataLen) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  if (transceiveDataLen == 3) {
+    if ((pTransceiveData)[0] == 0x10 && (pTransceiveData)[1] != 0x0A) {
+      NXPLOG_NCIHAL_E("Mifare Error in payload response");
+      transceiveDataLen = 0x1;
+      pTransceiveData += 1;
+      return NFCSTATUS_FAILED;
+    }
+  }
+  if ((pTransceiveData)[0] == 0x40) {
+    pTransceiveData += 1;
+    transceiveDataLen = 0x01;
+    if ((pTransceiveData)[0] == 0x03) {
+      transceiveDataLen = 0x00;
+      status = NFCSTATUS_FAILED;
+    }
+  } else if ((pTransceiveData)[0] == 0x10) {
+    pTransceiveData += 1;
+    transceiveDataLen = 0x10;
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         MfcAckReceived
+**
+** Description      This function is called to notify that MFC
+**                  response data is received
+**
+** Returns          NFCSTATUS_SUCCESS
+**                  NFCSTATUS_FAILED
+**
+*******************************************************************************/
+void NxpMfcReader::MfcNotifyOnAckReceived(uint8_t *buff) {
+  const uint8_t NCI_RF_CONN_ID = 0;
+  /*
+   * If Mifare Activated & received RF data packet
+   */
+  if (bEnableMfcExtns && bDisableLegacyMfcExtns &&
+      (buff[0] == NCI_RF_CONN_ID)) {
+    int sem_val;
+    isAck = (buff[3] == NFCSTATUS_SUCCESS);
+    sem_getvalue(&mNacksem, &sem_val);
+    if (sem_val == 0) {
+      if (sem_post(&mNacksem) == -1) {
+        NXPLOG_NCIHAL_E("%s : sem_post failed", __func__);
+      }
+    }
+  }
+}
+
+/*******************************************************************************
+**
+** Function         MfcWaitForAck
+**
+** Description      This function is called to wait for MFC NACK
+**
+** Returns          NFCSTATUS_SUCCESS
+**                  NFCSTATUS_FAILED
+**
+*******************************************************************************/
+NFCSTATUS NxpMfcReader::MfcWaitForAck() {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  int sem_timedout = 2, s;
+  struct timespec ts;
+  isAck = false;
+  clock_gettime(CLOCK_MONOTONIC, &ts);
+  ts.tv_sec += sem_timedout;
+  while ((s = sem_timedwait_monotonic_np(&mNacksem, &ts)) == -1 &&
+         errno == EINTR) {
+    continue; /* Restart if interrupted by handler */
+  }
+  if (s != -1) {
+    status = NFCSTATUS_SUCCESS;
+  }
+  return status;
+}
diff --git a/pn72xx/halimpl/mifare/NxpMfcReader.h b/pn72xx/halimpl/mifare/NxpMfcReader.h
new file mode 100644
index 00000000..e9467cd9
--- /dev/null
+++ b/pn72xx/halimpl/mifare/NxpMfcReader.h
@@ -0,0 +1,128 @@
+/******************************************************************************
+ *
+ *  Copyright 2019-2020,2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#pragma once
+
+/*include files*/
+#include <phNfcStatus.h>
+#include <phNfcTypes.h>
+#include <semaphore.h>
+
+#define NxpMfcReaderInstance (NxpMfcReader::getInstance())
+
+#define MAX_MFC_BUFF_SIZE 300
+#define MFC_TAG_INCR_DECR_CMD_PART1_LEN 5
+#define MFC_TAG_INCR_DECR_CMD_PART2_LEN 4
+
+#define MFC_4K_BLK128 128  /*Block number 128 for Mifare 4k */
+#define MFC_SECTOR_NO32 32 /* Sector 32 for Mifare 4K*/
+#define MFC_BYTES_PER_BLOCK 16
+#define MFC_BLKS_PER_SECTOR (0x04)
+
+#define MFC_EXTN_ID_SIZE (0x01U)     /* Size of Mfc Req/Rsp Id */
+#define MFC_EXTN_STATUS_SIZE (0x01U) /* Size of Mfc Resp Status Byte */
+
+#define MFC_AUTHKEYLEN 0x06 /* Authentication key length */
+#define MFC_AUTHENTICATION_KEY                                                 \
+  (0x00U) /* Authentication key passed in extension                            \
+             command header of authentication command */
+#define MFC_ENABLE_KEY_B (0x80U)
+#define MFC_EMBEDDED_KEY (0x10)
+#define MFC_NUM_OF_KEYS (0x03U)
+#define MFC_KEY_SIZE (0x06U)
+#define MFC_KEYS                                                               \
+  {                                                                            \
+    {0xA0, 0XA1, 0xA2, 0XA3, 0xA4, 0XA5},                                      \
+        {0xD3, 0XF7, 0xD3, 0XF7, 0xD3, 0XF7},                                  \
+        {0xFF, 0XFF, 0xFF, 0XFF, 0xFF, 0XFF},                                  \
+  } /* Key used during NDEF format */
+
+typedef enum MifareCmdList {
+  eMifareRaw = 0x00U,         /* This command performs raw transcations */
+  eMifareAuthentA = 0x60U,    /* This command performs an authentication with
+                                       KEY A for a sector. */
+  eMifareAuthentB = 0x61U,    /* This command performs an authentication with
+                                       KEY B for a sector. */
+  eMifareRead16 = 0x30U,      /* Read 16 Bytes from a Mifare Standard block */
+  eMifareRead = 0x30U,        /* Read Mifare Standard */
+  eMifareWrite16 = 0xA0U,     /* Write 16 Bytes to a Mifare Standard block */
+  eMifareWrite4 = 0xA2U,      /* Write 4 bytes. */
+  eMifareInc = 0xC1U,         /* Increment */
+  eMifareDec = 0xC0U,         /* Decrement */
+  eMifareTransfer = 0xB0U,    /* Transfer */
+  eMifareRestore = 0xC2U,     /* Restore.   */
+  eMifareReadSector = 0x38U,  /* Read Sector.   */
+  eMifareWriteSector = 0xA8U, /* Write Sector.   */
+} MifareCmdList_t;
+
+/*
+ * Request Id for different commands
+ */
+typedef enum MfcCmdReqId {
+  eMfRawDataXchgHdr = 0x10,   /* MF Raw Data Request from DH */
+  eMfWriteNReq = 0x31,        /* MF N bytes write request from DH */
+  eMfReadNReq = 0x32,         /* MF N bytes read request from DH */
+  eMfSectorSelReq = 0x33,     /* MF Block select request from DH */
+  eMfPlusProxCheckReq = 0x28, /* MF + Prox check request for NFCC from DH */
+  eMfcAuthReq = 0x40,         /* MFC Authentication request for NFCC from DH */
+  eInvalidReq                 /* Invalid ReqId */
+} MfcCmdReqId_t;
+
+/*
+ * Response Ids for different command response
+ */
+typedef enum MfcRespId {
+  eMfXchgDataRsp = 0x10,      /* DH gets Raw data from MF on successful req */
+  eMfWriteNRsp = 0x31,        /* DH gets write status */
+  eMfReadNRsp = 0x32,         /* DH gets N Bytes read from MF, if successful */
+  eMfSectorSelRsp = 0x33,     /* DH gets the Sector Select cmd status */
+  eMfPlusProxCheckRsp = 0x29, /* DH gets the MF+ Prox Check cmd status */
+  eMfcAuthRsp = 0x40,         /* DH gets the authenticate cmd status */
+  eInvalidRsp                 /* Invalid RspId */
+} MfcRespId_t;
+
+typedef struct MfcTagCmdIntfData {
+  uint8_t byAddr;      /* Start address to perform operation*/
+  uint16_t sendBufLen; /* Holds the length of the received data. */
+  uint8_t sendBuf[MAX_MFC_BUFF_SIZE]; /*Holds the ack of some initial commands*/
+} MfcTagCmdIntfData_t;
+
+class NxpMfcReader {
+private:
+  MfcTagCmdIntfData_t mMfcTagCmdIntfData;
+  sem_t mNacksem;
+  bool isAck;
+  void BuildMfcCmd(uint8_t *pData, uint16_t *pLength);
+  void BuildAuthCmd();
+  void BuildReadCmd();
+  void BuildWrite16Cmd();
+  void BuildRawCmd();
+  void BuildIncDecCmd();
+  void CalcSectorAddress();
+  void AuthForWrite();
+  void SendIncDecRestoreCmdPart2(uint16_t mfcDataLen, const uint8_t *mfcData);
+
+public:
+  int Write(uint16_t mfcDataLen, const uint8_t *pMfcData);
+  NFCSTATUS AnalyzeMfcResp(uint8_t *pBuff, uint16_t *pBufflen);
+  NFCSTATUS CheckMfcResponse(uint8_t *pTransceiveData,
+                             uint16_t transceiveDataLen);
+  void MfcNotifyOnAckReceived(uint8_t *buff);
+  NFCSTATUS MfcWaitForAck();
+  static NxpMfcReader &getInstance();
+  bool checkIsMFCIncDecRestore(uint8_t cmd);
+};
diff --git a/pn72xx/halimpl/src/include/buildcfg_hal.h b/pn72xx/halimpl/src/include/buildcfg_hal.h
new file mode 100755
index 00000000..d43fb0cb
--- /dev/null
+++ b/pn72xx/halimpl/src/include/buildcfg_hal.h
@@ -0,0 +1,24 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 1999-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  this file contains constant definitions for customizing NFA
+ *
+ ******************************************************************************/
+#pragma once
diff --git a/pn72xx/halimpl/src/include/data_types.h b/pn72xx/halimpl/src/include/data_types.h
new file mode 100755
index 00000000..3ce2d07d
--- /dev/null
+++ b/pn72xx/halimpl/src/include/data_types.h
@@ -0,0 +1,62 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 1999-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef DATA_TYPES_H
+#define DATA_TYPES_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#ifndef false
+#define false 0
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+typedef uint32_t TIME_STAMP;
+
+#ifndef true
+#define true (!false)
+#endif
+
+#ifndef TRUE
+#define TRUE (!FALSE)
+#endif
+typedef unsigned char UBYTE;
+
+#ifdef __arm
+#define PACKED __packed
+#define INLINE __inline
+#else
+#define PACKED
+#define INLINE
+#endif
+
+#ifndef BIG_ENDIAN
+#define BIG_ENDIAN false
+#endif
+
+#define UINT16_LOW_BYTE(x) ((x)&0xff)
+#define UINT16_HI_BYTE(x) ((x) >> 8)
+
+#endif
diff --git a/pn72xx/halimpl/src/include/ese_hal_api.h b/pn72xx/halimpl/src/include/ese_hal_api.h
new file mode 100755
index 00000000..68bf7aed
--- /dev/null
+++ b/pn72xx/halimpl/src/include/ese_hal_api.h
@@ -0,0 +1,108 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2012-2014 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+ *
+ *  The original Work has been changed by NXP.
+ *
+ *  Copyright 2015,2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  ESE Hardware Abstraction Layer API
+ *
+ ******************************************************************************/
+#ifndef ESE_HAL_API_H
+#define ESE_HAL_API_H
+#include "data_types.h"
+/*******************************************************************************
+** tHAL_HCI_NETWK_CMD Definitions
+*******************************************************************************/
+#define HAL_ESE_HCI_NO_UICC_HOST 0x00
+#define HAL_ESE_HCI_UICC0_HOST 0x01
+#define HAL_ESE_HCI_UICC1_HOST 0x02
+#define HAL_ESE_HCI_UICC2_HOST 0x04
+typedef uint8_t tHAL_ESE_STATUS;
+typedef void(tHAL_ESE_STATUS_CBACK)(tHAL_ESE_STATUS status);
+typedef void(tHAL_ESE_CBACK)(uint8_t event, tHAL_ESE_STATUS status);
+typedef void(tHAL_ESE_DATA_CBACK)(uint16_t data_len, uint8_t *p_data);
+
+/*******************************************************************************
+** tHAL_ESE_ENTRY HAL entry-point lookup table
+*******************************************************************************/
+
+typedef void(tHAL_SPIAPI_OPEN)(tHAL_ESE_CBACK *p_hal_cback,
+                               tHAL_ESE_DATA_CBACK *p_data_cback);
+typedef void(tHAL_SPIAPI_CLOSE)(void);
+typedef void(tHAL_SPIAPI_WRITE)(uint16_t data_len, uint8_t *p_data);
+typedef void(tHAL_SPIAPI_READ)(uint16_t data_len, uint8_t *p_data);
+typedef int(tHAL_SPIAPI_IOCTL)(long arg, void *p_data);
+
+#define ESE_HAL_DM_PRE_SET_MEM_LEN 5
+typedef struct {
+  uint32_t addr;
+  uint32_t data;
+} tESE_HAL_DM_PRE_SET_MEM;
+
+/* data members for ESE_HAL-HCI */
+typedef struct {
+  bool ese_hal_prm_nvm_required; /* set ese_hal_prm_nvm_required to true, if the
+                                    platform wants to abort PRM process without
+                                    NVM */
+  uint16_t ese_hal_esec_enable_timeout; /* max time to wait for RESET NTF after
+                                           setting REG_PU to high */
+  uint16_t ese_hal_post_xtal_timeout;   /* max time to wait for RESET NTF after
+                                           setting Xtal frequency */
+#if (ESE_HAL_HCI_INCLUDED == true)
+  bool ese_hal_first_boot; /* set ese_hal_first_boot to true, if platform
+                              enables ESE for the first time after bootup */
+  uint8_t ese_hal_hci_uicc_support; /* set ese_hal_hci_uicc_support to Zero, if
+                                       no UICC is supported otherwise set
+                                       corresponding bit(s) for every supported
+                                       UICC(s) */
+#endif
+} tESE_HAL_CFG;
+
+typedef struct {
+  tHAL_SPIAPI_OPEN *open;
+  tHAL_SPIAPI_CLOSE *close;
+  tHAL_SPIAPI_WRITE *write;
+  tHAL_SPIAPI_READ *Read;
+  tHAL_SPIAPI_IOCTL *ioctl;
+} tHAL_ESE_ENTRY;
+
+typedef struct {
+  tHAL_ESE_ENTRY *hal_entry_func;
+  uint8_t boot_mode;
+} tHAL_ESE_CONTEXT;
+tHAL_ESE_ENTRY *getInstance();
+
+#endif /* ESE_HAL_API_H  */
diff --git a/pn72xx/halimpl/tml/NfccTransportFactory.cc b/pn72xx/halimpl/tml/NfccTransportFactory.cc
new file mode 100644
index 00000000..e0562a59
--- /dev/null
+++ b/pn72xx/halimpl/tml/NfccTransportFactory.cc
@@ -0,0 +1,76 @@
+/******************************************************************************
+ *
+ *  Copyright 2020,2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <NfccI2cTransport.h>
+#include <NfccTransportFactory.h>
+#include <phNxpLog.h>
+
+/*******************************************************************************
+ **
+ ** Function         NfccTransportFactory
+ **
+ ** Description      Constructor for transportFactory. This will be private to
+ **                  support singleton
+ **
+ ** Parameters       none
+ **
+ ** Returns          none
+ ******************************************************************************/
+NfccTransportFactory::NfccTransportFactory() {}
+
+/*******************************************************************************
+**
+** Function         getTransport
+**
+** Description      selects and returns transport channel based on the input
+**                  parameter
+**
+** Parameters       Required transport Type
+**
+** Returns          Selected transport channel
+******************************************************************************/
+NfccTransportFactory &NfccTransportFactory::getInstance() {
+  static NfccTransportFactory mTransprtFactoryInstance;
+  return mTransprtFactoryInstance;
+}
+
+/*******************************************************************************
+**
+** Function         getTransport
+**
+** Description      selects and returns transport channel based on the input
+**                  parameter
+**
+** Parameters       Required transport Type
+**
+** Returns          Selected transport channel
+******************************************************************************/
+spTransport NfccTransportFactory::getTransport(transportIntf transportType) {
+  NXPLOG_TML_D("%s Requested transportType: %d\n", __func__, transportType);
+  spTransport mspTransportInterface;
+  switch (transportType) {
+  case I2C:
+  case UNKNOWN:
+    mspTransportInterface = std::make_shared<NfccI2cTransport>();
+    break;
+  default:
+    mspTransportInterface = std::make_shared<NfccI2cTransport>();
+    break;
+  }
+  return mspTransportInterface;
+}
diff --git a/pn72xx/halimpl/tml/NfccTransportFactory.h b/pn72xx/halimpl/tml/NfccTransportFactory.h
new file mode 100644
index 00000000..781acb09
--- /dev/null
+++ b/pn72xx/halimpl/tml/NfccTransportFactory.h
@@ -0,0 +1,67 @@
+/******************************************************************************
+ *
+ *  Copyright 2020,2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+#include <NfccTransport.h>
+#include <memory>
+
+#define transportFactory (NfccTransportFactory::getInstance())
+typedef std::shared_ptr<NfccTransport> spTransport;
+enum transportIntf { I2C, UNKNOWN };
+
+extern spTransport gpTransportObj;
+class NfccTransportFactory {
+  /*****************************************************************************
+   **
+   ** Function         NfccTransportFactory
+   **
+   ** Description      Constructor for transportFactory. This will be private to
+   **                  support singleton
+   **
+   ** Parameters       none
+   **
+   ** Returns          none
+   ****************************************************************************/
+  NfccTransportFactory();
+
+public:
+  /*****************************************************************************
+   **
+   ** Function         getInstance
+   **
+   ** Description      returns the static instance of TransportFactory
+   **
+   ** Parameters       none
+   **
+   ** Returns          TransportFactory instance
+   ****************************************************************************/
+  static NfccTransportFactory &getInstance();
+
+  /*****************************************************************************
+  **
+  ** Function         getTransport
+  **
+  ** Description      selects and returns transport channel based on the input
+  **                  parameter
+  **
+  ** Parameters       Required transport Type
+  **
+  ** Returns          Selected transport channel
+  ****************************************************************************/
+  spTransport getTransport(transportIntf transportType);
+};
diff --git a/pn72xx/halimpl/tml/phDal4Nfc_messageQueueLib.cc b/pn72xx/halimpl/tml/phDal4Nfc_messageQueueLib.cc
new file mode 100644
index 00000000..6e443097
--- /dev/null
+++ b/pn72xx/halimpl/tml/phDal4Nfc_messageQueueLib.cc
@@ -0,0 +1,241 @@
+/*
+ * Copyright 2010-2019,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * DAL independent message queue implementation for Android (can be used under
+ * Linux too)
+ */
+
+#include <errno.h>
+#include <linux/ipc.h>
+#include <phDal4Nfc_messageQueueLib.h>
+#include <phNxpLog.h>
+#include <pthread.h>
+#include <semaphore.h>
+
+typedef struct phDal4Nfc_message_queue_item {
+  phLibNfc_Message_t nMsg;
+  struct phDal4Nfc_message_queue_item *pPrev;
+  struct phDal4Nfc_message_queue_item *pNext;
+} phDal4Nfc_message_queue_item_t;
+
+typedef struct phDal4Nfc_message_queue {
+  phDal4Nfc_message_queue_item_t *pItems;
+  pthread_mutex_t nCriticalSectionMutex;
+  sem_t nProcessSemaphore;
+
+} phDal4Nfc_message_queue_t;
+
+/*******************************************************************************
+**
+** Function         phDal4Nfc_msgget
+**
+** Description      Allocates message queue
+**
+** Parameters       Ignored, included only for Linux queue API compatibility
+**
+** Returns          (int) value of pQueue if successful
+**                  -1, if failed to allocate memory or to init mutex
+**
+*******************************************************************************/
+intptr_t phDal4Nfc_msgget(key_t key, int msgflg) {
+  phDal4Nfc_message_queue_t *pQueue;
+  UNUSED_PROP(key);
+  UNUSED_PROP(msgflg);
+  pQueue =
+      (phDal4Nfc_message_queue_t *)malloc(sizeof(phDal4Nfc_message_queue_t));
+  if (pQueue == NULL)
+    return -1;
+  memset(pQueue, 0, sizeof(phDal4Nfc_message_queue_t));
+  if (pthread_mutex_init(&pQueue->nCriticalSectionMutex, NULL) != 0) {
+    free(pQueue);
+    return -1;
+  }
+  if (sem_init(&pQueue->nProcessSemaphore, 0, 0) == -1) {
+    free(pQueue);
+    return -1;
+  }
+
+  return ((intptr_t)pQueue);
+}
+
+/*******************************************************************************
+**
+** Function         phDal4Nfc_msgrelease
+**
+** Description      Releases message queue
+**
+** Parameters       msqid - message queue handle
+**
+** Returns          None
+**
+*******************************************************************************/
+void phDal4Nfc_msgrelease(intptr_t msqid) {
+  phDal4Nfc_message_queue_t *pQueue = (phDal4Nfc_message_queue_t *)msqid;
+
+  if (pQueue != NULL) {
+    sem_post(&pQueue->nProcessSemaphore);
+    usleep(3000);
+    if (sem_destroy(&pQueue->nProcessSemaphore)) {
+      NXPLOG_TML_E("Failed to destroy semaphore (errno=0x%08x)", errno);
+    }
+    pthread_mutex_destroy(&pQueue->nCriticalSectionMutex);
+
+    free(pQueue);
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phDal4Nfc_msgctl
+**
+** Description      Destroys message queue
+**
+** Parameters       msqid - message queue handle
+**                  cmd, buf - ignored, included only for Linux queue API
+**                  compatibility
+**
+** Returns          0,  if successful
+**                  -1, if invalid handle is passed
+**
+*******************************************************************************/
+int phDal4Nfc_msgctl(intptr_t msqid, int cmd, void *buf) {
+  phDal4Nfc_message_queue_t *pQueue;
+  phDal4Nfc_message_queue_item_t *p;
+  UNUSED_PROP(cmd);
+  UNUSED_PROP(buf);
+  if (msqid == 0)
+    return -1;
+
+  pQueue = (phDal4Nfc_message_queue_t *)msqid;
+  pthread_mutex_lock(&pQueue->nCriticalSectionMutex);
+  if (pQueue->pItems != NULL) {
+    p = pQueue->pItems;
+    while (p->pNext != NULL) {
+      p = p->pNext;
+    }
+    while (p->pPrev != NULL) {
+      p = p->pPrev;
+      free(p->pNext);
+      p->pNext = NULL;
+    }
+    free(p);
+  }
+  pQueue->pItems = NULL;
+  pthread_mutex_unlock(&pQueue->nCriticalSectionMutex);
+  pthread_mutex_destroy(&pQueue->nCriticalSectionMutex);
+  free(pQueue);
+
+  return 0;
+}
+
+/*******************************************************************************
+**
+** Function         phDal4Nfc_msgsnd
+**
+** Description      Sends a message to the queue. The message will be added at
+**                  the end of the queue as appropriate for FIFO policy
+**
+** Parameters       msqid  - message queue handle
+**                  msgp   - message to be sent
+**                  msgsz  - message size
+**                  msgflg - ignored
+**
+** Returns          0,  if successful
+**                  -1, if invalid parameter passed or failed to allocate memory
+**
+*******************************************************************************/
+intptr_t phDal4Nfc_msgsnd(intptr_t msqid, phLibNfc_Message_t *msg, int msgflg) {
+  phDal4Nfc_message_queue_t *pQueue;
+  phDal4Nfc_message_queue_item_t *p;
+  phDal4Nfc_message_queue_item_t *pNew;
+  UNUSED_PROP(msgflg);
+  if ((msqid == 0) || (msg == NULL))
+    return -1;
+
+  pQueue = (phDal4Nfc_message_queue_t *)msqid;
+  pNew = (phDal4Nfc_message_queue_item_t *)malloc(
+      sizeof(phDal4Nfc_message_queue_item_t));
+  if (pNew == NULL)
+    return -1;
+  memset(pNew, 0, sizeof(phDal4Nfc_message_queue_item_t));
+  memcpy(&pNew->nMsg, msg, sizeof(phLibNfc_Message_t));
+  pthread_mutex_lock(&pQueue->nCriticalSectionMutex);
+
+  if (pQueue->pItems != NULL) {
+    p = pQueue->pItems;
+    while (p->pNext != NULL) {
+      p = p->pNext;
+    }
+    p->pNext = pNew;
+    pNew->pPrev = p;
+  } else {
+    pQueue->pItems = pNew;
+  }
+  pthread_mutex_unlock(&pQueue->nCriticalSectionMutex);
+
+  sem_post(&pQueue->nProcessSemaphore);
+
+  return 0;
+}
+
+/*******************************************************************************
+**
+** Function         phDal4Nfc_msgrcv
+**
+** Description      Gets the oldest message from the queue.
+**                  If the queue is empty the function waits (blocks on a mutex)
+**                  until a message is posted to the queue with phDal4Nfc_msgsnd
+**
+** Parameters       msqid  - message queue handle
+**                  msgp   - message to be received
+**                  msgsz  - message size
+**                  msgtyp - ignored
+**                  msgflg - ignored
+**
+** Returns          0,  if successful
+**                  -1, if invalid parameter passed
+**
+*******************************************************************************/
+int phDal4Nfc_msgrcv(intptr_t msqid, phLibNfc_Message_t *msg, long msgtyp,
+                     int msgflg) {
+  phDal4Nfc_message_queue_t *pQueue;
+  phDal4Nfc_message_queue_item_t *p;
+  UNUSED_PROP(msgflg);
+  UNUSED_PROP(msgtyp);
+  if ((msqid == 0) || (msg == NULL))
+    return -1;
+
+  pQueue = (phDal4Nfc_message_queue_t *)msqid;
+
+  if (-1 == sem_wait(&pQueue->nProcessSemaphore)) {
+    NXPLOG_TML_E("sem_wait didn't return success\n");
+  }
+
+  pthread_mutex_lock(&pQueue->nCriticalSectionMutex);
+
+  if (pQueue->pItems != NULL) {
+    memcpy(msg, &(pQueue->pItems)->nMsg, sizeof(phLibNfc_Message_t));
+    p = pQueue->pItems->pNext;
+    free(pQueue->pItems);
+    pQueue->pItems = p;
+  }
+  pthread_mutex_unlock(&pQueue->nCriticalSectionMutex);
+
+  return 0;
+}
diff --git a/pn72xx/halimpl/tml/phDal4Nfc_messageQueueLib.h b/pn72xx/halimpl/tml/phDal4Nfc_messageQueueLib.h
new file mode 100644
index 00000000..521df0fd
--- /dev/null
+++ b/pn72xx/halimpl/tml/phDal4Nfc_messageQueueLib.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2010-2014,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * DAL independent message queue implementation for Android
+ */
+
+#ifndef PHDAL4NFC_MESSAGEQUEUE_H
+#define PHDAL4NFC_MESSAGEQUEUE_H
+
+#include <linux/ipc.h>
+#include <phNfcTypes.h>
+
+intptr_t phDal4Nfc_msgget(key_t key, int msgflg);
+void phDal4Nfc_msgrelease(intptr_t msqid);
+int phDal4Nfc_msgctl(intptr_t msqid, int cmd, void *buf);
+intptr_t phDal4Nfc_msgsnd(intptr_t msqid, phLibNfc_Message_t *msg, int msgflg);
+int phDal4Nfc_msgrcv(intptr_t msqid, phLibNfc_Message_t *msg, long msgtyp,
+                     int msgflg);
+
+#endif /*  PHDAL4NFC_MESSAGEQUEUE_H  */
diff --git a/pn72xx/halimpl/tml/phOsalNfc_Timer.cc b/pn72xx/halimpl/tml/phOsalNfc_Timer.cc
new file mode 100644
index 00000000..dd1f44f0
--- /dev/null
+++ b/pn72xx/halimpl/tml/phOsalNfc_Timer.cc
@@ -0,0 +1,444 @@
+/*
+ * Copyright 2010-2014, 2020,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * OSAL Implementation for Timers.
+ */
+
+#include <phNfcCommon.h>
+#include <phNfcTypes.h>
+#include <phNxpLog.h>
+#include <phNxpNciHal.h>
+#include <phOsalNfc_Timer.h>
+#include <signal.h>
+
+#define PH_NFC_MAX_TIMER (5U)
+static phOsalNfc_TimerHandle_t apTimerInfo[PH_NFC_MAX_TIMER];
+
+extern phNxpNciHal_Control_t nxpncihal_ctrl;
+
+/*
+ * Defines the base address for generating timerid.
+ */
+#define PH_NFC_TIMER_BASE_ADDRESS (100U)
+
+/*
+ *  Defines the value for invalid timerid returned during timeSetEvent
+ */
+#define PH_NFC_TIMER_ID_ZERO (0x00)
+
+/*
+ * Invalid timer ID type. This ID used indicate timer creation is failed */
+#define PH_NFC_TIMER_ID_INVALID (0xFFFF)
+
+/* Forward declarations */
+static void phOsalNfc_PostTimerMsg(phLibNfc_Message_t *pMsg);
+static void phOsalNfc_DeferredCall(void *pParams);
+static void phOsalNfc_Timer_Expired(union sigval sv);
+
+/*
+ *************************** Function Definitions ******************************
+ */
+
+/*******************************************************************************
+**
+** Function         phOsalNfc_Timer_Create
+**
+** Description      Creates a timer which shall call back the specified function
+**                  when the timer expires. Fails if OSAL module is not
+**                  initialized or timers are already occupied
+**
+** Parameters       None
+**
+** Returns          TimerId
+**                  TimerId value of PH_OSALNFC_TIMER_ID_INVALID indicates that
+**                  timer is not created
+**
+*******************************************************************************/
+uint32_t phOsalNfc_Timer_Create(void) {
+  /* dwTimerId is also used as an index at which timer object can be stored */
+  uint32_t dwTimerId = PH_OSALNFC_TIMER_ID_INVALID;
+  static struct sigevent se;
+  phOsalNfc_TimerHandle_t *pTimerHandle;
+  /* Timer needs to be initialized for timer usage */
+
+  se.sigev_notify = SIGEV_THREAD;
+  se.sigev_notify_function = phOsalNfc_Timer_Expired;
+  se.sigev_notify_attributes = NULL;
+  dwTimerId = phUtilNfc_CheckForAvailableTimer();
+
+  /* Check whether timers are available, if yes create a timer handle structure
+   */
+  if ((PH_NFC_TIMER_ID_ZERO != dwTimerId) && (dwTimerId <= PH_NFC_MAX_TIMER)) {
+    pTimerHandle = (phOsalNfc_TimerHandle_t *)&apTimerInfo[dwTimerId - 1];
+    /* Build the Timer Id to be returned to Caller Function */
+    dwTimerId += PH_NFC_TIMER_BASE_ADDRESS;
+    se.sigev_value.sival_int = (int)dwTimerId;
+    /* Create POSIX timer */
+    if (timer_create(CLOCK_REALTIME, &se, &(pTimerHandle->hTimerHandle)) ==
+        -1) {
+      dwTimerId = PH_NFC_TIMER_ID_INVALID;
+    } else {
+      /* Set the state to indicate timer is ready */
+      pTimerHandle->eState = eTimerIdle;
+      /* Store the Timer Id which shall act as flag during check for timer
+       * availability */
+      pTimerHandle->TimerId = dwTimerId;
+    }
+  } else {
+    dwTimerId = PH_NFC_TIMER_ID_INVALID;
+  }
+
+  /* Timer ID invalid can be due to Uninitialized state,Non availability of
+   * Timer */
+  return dwTimerId;
+}
+
+/*******************************************************************************
+**
+** Function         phOsalNfc_Timer_Start
+**
+** Description      Starts the requested, already created, timer.
+**                  If the timer is already running, timer stops and restarts
+**                  with the new timeout value and new callback function in case
+**                  any ??????
+**                  Creates a timer which shall call back the specified function
+**                  when the timer expires
+**
+** Parameters       dwTimerId - valid timer ID obtained during timer creation
+**                  dwRegTimeCnt - requested timeout in milliseconds
+**                  pApplication_callback - application callback interface to be
+**                                          called when timer expires
+**                  pContext - caller context, to be passed to the application
+**                             callback function
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - the operation was successful
+**                  NFCSTATUS_NOT_INITIALISED - OSAL Module is not initialized
+**                  NFCSTATUS_INVALID_PARAMETER - invalid parameter passed to
+**                                                the function
+**                  PH_OSALNFC_TIMER_START_ERROR - timer could not be created
+**                                                 due to system error
+**
+*******************************************************************************/
+NFCSTATUS phOsalNfc_Timer_Start(uint32_t dwTimerId, uint32_t dwRegTimeCnt,
+                                pphOsalNfc_TimerCallbck_t pApplication_callback,
+                                void *pContext) {
+  NFCSTATUS wStartStatus = NFCSTATUS_SUCCESS;
+
+  struct itimerspec its;
+  uint32_t dwIndex;
+  phOsalNfc_TimerHandle_t *pTimerHandle;
+  /* Retrieve the index at which the timer handle structure is stored */
+  dwIndex = dwTimerId - PH_NFC_TIMER_BASE_ADDRESS - 0x01;
+  pTimerHandle = (phOsalNfc_TimerHandle_t *)&apTimerInfo[dwIndex];
+  /* OSAL Module needs to be initialized for timer usage */
+  /* Check whether the handle provided by user is valid */
+  if ((dwIndex < PH_NFC_MAX_TIMER) && (0x00 != pTimerHandle->TimerId) &&
+      (NULL != pApplication_callback)) {
+    its.it_interval.tv_sec = 0;
+    its.it_interval.tv_nsec = 0;
+    its.it_value.tv_sec = dwRegTimeCnt / 1000;
+    its.it_value.tv_nsec = 1000000 * (dwRegTimeCnt % 1000);
+    if (its.it_value.tv_sec == 0 && its.it_value.tv_nsec == 0) {
+      /* This would inadvertently stop the timer*/
+      its.it_value.tv_nsec = 1;
+    }
+    pTimerHandle->Application_callback = pApplication_callback;
+    pTimerHandle->pContext = pContext;
+    pTimerHandle->eState = eTimerRunning;
+    /* Arm the timer */
+    if ((timer_settime(pTimerHandle->hTimerHandle, 0, &its, NULL)) == -1) {
+      wStartStatus = PHNFCSTVAL(CID_NFC_OSAL, PH_OSALNFC_TIMER_START_ERROR);
+    }
+  } else {
+    wStartStatus = PHNFCSTVAL(CID_NFC_OSAL, NFCSTATUS_INVALID_PARAMETER);
+  }
+
+  return wStartStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phOsalNfc_Timer_Stop
+**
+** Description      Stops already started timer
+**                  Allows to stop running timer. In case timer is stopped,
+**                  timer callback will not be notified any more
+**
+** Parameters       dwTimerId - valid timer ID obtained during timer creation
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - the operation was successful
+**                  NFCSTATUS_NOT_INITIALISED - OSAL Module is not initialized
+**                  NFCSTATUS_INVALID_PARAMETER - invalid parameter passed to
+**                                                the function
+**                  PH_OSALNFC_TIMER_STOP_ERROR - timer could not be stopped due
+**                                                to system error
+**
+*******************************************************************************/
+NFCSTATUS phOsalNfc_Timer_Stop(uint32_t dwTimerId) {
+  NFCSTATUS wStopStatus = NFCSTATUS_SUCCESS;
+  static struct itimerspec its = {{0, 0}, {0, 0}};
+
+  uint32_t dwIndex;
+  phOsalNfc_TimerHandle_t *pTimerHandle;
+  dwIndex = dwTimerId - PH_NFC_TIMER_BASE_ADDRESS - 0x01;
+  pTimerHandle = (phOsalNfc_TimerHandle_t *)&apTimerInfo[dwIndex];
+  /* OSAL Module and Timer needs to be initialized for timer usage */
+  /* Check whether the TimerId provided by user is valid */
+  if ((dwIndex < PH_NFC_MAX_TIMER) && (0x00 != pTimerHandle->TimerId) &&
+      (pTimerHandle->eState != eTimerIdle)) {
+    /* Stop the timer only if the callback has not been invoked */
+    if (pTimerHandle->eState == eTimerRunning) {
+      if ((timer_settime(pTimerHandle->hTimerHandle, 0, &its, NULL)) == -1) {
+        wStopStatus = PHNFCSTVAL(CID_NFC_OSAL, PH_OSALNFC_TIMER_STOP_ERROR);
+      } else {
+        /* Change the state of timer to Stopped */
+        pTimerHandle->eState = eTimerStopped;
+      }
+    }
+  } else {
+    wStopStatus = PHNFCSTVAL(CID_NFC_OSAL, NFCSTATUS_INVALID_PARAMETER);
+  }
+
+  return wStopStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phOsalNfc_Timer_Delete
+**
+** Description      Deletes previously created timer
+**                  Allows to delete previously created timer. In case timer is
+**                  running, it is first stopped and then deleted
+**
+** Parameters       dwTimerId - valid timer ID obtained during timer creation
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - the operation was successful
+**                  NFCSTATUS_NOT_INITIALISED - OSAL Module is not initialized
+**                  NFCSTATUS_INVALID_PARAMETER - invalid parameter passed to
+**                                                the function
+**                  PH_OSALNFC_TIMER_DELETE_ERROR - timer could not be stopped
+**                                                  due to system error
+**
+*******************************************************************************/
+NFCSTATUS phOsalNfc_Timer_Delete(uint32_t dwTimerId) {
+  NFCSTATUS wDeleteStatus = NFCSTATUS_SUCCESS;
+
+  uint32_t dwIndex;
+  phOsalNfc_TimerHandle_t *pTimerHandle;
+  dwIndex = dwTimerId - PH_NFC_TIMER_BASE_ADDRESS - 0x01;
+  pTimerHandle = (phOsalNfc_TimerHandle_t *)&apTimerInfo[dwIndex];
+  /* OSAL Module and Timer needs to be initialized for timer usage */
+
+  /* Check whether the TimerId passed by user is valid and Deregistering of
+   * timer is successful */
+  if ((dwIndex < PH_NFC_MAX_TIMER) && (0x00 != pTimerHandle->TimerId) &&
+      (NFCSTATUS_SUCCESS == phOsalNfc_CheckTimerPresence(pTimerHandle))) {
+    /* Cancel the timer before deleting */
+    if (timer_delete(pTimerHandle->hTimerHandle) == -1) {
+      wDeleteStatus = PHNFCSTVAL(CID_NFC_OSAL, PH_OSALNFC_TIMER_DELETE_ERROR);
+    }
+    /* Clear Timer structure used to store timer related data */
+    memset(pTimerHandle, (uint8_t)0x00, sizeof(phOsalNfc_TimerHandle_t));
+  } else {
+    wDeleteStatus = PHNFCSTVAL(CID_NFC_OSAL, NFCSTATUS_INVALID_PARAMETER);
+  }
+  return wDeleteStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phOsalNfc_Timer_Cleanup
+**
+** Description      Deletes all previously created timers
+**                  Allows to delete previously created timers. In case timer is
+**                  running, it is first stopped and then deleted
+**
+** Parameters       None
+**
+** Returns          None
+**
+*******************************************************************************/
+void phOsalNfc_Timer_Cleanup(void) {
+  /* Delete all timers */
+  uint32_t dwIndex;
+  phOsalNfc_TimerHandle_t *pTimerHandle;
+  for (dwIndex = 0; dwIndex < PH_NFC_MAX_TIMER; dwIndex++) {
+    pTimerHandle = (phOsalNfc_TimerHandle_t *)&apTimerInfo[dwIndex];
+    /* OSAL Module and Timer needs to be initialized for timer usage */
+
+    /* Check whether the TimerId passed by user is valid and Deregistering of
+     * timer is successful */
+    if ((0x00 != pTimerHandle->TimerId) &&
+        (NFCSTATUS_SUCCESS == phOsalNfc_CheckTimerPresence(pTimerHandle))) {
+      /* Cancel the timer before deleting */
+      if (timer_delete(pTimerHandle->hTimerHandle) == -1) {
+        NXPLOG_TML_E("timer %d delete error!", dwIndex);
+      }
+      /* Clear Timer structure used to store timer related data */
+      memset(pTimerHandle, (uint8_t)0x00, sizeof(phOsalNfc_TimerHandle_t));
+    }
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phOsalNfc_DeferredCall
+**
+** Description      Invokes the timer callback function after timer expiration.
+**                  Shall invoke the callback function registered by the timer
+**                  caller function
+**
+** Parameters       pParams - parameters indicating the ID of the timer
+**
+** Returns          None                -
+**
+*******************************************************************************/
+static void phOsalNfc_DeferredCall(void *pParams) {
+  /* Retrieve the timer id from the parameter */
+  unsigned long dwIndex;
+  phOsalNfc_TimerHandle_t *pTimerHandle;
+  if (NULL != pParams) {
+    /* Retrieve the index at which the timer handle structure is stored */
+    dwIndex = (uintptr_t)pParams - PH_NFC_TIMER_BASE_ADDRESS - 0x01;
+    pTimerHandle = (phOsalNfc_TimerHandle_t *)&apTimerInfo[dwIndex];
+    if (pTimerHandle->Application_callback != NULL) {
+      /* Invoke the callback function with osal Timer ID */
+      pTimerHandle->Application_callback((uintptr_t)pParams,
+                                         pTimerHandle->pContext);
+    }
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phOsalNfc_PostTimerMsg
+**
+** Description      Posts message on the user thread
+**                  Shall be invoked upon expiration of a timer
+**                  Shall post message on user thread through which timer
+**                  callback function shall be invoked
+**
+** Parameters       pMsg - pointer to the message structure posted on user
+**                         thread
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phOsalNfc_PostTimerMsg(phLibNfc_Message_t *pMsg) {
+  (void)phDal4Nfc_msgsnd(
+      nxpncihal_ctrl.gDrvCfg
+          .nClientId /*gpphOsalNfc_Context->dwCallbackThreadID*/,
+      pMsg, 0);
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phOsalNfc_Timer_Expired
+**
+** Description      posts message upon expiration of timer
+**                  Shall be invoked when any one timer is expired
+**                  Shall post message on user thread to invoke respective
+**                  callback function provided by the caller of Timer function
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phOsalNfc_Timer_Expired(union sigval sv) {
+  uint32_t dwIndex;
+  phOsalNfc_TimerHandle_t *pTimerHandle;
+
+  dwIndex = ((uint32_t)(sv.sival_int)) - PH_NFC_TIMER_BASE_ADDRESS - 0x01;
+  pTimerHandle = (phOsalNfc_TimerHandle_t *)&apTimerInfo[dwIndex];
+  /* Timer is stopped when callback function is invoked */
+  pTimerHandle->eState = eTimerStopped;
+
+  pTimerHandle->tDeferedCallInfo.pDeferedCall = &phOsalNfc_DeferredCall;
+  pTimerHandle->tDeferedCallInfo.pParam = (void *)((intptr_t)(sv.sival_int));
+
+  pTimerHandle->tOsalMessage.eMsgType = PH_LIBNFC_DEFERREDCALL_MSG;
+  pTimerHandle->tOsalMessage.pMsgData = (void *)&pTimerHandle->tDeferedCallInfo;
+
+  /* Post a message on the queue to invoke the function */
+  phOsalNfc_PostTimerMsg((phLibNfc_Message_t *)&pTimerHandle->tOsalMessage);
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phUtilNfc_CheckForAvailableTimer
+**
+** Description      Find an available timer id
+**
+** Parameters       void
+**
+** Returns          Available timer id
+**
+*******************************************************************************/
+uint32_t phUtilNfc_CheckForAvailableTimer(void) {
+  /* Variable used to store the index at which the object structure details
+     can be stored. Initialize it as not available. */
+  uint32_t dwIndex = 0x00;
+  uint32_t dwRetval = 0x00;
+
+  /* Check whether Timer object can be created */
+  for (dwIndex = 0x00; ((dwIndex < PH_NFC_MAX_TIMER) && (0x00 == dwRetval));
+       dwIndex++) {
+    if (!(apTimerInfo[dwIndex].TimerId)) {
+      dwRetval = (dwIndex + 0x01);
+    }
+  }
+
+  return (dwRetval);
+}
+
+/*******************************************************************************
+**
+** Function         phOsalNfc_CheckTimerPresence
+**
+** Description      Checks the requested timer is present or not
+**
+** Parameters       pObjectHandle - timer context
+**
+** Returns          NFCSTATUS_SUCCESS if found
+**                  Other value if not found
+**
+*******************************************************************************/
+NFCSTATUS phOsalNfc_CheckTimerPresence(void *pObjectHandle) {
+  uint32_t dwIndex;
+  NFCSTATUS wRegisterStatus = NFCSTATUS_INVALID_PARAMETER;
+
+  for (dwIndex = 0x00;
+       ((dwIndex < PH_NFC_MAX_TIMER) && (wRegisterStatus != NFCSTATUS_SUCCESS));
+       dwIndex++) {
+    /* For Timer, check whether the requested handle is present or not */
+    if (((&apTimerInfo[dwIndex]) == (phOsalNfc_TimerHandle_t *)pObjectHandle) &&
+        (apTimerInfo[dwIndex].TimerId)) {
+      wRegisterStatus = NFCSTATUS_SUCCESS;
+    }
+  }
+  return wRegisterStatus;
+}
diff --git a/pn72xx/halimpl/tml/phOsalNfc_Timer.h b/pn72xx/halimpl/tml/phOsalNfc_Timer.h
new file mode 100644
index 00000000..3eb4bbb1
--- /dev/null
+++ b/pn72xx/halimpl/tml/phOsalNfc_Timer.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2010-2014,2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * OSAL header files related to Timer functions.
+ */
+
+#ifndef PHOSALNFC_TIMER_H
+#define PHOSALNFC_TIMER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+************************* Include Files ****************************************
+*/
+
+/*
+ * Timer callback interface which will be called once registered timer
+ * time out expires.
+ *        TimerId  - Timer Id for which callback is called.
+ *        pContext - Parameter to be passed to the callback function
+ */
+typedef void (*pphOsalNfc_TimerCallbck_t)(uint32_t TimerId, void *pContext);
+
+/*
+ * The Timer could not be created due to a
+ * system error */
+#define PH_OSALNFC_TIMER_CREATE_ERROR (0X00E0)
+
+/*
+ * The Timer could not be started due to a
+ * system error or invalid handle */
+#define PH_OSALNFC_TIMER_START_ERROR (0X00E1)
+
+/*
+ * The Timer could not be stopped due to a
+ * system error or invalid handle */
+#define PH_OSALNFC_TIMER_STOP_ERROR (0X00E2)
+
+/*
+ * The Timer could not be deleted due to a
+ * system error or invalid handle */
+#define PH_OSALNFC_TIMER_DELETE_ERROR (0X00E3)
+
+/*
+ * Invalid timer ID type.This ID used indicate timer creation is failed */
+#define PH_OSALNFC_TIMER_ID_INVALID (0xFFFF)
+
+/*
+ * OSAL timer message .This message type will be posted to
+ * calling application thread.*/
+#define PH_OSALNFC_TIMER_MSG (0x315)
+
+/*
+***************************Globals,Structure and Enumeration ******************
+*/
+
+uint32_t phOsalNfc_Timer_Create(void);
+NFCSTATUS phOsalNfc_Timer_Start(uint32_t dwTimerId, uint32_t dwRegTimeCnt,
+                                pphOsalNfc_TimerCallbck_t pApplication_callback,
+                                void *pContext);
+NFCSTATUS phOsalNfc_Timer_Stop(uint32_t dwTimerId);
+NFCSTATUS phOsalNfc_Timer_Delete(uint32_t dwTimerId);
+void phOsalNfc_Timer_Cleanup(void);
+uint32_t phUtilNfc_CheckForAvailableTimer(void);
+NFCSTATUS phOsalNfc_CheckTimerPresence(void *pObjectHandle);
+
+#ifdef __cplusplus
+}
+#endif /*  C++ Compilation guard */
+#endif /* PHOSALNFC_TIMER_H */
diff --git a/pn72xx/halimpl/tml/phTmlNfc.cc b/pn72xx/halimpl/tml/phTmlNfc.cc
new file mode 100644
index 00000000..386a1c42
--- /dev/null
+++ b/pn72xx/halimpl/tml/phTmlNfc.cc
@@ -0,0 +1,1183 @@
+/*
+ * Copyright 2010-2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * TML Implementation.
+ */
+
+#include "NfccTransportFactory.h"
+#include <phDal4Nfc_messageQueueLib.h>
+#include <phNxpConfig.h>
+#include <phNxpLog.h>
+#include <phNxpNciHal_utils.h>
+#include <phOsalNfc_Timer.h>
+#include <phTmlNfc.h>
+
+/*
+ * Duration of Timer to wait after sending an Nci packet
+ */
+#define PHTMLNFC_MAXTIME_RETRANSMIT (200U)
+#define MAX_WRITE_RETRY_COUNT 0x03
+#define MAX_READ_RETRY_DELAY_IN_MILLISEC (150U)
+/* Retry Count = Standby Recovery time of NFCC / Retransmission time + 1 */
+static uint8_t bCurrentRetryCount = (2000 / PHTMLNFC_MAXTIME_RETRANSMIT) + 1;
+
+/* Value to reset variables of TML  */
+#define PH_TMLNFC_RESET_VALUE (0x00)
+
+/* Indicates a Initial or offset value */
+#define PH_TMLNFC_VALUE_ONE (0x01)
+
+spTransport gpTransportObj;
+extern bool_t gsIsFirstHalMinOpen;
+
+/* Initialize Context structure pointer used to access context structure */
+phTmlNfc_Context_t *gpphTmlNfc_Context = NULL;
+/* Local Function prototypes */
+static NFCSTATUS phTmlNfc_StartThread(void);
+static void phTmlNfc_ReadDeferredCb(void *pParams);
+static void phTmlNfc_WriteDeferredCb(void *pParams);
+static void *phTmlNfc_TmlThread(void *pParam);
+static void *phTmlNfc_TmlWriterThread(void *pParam);
+static void phTmlNfc_ReTxTimerCb(uint32_t dwTimerId, void *pContext);
+static NFCSTATUS phTmlNfc_InitiateTimer(void);
+static void phTmlNfc_SignalWriteComplete(void);
+static int phTmlNfc_WaitReadInit(void);
+
+/* Function definitions */
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_Init
+**
+** Description      Provides initialization of TML layer and hardware interface
+**                  Configures given hardware interface and sends handle to the
+**                  caller
+**
+** Parameters       pConfig - TML configuration details as provided by the upper
+**                            layer
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - initialization successful
+**                  NFCSTATUS_INVALID_PARAMETER - at least one parameter is
+**                                                invalid
+**                  NFCSTATUS_FAILED - initialization failed (for example,
+**                                     unable to open hardware interface)
+**                  NFCSTATUS_INVALID_DEVICE - device has not been opened or has
+**                                             been disconnected
+**
+*******************************************************************************/
+NFCSTATUS phTmlNfc_Init(pphTmlNfc_Config_t pConfig) {
+  NFCSTATUS wInitStatus = NFCSTATUS_SUCCESS;
+
+  /* Check if TML layer is already Initialized */
+  if (NULL != gpphTmlNfc_Context) {
+    /* TML initialization is already completed */
+    wInitStatus = PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_ALREADY_INITIALISED);
+  }
+  /* Validate Input parameters */
+  else if ((NULL == pConfig) ||
+           (PH_TMLNFC_RESET_VALUE == pConfig->dwGetMsgThreadId)) {
+    /*Parameters passed to TML init are wrong */
+    wInitStatus = PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    /* Allocate memory for TML context */
+    gpphTmlNfc_Context =
+        (phTmlNfc_Context_t *)malloc(sizeof(phTmlNfc_Context_t));
+
+    if (NULL == gpphTmlNfc_Context) {
+      wInitStatus = PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_FAILED);
+    } else {
+      /*Configure transport layer for communication*/
+      if ((gpTransportObj == NULL) &&
+          (NFCSTATUS_SUCCESS != phTmlNfc_ConfigTransport()))
+        return NFCSTATUS_FAILED;
+
+      if (gsIsFirstHalMinOpen) {
+        if (!gpTransportObj->Flushdata(pConfig)) {
+          NXPLOG_NCIHAL_E("Flushdata Failed");
+        }
+      }
+      /* Initialise all the internal TML variables */
+      memset(gpphTmlNfc_Context, PH_TMLNFC_RESET_VALUE,
+             sizeof(phTmlNfc_Context_t));
+      /* Make sure that the thread runs once it is created */
+      gpphTmlNfc_Context->bThreadDone = 1;
+      /* Open the device file to which data is read/written */
+      wInitStatus = gpTransportObj->OpenAndConfigure(
+          pConfig, &(gpphTmlNfc_Context->pDevHandle));
+
+      if (NFCSTATUS_SUCCESS != wInitStatus) {
+        wInitStatus = PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_INVALID_DEVICE);
+        gpphTmlNfc_Context->pDevHandle = NULL;
+      } else {
+        gpphTmlNfc_Context->tReadInfo.bEnable = 0;
+        gpphTmlNfc_Context->tWriteInfo.bEnable = 0;
+        gpphTmlNfc_Context->tReadInfo.bThreadBusy = false;
+        gpphTmlNfc_Context->tWriteInfo.bThreadBusy = false;
+        gpphTmlNfc_Context->fragment_len = pConfig->fragment_len;
+
+        if (0 != sem_init(&gpphTmlNfc_Context->rxSemaphore, 0, 0)) {
+          wInitStatus = NFCSTATUS_FAILED;
+        } else if (0 != phTmlNfc_WaitReadInit()) {
+          wInitStatus = NFCSTATUS_FAILED;
+        } else if (0 != sem_init(&gpphTmlNfc_Context->txSemaphore, 0, 0)) {
+          wInitStatus = NFCSTATUS_FAILED;
+        } else if (0 != sem_init(&gpphTmlNfc_Context->postMsgSemaphore, 0, 0)) {
+          wInitStatus = NFCSTATUS_FAILED;
+        } else {
+          sem_post(&gpphTmlNfc_Context->postMsgSemaphore);
+          /* Start TML thread (to handle write and read operations) */
+          if (NFCSTATUS_SUCCESS != phTmlNfc_StartThread()) {
+            wInitStatus = PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_FAILED);
+          } else {
+            /* Create Timer used for Retransmission of NCI packets */
+            gpphTmlNfc_Context->dwTimerId = phOsalNfc_Timer_Create();
+            if (PH_OSALNFC_TIMER_ID_INVALID != gpphTmlNfc_Context->dwTimerId) {
+              /* Store the Thread Identifier to which Message is to be posted */
+              gpphTmlNfc_Context->dwCallbackThreadId =
+                  pConfig->dwGetMsgThreadId;
+              /* Enable retransmission of Nci packet & set retry count to
+               * default */
+              gpphTmlNfc_Context->eConfig = phTmlNfc_e_DisableRetrans;
+              /* Retry Count = Standby Recovery time of NFCC / Retransmission
+               * time + 1 */
+              gpphTmlNfc_Context->bRetryCount =
+                  (2000 / PHTMLNFC_MAXTIME_RETRANSMIT) + 1;
+              gpphTmlNfc_Context->bWriteCbInvoked = false;
+            } else {
+              wInitStatus = PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_FAILED);
+            }
+          }
+        }
+      }
+    }
+  }
+  /* Clean up all the TML resources if any error */
+  if (NFCSTATUS_SUCCESS != wInitStatus) {
+    /* Clear all handles and memory locations initialized during init */
+    phTmlNfc_Shutdown_CleanUp();
+  }
+
+  return wInitStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_ConfigTransport
+**
+** Description      Configure Transport channel based on transport type provided
+**                  in config file
+**
+** Returns          NFCSTATUS_SUCCESS If transport channel is configured
+**                  NFCSTATUS_FAILED If transport channel configuration failed
+**
+*******************************************************************************/
+NFCSTATUS phTmlNfc_ConfigTransport() {
+  unsigned long transportType = UNKNOWN;
+  unsigned long value = 0;
+  int isfound = GetNxpNumValue(NAME_NXP_TRANSPORT, &value, sizeof(value));
+  if (isfound > 0) {
+    transportType = value;
+  }
+  gpTransportObj = transportFactory.getTransport((transportIntf)transportType);
+  if (gpTransportObj == nullptr) {
+    NXPLOG_TML_E("No Transport channel available \n");
+    return NFCSTATUS_FAILED;
+  }
+  return NFCSTATUS_SUCCESS;
+}
+/*******************************************************************************
+**
+** Function         phTmlNfc_ConfigNciPktReTx
+**
+** Description      Provides Enable/Disable Retransmission of NCI packets
+**                  Needed in case of Timeout between Transmission and Reception
+**                  of NCI packets. Retransmission can be enabled only if
+**                  standby mode is enabled
+**
+** Parameters       eConfig - values from phTmlNfc_ConfigRetrans_t
+**                  bRetryCount - Number of times Nci packets shall be
+**                                retransmitted (default = 3)
+**
+** Returns          None
+**
+*******************************************************************************/
+void phTmlNfc_ConfigNciPktReTx(phTmlNfc_ConfigRetrans_t eConfiguration,
+                               uint8_t bRetryCounter) {
+  /* Enable/Disable Retransmission */
+
+  gpphTmlNfc_Context->eConfig = eConfiguration;
+  if (phTmlNfc_e_EnableRetrans == eConfiguration) {
+    /* Check whether Retry counter passed is valid */
+    if (0 != bRetryCounter) {
+      gpphTmlNfc_Context->bRetryCount = bRetryCounter;
+    }
+    /* Set retry counter to its default value */
+    else {
+      /* Retry Count = Standby Recovery time of NFCC / Retransmission time + 1
+       */
+      gpphTmlNfc_Context->bRetryCount =
+          (2000 / PHTMLNFC_MAXTIME_RETRANSMIT) + 1;
+    }
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_StartThread
+**
+** Description      Initializes comport, reader and writer threads
+**
+** Parameters       None
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - threads initialized successfully
+**                  NFCSTATUS_FAILED - initialization failed due to system error
+**
+*******************************************************************************/
+static NFCSTATUS phTmlNfc_StartThread(void) {
+  NFCSTATUS wStartStatus = NFCSTATUS_SUCCESS;
+  void *h_threadsEvent = 0x00;
+  int pthread_create_status = 0;
+
+  /* Create Reader and Writer threads */
+  pthread_create_status =
+      pthread_create(&gpphTmlNfc_Context->readerThread, NULL,
+                     &phTmlNfc_TmlThread, (void *)h_threadsEvent);
+  if (0 != pthread_create_status) {
+    wStartStatus = NFCSTATUS_FAILED;
+  } else {
+    /*Start Writer Thread*/
+    pthread_create_status =
+        pthread_create(&gpphTmlNfc_Context->writerThread, NULL,
+                       &phTmlNfc_TmlWriterThread, (void *)h_threadsEvent);
+    if (0 != pthread_create_status) {
+      wStartStatus = NFCSTATUS_FAILED;
+    }
+  }
+
+  return wStartStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_ReTxTimerCb
+**
+** Description      This is the timer callback function after timer expiration.
+**
+** Parameters       dwThreadId  - id of the thread posting message
+**                  pContext    - context provided by upper layer
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phTmlNfc_ReTxTimerCb(uint32_t dwTimerId, void *pContext) {
+  if ((gpphTmlNfc_Context->dwTimerId == dwTimerId) && (NULL == pContext)) {
+    /* If Retry Count has reached its limit,Retransmit Nci
+       packet */
+    if (0 == bCurrentRetryCount) {
+      /* Since the count has reached its limit,return from timer callback
+         Upper layer Timeout would have happened */
+    } else {
+      bCurrentRetryCount--;
+      gpphTmlNfc_Context->tWriteInfo.bThreadBusy = true;
+      gpphTmlNfc_Context->tWriteInfo.bEnable = 1;
+    }
+    sem_post(&gpphTmlNfc_Context->txSemaphore);
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_InitiateTimer
+**
+** Description      Start a timer for Tx and Rx thread.
+**
+** Parameters       void
+**
+** Returns          NFC status
+**
+*******************************************************************************/
+static NFCSTATUS phTmlNfc_InitiateTimer(void) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  /* Start Timer once Nci packet is sent */
+  wStatus = phOsalNfc_Timer_Start(gpphTmlNfc_Context->dwTimerId,
+                                  (uint32_t)PHTMLNFC_MAXTIME_RETRANSMIT,
+                                  phTmlNfc_ReTxTimerCb, NULL);
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_TmlThread
+**
+** Description      Read the data from the lower layer driver
+**
+** Parameters       pParam  - parameters for Writer thread function
+**
+** Returns          None
+**
+*******************************************************************************/
+static void *phTmlNfc_TmlThread(void *pParam) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  int32_t dwNoBytesWrRd = PH_TMLNFC_RESET_VALUE;
+  uint8_t temp[260];
+  uint8_t readRetryDelay = 0;
+  /* Transaction info buffer to be passed to Callback Thread */
+  static phTmlNfc_TransactInfo_t tTransactionInfo;
+  /* Structure containing Tml callback function and parameters to be invoked
+     by the callback thread */
+  static phLibNfc_DeferredCall_t tDeferredInfo;
+  /* Initialize Message structure to post message onto Callback Thread */
+  static phLibNfc_Message_t tMsg;
+  UNUSED_PROP(pParam);
+  NXPLOG_TML_D("PN72xx - Tml Reader Thread Started................\n");
+
+  /* Reader thread loop shall be running till shutdown is invoked */
+  while (gpphTmlNfc_Context->bThreadDone) {
+    /* If Tml read is requested */
+    /* Set the variable to success initially */
+    wStatus = NFCSTATUS_SUCCESS;
+    if (-1 == sem_wait(&gpphTmlNfc_Context->rxSemaphore)) {
+      NXPLOG_TML_E("sem_wait didn't return success \n");
+    }
+
+    /* If Tml read is requested */
+    if (1 == gpphTmlNfc_Context->tReadInfo.bEnable) {
+      NXPLOG_TML_D("PN72xx - Read requested.....\n");
+      /* Set the variable to success initially */
+      wStatus = NFCSTATUS_SUCCESS;
+
+      /* Variable to fetch the actual number of bytes read */
+      dwNoBytesWrRd = PH_TMLNFC_RESET_VALUE;
+
+      /* Read the data from the file onto the buffer */
+      if (NULL != gpphTmlNfc_Context->pDevHandle) {
+        NXPLOG_TML_D("PN72xx - Invoking I2C Read.....\n");
+        dwNoBytesWrRd =
+            gpTransportObj->Read(gpphTmlNfc_Context->pDevHandle, temp, 260);
+
+        if (-1 == dwNoBytesWrRd) {
+          NXPLOG_TML_E("PN72xx - Error in I2C Read.....\n");
+          if (readRetryDelay < MAX_READ_RETRY_DELAY_IN_MILLISEC) {
+            /*sleep for 30/60/90/120/150 msec between each read trial incase of
+             * read error*/
+            readRetryDelay += 30;
+          }
+          usleep(readRetryDelay * 1000);
+          sem_post(&gpphTmlNfc_Context->rxSemaphore);
+        } else if (dwNoBytesWrRd > 260) {
+          NXPLOG_TML_E("Numer of bytes read exceeds the limit 260.....\n");
+          readRetryDelay = 0;
+          sem_post(&gpphTmlNfc_Context->rxSemaphore);
+        } else {
+          memcpy(gpphTmlNfc_Context->tReadInfo.pBuffer, temp, dwNoBytesWrRd);
+          readRetryDelay = 0;
+
+          NXPLOG_TML_D("PN72xx - I2C Read successful.....\n");
+          /* This has to be reset only after a successful read */
+          gpphTmlNfc_Context->tReadInfo.bEnable = 0;
+          if ((phTmlNfc_e_EnableRetrans == gpphTmlNfc_Context->eConfig) &&
+              (0x00 != (gpphTmlNfc_Context->tReadInfo.pBuffer[0] & 0xE0))) {
+            NXPLOG_TML_D("PN72xx - Retransmission timer stopped.....\n");
+            /* Stop Timer to prevent Retransmission */
+            uint32_t timerStatus =
+                phOsalNfc_Timer_Stop(gpphTmlNfc_Context->dwTimerId);
+            if (NFCSTATUS_SUCCESS != timerStatus) {
+              NXPLOG_TML_E("PN72xx - timer stopped returned failure.....\n");
+            } else {
+              gpphTmlNfc_Context->bWriteCbInvoked = false;
+            }
+          }
+          /* Update the actual number of bytes read including header */
+          gpphTmlNfc_Context->tReadInfo.wLength = (uint16_t)(dwNoBytesWrRd);
+          phNxpNciHal_print_packet("RECV",
+                                   gpphTmlNfc_Context->tReadInfo.pBuffer,
+                                   gpphTmlNfc_Context->tReadInfo.wLength);
+
+          dwNoBytesWrRd = PH_TMLNFC_RESET_VALUE;
+
+          /* Fill the Transaction info structure to be passed to Callback
+           * Function */
+          tTransactionInfo.wStatus = wStatus;
+          tTransactionInfo.pBuff = gpphTmlNfc_Context->tReadInfo.pBuffer;
+          /* Actual number of bytes read is filled in the structure */
+          tTransactionInfo.wLength = gpphTmlNfc_Context->tReadInfo.wLength;
+
+          /* Read operation completed successfully. Post a Message onto Callback
+           * Thread*/
+          /* Prepare the message to be posted on User thread */
+          tDeferredInfo.pCallback = &phTmlNfc_ReadDeferredCb;
+          tDeferredInfo.pParameter = &tTransactionInfo;
+          tMsg.eMsgType = PH_LIBNFC_DEFERREDCALL_MSG;
+          tMsg.pMsgData = &tDeferredInfo;
+          tMsg.Size = sizeof(tDeferredInfo);
+          NXPLOG_TML_D("PN72xx - Posting read message.....\n");
+          phTmlNfc_DeferredCall(gpphTmlNfc_Context->dwCallbackThreadId, &tMsg);
+        }
+      } else {
+        NXPLOG_TML_D("PN72xx -gpphTmlNfc_Context->pDevHandle is NULL");
+      }
+    } else {
+      NXPLOG_TML_D("PN72xx - read request NOT enabled");
+      usleep(10 * 1000);
+    }
+  } /* End of While loop */
+
+  return NULL;
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_TmlWriterThread
+**
+** Description      Writes the requested data onto the lower layer driver
+**
+** Parameters       pParam  - context provided by upper layer
+**
+** Returns          None
+**
+*******************************************************************************/
+static void *phTmlNfc_TmlWriterThread(void *pParam) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  int32_t dwNoBytesWrRd = PH_TMLNFC_RESET_VALUE;
+  /* Transaction info buffer to be passed to Callback Thread */
+  static phTmlNfc_TransactInfo_t tTransactionInfo;
+  /* Structure containing Tml callback function and parameters to be invoked
+     by the callback thread */
+  static phLibNfc_DeferredCall_t tDeferredInfo;
+  /* Initialize Message structure to post message onto Callback Thread */
+  static phLibNfc_Message_t tMsg;
+  /* In case of I2C Write Retry */
+  static uint16_t retry_cnt;
+  UNUSED_PROP(pParam);
+  NXPLOG_TML_D("PN72xx - Tml Writer Thread Started................\n");
+
+  /* Writer thread loop shall be running till shutdown is invoked */
+  while (gpphTmlNfc_Context->bThreadDone) {
+    NXPLOG_TML_D("PN72xx - Tml Writer Thread Running................\n");
+    if (-1 == sem_wait(&gpphTmlNfc_Context->txSemaphore)) {
+      NXPLOG_TML_E("sem_wait didn't return success \n");
+    }
+    /* If Tml write is requested */
+    if (1 == gpphTmlNfc_Context->tWriteInfo.bEnable) {
+      NXPLOG_TML_D("PN72xx - Write requested.....\n");
+      /* Set the variable to success initially */
+      wStatus = NFCSTATUS_SUCCESS;
+      if (NULL != gpphTmlNfc_Context->pDevHandle) {
+      retry:
+        gpphTmlNfc_Context->tWriteInfo.bEnable = 0;
+        /* Variable to fetch the actual number of bytes written */
+        dwNoBytesWrRd = PH_TMLNFC_RESET_VALUE;
+        /* Write the data in the buffer onto the file */
+        NXPLOG_TML_D("PN72xx - Invoking I2C Write.....\n");
+        /* TML reader writer callback synchronization mutex lock --- START */
+        pthread_mutex_lock(&gpphTmlNfc_Context->wait_busy_lock);
+        gpphTmlNfc_Context->gWriterCbflag = false;
+        dwNoBytesWrRd =
+            gpTransportObj->Write(gpphTmlNfc_Context->pDevHandle,
+                                  gpphTmlNfc_Context->tWriteInfo.pBuffer,
+                                  gpphTmlNfc_Context->tWriteInfo.wLength);
+        /* TML reader writer callback synchronization mutex lock --- END */
+        pthread_mutex_unlock(&gpphTmlNfc_Context->wait_busy_lock);
+
+        /* Try I2C Write Five Times, if it fails : Raju */
+        if (-1 == dwNoBytesWrRd) {
+          if (gpTransportObj->IsFwDnldModeEnabled()) {
+            if (retry_cnt++ < MAX_WRITE_RETRY_COUNT) {
+              NXPLOG_TML_D("PN72xx - Error in I2C Write  - Retry 0x%x",
+                           retry_cnt);
+              // Add a 10 ms delay to ensure NFCC is not still in stand by mode.
+              usleep(10 * 1000);
+              goto retry;
+            }
+          }
+          NXPLOG_TML_D("PN72xx - Error in I2C Write.....\n");
+          wStatus = PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_FAILED);
+        } else {
+          phNxpNciHal_print_packet("SEND",
+                                   gpphTmlNfc_Context->tWriteInfo.pBuffer,
+                                   gpphTmlNfc_Context->tWriteInfo.wLength);
+        }
+        retry_cnt = 0;
+        if (NFCSTATUS_SUCCESS == wStatus) {
+          NXPLOG_TML_D("PN72xx - I2C Write successful.....\n");
+          dwNoBytesWrRd = PH_TMLNFC_VALUE_ONE;
+        }
+        /* Fill the Transaction info structure to be passed to Callback Function
+         */
+        tTransactionInfo.wStatus = wStatus;
+        tTransactionInfo.pBuff = gpphTmlNfc_Context->tWriteInfo.pBuffer;
+        /* Actual number of bytes written is filled in the structure */
+        tTransactionInfo.wLength = (uint16_t)dwNoBytesWrRd;
+
+        /* Prepare the message to be posted on the User thread */
+        tDeferredInfo.pCallback = &phTmlNfc_WriteDeferredCb;
+        tDeferredInfo.pParameter = &tTransactionInfo;
+        /* Write operation completed successfully. Post a Message onto Callback
+         * Thread*/
+        tMsg.eMsgType = PH_LIBNFC_DEFERREDCALL_MSG;
+        tMsg.pMsgData = &tDeferredInfo;
+        tMsg.Size = sizeof(tDeferredInfo);
+
+        /* Check whether Retransmission needs to be started,
+         * If yes, Post message only if
+         * case 1. Message is not posted &&
+         * case 11. Write status is success ||
+         * case 12. Last retry of write is also failure
+         */
+        if ((phTmlNfc_e_EnableRetrans == gpphTmlNfc_Context->eConfig) &&
+            (0x00 != (gpphTmlNfc_Context->tWriteInfo.pBuffer[0] & 0xE0))) {
+          if (gpphTmlNfc_Context->bWriteCbInvoked == false) {
+            if ((NFCSTATUS_SUCCESS == wStatus) || (bCurrentRetryCount == 0)) {
+              NXPLOG_TML_D("PN72xx - Posting Write message.....\n");
+              phTmlNfc_DeferredCall(gpphTmlNfc_Context->dwCallbackThreadId,
+                                    &tMsg);
+              gpphTmlNfc_Context->bWriteCbInvoked = true;
+            }
+          }
+        } else {
+          NXPLOG_TML_D("PN72xx - Posting Fresh Write message.....\n");
+          phTmlNfc_DeferredCall(gpphTmlNfc_Context->dwCallbackThreadId, &tMsg);
+          if (NFCSTATUS_SUCCESS == wStatus) {
+            /*TML reader writer thread callback synchronization---START*/
+            pthread_mutex_lock(&gpphTmlNfc_Context->wait_busy_lock);
+            gpphTmlNfc_Context->gWriterCbflag = true;
+            phTmlNfc_SignalWriteComplete();
+            /*TML reader writer thread callback synchronization---END*/
+            pthread_mutex_unlock(&gpphTmlNfc_Context->wait_busy_lock);
+          }
+        }
+      } else {
+        NXPLOG_TML_D("PN72xx - gpphTmlNfc_Context->pDevHandle is NULL");
+      }
+
+      /* If Data packet is sent, then NO retransmission */
+      if ((phTmlNfc_e_EnableRetrans == gpphTmlNfc_Context->eConfig) &&
+          (0x00 != (gpphTmlNfc_Context->tWriteInfo.pBuffer[0] & 0xE0))) {
+        NXPLOG_TML_D("PN72xx - Starting timer for Retransmission case");
+        wStatus = phTmlNfc_InitiateTimer();
+        if (NFCSTATUS_SUCCESS != wStatus) {
+          /* Reset Variables used for Retransmission */
+          NXPLOG_TML_D("PN72xx - Retransmission timer initiate failed");
+          gpphTmlNfc_Context->tWriteInfo.bEnable = 0;
+          bCurrentRetryCount = 0;
+        }
+      }
+    } else {
+      NXPLOG_TML_D("PN72xx - Write request NOT enabled");
+      usleep(10000);
+    }
+
+  } /* End of While loop */
+
+  return NULL;
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_CleanUp
+**
+** Description      Clears all handles opened during TML initialization
+**
+** Parameters       None
+**
+** Returns          None
+**
+*******************************************************************************/
+void phTmlNfc_CleanUp(void) {
+  if (NULL == gpphTmlNfc_Context) {
+    return;
+  }
+  sem_destroy(&gpphTmlNfc_Context->rxSemaphore);
+  sem_destroy(&gpphTmlNfc_Context->txSemaphore);
+  sem_destroy(&gpphTmlNfc_Context->postMsgSemaphore);
+  pthread_mutex_destroy(&gpphTmlNfc_Context->wait_busy_lock);
+  pthread_cond_destroy(&gpphTmlNfc_Context->wait_busy_condition);
+  gpTransportObj = NULL;
+  /* Clear memory allocated for storing Context variables */
+  free((void *)gpphTmlNfc_Context);
+  /* Set the pointer to NULL to indicate De-Initialization */
+  gpphTmlNfc_Context = NULL;
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_Shutdown
+**
+** Description      Uninitializes TML layer and hardware interface
+**
+** Parameters       None
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - TML configuration released successfully
+**                  NFCSTATUS_INVALID_PARAMETER - at least one parameter is
+**                                                invalid
+**                  NFCSTATUS_FAILED - un-initialization failed (example: unable
+**                                     to close interface)
+**
+*******************************************************************************/
+NFCSTATUS phTmlNfc_Shutdown(void) {
+  NFCSTATUS wShutdownStatus = NFCSTATUS_SUCCESS;
+
+  /* Check whether TML is Initialized */
+  if (NULL != gpphTmlNfc_Context) {
+    /* Reset thread variable to terminate the thread */
+    gpphTmlNfc_Context->bThreadDone = 0;
+    usleep(1000);
+    /* Clear All the resources allocated during initialization */
+    sem_post(&gpphTmlNfc_Context->rxSemaphore);
+    usleep(1000);
+    sem_post(&gpphTmlNfc_Context->txSemaphore);
+    usleep(1000);
+    sem_post(&gpphTmlNfc_Context->postMsgSemaphore);
+    usleep(1000);
+    sem_post(&gpphTmlNfc_Context->postMsgSemaphore);
+    usleep(1000);
+
+    if (nfcFL.chipType < sn100u) {
+      (void)gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                      MODE_POWER_OFF);
+    }
+
+    gpTransportObj->Close(gpphTmlNfc_Context->pDevHandle);
+    gpphTmlNfc_Context->pDevHandle = NULL;
+    if (0 != pthread_join(gpphTmlNfc_Context->readerThread, (void **)NULL)) {
+      NXPLOG_TML_E("Fail to kill reader thread!");
+    }
+    if (0 != pthread_join(gpphTmlNfc_Context->writerThread, (void **)NULL)) {
+      NXPLOG_TML_E("Fail to kill writer thread!");
+    }
+    NXPLOG_TML_D("bThreadDone == 0");
+
+  } else {
+    wShutdownStatus = PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_NOT_INITIALISED);
+  }
+
+  return wShutdownStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_Write
+**
+** Description      Asynchronously writes given data block to hardware
+**                  interface/driver. Enables writer thread if there are no
+**                  write requests pending. Returns successfully once writer
+**                  thread completes write operation. Notifies upper layer using
+**                  callback mechanism.
+**
+**                  NOTE:
+**                  * it is important to post a message with id
+**                    PH_TMLNFC_WRITE_MESSAGE to IntegrationThread after data
+**                    has been written to PN72xx
+**                  * if CRC needs to be computed, then input buffer should be
+**                    capable to store two more bytes apart from length of
+**                    packet
+**
+** Parameters       pBuffer - data to be sent
+**                  wLength - length of data buffer
+**                  pTmlWriteComplete - pointer to the function to be invoked
+**                                      upon completion
+**                  pContext - context provided by upper layer
+**
+** Returns          NFC status:
+**                  NFCSTATUS_PENDING - command is yet to be processed
+**                  NFCSTATUS_INVALID_PARAMETER - at least one parameter is
+**                                                invalid
+**                  NFCSTATUS_BUSY - write request is already in progress
+**
+*******************************************************************************/
+NFCSTATUS phTmlNfc_Write(uint8_t *pBuffer, uint16_t wLength,
+                         pphTmlNfc_TransactCompletionCb_t pTmlWriteComplete,
+                         void *pContext) {
+  NFCSTATUS wWriteStatus;
+
+  /* Check whether TML is Initialized */
+
+  if (NULL != gpphTmlNfc_Context) {
+    if ((NULL != gpphTmlNfc_Context->pDevHandle) && (NULL != pBuffer) &&
+        (PH_TMLNFC_RESET_VALUE != wLength) && (NULL != pTmlWriteComplete)) {
+      if (!gpphTmlNfc_Context->tWriteInfo.bThreadBusy) {
+        /* Setting the flag marks beginning of a Write Operation */
+        gpphTmlNfc_Context->tWriteInfo.bThreadBusy = true;
+        /* Copy the buffer, length and Callback function,
+           This shall be utilized while invoking the Callback function in thread
+           */
+        gpphTmlNfc_Context->tWriteInfo.pBuffer = pBuffer;
+        gpphTmlNfc_Context->tWriteInfo.wLength = wLength;
+        gpphTmlNfc_Context->tWriteInfo.pThread_Callback = pTmlWriteComplete;
+        gpphTmlNfc_Context->tWriteInfo.pContext = pContext;
+
+        wWriteStatus = NFCSTATUS_PENDING;
+        // FIXME: If retry is going on. Stop the retry thread/timer
+        if (phTmlNfc_e_EnableRetrans == gpphTmlNfc_Context->eConfig) {
+          /* Set retry count to default value */
+          // FIXME: If the timer expired there, and meanwhile we have created
+          // a new request. The expired timer will think that retry is still
+          // ongoing.
+          bCurrentRetryCount = gpphTmlNfc_Context->bRetryCount;
+          gpphTmlNfc_Context->bWriteCbInvoked = false;
+        }
+        /* Set event to invoke Writer Thread */
+        gpphTmlNfc_Context->tWriteInfo.bEnable = 1;
+        sem_post(&gpphTmlNfc_Context->txSemaphore);
+      } else {
+        wWriteStatus = PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_BUSY);
+      }
+    } else {
+      wWriteStatus = PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_INVALID_PARAMETER);
+    }
+  } else {
+    wWriteStatus = PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_NOT_INITIALISED);
+  }
+
+  return wWriteStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_Read
+**
+** Description      Asynchronously reads data from the driver
+**                  Number of bytes to be read and buffer are passed by upper
+**                  layer.
+**                  Enables reader thread if there are no read requests pending
+**                  Returns successfully once read operation is completed
+**                  Notifies upper layer using callback mechanism
+**
+** Parameters       pBuffer - location to send read data to the upper layer via
+**                            callback
+**                  wLength - length of read data buffer passed by upper layer
+**                  pTmlReadComplete - pointer to the function to be invoked
+**                                     upon completion of read operation
+**                  pContext - context provided by upper layer
+**
+** Returns          NFC status:
+**                  NFCSTATUS_PENDING - command is yet to be processed
+**                  NFCSTATUS_INVALID_PARAMETER - at least one parameter is
+**                                                invalid
+**                  NFCSTATUS_BUSY - read request is already in progress
+**
+*******************************************************************************/
+NFCSTATUS phTmlNfc_Read(uint8_t *pBuffer, uint16_t wLength,
+                        pphTmlNfc_TransactCompletionCb_t pTmlReadComplete,
+                        void *pContext) {
+  NFCSTATUS wReadStatus;
+  int rxSemVal = 0, ret = 0;
+
+  /* Check whether TML is Initialized */
+  if (NULL != gpphTmlNfc_Context) {
+    if ((gpphTmlNfc_Context->pDevHandle != NULL) && (NULL != pBuffer) &&
+        (PH_TMLNFC_RESET_VALUE != wLength) && (NULL != pTmlReadComplete)) {
+      if (!gpphTmlNfc_Context->tReadInfo.bThreadBusy) {
+        /* Setting the flag marks beginning of a Read Operation */
+        gpphTmlNfc_Context->tReadInfo.bThreadBusy = true;
+        /* Copy the buffer, length and Callback function,
+           This shall be utilized while invoking the Callback function in thread
+           */
+        gpphTmlNfc_Context->tReadInfo.pBuffer = pBuffer;
+        gpphTmlNfc_Context->tReadInfo.wLength = wLength;
+        gpphTmlNfc_Context->tReadInfo.pThread_Callback = pTmlReadComplete;
+        gpphTmlNfc_Context->tReadInfo.pContext = pContext;
+        wReadStatus = NFCSTATUS_PENDING;
+
+        /* Set event to invoke Reader Thread */
+        gpphTmlNfc_Context->tReadInfo.bEnable = 1;
+        ret = sem_getvalue(&gpphTmlNfc_Context->rxSemaphore, &rxSemVal);
+        /* Post rxSemaphore either if sem_getvalue() is failed or rxSemVal is 0
+         */
+        if (ret || !rxSemVal) {
+          sem_post(&gpphTmlNfc_Context->rxSemaphore);
+        } else {
+          NXPLOG_TML_D(
+              "%s: skip reader thread scheduling, ret=%x, rxSemaVal=%x",
+              __func__, ret, rxSemVal);
+        }
+      } else {
+        wReadStatus = PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_BUSY);
+      }
+    } else {
+      wReadStatus = PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_INVALID_PARAMETER);
+    }
+  } else {
+    wReadStatus = PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_NOT_INITIALISED);
+  }
+
+  return wReadStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_ReadAbort
+**
+** Description      Aborts pending read request (if any)
+**
+** Parameters       None
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - ongoing read operation aborted
+**                  NFCSTATUS_INVALID_PARAMETER - at least one parameter is
+**                                                invalid
+**                  NFCSTATUS_NOT_INITIALIZED - TML layer is not initialized
+**                  NFCSTATUS_BOARD_COMMUNICATION_ERROR - unable to cancel read
+**                                                        operation
+**
+*******************************************************************************/
+NFCSTATUS phTmlNfc_ReadAbort(void) {
+  NFCSTATUS wStatus = NFCSTATUS_INVALID_PARAMETER;
+  gpphTmlNfc_Context->tReadInfo.bEnable = 0;
+
+  /*Reset the flag to accept another Read Request */
+  gpphTmlNfc_Context->tReadInfo.bThreadBusy = false;
+  wStatus = NFCSTATUS_SUCCESS;
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_WriteAbort
+**
+** Description      Aborts pending write request (if any)
+**
+** Parameters       None
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - ongoing write operation aborted
+**                  NFCSTATUS_INVALID_PARAMETER - at least one parameter is
+**                                                invalid
+**                  NFCSTATUS_NOT_INITIALIZED - TML layer is not initialized
+**                  NFCSTATUS_BOARD_COMMUNICATION_ERROR - unable to cancel write
+**                                                        operation
+**
+*******************************************************************************/
+NFCSTATUS phTmlNfc_WriteAbort(void) {
+  NFCSTATUS wStatus = NFCSTATUS_INVALID_PARAMETER;
+
+  gpphTmlNfc_Context->tWriteInfo.bEnable = 0;
+  /* Stop if any retransmission is in progress */
+  bCurrentRetryCount = 0;
+
+  /* Reset the flag to accept another Write Request */
+  gpphTmlNfc_Context->tWriteInfo.bThreadBusy = false;
+  wStatus = NFCSTATUS_SUCCESS;
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_IoCtl
+**
+** Description      Resets device when insisted by upper layer
+**                  Number of bytes to be read and buffer are passed by upper
+**                  layer
+**                  Enables reader thread if there are no read requests pending
+**                  Returns successfully once read operation is completed
+**                  Notifies upper layer using callback mechanism
+**
+** Parameters       eControlCode       - control code for a specific operation
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS  - ioctl command completed successfully
+**                  NFCSTATUS_FAILED   - ioctl command request failed
+**
+*******************************************************************************/
+NFCSTATUS phTmlNfc_IoCtl(phTmlNfc_ControlCode_t eControlCode) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  if (NULL == gpphTmlNfc_Context) {
+    wStatus = NFCSTATUS_FAILED;
+  } else {
+    uint8_t read_flag = (gpphTmlNfc_Context->tReadInfo.bEnable > 0);
+
+    switch (eControlCode) {
+    case phTmlNfc_e_EnableVen: {
+      gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle, MODE_POWER_ON);
+      usleep(100 * 1000);
+      break;
+    }
+    case phTmlNfc_e_ResetDevice: {
+      /*Reset PN72XXX*/
+      gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle, MODE_POWER_ON);
+      usleep(100 * 1000);
+      gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle, MODE_POWER_OFF);
+      usleep(100 * 1000);
+      gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle, MODE_POWER_ON);
+      break;
+    }
+    case phTmlNfc_e_EnableNormalMode: {
+      /*Reset PN72XX*/
+      gpphTmlNfc_Context->tReadInfo.bEnable = 0;
+      if (nfcFL.nfccFL._NFCC_DWNLD_MODE == NFCC_DWNLD_WITH_VEN_RESET) {
+        NXPLOG_TML_D(" phTmlNfc_e_EnableNormalMode complete with VEN RESET ");
+        if (nfcFL.chipType >= pn7220) {
+          gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                    MODE_POWER_RESET);
+        } else {
+          gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                    MODE_FW_GPIO_LOW);
+        }
+      } else if (nfcFL.nfccFL._NFCC_DWNLD_MODE == NFCC_DWNLD_WITH_NCI_CMD) {
+        NXPLOG_TML_D(" phTmlNfc_e_EnableNormalMode complete with NCI CMD ");
+        if (nfcFL.chipType < sn100u) {
+          gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                    MODE_POWER_ON);
+        } else {
+          gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                    MODE_FW_GPIO_LOW);
+        }
+      }
+      break;
+    }
+    case phTmlNfc_e_EnableDownloadMode: {
+      phTmlNfc_ConfigNciPktReTx(phTmlNfc_e_DisableRetrans, 0);
+      gpphTmlNfc_Context->tReadInfo.bEnable = 0;
+      if (nfcFL.nfccFL._NFCC_DWNLD_MODE == NFCC_DWNLD_WITH_VEN_RESET) {
+        NXPLOG_TML_D(" phTmlNfc_e_EnableDownloadMode complete with VEN RESET");
+        wStatus = gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                            MODE_FW_DWNLD_WITH_VEN);
+      } else if (nfcFL.nfccFL._NFCC_DWNLD_MODE == NFCC_DWNLD_WITH_NCI_CMD) {
+        NXPLOG_TML_D(" phTmlNfc_e_EnableDownloadMode complete with NCI CMD");
+        wStatus = gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                            MODE_FW_DWND_HIGH);
+      }
+      break;
+    }
+    case phTmlNfc_e_setFragmentSize: {
+      gpphTmlNfc_Context->fragment_len = PH_TMLNFC_FRGMENT_SIZE_PN72XX;
+      NXPLOG_TML_D("phTmlNfc_e_setFragmentSize 0x22A");
+      break;
+    }
+    case phTmlNfc_e_RedLedOff: {
+      gpTransportObj->SetLED(gpphTmlNfc_Context->pDevHandle, RED_LED_OFF);
+      break;
+    }
+    case phTmlNfc_e_RedLedOn: {
+      gpTransportObj->SetLED(gpphTmlNfc_Context->pDevHandle, RED_LED_ON);
+      break;
+    }
+    case phTmlNfc_e_ModeSwitchOn: {
+      gpTransportObj->SetModeSwitch(gpphTmlNfc_Context->pDevHandle, NCI_MODE);
+      break;
+    }
+    case phTmlNfc_e_ModeSwitchOff: {
+      gpTransportObj->SetModeSwitch(gpphTmlNfc_Context->pDevHandle, EMVCO_MODE);
+      break;
+    }
+    default: {
+      wStatus = NFCSTATUS_INVALID_PARAMETER;
+      break;
+    }
+    }
+    if (read_flag && (gpphTmlNfc_Context->tReadInfo.bEnable == 0x00)) {
+      gpphTmlNfc_Context->tReadInfo.bEnable = 1;
+      sem_post(&gpphTmlNfc_Context->rxSemaphore);
+    }
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_DeferredCall
+**
+** Description      Posts message on upper layer thread
+**                  upon successful read or write operation
+**
+** Parameters       dwThreadId  - id of the thread posting message
+**                  ptWorkerMsg - message to be posted
+**
+** Returns          None
+**
+*******************************************************************************/
+void phTmlNfc_DeferredCall(uintptr_t dwThreadId,
+                           phLibNfc_Message_t *ptWorkerMsg) {
+  intptr_t bPostStatus;
+  UNUSED_PROP(dwThreadId);
+  /* Post message on the user thread to invoke the callback function */
+  if (-1 == sem_wait(&gpphTmlNfc_Context->postMsgSemaphore)) {
+    NXPLOG_TML_E("sem_wait didn't return success \n");
+  }
+  bPostStatus =
+      phDal4Nfc_msgsnd(gpphTmlNfc_Context->dwCallbackThreadId, ptWorkerMsg, 0);
+  sem_post(&gpphTmlNfc_Context->postMsgSemaphore);
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_ReadDeferredCb
+**
+** Description      Read thread call back function
+**
+** Parameters       pParams - context provided by upper layer
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phTmlNfc_ReadDeferredCb(void *pParams) {
+  /* Transaction info buffer to be passed to Callback Function */
+  phTmlNfc_TransactInfo_t *pTransactionInfo =
+      (phTmlNfc_TransactInfo_t *)pParams;
+
+  /* Reset the flag to accept another Read Request */
+  gpphTmlNfc_Context->tReadInfo.bThreadBusy = false;
+  gpphTmlNfc_Context->tReadInfo.pThread_Callback(
+      gpphTmlNfc_Context->tReadInfo.pContext, pTransactionInfo);
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_WriteDeferredCb
+**
+** Description      Write thread call back function
+**
+** Parameters       pParams - context provided by upper layer
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phTmlNfc_WriteDeferredCb(void *pParams) {
+  /* Transaction info buffer to be passed to Callback Function */
+  phTmlNfc_TransactInfo_t *pTransactionInfo =
+      (phTmlNfc_TransactInfo_t *)pParams;
+
+  /* Reset the flag to accept another Write Request */
+  gpphTmlNfc_Context->tWriteInfo.bThreadBusy = false;
+  gpphTmlNfc_Context->tWriteInfo.pThread_Callback(
+      gpphTmlNfc_Context->tWriteInfo.pContext, pTransactionInfo);
+
+  return;
+}
+
+void phTmlNfc_set_fragmentation_enabled(phTmlNfc_i2cfragmentation_t result) {
+  fragmentation_enabled = result;
+}
+
+phTmlNfc_i2cfragmentation_t phTmlNfc_get_fragmentation_enabled() {
+  return fragmentation_enabled;
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_SignalWriteComplete
+**
+** Description      function to invoke reader thread
+**
+** Parameters       None
+**
+** Returns          None
+**
+*******************************************************************************/
+static void phTmlNfc_SignalWriteComplete(void) {
+  int ret = -1;
+  if (gpphTmlNfc_Context->wait_busy_flag == true) {
+    NXPLOG_TML_D("phTmlNfc_SignalWriteComplete - enter");
+    gpphTmlNfc_Context->wait_busy_flag = false;
+
+    ret = pthread_cond_signal(&gpphTmlNfc_Context->wait_busy_condition);
+    if (ret) {
+      NXPLOG_TML_E(" phTmlNfc_SignalWriteComplete failed, error = 0x%X", ret);
+    }
+    NXPLOG_TML_D("phTmlNfc_SignalWriteComplete - exit");
+  }
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_WaitReadInit
+**
+** Description      init function for reader thread
+**
+** Parameters       None
+**
+** Returns          int
+**
+*******************************************************************************/
+static int phTmlNfc_WaitReadInit(void) {
+  int ret = -1;
+  pthread_condattr_t attr;
+  pthread_condattr_init(&attr);
+  pthread_condattr_setclock(&attr, CLOCK_MONOTONIC);
+  memset(&gpphTmlNfc_Context->wait_busy_condition, 0,
+         sizeof(gpphTmlNfc_Context->wait_busy_condition));
+  pthread_mutex_init(&gpphTmlNfc_Context->wait_busy_lock, NULL);
+  ret = pthread_cond_init(&gpphTmlNfc_Context->wait_busy_condition, &attr);
+  if (ret) {
+    NXPLOG_TML_E(" phTphTmlNfc_WaitReadInit failed, error = 0x%X", ret);
+  }
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_EnableFwDnldMode
+**
+** Description      wrapper function for enabling/disabling FW download mode
+**
+** Parameters       True/False
+**
+** Returns          NFCSTATUS
+**
+*******************************************************************************/
+void phTmlNfc_EnableFwDnldMode(bool mode) {
+  gpTransportObj->EnableFwDnldMode(mode);
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_IsFwDnldModeEnabled
+**
+** Description      wrapper function  to get the FW download flag
+**
+** Parameters       None
+**
+** Returns          True/False status of FW download flag
+**
+*******************************************************************************/
+bool phTmlNfc_IsFwDnldModeEnabled(void) {
+  return gpTransportObj->IsFwDnldModeEnabled();
+}
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_Shutdown_CleanUp
+**
+** Description      wrapper function  for shutdown  and cleanup of resources
+**
+** Parameters       None
+**
+** Returns          NFCSTATUS
+**
+*******************************************************************************/
+NFCSTATUS phTmlNfc_Shutdown_CleanUp() {
+  NFCSTATUS wShutdownStatus = phTmlNfc_Shutdown();
+  phTmlNfc_CleanUp();
+  return wShutdownStatus;
+}
diff --git a/pn72xx/halimpl/tml/phTmlNfc.h b/pn72xx/halimpl/tml/phTmlNfc.h
new file mode 100644
index 00000000..3c350788
--- /dev/null
+++ b/pn72xx/halimpl/tml/phTmlNfc.h
@@ -0,0 +1,251 @@
+/*
+ * Copyright 2010-2023 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Transport Mapping Layer header files containing APIs related to initializing,
+ * reading
+ * and writing data into files provided by the driver interface.
+ *
+ * API listed here encompasses Transport Mapping Layer interfaces required to be
+ * mapped
+ * to different Interfaces and Platforms.
+ *
+ */
+
+#ifndef PHTMLNFC_H
+#define PHTMLNFC_H
+
+#include <phNfcCommon.h>
+
+/*
+ * Message posted by Reader thread upon
+ * completion of requested operation
+ */
+#define PH_TMLNFC_READ_MESSAGE (0xAA)
+
+/*
+ * Message posted by Writer thread upon
+ * completion of requested operation
+ */
+#define PH_TMLNFC_WRITE_MESSAGE (0x55)
+
+/*
+ * Value indicates to reset device
+ */
+#define PH_TMLNFC_RESETDEVICE (0x00008001)
+
+/*
+ * Fragment Length for PN72XX
+ */
+#define PH_TMLNFC_FRGMENT_SIZE_PN72XX (0x22A)
+
+/*
+***************************Globals,Structure and Enumeration ******************
+*/
+
+/*
+ * Transaction (Tx/Rx) completion information structure of TML
+ *
+ * This structure holds the completion callback information of the
+ * transaction passed from the TML layer to the Upper layer
+ * along with the completion callback.
+ *
+ * The value of field wStatus can be interpreted as:
+ *
+ *     - NFCSTATUS_SUCCESS                    Transaction performed
+ * successfully.
+ *     - NFCSTATUS_FAILED                     Failed to wait on Read/Write
+ * operation.
+ *     - NFCSTATUS_INSUFFICIENT_STORAGE       Not enough memory to store data in
+ * case of read.
+ *     - NFCSTATUS_BOARD_COMMUNICATION_ERROR  Failure to Read/Write from the
+ * file or timeout.
+ */
+
+typedef struct phTmlNfc_TransactInfo {
+  NFCSTATUS wStatus;       /* Status of the Transaction Completion*/
+  uint8_t *pBuff;          /* Response Data of the Transaction*/
+  uint16_t wLength;        /* Data size of the Transaction*/
+} phTmlNfc_TransactInfo_t; /* Instance of Transaction structure */
+
+/*
+ * TML transreceive completion callback to Upper Layer
+ *
+ * pContext - Context provided by upper layer
+ * pInfo    - Transaction info. See phTmlNfc_TransactInfo
+ */
+typedef void (*pphTmlNfc_TransactCompletionCb_t)(
+    void *pContext, phTmlNfc_TransactInfo_t *pInfo);
+
+/*
+ * TML Deferred callback interface structure invoked by upper layer
+ *
+ * This could be used for read/write operations
+ *
+ * dwMsgPostedThread Message source identifier
+ * pParams Parameters for the deferred call processing
+ */
+typedef void (*pphTmlNfc_DeferFuncPointer_t)(uint32_t dwMsgPostedThread,
+                                             void *pParams);
+
+/*
+ * Enum definition contains  supported ioctl control codes.
+ *
+ * phTmlNfc_IoCtl
+ */
+typedef enum {
+  phTmlNfc_e_Invalid = 0,
+  phTmlNfc_e_ResetDevice = PH_TMLNFC_RESETDEVICE, /* Reset the device */
+  phTmlNfc_e_EnableDownloadMode, /* Do the hardware setting to enter into
+                                    download mode */
+  phTmlNfc_e_EnableNormalMode, /* Hardware setting for normal mode of operation
+                                */
+  phTmlNfc_e_EnableVen,        /* Enable Ven for PN557 chip*/
+  phTmlNfc_e_setFragmentSize = 5,
+  phTmlNfc_e_RedLedOff,     /* Turns off red led */
+  phTmlNfc_e_RedLedOn,      /* Turns on red led */
+  phTmlNfc_e_ModeSwitchOn,  /* sets mode switch gpio high */
+  phTmlNfc_e_ModeSwitchOff, /* sets mode switch gpio low */
+} phTmlNfc_ControlCode_t;   /* Control code for IOCTL call */
+
+/*
+ * Enable / Disable Re-Transmission of Packets
+ *
+ * phTmlNfc_ConfigNciPktReTx
+ */
+typedef enum {
+  phTmlNfc_e_EnableRetrans = 0x00, /*Enable retransmission of Nci packet */
+  phTmlNfc_e_DisableRetrans = 0x01 /*Disable retransmission of Nci packet */
+} phTmlNfc_ConfigRetrans_t;        /* Configuration for Retransmission */
+
+/*
+ * Structure containing details related to read and write operations
+ *
+ */
+typedef struct phTmlNfc_ReadWriteInfo {
+  volatile uint8_t bEnable; /*This flag shall decide whether to perform
+                               Write/Read operation */
+  uint8_t
+      bThreadBusy; /*Flag to indicate thread is busy on respective operation */
+  /* Transaction completion Callback function */
+  pphTmlNfc_TransactCompletionCb_t pThread_Callback;
+  void *pContext;        /*Context passed while invocation of operation */
+  uint8_t *pBuffer;      /*Buffer passed while invocation of operation */
+  uint16_t wLength;      /*Length of data read/written */
+  NFCSTATUS wWorkStatus; /*Status of the transaction performed */
+} phTmlNfc_ReadWriteInfo_t;
+
+/*
+ *Base Context Structure containing members required for entire session
+ */
+typedef struct phTmlNfc_Context {
+  pthread_t readerThread; /*Handle to the thread which handles write and read
+                             operations */
+  pthread_t writerThread;
+  volatile uint8_t
+      bThreadDone; /*Flag to decide whether to run or abort the thread */
+  phTmlNfc_ConfigRetrans_t
+      eConfig;             /*Retransmission of Nci Packet during timeout */
+  uint8_t bRetryCount;     /*Number of times retransmission shall happen */
+  uint8_t bWriteCbInvoked; /* Indicates whether write callback is invoked during
+                              retransmission */
+  uint32_t dwTimerId;      /* Timer used to retransmit nci packet */
+  phTmlNfc_ReadWriteInfo_t tReadInfo;  /*Pointer to Reader Thread Structure */
+  phTmlNfc_ReadWriteInfo_t tWriteInfo; /*Pointer to Writer Thread Structure */
+  void *pDevHandle;                    /* Pointer to Device Handle */
+  uintptr_t dwCallbackThreadId; /* Thread ID to which message to be posted */
+  uint8_t bEnableCrc;           /*Flag to validate/not CRC for input buffer */
+  sem_t rxSemaphore;
+  sem_t txSemaphore;      /* Lock/Acquire txRx Semaphore */
+  sem_t postMsgSemaphore; /* Semaphore to post message atomically by Reader &
+                             writer thread */
+  pthread_cond_t wait_busy_condition; /*Condition to wait reader thread*/
+  pthread_mutex_t wait_busy_lock;     /*Condition lock to wait reader thread*/
+  volatile uint8_t wait_busy_flag;    /*Condition flag to wait reader thread*/
+  volatile uint8_t gWriterCbflag; /* flag to indicate write callback message is
+                                     pushed to queue*/
+  long nfc_service_pid; /*NFC Service PID to be used by driver to signal*/
+  uint16_t fragment_len;
+} phTmlNfc_Context_t;
+
+/*
+ * TML Configuration exposed to upper layer.
+ */
+typedef struct phTmlNfc_Config {
+  /* Port name connected to PN72xx
+   *
+   * Platform specific canonical device name to which nxpnfc is connected.
+   *
+   * e.g. On Linux based systems this would be /dev/nxpnfc
+   */
+  int8_t *pDevName;
+  /* Callback Thread ID
+   *
+   * This is the thread ID on which the Reader & Writer thread posts message. */
+  uintptr_t dwGetMsgThreadId;
+  /* Communication speed between DH and PN72xx
+   *
+   * This is the baudrate of the bus for communication between DH and PN72xx */
+  uint32_t dwBaudRate;
+  uint16_t fragment_len;
+} phTmlNfc_Config_t, *pphTmlNfc_Config_t; /* pointer to phTmlNfc_Config_t */
+
+/*
+ * TML Deferred Callback structure used to invoke Upper layer Callback function.
+ */
+typedef struct {
+  /* Deferred callback function to be invoked */
+  pphTmlNfc_DeferFuncPointer_t pDef_call;
+  /* Source identifier
+   *
+   * Identifier of the source which posted the message
+   */
+  uint32_t dwMsgPostedThread;
+  /** Actual Message
+   *
+   * This is passed as a parameter passed to the deferred callback function
+   * pDef_call. */
+  void *pParams;
+} phTmlNfc_DeferMsg_t; /* DeferMsg structure passed to User Thread */
+
+typedef enum {
+  I2C_FRAGMENATATION_DISABLED, /*i2c fragmentation_disabled           */
+  I2C_FRAGMENTATION_ENABLED    /*i2c_fragmentation_enabled          */
+} phTmlNfc_i2cfragmentation_t;
+/* Function declarations */
+NFCSTATUS phTmlNfc_Init(pphTmlNfc_Config_t pConfig);
+NFCSTATUS phTmlNfc_Shutdown(void);
+NFCSTATUS phTmlNfc_Shutdown_CleanUp();
+void phTmlNfc_CleanUp(void);
+NFCSTATUS phTmlNfc_Write(uint8_t *pBuffer, uint16_t wLength,
+                         pphTmlNfc_TransactCompletionCb_t pTmlWriteComplete,
+                         void *pContext);
+NFCSTATUS phTmlNfc_Read(uint8_t *pBuffer, uint16_t wLength,
+                        pphTmlNfc_TransactCompletionCb_t pTmlReadComplete,
+                        void *pContext);
+NFCSTATUS phTmlNfc_WriteAbort(void);
+NFCSTATUS phTmlNfc_ReadAbort(void);
+NFCSTATUS phTmlNfc_IoCtl(phTmlNfc_ControlCode_t eControlCode);
+void phTmlNfc_DeferredCall(uintptr_t dwThreadId,
+                           phLibNfc_Message_t *ptWorkerMsg);
+void phTmlNfc_ConfigNciPktReTx(phTmlNfc_ConfigRetrans_t eConfig,
+                               uint8_t bRetryCount);
+void phTmlNfc_set_fragmentation_enabled(phTmlNfc_i2cfragmentation_t enable);
+phTmlNfc_i2cfragmentation_t phTmlNfc_get_fragmentation_enabled();
+NFCSTATUS phTmlNfc_ConfigTransport();
+void phTmlNfc_EnableFwDnldMode(bool mode);
+bool phTmlNfc_IsFwDnldModeEnabled(void);
+#endif /*  PHTMLNFC_H  */
diff --git a/pn72xx/halimpl/tml/transport/NfccI2cTransport.cc b/pn72xx/halimpl/tml/transport/NfccI2cTransport.cc
new file mode 100644
index 00000000..ab67e04c
--- /dev/null
+++ b/pn72xx/halimpl/tml/transport/NfccI2cTransport.cc
@@ -0,0 +1,470 @@
+/******************************************************************************
+ *  Copyright 2020-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/*
+ * DAL I2C port implementation for linux
+ *
+ * Project: Trusted NFC Linux
+ *
+ */
+#include <errno.h>
+#include <fcntl.h>
+#include <hardware/nfc.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/select.h>
+#include <termios.h>
+#include <unistd.h>
+
+#include "phNxpNciHal_utils.h"
+#include <NfccI2cTransport.h>
+#include <phNfcStatus.h>
+#include <phNxpLog.h>
+#include <string.h>
+
+#define CRC_LEN 2
+#define NORMAL_MODE_HEADER_LEN 3
+#define FW_DNLD_HEADER_LEN 2
+#define FW_DNLD_LEN_OFFSET 1
+#define NORMAL_MODE_LEN_OFFSET 2
+#define FLUSH_BUFFER_SIZE 0xFF
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+extern phTmlNfc_Context_t *gpphTmlNfc_Context;
+/*******************************************************************************
+**
+** Function         Close
+**
+** Description      Closes NFCC device
+**
+** Parameters       pDevHandle - device handle
+**
+** Returns          None
+**
+*******************************************************************************/
+void NfccI2cTransport::Close(void *pDevHandle) {
+  if (NULL != pDevHandle) {
+    close((int)(intptr_t)pDevHandle);
+  }
+  sem_destroy(&mTxRxSemaphore);
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         OpenAndConfigure
+**
+** Description      Open and configure NFCC device
+**
+** Parameters       pConfig     - hardware information
+**                  pLinkHandle - device handle
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - open_and_configure operation success
+**                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+**
+*******************************************************************************/
+NFCSTATUS NfccI2cTransport::OpenAndConfigure(pphTmlNfc_Config_t pConfig,
+                                             void **pLinkHandle) {
+  int nHandle;
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  NXPLOG_TML_D("%s Opening port=%s\n", __func__, pConfig->pDevName);
+  /* open port */
+  nHandle = open((const char *)pConfig->pDevName, O_RDWR);
+  if (nHandle < 0) {
+    NXPLOG_TML_E("_i2c_open() Failed: retval %x", nHandle);
+    *pLinkHandle = NULL;
+    status = NFCSTATUS_INVALID_DEVICE;
+  } else {
+    *pLinkHandle = (void *)((intptr_t)nHandle);
+    if (0 != sem_init(&mTxRxSemaphore, 0, 1)) {
+      NXPLOG_TML_E("%s Failed: reason sem_init : retval %x", __func__, nHandle);
+      status = NFCSTATUS_FAILED;
+    }
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         Flushdata
+**
+** Description      Reads payload of FW rsp from NFCC device into given buffer
+**
+** Parameters       pConfig     - hardware information
+**
+** Returns          True(Success)/False(Fail)
+**
+*******************************************************************************/
+bool NfccI2cTransport::Flushdata(pphTmlNfc_Config_t pConfig) {
+  int retRead = 0;
+  int nHandle;
+  uint8_t pBuffer[FLUSH_BUFFER_SIZE];
+  NXPLOG_TML_D("%s: Enter", __func__);
+  nHandle = open((const char *)pConfig->pDevName, O_RDWR | O_NONBLOCK);
+  if (nHandle < 0) {
+    NXPLOG_TML_E("%s: _i2c_open() Failed: retval %x", __func__, nHandle);
+    return false;
+  }
+  do {
+    retRead = read(nHandle, pBuffer, sizeof(pBuffer));
+    if (retRead > 0) {
+      phNxpNciHal_print_packet("RECV", pBuffer, retRead);
+      usleep(2 * 1000);
+    }
+  } while (retRead > 0);
+  close(nHandle);
+  NXPLOG_TML_D("%s: Exit", __func__);
+  return true;
+}
+
+/*******************************************************************************
+**
+** Function         Read
+**
+** Description      Reads requested number of bytes from NFCC device into given
+**                  buffer
+**
+** Parameters       pDevHandle       - valid device handle
+**                  pBuffer          - buffer for read data
+**                  nNbBytesToRead   - number of bytes requested to be read
+**
+** Returns          numRead   - number of successfully read bytes
+**                  -1        - read operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::Read(void *pDevHandle, uint8_t *pBuffer,
+                           int nNbBytesToRead) {
+  int ret_Read;
+  int ret_Select;
+  int numRead = 0;
+  struct timeval tv;
+  fd_set rfds;
+  uint16_t totalBtyesToRead = 0;
+
+  UNUSED_PROP(nNbBytesToRead);
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+
+  if (bFwDnldFlag == false) {
+    totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
+  } else {
+    totalBtyesToRead = FW_DNLD_HEADER_LEN;
+  }
+
+  /* Read with 2 second timeout, so that the read thread can be aborted
+     when the NFCC does not respond and we need to switch to FW download
+     mode. This should be done via a control socket instead. */
+  FD_ZERO(&rfds);
+  FD_SET((int)(intptr_t)pDevHandle, &rfds);
+  tv.tv_sec = 2;
+  tv.tv_usec = 1;
+
+  ret_Select =
+      select((int)((intptr_t)pDevHandle + (int)1), &rfds, NULL, NULL, &tv);
+  if (ret_Select < 0) {
+    NXPLOG_TML_D("%s errno : %x", __func__, errno);
+    return -1;
+  } else if (ret_Select == 0) {
+    NXPLOG_TML_D("%s Timeout", __func__);
+    return -1;
+  } else {
+    ret_Read =
+        read((int)(intptr_t)pDevHandle, pBuffer, totalBtyesToRead - numRead);
+    if (ret_Read > 0 && !(pBuffer[0] == 0xFF && pBuffer[1] == 0xFF)) {
+      numRead += ret_Read;
+    } else if (ret_Read == 0) {
+      NXPLOG_TML_E("%s [hdr]EOF", __func__);
+      return -1;
+    } else {
+      NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
+      NXPLOG_TML_E(" %s pBuffer[0] = %x pBuffer[1]= %x", __func__, pBuffer[0],
+                   pBuffer[1]);
+      return -1;
+    }
+
+    if (bFwDnldFlag && (pBuffer[0] != 0x00)) {
+      bFwDnldFlag = false;
+    }
+
+    if (bFwDnldFlag == false) {
+      totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
+    } else {
+      totalBtyesToRead = FW_DNLD_HEADER_LEN;
+    }
+
+    if (numRead < totalBtyesToRead) {
+      ret_Read = read((int)(intptr_t)pDevHandle, (pBuffer + numRead),
+                      totalBtyesToRead - numRead);
+
+      if (ret_Read != totalBtyesToRead - numRead) {
+        NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
+        return -1;
+      } else {
+        numRead += ret_Read;
+      }
+    }
+    if (bFwDnldFlag == true) {
+      totalBtyesToRead =
+          pBuffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
+    } else {
+      totalBtyesToRead =
+          pBuffer[NORMAL_MODE_LEN_OFFSET] + NORMAL_MODE_HEADER_LEN;
+    }
+    if ((totalBtyesToRead - numRead) != 0) {
+      ret_Read = read((int)(intptr_t)pDevHandle, (pBuffer + numRead),
+                      totalBtyesToRead - numRead);
+      if (ret_Read > 0) {
+        numRead += ret_Read;
+      } else if (ret_Read == 0) {
+        NXPLOG_TML_E("%s [pyld] EOF", __func__);
+        return -1;
+      } else {
+        if (bFwDnldFlag == false) {
+          NXPLOG_TML_D("_i2c_read() [hdr] received");
+          phNxpNciHal_print_packet("RECV", pBuffer, NORMAL_MODE_HEADER_LEN);
+        }
+        NXPLOG_TML_E("%s [pyld] errno : %x", __func__, errno);
+        return -1;
+      }
+    } else {
+      NXPLOG_TML_E("%s _>>>>> Empty packet received !!", __func__);
+    }
+  }
+  return numRead;
+}
+
+/*******************************************************************************
+**
+** Function         Write
+**
+** Description      Writes requested number of bytes from given buffer into
+**                  NFCC device
+**
+** Parameters       pDevHandle       - valid device handle
+**                  pBuffer          - buffer for read data
+**                  nNbBytesToWrite  - number of bytes requested to be written
+**
+** Returns          numWrote   - number of successfully written bytes
+**                  -1         - write operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::Write(void *pDevHandle, uint8_t *pBuffer,
+                            int nNbBytesToWrite) {
+  int ret;
+  int numWrote = 0;
+  int numBytes = nNbBytesToWrite;
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  if (fragmentation_enabled == I2C_FRAGMENATATION_DISABLED &&
+      nNbBytesToWrite > gpphTmlNfc_Context->fragment_len) {
+    NXPLOG_TML_D(
+        "%s data larger than maximum I2C  size,enable I2C fragmentation",
+        __func__);
+    return -1;
+  }
+  while (numWrote < nNbBytesToWrite) {
+    if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
+        nNbBytesToWrite > gpphTmlNfc_Context->fragment_len) {
+      if (nNbBytesToWrite - numWrote > gpphTmlNfc_Context->fragment_len) {
+        numBytes = numWrote + gpphTmlNfc_Context->fragment_len;
+      } else {
+        numBytes = nNbBytesToWrite;
+      }
+    }
+    ret = write((int)(intptr_t)pDevHandle, pBuffer + numWrote,
+                numBytes - numWrote);
+    if (ret > 0) {
+      numWrote += ret;
+      if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
+          numWrote < nNbBytesToWrite) {
+        usleep(500);
+      }
+    } else if (ret == 0) {
+      NXPLOG_TML_D("%s EOF", __func__);
+      return -1;
+    } else {
+      NXPLOG_TML_D("%s errno : %x", __func__, errno);
+      if (errno == EINTR || errno == EAGAIN) {
+        continue;
+      }
+      return -1;
+    }
+  }
+
+  return numWrote;
+}
+
+/*******************************************************************************
+**
+** Function         Reset
+**
+** Description      Reset NFCC device, using VEN pin
+**
+** Parameters       pDevHandle     - valid device handle
+**                  eType          - reset level
+**
+** Returns           0   - reset operation success
+**                  -1   - reset operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::NfccReset(void *pDevHandle, NfccResetType eType) {
+  int ret = -1;
+  NXPLOG_TML_D("%s, VEN eType %u", __func__, eType);
+
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+
+  ret = ioctl((int)(intptr_t)pDevHandle, NFC_SET_PWR, eType);
+  if (ret < 0) {
+    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  if ((eType != MODE_FW_DWNLD_WITH_VEN && eType != MODE_FW_DWND_HIGH) &&
+      ret == 0) {
+    bFwDnldFlag = false;
+  }
+
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         EseReset
+**
+** Description      Request NFCC to reset the eSE
+**
+** Parameters       pDevHandle     - valid device handle
+**                  eType          - EseResetType
+**
+** Returns           0   - reset operation success
+**                  else - reset operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::EseReset(void *pDevHandle, EseResetType eType) {
+  int ret = -1;
+  NXPLOG_TML_D("%s, eType %u", __func__, eType);
+
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  ret = ioctl((int)(intptr_t)pDevHandle, ESE_SET_PWR, eType);
+  if (ret < 0) {
+    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         EseGetPower
+**
+** Description      Request NFCC to reset the eSE
+**
+** Parameters       pDevHandle     - valid device handle
+**                  level          - reset level
+**
+** Returns           0   - reset operation success
+**                  else - reset operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::EseGetPower(void *pDevHandle, uint32_t level) {
+  return ioctl((int)(intptr_t)pDevHandle, ESE_GET_PWR, level);
+}
+
+/*******************************************************************************
+**
+** Function         EnableFwDnldMode
+**
+** Description      updates the state to Download mode
+**
+** Parameters       True/False
+**
+** Returns          None
+*******************************************************************************/
+void NfccI2cTransport::EnableFwDnldMode(bool mode) { bFwDnldFlag = mode; }
+
+/*******************************************************************************
+**
+** Function         IsFwDnldModeEnabled
+**
+** Description      Returns the current mode
+**
+** Parameters       none
+**
+** Returns           Current mode download/NCI
+*******************************************************************************/
+bool_t NfccI2cTransport::IsFwDnldModeEnabled(void) { return bFwDnldFlag; }
+
+#if (NXP_EXTNS == TRUE)
+/*******************************************************************************
+**
+** Function         SetLED
+**
+** Description      Request NFCC to set the respective LED ON or OFF
+**
+** Parameters       pDevHandle     - valid device handle
+**                  eType          - LEDControl
+**
+** Returns           0   SetLED operation success
+**                   1   SetLED operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::SetLED(void *pDevHandle, LEDControl eType) {
+  int ret = -1;
+  NXPLOG_TML_D("%s, eType %u", __func__, eType);
+
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  ret = ioctl((int)(intptr_t)pDevHandle, LEDS_CONTROL, eType);
+  if (ret < 0) {
+    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  return ret;
+}
+
+/*******************************************************************************
+** Function         SetModeSwitch
+**
+** Description      sets the mode switch to NFCC
+**
+** Parameters       p_dev_handle     - valid device handle
+**                  eType          - mode switch control
+**
+** Returns           0   - reset operation success
+**                  -1   - reset operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::SetModeSwitch(void *p_dev_handle,
+                                    enum ProfileMode eType) {
+  int ret = -1;
+  NXPLOG_TML_D("%s, LEDControl eType %u", __func__, eType);
+
+  if (NULL == p_dev_handle) {
+    return -1;
+  }
+
+  ret = ioctl((int)(intptr_t)p_dev_handle, NFCC_PROFILE_SWITCH, eType, 2);
+
+  if (ret < 0) {
+    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  return ret;
+}
+#endif
\ No newline at end of file
diff --git a/pn72xx/halimpl/tml/transport/NfccI2cTransport.h b/pn72xx/halimpl/tml/transport/NfccI2cTransport.h
new file mode 100644
index 00000000..0293d914
--- /dev/null
+++ b/pn72xx/halimpl/tml/transport/NfccI2cTransport.h
@@ -0,0 +1,248 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+#include <NfccTransport.h>
+
+#define NFC_MAGIC 0xE9
+/*
+ * NFCC power control via ioctl
+ * NFC_SET_PWR(0): power off
+ * NFC_SET_PWR(1): power on
+ * NFC_SET_PWR(2): reset and power on with firmware download enabled
+ */
+#define NFC_SET_PWR _IOW(NFC_MAGIC, 0x01, uint32_t)
+/*
+ * 1. SPI Request NFCC to enable ESE power, only in param
+ *   Only for SPI
+ *   level 1 = Enable power
+ *   level 0 = Disable power
+ * 2. NFC Request the eSE cold reset, only with MODE_ESE_COLD_RESET
+ */
+#define ESE_SET_PWR _IOW(NFC_MAGIC, 0x02, uint32_t)
+
+/*
+ * SPI or DWP can call this ioctl to get the current
+ * power state of ESE
+ */
+#define ESE_GET_PWR _IOR(NFC_MAGIC, 0x03, uint32_t)
+
+#if (NXP_EXTNS == TRUE)
+/*
+ * ioctl code to switch between the NFC polling and EMVCo polling
+ *
+ */
+#define NFCC_PROFILE_SWITCH _IOW(NFC_MAGIC, 0x04, uint32_t)
+/*
+ * LED control via ioctl
+ * RED_LED_OFF(0): RED LED OFF
+ * RED_LED_ON(1):  RED LED ON
+ * GREEN_LED_OFF(2): GREEN LED OFF
+ * GREEN_LED_ON(3): GREEN LED ON
+ */
+#define LEDS_CONTROL _IOW(NFC_MAGIC, 0x06, uint32_t)
+#endif
+
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+
+class NfccI2cTransport : public NfccTransport {
+private:
+  bool_t bFwDnldFlag = false;
+  sem_t mTxRxSemaphore;
+
+public:
+  /*****************************************************************************
+  **
+  ** Function         Close
+  **
+  ** Description      Closes NFCC device
+  **
+  ** Parameters       pDevHandle - device handle
+  **
+  ** Returns          None
+  **
+  *****************************************************************************/
+  void Close(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         OpenAndConfigure
+   **
+   ** Description      Open and configure NFCC device
+   **
+   ** Parameters       pConfig     - hardware information
+   **                  pLinkHandle - device handle
+   **
+   ** Returns          NFC status:
+   **                  NFCSTATUS_SUCCESS - open_and_configure operation success
+   **                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+   **
+   ****************************************************************************/
+  NFCSTATUS OpenAndConfigure(pphTmlNfc_Config_t pConfig, void **pLinkHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         Read
+   **
+   ** Description      Reads requested number of bytes from NFCC device into
+   *given
+   **                  buffer
+   **
+   ** Parameters       pDevHandle       - valid device handle
+   **                  pBuffer          - buffer for read data
+   **                  nNbBytesToRead   - number of bytes requested to be read
+   **
+   ** Returns          numRead   - number of successfully read bytes
+   **                  -1        - read operation failure
+   **
+   ****************************************************************************/
+  int Read(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToRead);
+
+  /*****************************************************************************
+  **
+  ** Function         Write
+  **
+  ** Description      Writes requested number of bytes from given buffer into
+  **                  NFCC device
+  **
+  ** Parameters       pDevHandle       - valid device handle
+  **                  pBuffer          - buffer for read data
+  **                  nNbBytesToWrite  - number of bytes requested to be
+  *written
+  **
+  ** Returns          numWrote   - number of successfully written bytes
+  **                  -1         - write operation failure
+  **
+  *****************************************************************************/
+  int Write(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToWrite);
+
+  /*****************************************************************************
+   **
+   ** Function         Reset
+   **
+   ** Description      Reset NFCC device, using VEN pin
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  -1   - reset operation failure
+   **
+   ****************************************************************************/
+  int NfccReset(void *pDevHandle, NfccResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseReset
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  eType          - EseResetType
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  int EseReset(void *pDevHandle, EseResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseGetPower
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  int EseGetPower(void *pDevHandle, uint32_t level);
+
+  /*****************************************************************************
+   **
+   ** Function         EnableFwDnldMode
+   **
+   ** Description      updates the state to Download mode
+   **
+   ** Parameters       True/False
+   **
+   ** Returns          None
+   ****************************************************************************/
+  void EnableFwDnldMode(bool mode);
+
+  /*****************************************************************************
+   **
+   ** Function         IsFwDnldModeEnabled
+   **
+   ** Description      Returns the current mode
+   **
+   ** Parameters       none
+   **
+   ** Returns           Current mode download/NCI
+   ****************************************************************************/
+  bool_t IsFwDnldModeEnabled(void);
+
+  /*******************************************************************************
+  **
+  ** Function         Flushdata
+  **
+  ** Description      Reads payload of FW rsp from NFCC device into given
+  *buffer
+  **
+  ** Parameters       pConfig     - hardware information
+  **
+  ** Returns          True(Success)/False(Fail)
+  **
+  *******************************************************************************/
+  bool Flushdata(pphTmlNfc_Config_t pConfig);
+
+#if (NXP_EXTNS == TRUE)
+  /*******************************************************************************
+  **
+  ** Function         SetLED
+  **
+  ** Description      Request NFCC to set the respective LED ON or OFF
+  **
+  ** Parameters       pDevHandle     - valid device handle
+  **                  eType          - LEDControl
+  **
+  ** Returns           0   SetLED operation success
+  **                   1   SetLED operation failure
+  **
+  *******************************************************************************/
+  int SetLED(void *pDevHandle, LEDControl eType);
+
+  /*******************************************************************************
+  ** Function         SetModeSwitch
+  **
+  ** Description      sets the mode switch to NFCC
+  **
+  ** Parameters       p_dev_handle     - valid device handle
+  **                  eType          - mode switch control
+  **
+  ** Returns           0   - reset operation success
+  **                  -1   - reset operation failure
+  **
+  *******************************************************************************/
+  int SetModeSwitch(void *p_dev_handle, enum ProfileMode eType);
+
+#endif
+};
diff --git a/pn72xx/halimpl/tml/transport/NfccTransport.cc b/pn72xx/halimpl/tml/transport/NfccTransport.cc
new file mode 100644
index 00000000..db5bb470
--- /dev/null
+++ b/pn72xx/halimpl/tml/transport/NfccTransport.cc
@@ -0,0 +1,56 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <NfccTransport.h>
+
+int NfccTransport::NfccReset(__attribute__((unused)) void *pDevHandle,
+                             __attribute__((unused)) NfccResetType eType) {
+  return NFCSTATUS_SUCCESS;
+}
+
+int NfccTransport::EseReset(__attribute__((unused)) void *pDevHandle,
+                            __attribute__((unused)) EseResetType eType) {
+  return NFCSTATUS_SUCCESS;
+}
+int NfccTransport::EseGetPower(__attribute__((unused)) void *pDevHandle,
+                               __attribute__((unused)) uint32_t level) {
+  return NFCSTATUS_SUCCESS;
+}
+
+void NfccTransport::EnableFwDnldMode(__attribute__((unused)) bool mode) {
+  return;
+}
+
+bool_t NfccTransport::IsFwDnldModeEnabled(void) { return false; }
+
+bool NfccTransport::Flushdata(__attribute__((unused))
+                              pphTmlNfc_Config_t pConfig) {
+  return true;
+}
+
+#if (NXP_EXTNS == TRUE)
+int NfccTransport::SetLED(__attribute__((unused)) void *pDevHandle,
+                          __attribute__((unused)) LEDControl eType) {
+  return true;
+}
+int NfccTransport::SetModeSwitch(
+    __attribute__((unused)) void *p_dev_handle,
+    __attribute__((unused)) enum ProfileMode eType) {
+  return NFCSTATUS_SUCCESS;
+}
+#endif
diff --git a/pn72xx/halimpl/tml/transport/NfccTransport.h b/pn72xx/halimpl/tml/transport/NfccTransport.h
new file mode 100644
index 00000000..a7cc6c16
--- /dev/null
+++ b/pn72xx/halimpl/tml/transport/NfccTransport.h
@@ -0,0 +1,263 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+#include <phNfcTypes.h>
+#include <phTmlNfc.h>
+
+enum NfccResetType : uint32_t {
+  MODE_POWER_OFF = 0x00,
+  MODE_POWER_ON,
+  MODE_FW_DWNLD_WITH_VEN,
+  MODE_ISO_RST,
+  MODE_FW_DWND_HIGH,
+  MODE_POWER_RESET,
+  MODE_FW_GPIO_LOW
+};
+
+enum EseResetCallSrc : uint32_t {
+  SRC_SPI = 0x0,
+  SRC_NFC = 0x10,
+};
+
+enum EseResetType : uint32_t {
+  MODE_ESE_POWER_ON = 0,
+  MODE_ESE_POWER_OFF,
+  MODE_ESE_POWER_STATE,
+  /*Request from eSE HAL/Service*/
+  MODE_ESE_COLD_RESET,
+  MODE_ESE_RESET_PROTECTION_ENABLE,
+  MODE_ESE_RESET_PROTECTION_DISABLE,
+  /*Request from NFC HAL/Service*/
+  MODE_ESE_COLD_RESET_NFC = MODE_ESE_COLD_RESET | SRC_NFC,
+  MODE_ESE_RESET_PROTECTION_ENABLE_NFC =
+      MODE_ESE_RESET_PROTECTION_ENABLE | SRC_NFC,
+  MODE_ESE_RESET_PROTECTION_DISABLE_NFC =
+      MODE_ESE_RESET_PROTECTION_DISABLE | SRC_NFC,
+};
+
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+
+#if (NXP_EXTNS == TRUE)
+enum LEDControl : uint32_t {
+  RED_LED_OFF = 0x00,
+  RED_LED_ON,
+  GREEN_LED_OFF,
+  GREEN_LED_ON
+};
+/* Profile mode type */
+enum ProfileMode : uint32_t {
+  NCI_MODE = 0,
+  EMVCO_MODE,
+};
+#endif
+
+class NfccTransport {
+public:
+  /*****************************************************************************
+   **
+   ** Function         Close
+   **
+   ** Description      Closes NFCC device
+   **
+   ** Parameters       pDevHandle - device handle
+   **
+   ** Returns          None
+   **
+   *****************************************************************************/
+  virtual void Close(void *pDevHandle) = 0;
+
+  /*****************************************************************************
+   **
+   ** Function         OpenAndConfigure
+   **
+   ** Description      Open and configure NFCC device and transport layer
+   **
+   ** Parameters       pConfig     - hardware information
+   **                  pLinkHandle - device handle
+   **
+   ** Returns          NFC status:
+   **                  NFCSTATUS_SUCCESS - open_and_configure operation success
+   **                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+   **
+   ****************************************************************************/
+  virtual NFCSTATUS OpenAndConfigure(pphTmlNfc_Config_t pConfig,
+                                     void **pLinkHandle) = 0;
+
+  /*****************************************************************************
+   **
+   ** Function         Read
+   **
+   ** Description      Reads requested number of bytes from NFCC device into
+   **                 given buffer
+   **
+   ** Parameters       pDevHandle       - valid device handle
+   **                  pBuffer          - buffer for read data
+   **                  nNbBytesToRead   - number of bytes requested to be read
+   **
+   ** Returns          numRead   - number of successfully read bytes
+   **                  -1        - read operation failure
+   **
+   ****************************************************************************/
+  virtual int Read(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToRead) = 0;
+
+  /*****************************************************************************
+   **
+   ** Function         Write
+   **
+   ** Description      Writes requested number of bytes from given buffer into
+   **                  NFCC device
+   **
+   ** Parameters       pDevHandle       - valid device handle
+   **                  pBuffer          - buffer for read data
+   **                  nNbBytesToWrite  - number of bytes requested to be
+   *written
+   **
+   ** Returns          numWrote   - number of successfully written bytes
+   **                  -1         - write operation failure
+   **
+   *****************************************************************************/
+  virtual int Write(void *pDevHandle, uint8_t *pBuffer,
+                    int nNbBytesToWrite) = 0;
+
+  /*****************************************************************************
+   **
+   ** Function         Reset
+   **
+   ** Description      Reset NFCC device, using VEN pin
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  eType          - NfccResetType
+   **
+   ** Returns           0   - reset operation success
+   **                  -1   - reset operation failure
+   **
+   ****************************************************************************/
+  virtual int NfccReset(void *pDevHandle, NfccResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseReset
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  eType          - EseResetType
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  virtual int EseReset(void *pDevHandle, EseResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseGetPower
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  virtual int EseGetPower(void *pDevHandle, uint32_t level);
+
+  /*****************************************************************************
+   **
+   ** Function         EnableFwDnldMode
+   **
+   ** Description      updates the state to Download mode
+   **
+   ** Parameters       True/False
+   **
+   ** Returns          None
+   ****************************************************************************/
+  virtual void EnableFwDnldMode(bool mode);
+
+  /*****************************************************************************
+   **
+   ** Function         IsFwDnldModeEnabled
+   **
+   ** Description      Returns the current mode
+   **
+   ** Parameters       none
+   **
+   ** Returns          Current mode download/NCI
+   ****************************************************************************/
+  virtual bool_t IsFwDnldModeEnabled(void);
+
+  /*******************************************************************************
+  **
+  ** Function         Flushdata
+  **
+  ** Description      Reads payload of FW rsp from NFCC device into given
+  *buffer
+  **
+  ** Parameters       pConfig     - hardware information
+  **
+  ** Returns          True(Success)/False(Fail)
+  **
+  *******************************************************************************/
+  virtual bool Flushdata(pphTmlNfc_Config_t pConfig);
+
+  /*****************************************************************************
+   **
+   ** Function         ~NfccTransport
+   **
+   ** Description      TransportLayer destructor
+   **
+   ** Parameters       none
+   **
+   ** Returns          None
+   ****************************************************************************/
+  virtual ~NfccTransport(){};
+
+#if (NXP_EXTNS == TRUE)
+  /*******************************************************************************
+  **
+  ** Function         SetLED
+  **
+  ** Description      Request NFCC to set the respective LED ON or OFF
+  **
+  ** Parameters       pDevHandle     - valid device handle
+  **                  eType          - LEDControl
+  **
+  ** Returns           0   SetLED operation success
+  **                   1   SetLED operation failure
+  **
+  *******************************************************************************/
+  virtual int SetLED(void *pDevHandle, LEDControl eType);
+
+  /*******************************************************************************
+  ** Function         SetModeSwitch
+  **
+  ** Description      sets the mode switch to NFCC
+  **
+  ** Parameters       p_dev_handle     - valid device handle
+  **                  eType          - mode switch control
+  **
+  ** Returns           0   - reset operation success
+  **                  -1   - reset operation failure
+  **
+  *******************************************************************************/
+  virtual int SetModeSwitch(void *p_dev_handle, enum ProfileMode eType);
+#endif
+};
diff --git a/pn72xx/halimpl/utils/NxpNfcCapability.cc b/pn72xx/halimpl/utils/NxpNfcCapability.cc
new file mode 100644
index 00000000..abea2be9
--- /dev/null
+++ b/pn72xx/halimpl/utils/NxpNfcCapability.cc
@@ -0,0 +1,92 @@
+/******************************************************************************
+ *
+ *  Copyright 2015-2018,2020-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#define LOG_TAG "NxpHal"
+#include "NxpNfcCapability.h"
+#include <phNxpLog.h>
+
+capability *capability::instance = NULL;
+tNFC_chipType capability::chipType = pn7220;
+tNfc_featureList nfcFL;
+
+capability::capability() {}
+
+capability *capability::getInstance() {
+  if (NULL == instance) {
+    instance = new capability();
+  }
+  return instance;
+}
+
+tNFC_chipType capability::processChipType(uint8_t *msg, uint16_t msg_len) {
+  if ((msg != NULL) && (msg_len != 0)) {
+    if (msg[0] == 0x60 && msg[1] == 0x00) {
+      if ((msg[msg_len - 3] == 0x03) && (msg[msg_len - 2] == 0x00) &&
+          ((msg[msg_len - 5] == 0x20) || (msg[msg_len - 5] == 0x00))) {
+        chipType = pn7220;
+      } else if ((msg[msg_len - 3] == 0x03) && (msg[msg_len - 2] == 0x00) &&
+                 (msg[msg_len - 5] == 0x21)) {
+        chipType = pn7221;
+      } else {
+        ALOGD("%s Setting Default ChiptType pn7220", __func__);
+        chipType = pn7220;
+      }
+    } else if (msg[0] == 0x00) {
+      if ((msg[offsetFwRomCodeVersion] == 0x03) &&
+          ((msg[offsetModelID] == 0x20) || (msg[offsetModelID] == 0x00))) {
+        chipType = pn7220;
+      } else if ((msg[offsetFwRomCodeVersion] == 0x03) &&
+                 (msg[offsetModelID] == 0x21)) {
+        chipType = pn7221;
+      } else {
+        ALOGD("%s Setting Default ChiptType pn7220 in FW DNLD Mode", __func__);
+        chipType = pn7220;
+      }
+    } else if (offsetHwVersion < msg_len) {
+      ALOGD("%s HwVersion : 0x%02x  Product ID : 0x%02x", __func__,
+            msg[msg_len - 4], msg[msg_len - 5]);
+      switch (msg[msg_len - 5]) {
+      case 0x20:
+      case 0x00:
+        chipType = pn7220;
+        break;
+      case 0x21:
+        chipType = pn7221;
+        break;
+      default:
+        chipType = pn7220;
+      }
+    } else {
+      ALOGD("%s Wrong msg_len. Setting Default ChiptType pn7220", __func__);
+      chipType = pn7220;
+    }
+  }
+  ALOGD("%s Product : %s", __func__, product[chipType]);
+  return chipType;
+}
+
+uint32_t capability::getFWVersionInfo(uint8_t *msg, uint16_t msg_len) {
+  uint32_t versionInfo = 0;
+  if ((msg != NULL) && (msg_len != 0)) {
+    if (msg[0] == 0x00) {
+      versionInfo = msg[offsetFwRomCodeVersion] << 16;
+      versionInfo |= msg[offsetFwMajorVersion] << 8;
+      versionInfo |= msg[offsetFwMinorVersion];
+    }
+  }
+  return versionInfo;
+}
diff --git a/pn72xx/halimpl/utils/NxpNfcCapability.h b/pn72xx/halimpl/utils/NxpNfcCapability.h
new file mode 100644
index 00000000..60865cc3
--- /dev/null
+++ b/pn72xx/halimpl/utils/NxpNfcCapability.h
@@ -0,0 +1,43 @@
+/******************************************************************************
+ *
+ *  Copyright 2015-2018,2020-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef __CAP_H__
+#define __CAP_H__
+#include "Nxp_Features.h"
+#define pConfigFL (capability::getInstance())
+
+class capability {
+private:
+  static capability *instance;
+  const uint16_t offsetModelID = 5;
+  const uint16_t offsetHwVersion = 24;
+  const uint16_t offsetFwRomCodeVersion = 4;
+  const uint16_t offsetFwMinorVersion = 6;
+  const uint16_t offsetFwMajorVersion = 7;
+  /*product[] will be used to print product version and
+  should be kept in accordance with tNFC_chipType*/
+
+  const char *product[14] = {"UNKNOWN", "sn100u", "sn220u", "pn7220", "pn7221"};
+  capability();
+
+public:
+  static tNFC_chipType chipType;
+  static capability *getInstance();
+  tNFC_chipType processChipType(uint8_t *msg, uint16_t msg_len);
+  uint32_t getFWVersionInfo(uint8_t *msg, uint16_t msg_len);
+};
+#endif
diff --git a/pn72xx/halimpl/utils/NxpNfcThreadMutex.cc b/pn72xx/halimpl/utils/NxpNfcThreadMutex.cc
new file mode 100644
index 00000000..3aaef70d
--- /dev/null
+++ b/pn72xx/halimpl/utils/NxpNfcThreadMutex.cc
@@ -0,0 +1,149 @@
+/*
+ *
+ *  Copyright 2021,2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#include "NxpNfcThreadMutex.h"
+
+/*******************************************************************************
+**
+** Function:    NfcHalThreadMutex::NfcHalThreadMutex()
+**
+** Description: class constructor
+**
+** Returns:     none
+**
+*******************************************************************************/
+NfcHalThreadMutex::NfcHalThreadMutex() {
+  pthread_mutexattr_t mutexAttr;
+
+  pthread_mutexattr_init(&mutexAttr);
+  pthread_mutex_init(&mMutex, &mutexAttr);
+  pthread_mutexattr_destroy(&mutexAttr);
+}
+
+/*******************************************************************************
+**
+** Function:    NfcHalThreadMutex::~NfcHalThreadMutex()
+**
+** Description: class destructor
+**
+** Returns:     none
+**
+*******************************************************************************/
+NfcHalThreadMutex::~NfcHalThreadMutex() { pthread_mutex_destroy(&mMutex); }
+
+/*******************************************************************************
+**
+** Function:    NfcHalThreadMutex::lock()
+**
+** Description: lock kthe mutex
+**
+** Returns:     none
+**
+*******************************************************************************/
+void NfcHalThreadMutex::lock() { pthread_mutex_lock(&mMutex); }
+
+/*******************************************************************************
+**
+** Function:    NfcHalThreadMutex::unblock()
+**
+** Description: unlock the mutex
+**
+** Returns:     none
+**
+*******************************************************************************/
+void NfcHalThreadMutex::unlock() { pthread_mutex_unlock(&mMutex); }
+
+/*******************************************************************************
+**
+** Function:    NfcHalThreadCondVar::NfcHalThreadCondVar()
+**
+** Description: class constructor
+**
+** Returns:     none
+**
+*******************************************************************************/
+NfcHalThreadCondVar::NfcHalThreadCondVar() {
+  pthread_condattr_t CondAttr;
+
+  pthread_condattr_init(&CondAttr);
+  pthread_cond_init(&mCondVar, &CondAttr);
+
+  pthread_condattr_destroy(&CondAttr);
+}
+
+/*******************************************************************************
+**
+** Function:    NfcHalThreadCondVar::~NfcHalThreadCondVar()
+**
+** Description: class destructor
+**
+** Returns:     none
+**
+*******************************************************************************/
+NfcHalThreadCondVar::~NfcHalThreadCondVar() { pthread_cond_destroy(&mCondVar); }
+
+/*******************************************************************************
+**
+** Function:    NfcHalThreadCondVar::wait()
+**
+** Description: wait on the mCondVar
+**
+** Returns:     none
+**
+*******************************************************************************/
+void NfcHalThreadCondVar::wait() {
+  pthread_cond_wait(&mCondVar, *this);
+  pthread_mutex_unlock(*this);
+}
+
+/*******************************************************************************
+**
+** Function:    NfcHalThreadCondVar::signal()
+**
+** Description: signal the mCondVar
+**
+** Returns:     none
+**
+*******************************************************************************/
+void NfcHalThreadCondVar::signal() {
+  NfcHalAutoThreadMutex a(*this);
+  pthread_cond_signal(&mCondVar);
+}
+
+/*******************************************************************************
+**
+** Function:    NfcHalAutoThreadMutex::NfcHalAutoThreadMutex()
+**
+** Description: class constructor, automatically lock the mutex
+**
+** Returns:     none
+**
+*******************************************************************************/
+NfcHalAutoThreadMutex::NfcHalAutoThreadMutex(NfcHalThreadMutex &m) : mm(m) {
+  mm.lock();
+}
+
+/*******************************************************************************
+**
+** Function:    NfcHalAutoThreadMutex::~NfcHalAutoThreadMutex()
+**
+** Description: class destructor, automatically unlock the mutex
+**
+** Returns:     none
+**
+*******************************************************************************/
+NfcHalAutoThreadMutex::~NfcHalAutoThreadMutex() { mm.unlock(); }
diff --git a/pn72xx/halimpl/utils/NxpNfcThreadMutex.h b/pn72xx/halimpl/utils/NxpNfcThreadMutex.h
new file mode 100644
index 00000000..904641c3
--- /dev/null
+++ b/pn72xx/halimpl/utils/NxpNfcThreadMutex.h
@@ -0,0 +1,58 @@
+/*
+ *
+ *  Copyright 2021,2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#pragma once
+
+#include <pthread.h>
+
+class NfcHalThreadMutex {
+public:
+  NfcHalThreadMutex();
+  virtual ~NfcHalThreadMutex();
+  void lock();
+  void unlock();
+  operator pthread_mutex_t *() { return &mMutex; }
+
+private:
+  pthread_mutex_t mMutex;
+};
+
+class NfcHalThreadCondVar : public NfcHalThreadMutex {
+public:
+  NfcHalThreadCondVar();
+  virtual ~NfcHalThreadCondVar();
+  void signal();
+  void wait();
+  operator pthread_cond_t *() { return &mCondVar; }
+  operator pthread_mutex_t *() {
+    return NfcHalThreadMutex::operator pthread_mutex_t *();
+  }
+
+private:
+  pthread_cond_t mCondVar;
+};
+
+class NfcHalAutoThreadMutex {
+public:
+  NfcHalAutoThreadMutex(NfcHalThreadMutex &m);
+  virtual ~NfcHalAutoThreadMutex();
+  operator NfcHalThreadMutex &() { return mm; }
+  operator pthread_mutex_t *() { return (pthread_mutex_t *)mm; }
+
+private:
+  NfcHalThreadMutex &mm;
+};
\ No newline at end of file
diff --git a/pn72xx/halimpl/utils/phNxpConfig.cc b/pn72xx/halimpl/utils/phNxpConfig.cc
new file mode 100755
index 00000000..c046fd0c
--- /dev/null
+++ b/pn72xx/halimpl/utils/phNxpConfig.cc
@@ -0,0 +1,1244 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2011-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  The original Work has been changed by NXP.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  Copyright 2013-2021,2023 NXP
+ *
+ ******************************************************************************/
+
+#include <android-base/properties.h>
+#include <errno.h>
+#include <log/log.h>
+#include <phDnldNfc_Internal.h>
+#include <phNxpConfig.h>
+#include <phNxpLog.h>
+#include <stdio.h>
+#include <sys/stat.h>
+
+#include <list>
+#include <string>
+#include <vector>
+
+#include "sparse_crc32.h"
+#if GENERIC_TARGET
+const char alternative_config_path[] = "/data/vendor/nfc/";
+#else
+const char alternative_config_path[] = "";
+#endif
+
+#if 1
+const char *transport_config_paths[] = {"/odm/etc/", "/vendor/etc/", "/etc/"};
+#else
+const char *transport_config_paths[] = {"res/"};
+#endif
+const int transport_config_path_size =
+    (sizeof(transport_config_paths) / sizeof(transport_config_paths[0]));
+
+#define config_name "libnfc-nxp.conf"
+#define extra_config_base "libnfc-"
+#define extra_config_ext ".conf"
+#define IsStringValue 0x80000000
+
+typedef enum {
+  CONF_FILE_NXP = 0x00,
+  CONF_FILE_NXP_RF,
+  CONF_FILE_NXP_TRANSIT,
+  CONF_FILE_NXP_EEPROM
+} tNXP_CONF_FILE;
+
+const char rf_config_timestamp_path[] =
+    "/data/vendor/nfc/libnfc-nxpRFConfigState.bin";
+const char tr_config_timestamp_path[] =
+    "/data/vendor/nfc/libnfc-nxpTransitConfigState.bin";
+const char config_timestamp_path[] =
+    "/data/vendor/nfc/libnfc-nxpConfigState.bin";
+const char eeprom_config_timestamp_path[] =
+    "/data/vendor/nfc/libnfc-nxpEepromConfigState.bin";
+char nxp_eeprom_config_path[50] = "/vendor/etc/libnfc-nxp-eeprom.conf";
+/*const char default_nxp_config_path[] =
+        "/vendor/etc/libnfc-nxp.conf";*/
+char nxp_rf_config_path[256] = "/system/vendor/libnfc-nxp_RF.conf";
+#if (defined(__arm64__) || defined(__aarch64__) || defined(_M_ARM64))
+char Fw_Lib_Path[256] = "/vendor/lib64/libsn100u_fw.so";
+#else
+char Fw_Lib_Path[256] = "/vendor/lib/libsn100u_fw.so";
+#endif
+
+const char transit_config_path[] = "/data/vendor/nfc/libnfc-nxpTransit.conf";
+void readOptionalConfig(const char *optional);
+
+size_t readConfigFile(const char *fileName, uint8_t **p_data) {
+  FILE *fd = fopen(fileName, "rb");
+  if (fd == nullptr)
+    return 0;
+
+  fseek(fd, 0L, SEEK_END);
+  const size_t file_size = ftell(fd);
+  rewind(fd);
+  if ((long)file_size < 0) {
+    ALOGE("%s Invalid file size file_size = %zu\n", __func__, file_size);
+    fclose(fd);
+    return 0;
+  }
+  uint8_t *buffer = new uint8_t[file_size + 1];
+  if (!buffer) {
+    fclose(fd);
+    return 0;
+  }
+  size_t read = fread(buffer, file_size, 1, fd);
+  fclose(fd);
+
+  if (read == 1) {
+    buffer[file_size] = '\n';
+    *p_data = buffer;
+    return file_size + 1;
+  }
+  delete[] buffer;
+  return 0;
+}
+
+using namespace ::std;
+
+class CNfcParam : public string {
+public:
+  CNfcParam();
+  CNfcParam(const char *name, const string &value);
+  CNfcParam(const char *name, unsigned long value);
+  virtual ~CNfcParam();
+  unsigned long numValue() const { return m_numValue; }
+  const char *str_value() const { return m_str_value.c_str(); }
+  size_t str_len() const { return m_str_value.length(); }
+
+private:
+  string m_str_value;
+  unsigned long m_numValue;
+};
+
+class CNfcConfig : public vector<const CNfcParam *> {
+public:
+  virtual ~CNfcConfig();
+  static CNfcConfig &GetInstance();
+  friend void readOptionalConfig(const char *optional);
+  bool isModified(tNXP_CONF_FILE aType);
+  void resetModified(tNXP_CONF_FILE aType);
+
+  bool getValue(const char *name, char *pValue, size_t len) const;
+  bool getValue(const char *name, unsigned long &rValue) const;
+  bool getValue(const char *name, unsigned short &rValue) const;
+  bool getValue(const char *name, char *pValue, long len, long *readlen) const;
+  const CNfcParam *find(const char *p_name) const;
+  void readNxpTransitConfig(const char *fileName) const;
+  void readNxpEepromConfig(const char *fileName) const;
+  void readNxpRFConfig(const char *fileName) const;
+  void clean();
+
+private:
+  CNfcConfig();
+  bool readConfig(const char *name, bool bResetContent);
+  void moveFromList();
+  void moveToList();
+  void add(const CNfcParam *pParam);
+  void dump();
+  bool isAllowed(const char *name);
+  list<const CNfcParam *> m_list;
+  bool mValidFile;
+  uint32_t config_crc32_;
+  uint32_t config_rf_crc32_;
+  uint32_t config_tr_crc32_;
+  uint32_t config_eeprom_crc32_;
+  string mCurrentFile;
+
+  unsigned long state;
+
+  inline bool Is(unsigned long f) { return (state & f) == f; }
+  inline void Set(unsigned long f) { state |= f; }
+  inline void Reset(unsigned long f) { state &= ~f; }
+};
+
+/*******************************************************************************
+**
+** Function:    isPrintable()
+**
+** Description: determine if 'c' is printable
+**
+** Returns:     1, if printable, otherwise 0
+**
+*******************************************************************************/
+inline bool isPrintable(char c) {
+  return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||
+         (c >= '0' && c <= '9') || c == '/' || c == '_' || c == '-' || c == '.';
+}
+
+/*******************************************************************************
+**
+** Function:    isDigit()
+**
+** Description: determine if 'c' is numeral digit
+**
+** Returns:     true, if numerical digit
+**
+*******************************************************************************/
+inline bool isDigit(char c, int base) {
+  if ('0' <= c && c <= '9')
+    return true;
+  if (base == 16) {
+    if (('A' <= c && c <= 'F') || ('a' <= c && c <= 'f'))
+      return true;
+  }
+  return false;
+}
+
+/*******************************************************************************
+**
+** Function:    getDigitValue()
+**
+** Description: return numerical value of a decimal or hex char
+**
+** Returns:     numerical value if decimal or hex char, otherwise 0
+**
+*******************************************************************************/
+inline int getDigitValue(char c, int base) {
+  if ('0' <= c && c <= '9')
+    return c - '0';
+  if (base == 16) {
+    if ('A' <= c && c <= 'F')
+      return c - 'A' + 10;
+    else if ('a' <= c && c <= 'f')
+      return c - 'a' + 10;
+  }
+  return 0;
+}
+
+/*******************************************************************************
+**
+** Function:    findConfigFilePathFromTransportConfigPaths()
+**
+** Description: find a config file path with a given config name from transport
+**              config paths
+**
+** Returns:     none
+**
+*******************************************************************************/
+bool findConfigFilePathFromTransportConfigPaths(const string &configName,
+                                                string &filePath) {
+  for (int i = 0; i < transport_config_path_size - 1; i++) {
+    if (configName.empty())
+      break;
+    filePath.assign(transport_config_paths[i]);
+    filePath += configName;
+    struct stat file_stat;
+    if (stat(filePath.c_str(), &file_stat) == 0 && S_ISREG(file_stat.st_mode)) {
+      return true;
+    }
+  }
+  filePath = "";
+  return false;
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::readConfig()
+**
+** Description: read Config settings and parse them into a linked list
+**              move the element from linked list to a array at the end
+**
+** Returns:     1, if there are any config data, 0 otherwise
+**
+*******************************************************************************/
+bool CNfcConfig::readConfig(const char *name, bool bResetContent) {
+  enum {
+    BEGIN_LINE = 1,
+    TOKEN,
+    STR_VALUE,
+    NUM_VALUE,
+    BEGIN_HEX,
+    BEGIN_QUOTE,
+    END_LINE
+  };
+
+  uint8_t *p_config = nullptr;
+  size_t config_size = readConfigFile(name, &p_config);
+  if (p_config == nullptr) {
+    ALOGE("%s Cannot open config file %s\n", __func__, name);
+    if (bResetContent) {
+      ALOGE("%s Using default value for all settings\n", __func__);
+      mValidFile = false;
+    }
+    return false;
+  }
+
+  string token;
+  string strValue;
+  unsigned long numValue = 0;
+  CNfcParam *pParam = NULL;
+  int i = 0;
+  int base = 0;
+  char c;
+  int bflag = 0;
+  state = BEGIN_LINE;
+
+  ALOGD("readConfig; filename is %s", name);
+  if (strcmp(name, nxp_rf_config_path) == 0) {
+    config_rf_crc32_ =
+        sparse_crc32(0, (const void *)p_config, (int)config_size);
+  } else if (strcmp(name, transit_config_path) == 0) {
+    config_tr_crc32_ =
+        sparse_crc32(0, (const void *)p_config, (int)config_size);
+  } else if (strcmp(name, nxp_eeprom_config_path) == 0) {
+    config_eeprom_crc32_ =
+        sparse_crc32(0, (const void *)p_config, (int)config_size);
+  } else {
+    config_crc32_ = sparse_crc32(0, (const void *)p_config, (int)config_size);
+  }
+
+  mValidFile = true;
+  if (size() > 0) {
+    if (bResetContent)
+      clean();
+    else
+      moveToList();
+  }
+
+  for (size_t offset = 0; offset != config_size; ++offset) {
+    c = p_config[offset];
+    switch (state & 0xff) {
+    case BEGIN_LINE:
+      if (c == '#')
+        state = END_LINE;
+      else if (isPrintable(c)) {
+        i = 0;
+        token.erase();
+        strValue.erase();
+        state = TOKEN;
+        token.push_back(c);
+      }
+      break;
+    case TOKEN:
+      if (c == '=') {
+        token.push_back('\0');
+        state = BEGIN_QUOTE;
+      } else if (isPrintable(c))
+        token.push_back(c);
+      else
+        state = END_LINE;
+      break;
+    case BEGIN_QUOTE:
+      if (c == '"') {
+        state = STR_VALUE;
+        base = 0;
+      } else if (c == '0')
+        state = BEGIN_HEX;
+      else if (isDigit(c, 10)) {
+        state = NUM_VALUE;
+        base = 10;
+        numValue = getDigitValue(c, base);
+        i = 0;
+      } else if (c == '{') {
+        state = NUM_VALUE;
+        bflag = 1;
+        base = 16;
+        i = 0;
+        Set(IsStringValue);
+      } else
+        state = END_LINE;
+      break;
+    case BEGIN_HEX:
+      if (c == 'x' || c == 'X') {
+        state = NUM_VALUE;
+        base = 16;
+        numValue = 0;
+        i = 0;
+        break;
+      } else if (isDigit(c, 10)) {
+        state = NUM_VALUE;
+        base = 10;
+        numValue = getDigitValue(c, base);
+        break;
+      } else if (c != '\n' && c != '\r') {
+        state = END_LINE;
+        break;
+      }
+      // fall through to numValue to handle numValue
+      [[fallthrough]];
+    case NUM_VALUE:
+      if (isDigit(c, base)) {
+        numValue *= base;
+        numValue += getDigitValue(c, base);
+        ++i;
+      } else if (bflag == 1 &&
+                 (c == ' ' || c == '\r' || c == '\n' || c == '\t')) {
+        break;
+      } else if (base == 16 &&
+                 (c == ',' || c == ':' || c == '-' || c == ' ' || c == '}')) {
+        if (c == '}') {
+          bflag = 0;
+        }
+        if (i > 0) {
+          int n = (i + 1) / 2;
+          while (n-- > 0) {
+            numValue = numValue >> (n * 8);
+            unsigned char c = (numValue)&0xFF;
+            strValue.push_back(c);
+          }
+        }
+
+        Set(IsStringValue);
+        numValue = 0;
+        i = 0;
+      } else {
+        if (c == '\n' || c == '\r') {
+          if (bflag == 0) {
+            state = BEGIN_LINE;
+          }
+        } else {
+          if (bflag == 0) {
+            state = END_LINE;
+          }
+        }
+        if (Is(IsStringValue) && base == 16 && i > 0) {
+          int n = (i + 1) / 2;
+          while (n-- > 0)
+            strValue.push_back(((numValue >> (n * 8)) & 0xFF));
+        }
+        if (strValue.length() > 0)
+          pParam = new CNfcParam(token.c_str(), strValue);
+        else
+          pParam = new CNfcParam(token.c_str(), numValue);
+        add(pParam);
+        strValue.erase();
+        numValue = 0;
+      }
+      break;
+    case STR_VALUE:
+      if (c == '"') {
+        strValue.push_back('\0');
+        state = END_LINE;
+        pParam = new CNfcParam(token.c_str(), strValue);
+        add(pParam);
+      } else if (isPrintable(c))
+        strValue.push_back(c);
+      break;
+    case END_LINE:
+      if (c == '\n' || c == '\r')
+        state = BEGIN_LINE;
+      break;
+    default:
+      break;
+    }
+  }
+
+  delete[] p_config;
+
+  moveFromList();
+  return size() > 0;
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::CNfcConfig()
+**
+** Description: class constructor
+**
+** Returns:     none
+**
+*******************************************************************************/
+CNfcConfig::CNfcConfig()
+    : mValidFile(true), config_crc32_(0), config_rf_crc32_(0),
+      config_tr_crc32_(0), config_eeprom_crc32_(0), state(0) {}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::~CNfcConfig()
+**
+** Description: class destructor
+**
+** Returns:     none
+**
+*******************************************************************************/
+CNfcConfig::~CNfcConfig() {}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::GetInstance()
+**
+** Description: get class singleton object
+**
+** Returns:     none
+**
+*******************************************************************************/
+CNfcConfig &CNfcConfig::GetInstance() {
+  static CNfcConfig theInstance;
+
+  if (theInstance.size() == 0 && theInstance.mValidFile) {
+    string strPath;
+    if (alternative_config_path[0] != '\0') {
+      strPath.assign(alternative_config_path);
+      strPath += config_name;
+      theInstance.readConfig(strPath.c_str(), true);
+      if (!theInstance.empty()) {
+        return theInstance;
+      }
+    }
+
+    if (findConfigFilePathFromTransportConfigPaths(
+            android::base::GetProperty("persist.vendor.nfc.config_file_name",
+                                       ""),
+            strPath)) {
+      NXPLOG_EXTNS_D("%s load %s\n", __func__, strPath.c_str());
+    } else if (findConfigFilePathFromTransportConfigPaths(
+                   extra_config_base +
+                       android::base::GetProperty(
+                           "ro.boot.product.hardware.sku", "") +
+                       +extra_config_ext,
+                   strPath)) {
+      NXPLOG_EXTNS_D("%s load %s\n", __func__, strPath.c_str());
+    } else {
+      findConfigFilePathFromTransportConfigPaths(config_name, strPath);
+    }
+
+    theInstance.readConfig(strPath.c_str(), true);
+    theInstance.readNxpEepromConfig(nxp_eeprom_config_path);
+#if (NXP_EXTNS == TRUE)
+    theInstance.readNxpRFConfig(nxp_rf_config_path);
+    theInstance.readNxpTransitConfig(transit_config_path);
+#endif
+  }
+  return theInstance;
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::getValue()
+**
+** Description: get a string value of a setting
+**
+** Returns:     true if setting exists
+**              false if setting does not exist
+**
+*******************************************************************************/
+bool CNfcConfig::getValue(const char *name, char *pValue, size_t len) const {
+  const CNfcParam *pParam = find(name);
+  if (pParam == NULL)
+    return false;
+
+  if (pParam->str_len() > 0) {
+    memset(pValue, 0, len);
+    memcpy(pValue, pParam->str_value(), pParam->str_len());
+    return true;
+  }
+  return false;
+}
+
+bool CNfcConfig::getValue(const char *name, char *pValue, long len,
+                          long *readlen) const {
+  const CNfcParam *pParam = find(name);
+  if (pParam == NULL)
+    return false;
+
+  if (pParam->str_len() > 0) {
+    if (pParam->str_len() <= (unsigned long)len) {
+      memset(pValue, 0, len);
+      memcpy(pValue, pParam->str_value(), pParam->str_len());
+      *readlen = pParam->str_len();
+    } else {
+      *readlen = -1;
+    }
+
+    return true;
+  }
+  return false;
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::getValue()
+**
+** Description: get a long numerical value of a setting
+**
+** Returns:     true if setting exists
+**              false if setting does not exist
+**
+*******************************************************************************/
+bool CNfcConfig::getValue(const char *name, unsigned long &rValue) const {
+  const CNfcParam *pParam = find(name);
+  if (pParam == NULL)
+    return false;
+
+  if (pParam->str_len() == 0) {
+    rValue = static_cast<unsigned long>(pParam->numValue());
+    return true;
+  }
+  return false;
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::getValue()
+**
+** Description: get a short numerical value of a setting
+**
+** Returns:     true if setting exists
+**              false if setting does not exist
+**
+*******************************************************************************/
+bool CNfcConfig::getValue(const char *name, unsigned short &rValue) const {
+  const CNfcParam *pParam = find(name);
+  if (pParam == NULL)
+    return false;
+
+  if (pParam->str_len() == 0) {
+    rValue = static_cast<unsigned short>(pParam->numValue());
+    return true;
+  }
+  return false;
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::find()
+**
+** Description: search if a setting exist in the setting array
+**
+** Returns:     pointer to the setting object
+**
+*******************************************************************************/
+const CNfcParam *CNfcConfig::find(const char *p_name) const {
+  if (size() == 0)
+    return NULL;
+
+  for (const_iterator it = begin(), itEnd = end(); it != itEnd; ++it) {
+    if (**it < p_name) {
+      continue;
+    } else if (**it == p_name) {
+      if ((*it)->str_len() > 0) {
+        NXPLOG_EXTNS_D("%s found %s=%s\n", __func__, p_name,
+                       (*it)->str_value());
+      } else {
+        NXPLOG_EXTNS_D("%s found %s=(0x%lx)\n", __func__, p_name,
+                       (*it)->numValue());
+      }
+      return *it;
+    } else
+      break;
+  }
+  return NULL;
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::readNxpTransitConfig()
+**
+** Description: read Config settings from transit conf file
+**
+** Returns:     none
+**
+*******************************************************************************/
+void CNfcConfig::readNxpTransitConfig(const char *fileName) const {
+  ALOGD("readNxpTransitConfig-Enter..Reading %s", fileName);
+  CNfcConfig::GetInstance().readConfig(fileName, false);
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::readNxpRFConfig()
+**
+** Description: read Config settings from RF conf file
+**
+** Returns:     none
+**
+*******************************************************************************/
+void CNfcConfig::readNxpRFConfig(const char *fileName) const {
+  ALOGD("readNxpRFConfig-Enter..Reading %s", fileName);
+  CNfcConfig::GetInstance().readConfig(fileName, false);
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::readNxpEepromConfig()
+**
+** Description: read Config settings from EEPROM conf file
+**
+** Returns:     none
+**
+*******************************************************************************/
+void CNfcConfig::readNxpEepromConfig(const char *fileName) const {
+  ALOGD("readNxpEepromConfig-Enter..Reading %s", fileName);
+  CNfcConfig::GetInstance().readConfig(fileName, false);
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::clean()
+**
+** Description: reset the setting array
+**
+** Returns:     none
+**
+*******************************************************************************/
+void CNfcConfig::clean() {
+  if (size() == 0)
+    return;
+
+  for (iterator it = begin(), itEnd = end(); it != itEnd; ++it)
+    delete *it;
+  clear();
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::Add()
+**
+** Description: add a setting object to the list
+**
+** Returns:     none
+**
+*******************************************************************************/
+void CNfcConfig::add(const CNfcParam *pParam) {
+  if (m_list.size() == 0) {
+    m_list.push_back(pParam);
+    return;
+  }
+  if ((mCurrentFile.find("nxpTransit") != std::string::npos) &&
+      !isAllowed(pParam->c_str())) {
+    ALOGD("%s Token restricted. Returning", __func__);
+    return;
+  }
+  for (list<const CNfcParam *>::iterator it = m_list.begin(),
+                                         itEnd = m_list.end();
+       it != itEnd; ++it) {
+    if (**it < pParam->c_str())
+      continue;
+    if (**it == pParam->c_str())
+      m_list.insert(m_list.erase(it), pParam);
+    else
+      m_list.insert(it, pParam);
+
+    return;
+  }
+  m_list.push_back(pParam);
+}
+/*******************************************************************************
+**
+** Function:    CNfcConfig::dump()
+**
+** Description: prints all elements in the list
+**
+** Returns:     none
+**
+*******************************************************************************/
+void CNfcConfig::dump() {
+  ALOGD("%s Enter", __func__);
+
+  for (list<const CNfcParam *>::iterator it = m_list.begin(),
+                                         itEnd = m_list.end();
+       it != itEnd; ++it) {
+    if ((*it)->str_len() > 0)
+      ALOGD("%s %s \t= %s", __func__, (*it)->c_str(), (*it)->str_value());
+    else
+      ALOGD("%s %s \t= (0x%0lX)\n", __func__, (*it)->c_str(),
+            (*it)->numValue());
+  }
+}
+/*******************************************************************************
+**
+** Function:    CNfcConfig::isAllowed()
+**
+** Description: checks if token update is allowed
+**
+** Returns:     true if allowed else false
+**
+*******************************************************************************/
+bool CNfcConfig::isAllowed(const char *name) {
+  string token(name);
+  bool stat = false;
+  if ((token.find("P2P_LISTEN_TECH_MASK") != std::string::npos) ||
+      (token.find("HOST_LISTEN_TECH_MASK") != std::string::npos) ||
+      (token.find("UICC_LISTEN_TECH_MASK") != std::string::npos) ||
+      (token.find("NXP_ESE_LISTEN_TECH_MASK") != std::string::npos) ||
+      (token.find("POLLING_TECH_MASK") != std::string::npos) ||
+      (token.find("NXP_RF_CONF_BLK") != std::string::npos) ||
+      (token.find("NXP_CN_TRANSIT_BLK_NUM_CHECK_ENABLE") !=
+       std::string::npos) ||
+      (token.find("NXP_FWD_FUNCTIONALITY_ENABLE") != std::string::npos) ||
+      (token.find("NXP_MIFARE_NACK_TO_RATS_ENABLE") != std::string::npos))
+
+  {
+    stat = true;
+  }
+  return stat;
+}
+/*******************************************************************************
+**
+** Function:    CNfcConfig::moveFromList()
+**
+** Description: move the setting object from list to array
+**
+** Returns:     none
+**
+*******************************************************************************/
+void CNfcConfig::moveFromList() {
+  if (m_list.size() == 0)
+    return;
+
+  for (list<const CNfcParam *>::iterator it = m_list.begin(),
+                                         itEnd = m_list.end();
+       it != itEnd; ++it)
+    push_back(*it);
+  m_list.clear();
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::moveToList()
+**
+** Description: move the setting object from array to list
+**
+** Returns:     none
+**
+*******************************************************************************/
+void CNfcConfig::moveToList() {
+  if (m_list.size() != 0)
+    m_list.clear();
+
+  for (iterator it = begin(), itEnd = end(); it != itEnd; ++it)
+    m_list.push_back(*it);
+  clear();
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::isModified()
+**
+** Description: compare the timestamp and check config file is modified or not
+**
+** Returns:     true  (modified)
+**              false (Not modified)
+**
+*******************************************************************************/
+bool CNfcConfig::isModified(tNXP_CONF_FILE aType) {
+  FILE *fd = NULL;
+  bool isModified = false;
+
+  ALOGD("isModified enter; conf file type %d", aType);
+  switch (aType) {
+  case CONF_FILE_NXP:
+    fd = fopen(config_timestamp_path, "r+");
+    break;
+  case CONF_FILE_NXP_RF:
+    fd = fopen(rf_config_timestamp_path, "r+");
+    break;
+  case CONF_FILE_NXP_TRANSIT:
+    fd = fopen(tr_config_timestamp_path, "r+");
+    break;
+  case CONF_FILE_NXP_EEPROM:
+    fd = fopen(eeprom_config_timestamp_path, "r+");
+    break;
+  default:
+    ALOGD("Invalid conf file type");
+    return false;
+  }
+  if (fd == nullptr) {
+    ALOGE("%s Unable to open file assume modified", __func__);
+    return true;
+  }
+
+  uint32_t stored_crc32 = 0;
+  if (fread(&stored_crc32, sizeof(uint32_t), 1, fd) != 1) {
+    ALOGE("%s File read is not successful errno = %d", __func__, errno);
+  }
+
+  fclose(fd);
+  ALOGD("stored_crc32 is %d config_crc32_ is %d", stored_crc32, config_crc32_);
+
+  switch (aType) {
+  case CONF_FILE_NXP:
+    isModified = stored_crc32 != config_crc32_;
+    break;
+  case CONF_FILE_NXP_RF:
+    isModified = stored_crc32 != config_rf_crc32_;
+    break;
+  case CONF_FILE_NXP_TRANSIT:
+    isModified = stored_crc32 != config_tr_crc32_;
+    break;
+  case CONF_FILE_NXP_EEPROM:
+    isModified = stored_crc32 != config_eeprom_crc32_;
+    break;
+  }
+  return isModified;
+}
+
+void CNfcConfig::resetModified(tNXP_CONF_FILE aType) {
+  FILE *fd = NULL;
+
+  ALOGD("resetModified enter; conf file type is %d", aType);
+  switch (aType) {
+  case CONF_FILE_NXP:
+    fd = fopen(config_timestamp_path, "w+");
+    break;
+  case CONF_FILE_NXP_RF:
+    fd = fopen(rf_config_timestamp_path, "w+");
+    break;
+  case CONF_FILE_NXP_TRANSIT:
+    fd = fopen(tr_config_timestamp_path, "w+");
+    break;
+  case CONF_FILE_NXP_EEPROM:
+    fd = fopen(eeprom_config_timestamp_path, "w+");
+    break;
+  default:
+    ALOGD("Invalid conf file type");
+    return;
+  }
+
+  if (fd == nullptr) {
+    ALOGE("%s Unable to open file for writing", __func__);
+    return;
+  }
+
+  switch (aType) {
+  case CONF_FILE_NXP:
+    fwrite(&config_crc32_, sizeof(uint32_t), 1, fd);
+    break;
+  case CONF_FILE_NXP_RF:
+    fwrite(&config_rf_crc32_, sizeof(uint32_t), 1, fd);
+    break;
+  case CONF_FILE_NXP_TRANSIT:
+    fwrite(&config_tr_crc32_, sizeof(uint32_t), 1, fd);
+    break;
+  case CONF_FILE_NXP_EEPROM:
+    fwrite(&config_eeprom_crc32_, sizeof(uint32_t), 1, fd);
+    break;
+  }
+  fclose(fd);
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcParam::CNfcParam()
+**
+** Description: class constructor
+**
+** Returns:     none
+**
+*******************************************************************************/
+CNfcParam::CNfcParam() : m_numValue(0) {}
+
+/*******************************************************************************
+**
+** Function:    CNfcParam::~CNfcParam()
+**
+** Description: class destructor
+**
+** Returns:     none
+**
+*******************************************************************************/
+CNfcParam::~CNfcParam() {}
+
+/*******************************************************************************
+**
+** Function:    CNfcParam::CNfcParam()
+**
+** Description: class copy constructor
+**
+** Returns:     none
+**
+*******************************************************************************/
+CNfcParam::CNfcParam(const char *name, const string &value)
+    : string(name), m_str_value(value), m_numValue(0) {}
+
+/*******************************************************************************
+**
+** Function:    CNfcParam::CNfcParam()
+**
+** Description: class copy constructor
+**
+** Returns:     none
+**
+*******************************************************************************/
+CNfcParam::CNfcParam(const char *name, unsigned long value)
+    : string(name), m_numValue(value) {}
+
+/*******************************************************************************
+**
+** Function:    readOptionalConfig()
+**
+** Description: read Config settings from an optional conf file
+**
+** Returns:     none
+**
+*******************************************************************************/
+void readOptionalConfig(const char *extra) {
+  string strPath;
+  string configName(extra_config_base);
+  configName += extra;
+  configName += extra_config_ext;
+
+  if (alternative_config_path[0] != '\0') {
+    strPath.assign(alternative_config_path);
+    strPath += configName;
+  } else {
+    findConfigFilePathFromTransportConfigPaths(configName, strPath);
+  }
+
+  CNfcConfig::GetInstance().readConfig(strPath.c_str(), false);
+}
+
+/*******************************************************************************
+**
+** Function:    GetStrValue
+**
+** Description: API function for getting a string value of a setting
+**
+** Returns:     True if found, otherwise False.
+**
+*******************************************************************************/
+extern "C" int GetNxpStrValue(const char *name, char *pValue,
+                              unsigned long len) {
+  CNfcConfig &rConfig = CNfcConfig::GetInstance();
+
+  return rConfig.getValue(name, pValue, len);
+}
+
+/*******************************************************************************
+**
+** Function:    GetByteArrayValue()
+**
+** Description: Read byte array value from the config file.
+**
+** Parameters:
+**              name - name of the config param to read.
+**              pValue  - pointer to input buffer.
+**              bufflen - input buffer length.
+**              len - out parameter to return the number of bytes read from
+**                    config file, return -1 in case bufflen is not enough.
+**
+** Returns:     TRUE[1] if config param name is found in the config file, else
+**              FALSE[0]
+**
+*******************************************************************************/
+extern "C" int GetNxpByteArrayValue(const char *name, char *pValue,
+                                    long bufflen, long *len) {
+  CNfcConfig &rConfig = CNfcConfig::GetInstance();
+
+  return rConfig.getValue(name, pValue, bufflen, len);
+}
+
+/*******************************************************************************
+**
+** Function:    GetNumValue
+**
+** Description: API function for getting a numerical value of a setting
+**
+** Returns:     true, if successful
+**
+*******************************************************************************/
+extern "C" int GetNxpNumValue(const char *name, void *pValue,
+                              unsigned long len) {
+  if (!pValue)
+    return false;
+
+  CNfcConfig &rConfig = CNfcConfig::GetInstance();
+  const CNfcParam *pParam = rConfig.find(name);
+
+  if (pParam == NULL)
+    return false;
+  unsigned long v = pParam->numValue();
+  if (v == 0 && pParam->str_len() > 0 && pParam->str_len() < 4) {
+    const unsigned char *p = (const unsigned char *)pParam->str_value();
+    for (size_t i = 0; i < pParam->str_len(); ++i) {
+      v *= 256;
+      v += *p++;
+    }
+  }
+  switch (len) {
+  case sizeof(unsigned long):
+    *(static_cast<unsigned long *>(pValue)) = (unsigned long)v;
+    break;
+  case sizeof(unsigned short):
+    *(static_cast<unsigned short *>(pValue)) = (unsigned short)v;
+    break;
+  case sizeof(unsigned char):
+    *(static_cast<unsigned char *>(pValue)) = (unsigned char)v;
+    break;
+  default:
+    return false;
+  }
+  return true;
+}
+
+/*******************************************************************************
+**
+** Function:    setNxpRfConfigPath
+**
+** Description: sets the path of the NXP RF config file
+**
+** Returns:     none
+**
+*******************************************************************************/
+extern "C" void setNxpRfConfigPath(const char *name) {
+  memset(nxp_rf_config_path, 0, sizeof(nxp_rf_config_path));
+  strlcpy(nxp_rf_config_path, name, sizeof(nxp_rf_config_path));
+  ALOGD("nxp_rf_config_path=%s", nxp_rf_config_path);
+}
+
+/*******************************************************************************
+**
+** Function:    setNxpFwConfigPath
+**
+** Description: sets the path of the NXP FW library
+**
+** Returns:     none
+**
+*******************************************************************************/
+extern "C" void setNxpFwConfigPath() {
+  unsigned long fwType = FW_FORMAT_SO;
+  if (GetNxpNumValue(NAME_NXP_FW_TYPE, &fwType, sizeof(fwType))) {
+    NXPLOG_FWDNLD_D("firmware type from conf file: %lu", fwType);
+  }
+
+  memset(Fw_Lib_Path, 0, sizeof(Fw_Lib_Path));
+  if (fwType == FW_FORMAT_BIN) {
+    strlcpy(Fw_Lib_Path, nfcFL._FW_BIN_PATH.c_str(), sizeof(Fw_Lib_Path));
+  } else {
+    strlcpy(Fw_Lib_Path, nfcFL._FW_LIB_PATH.c_str(), sizeof(Fw_Lib_Path));
+  }
+
+  ALOGD("Fw_Lib_Path=%s", Fw_Lib_Path);
+}
+
+/*******************************************************************************
+**
+** Function:    resetConfig
+**
+** Description: reset settings array
+**
+** Returns:     none
+**
+*******************************************************************************/
+extern "C" void resetNxpConfig()
+
+{
+  CNfcConfig &rConfig = CNfcConfig::GetInstance();
+
+  rConfig.clean();
+}
+
+/*******************************************************************************
+**
+** Function:    isNxpConfigModified()
+**
+** Description: check if config file has modified
+**
+** Returns:     0 if not modified, 1 otherwise.
+**
+*******************************************************************************/
+extern "C" int isNxpConfigModified() {
+  CNfcConfig &rConfig = CNfcConfig::GetInstance();
+  return rConfig.isModified(CONF_FILE_NXP);
+}
+
+/*******************************************************************************
+**
+** Function:    isEEPROMConfigModified()
+**
+** Description: check if config file has modified
+**
+** Returns:     0 if not modified, 1 otherwise.
+**
+*******************************************************************************/
+extern "C" int isNxpEepromConfigModified() {
+  CNfcConfig &rConfig = CNfcConfig::GetInstance();
+  return rConfig.isModified(CONF_FILE_NXP_EEPROM);
+}
+/*******************************************************************************
+**
+** Function:    isNxpRFConfigModified()
+**
+** Description: check if config file has modified
+**
+** Returns:     0 if not modified, 1 otherwise.
+**
+*******************************************************************************/
+extern "C" int isNxpRFConfigModified() {
+  int retRF = 0, rettransit = 0, ret = 0;
+  CNfcConfig &rConfig = CNfcConfig::GetInstance();
+  retRF = rConfig.isModified(CONF_FILE_NXP_RF);
+  rettransit = rConfig.isModified(CONF_FILE_NXP_TRANSIT);
+  ret = retRF | rettransit;
+  ALOGD("ret RF or Transit value %d", ret);
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function:    updateNxpConfigTimestamp()
+**
+** Description: update if config file has modified
+**
+** Returns:     0 if not modified, 1 otherwise.
+**
+*******************************************************************************/
+extern "C" int updateNxpConfigTimestamp() {
+  CNfcConfig &rConfig = CNfcConfig::GetInstance();
+  rConfig.resetModified(CONF_FILE_NXP);
+  return 0;
+}
+
+/*******************************************************************************
+**
+** Function:    updateNxpEepromConfigTimestamp()
+**
+** Description: update if config file has modified
+**
+** Returns:     0 if not modified, 1 otherwise.
+**
+*******************************************************************************/
+extern "C" int updateNxpEepromConfigTimestamp() {
+  CNfcConfig &rConfig = CNfcConfig::GetInstance();
+  rConfig.resetModified(CONF_FILE_NXP_EEPROM);
+  return 0;
+}
+/*******************************************************************************
+**
+** Function:    updateNxpConfigTimestamp()
+**
+** Description: update if config file has modified
+**
+** Returns:     0 if not modified, 1 otherwise.
+**
+*******************************************************************************/
+extern "C" int updateNxpRfConfigTimestamp() {
+  CNfcConfig &rConfig = CNfcConfig::GetInstance();
+  rConfig.resetModified(CONF_FILE_NXP_RF);
+  rConfig.resetModified(CONF_FILE_NXP_TRANSIT);
+  return 0;
+}
diff --git a/pn72xx/halimpl/utils/phNxpConfig.h b/pn72xx/halimpl/utils/phNxpConfig.h
new file mode 100644
index 00000000..d06f60ef
--- /dev/null
+++ b/pn72xx/halimpl/utils/phNxpConfig.h
@@ -0,0 +1,203 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 1999-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  The original Work has been changed by NXP.
+ *
+ *  Copyright 2013-2021,2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int GetNxpStrValue(const char *name, char *p_value, unsigned long len);
+int GetNxpNumValue(const char *name, void *p_value, unsigned long len);
+int GetNxpByteArrayValue(const char *name, char *pValue, long bufflen,
+                         long *len);
+void resetNxpConfig(void);
+int isNxpRFConfigModified();
+int isNxpConfigModified();
+int isNxpEepromConfigModified();
+int updateNxpConfigTimestamp();
+int updateNxpEepromConfigTimestamp();
+int updateNxpRfConfigTimestamp();
+void setNxpRfConfigPath(const char *name);
+void setNxpFwConfigPath();
+
+#ifdef __cplusplus
+};
+#endif
+
+extern char Fw_Lib_Path[256];
+
+#define NAME_NXPLOG_EXTNS_LOGLEVEL "NXPLOG_EXTNS_LOGLEVEL"
+#define NAME_NXPLOG_NCIHAL_LOGLEVEL "NXPLOG_NCIHAL_LOGLEVEL"
+#define NAME_NXPLOG_NCIX_LOGLEVEL "NXPLOG_NCIX_LOGLEVEL"
+#define NAME_NXPLOG_NCIR_LOGLEVEL "NXPLOG_NCIR_LOGLEVEL"
+#define NAME_NXPLOG_FWDNLD_LOGLEVEL "NXPLOG_FWDNLD_LOGLEVEL"
+#define NAME_NXPLOG_TML_LOGLEVEL "NXPLOG_TML_LOGLEVEL"
+
+#define NAME_MIFARE_READER_ENABLE "MIFARE_READER_ENABLE"
+#define NAME_LEGACY_MIFARE_READER "LEGACY_MIFARE_READER"
+#define NAME_FW_STORAGE "FW_STORAGE"
+#define NAME_NXP_NFC_DEV_NODE "NXP_NFC_DEV_NODE"
+#define NAME_NXP_NFC_CHIP "NXP_NFC_CHIP"
+#define NAME_NXP_FW_TYPE "NXP_FW_TYPE"
+#define NAME_NXP_FW_PROTECION_OVERRIDE "NXP_FW_PROTECION_OVERRIDE"
+#define NAME_NXP_SYS_CLK_SRC_SEL "NXP_SYS_CLK_SRC_SEL"
+#define NAME_NXP_SYS_CLK_FREQ_SEL "NXP_SYS_CLK_FREQ_SEL"
+#define NAME_NXP_SYS_CLOCK_TO_CFG "NXP_SYS_CLOCK_TO_CFG"
+#define NAME_NXP_CLOCK_REQ_DELAY "NXP_CLOCK_REQ_DELAY"
+#define NAME_NXP_ACT_PROP_EXTN "NXP_ACT_PROP_EXTN"
+#define NAME_NXP_EXT_TVDD_CFG "NXP_EXT_TVDD_CFG"
+#define NAME_NXP_EXT_TVDD_CFG_1 "NXP_EXT_TVDD_CFG_1"
+#define NAME_NXP_EXT_TVDD_CFG_2 "NXP_EXT_TVDD_CFG_2"
+#define NAME_NXP_EXT_TVDD_CFG_3 "NXP_EXT_TVDD_CFG_3"
+#define NAME_NXP_CORE_CONF_EXTN "NXP_CORE_CONF_EXTN"
+#define NAME_NXP_CORE_CONF "NXP_CORE_CONF"
+#define NAME_NXP_CHINA_TIANJIN_RF_ENABLED "NXP_CHINA_TIANJIN_RF_ENABLED"
+#define NAME_NXP_CHINA_BLK_NUM_CHK_ENABLE "NXP_CN_TRANSIT_BLK_NUM_CHECK_ENABLE"
+#define NAME_NXP_CN_TRANSIT_CMA_BYPASSMODE_ENABLE                              \
+  "NXP_CN_TRANSIT_CMA_BYPASSMODE_ENABLE"
+#define NAME_NXP_ESE_POWER_DH_CONTROL "NXP_ESE_POWER_DH_CONTROL"
+#define NAME_NXP_ESE_POWER_EXT_PMU "NXP_ESE_POWER_EXT_PMU"
+#define NAME_NXP_ESE_POWER_DH_CONTROL_CFG_1 "NXP_ESE_POWER_DH_CONTROL_CFG_1"
+#define NAME_NXP_SWP_SWITCH_TIMEOUT "NXP_SWP_SWITCH_TIMEOUT"
+#define NAME_NXP_SWP_FULL_PWR_ON "NXP_SWP_FULL_PWR_ON"
+#define NAME_NXP_CORE_RF_FIELD "NXP_CORE_RF_FIELD"
+#define NAME_NXP_NFC_MERGE_RF_PARAMS "NXP_NFC_MERGE_RF_PARAMS"
+#define NAME_NXP_I2C_FRAGMENTATION_ENABLED "NXP_I2C_FRAGMENTATION_ENABLED"
+#define NAME_NFC_DEBUG_ENABLED "NFC_DEBUG_ENABLED"
+#define NAME_AID_MATCHING_PLATFORM "AID_MATCHING_PLATFORM"
+#define NAME_NXP_TYPEA_UICC_BAUD_RATE "NXP_TYPEA_UICC_BAUD_RATE"
+#define NAME_NXP_TYPEB_UICC_BAUD_RATE "NXP_TYPEB_UICC_BAUD_RATE"
+#define NAME_NXP_SET_CONFIG_ALWAYS "NXP_SET_CONFIG_ALWAYS"
+#define NAME_NXP_PROP_BLACKLIST_ROUTING "NXP_PROP_BLACKLIST_ROUTING"
+#define NAME_NXP_WIREDMODE_RESUME_TIMEOUT "NXP_WIREDMODE_RESUME_TIMEOUT"
+#define NAME_NXP_UICC_LISTEN_TECH_MASK "UICC_LISTEN_TECH_MASK"
+#define NAME_NXP_ESE_LISTEN_TECH_MASK "NXP_ESE_LISTEN_TECH_MASK"
+#define NAME_NXP_SVDD_SYNC_OFF_DELAY "NXP_SVDD_SYNC_OFF_DELAY"
+#define NAME_NXP_CORE_PROP_SYSTEM_DEBUG "NXP_CORE_PROP_SYSTEM_DEBUG"
+#define NAME_NXP_NCI_PARSER_LIBRARY "NXP_NCI_PARSER_LIBRARY"
+#define NAME_NXP_DEFAULT_UICC2_SELECT "NXP_DEFAULT_UICC2_SELECT"
+#define NAME_NXP_ALWAYS_FW_UPDATE "NXP_ALWAYS_FW_UPDATE"
+#define NAME_NXP_P61_JCOP_DEFAULT_INTERFACE "NXP_P61_JCOP_DEFAULT_INTERFACE"
+#define NAME_RF_STATUS_UPDATE_ENABLE "RF_STATUS_UPDATE_ENABLE"
+#define NAME_DEFAULT_ROUTE "DEFAULT_ROUTE"
+#define NAME_DEFAULT_SYS_CODE_ROUTE "DEFAULT_SYS_CODE_ROUTE"
+#define NAME_DEFAULT_SYS_CODE_PWR_STATE "DEFAULT_SYS_CODE_PWR_STATE"
+#define NAME_OFF_HOST_ESE_PIPE_ID "OFF_HOST_ESE_PIPE_ID"
+#define NAME_OFF_HOST_SIM_PIPE_ID "OFF_HOST_SIM_PIPE_ID"
+#define NAME_DEFAULT_OFFHOST_ROUTE "DEFAULT_OFFHOST_ROUTE"
+#define NAME_DEFAULT_NFCF_ROUTE "DEFAULT_NFCF_ROUTE"
+#define NAME_ISO_DEP_MAX_TRANSCEIVE "ISO_DEP_MAX_TRANSCEIVE"
+#define NAME_NFA_POLL_BAIL_OUT_MODE "NFA_POLL_BAIL_OUT_MODE"
+#define NAME_ACTIVE_SE "ACTIVE_SE"
+#define NAME_ACTIVE_SE_NFCF "ACTIVE_SE_NFCF"
+#define NAME_DEFAULT_FELICA_SYS_CODE_ROUTE "DEFAULT_FELICA_SYS_CODE_ROUTE"
+#define NAME_DEVICE_HOST_WHITE_LIST "DEVICE_HOST_WHITE_LIST"
+#define NAME_NFA_PROPRIETARY_CFG "NFA_PROPRIETARY_CFG"
+#define NAME_PRESENCE_CHECK_ALGORITHM "PRESENCE_CHECK_ALGORITHM"
+#define NAME_NXP_CORE_PROP_SYSTEM_DEBUG "NXP_CORE_PROP_SYSTEM_DEBUG"
+#define NAME_NXP_AUTONOMOUS_ENABLE "NXP_AUTONOMOUS_ENABLE"
+#define NAME_NXP_P61_LS_DEFAULT_INTERFACE "NXP_P61_LS_DEFAULT_INTERFACE"
+#define NAME_NXP_LS_FORCE_UPDATE_REQUIRED "NXP_LS_FORCE_UPDATE_REQUIRED"
+#define NAME_NXP_JCOP_FORCE_UPDATE_REQUIRED "NXP_JCOP_FORCE_UPDATE_REQUIRED"
+#define NAME_RF_STORAGE "RF_STORAGE"
+#define NAME_NXP_FLASH_CONFIG "NXP_FLASH_CONFIG"
+#define NAME_OFFHOST_ROUTE_ESE "OFFHOST_ROUTE_ESE"
+#define NAME_OFFHOST_ROUTE_UICC "OFFHOST_ROUTE_UICC"
+#define NAME_DEFAULT_ISODEP_ROUTE "DEFAULT_ISODEP_ROUTE"
+#if (NXP_EXTNS == TRUE)
+#define NAME_NXP_SE_COLD_TEMP_ERROR_DELAY "NXP_SE_COLD_TEMP_ERROR_DELAY"
+#define NAME_P2P_LISTEN_TECH_MASK "P2P_LISTEN_TECH_MASK"
+#define NAME_HOST_LISTEN_TECH_MASK "HOST_LISTEN_TECH_MASK"
+#define NAME_UICC_LISTEN_TECH_MASK "UICC_LISTEN_TECH_MASK"
+#define NAME_POLLING_TECH_MASK "POLLING_TECH_MASK"
+#define NAME_NXP_DEFAULT_SE "NXP_DEFAULT_SE"
+#define NAME_NXP_SWP_RD_TAG_OP_TIMEOUT "NXP_SWP_RD_TAG_OP_TIMEOUT"
+#define NAME_NXP_DUAL_UICC_ENABLE "NXP_DUAL_UICC_ENABLE"
+#define NAME_DEFAULT_AID_ROUTE "DEFAULT_AID_ROUTE"
+#define NAME_DEFAULT_MIFARE_CLT_ROUTE "DEFAULT_MIFARE_CLT_ROUTE"
+#define NAME_DEFAULT_FELICA_CLT_ROUTE "DEFAULT_FELICA_CLT_ROUTE"
+#define NAME_DEFAULT_AID_PWR_STATE "DEFAULT_AID_PWR_STATE"
+#define NAME_DEFAULT_DESFIRE_PWR_STATE "DEFAULT_DESFIRE_PWR_STATE"
+#define NAME_DEFAULT_MIFARE_CLT_PWR_STATE "DEFAULT_MIFARE_CLT_PWR_STATE"
+#define NAME_DEFAULT_T4TNFCEE_AID_POWER_STATE "DEFAULT_T4TNFCEE_AID_POWER_STATE"
+#define NAME_FORWARD_FUNCTIONALITY_ENABLE "FORWARD_FUNCTIONALITY_ENABLE"
+#define NAME_DEFAULT_FELICA_CLT_PWR_STATE "DEFAULT_FELICA_CLT_PWR_STATE"
+#define NAME_CHECK_DEFAULT_PROTO_SE_ID "NXP_CHECK_DEFAULT_PROTO_SE_ID"
+#define NAME_NXP_DEFAULT_UICC2_SELECT "NXP_DEFAULT_UICC2_SELECT"
+#define NAME_NXP_T4T_NFCEE_ENABLE "NXP_T4T_NFCEE_ENABLE"
+#define NAME_NXP_SMB_TRANSCEIVE_TIMEOUT "NXP_SMB_TRANSCEIVE_TIMEOUT"
+#define NAME_NXP_SMB_ERROR_RETRY "NXP_SMB_ERROR_RETRY"
+#define NAME_DEFAULT_GSMA_PWR_STATE "DEFAULT_GSMA_PWR_STATE"
+#define NAME_NXP_NFC_SE_TERMINAL_NUM "NXP_NFC_SE_TERMINAL_NUM"
+#define NAME_NXP_POLL_FOR_EFD_TIMEDELAY "NXP_POLL_FOR_EFD_TIMEDELAY"
+#define NAME_NXP_NFCC_MERGE_SAK_ENABLE "NXP_NFCC_MERGE_SAK_ENABLE"
+#define NAME_NXP_STAG_TIMEOUT_CFG "NXP_STAG_TIMEOUT_CFG"
+#define NAME_NXP_RF_FILE_VERSION_INFO "NXP_RF_FILE_VERSION_INFO"
+#define NAME_RF_STORAGE "RF_STORAGE"
+#define NAME_FW_STORAGE "FW_STORAGE"
+#define NAME_NXP_CORE_CONF "NXP_CORE_CONF"
+#define NAME_NXP_GUARD_TIMER_VALUE "NXP_GUARD_TIMER_VALUE"
+#define NAME_NXP_PROP_RESET_EMVCO_CMD "NXP_PROP_RESET_EMVCO_CMD"
+#define NAME_NFA_CONFIG_FORMAT "NFA_CONFIG_FORMAT"
+#define NAME_NXP_DISCONNECT_TAG_IN_SCRN_OFF "NXP_DISCONNECT_TAG_IN_SCRN_OFF"
+#define NAME_NXP_ENABLE_DISABLE_LOGS "NXP_ENABLE_DISABLE_LOGS"
+#define NAME_NXP_ENABLE_DISABLE_STANBY "NXP_ENABLE_DISABLE_STANBY"
+#define NAME_NXP_ENABLE_DISABLE_LPCD "NXP_ENABLE_DISABLE_LPCD"
+#define NAME_NXP_TRANSPORT "NXP_TRANSPORT"
+#define NAME_NXP_GET_HW_INFO_LOG "NXP_GET_HW_INFO_LOG"
+#define NAME_NXP_ISO_DEP_MERGE_SAK "NXP_ISO_DEP_MERGE_SAK"
+#define NAME_NXP_T4T_NDEF_NFCEE_AID "NXP_T4T_NDEF_NFCEE_AID"
+#define NAME_NXP_NON_STD_CARD_TIMEDIFF "NXP_NON_STD_CARD_TIMEDIFF"
+#define NAME_NXP_SRD_TIMEOUT "NXP_SRD_TIMEOUT"
+#define NAME_NXP_UICC_ETSI_SUPPORT "NXP_UICC_ETSI_SUPPORT"
+#define NAME_NXP_MINIMAL_FW_VERSION "NXP_MINIMAL_FW_VERSION"
+#define NAME_NXP_NFCC_RECOVERY_SUPPORT "NXP_NFCC_RECOVERY_SUPPORT"
+#define NAME_NXP_P2P_DISC_NTF_TIMEOUT "NXP_P2P_DISC_NTF_TIMEOUT"
+#define NAME_NXP_RESTART_RF_FOR_NFCEE_RECOVERY                                 \
+  "NXP_RESTART_RF_FOR_NFCEE_RECOVERY"
+#define NAME_NXP_PROP_CE_ACTION_NTF "NXP_PROP_CE_ACTION_NTF"
+#define NAME_NXP_AGC_DEBUG_ENABLE "NXP_AGC_DEBUG_ENABLE"
+#define NAME_NXP_EXTENDED_FIELD_DETECT_MODE "NXP_EXTENDED_FIELD_DETECT_MODE"
+#define NAME_NXP_MIFARE_NACK_TO_RATS_ENABLE "NXP_MIFARE_NACK_TO_RATS_ENABLE"
+#endif
+/* default configuration */
+#define default_storage_location "/data/vendor/nfc"
+#define NAME_NXP_AUTH_TIMEOUT_CFG "NXP_AUTH_TIMEOUT_CFG"
+#endif
diff --git a/pn72xx/halimpl/utils/phNxpNciHal_utils.cc b/pn72xx/halimpl/utils/phNxpNciHal_utils.cc
new file mode 100644
index 00000000..348426b4
--- /dev/null
+++ b/pn72xx/halimpl/utils/phNxpNciHal_utils.cc
@@ -0,0 +1,498 @@
+/*
+ *
+ *  Copyright 2013-2021,2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#include <errno.h>
+#include <log/log.h>
+#include <pthread.h>
+
+#include "phNxpNciHal_extOperations.h"
+#include <phNxpLog.h>
+#include <phNxpNciHal.h>
+#include <phNxpNciHal_utils.h>
+
+extern phNxpNciHal_Control_t nxpncihal_ctrl;
+/*********************** Link list functions **********************************/
+
+/*******************************************************************************
+**
+** Function         listInit
+**
+** Description      List initialization
+**
+** Returns          1, if list initialized, 0 otherwise
+**
+*******************************************************************************/
+int listInit(struct listHead *pList) {
+  pList->pFirst = NULL;
+  if (pthread_mutex_init(&pList->mutex, NULL) != 0) {
+    NXPLOG_NCIHAL_E("Mutex creation failed (errno=0x%08x)", errno);
+    return 0;
+  }
+
+  return 1;
+}
+
+/*******************************************************************************
+**
+** Function         listDestroy
+**
+** Description      List destruction
+**
+** Returns          1, if list destroyed, 0 if failed
+**
+*******************************************************************************/
+int listDestroy(struct listHead *pList) {
+  int bListNotEmpty = 1;
+  while (bListNotEmpty) {
+    bListNotEmpty = listGetAndRemoveNext(pList, NULL);
+  }
+
+  if (pthread_mutex_destroy(&pList->mutex) == -1) {
+    NXPLOG_NCIHAL_E("Mutex destruction failed (errno=0x%08x)", errno);
+    return 0;
+  }
+
+  return 1;
+}
+
+/*******************************************************************************
+**
+** Function         listAdd
+**
+** Description      Add a node to the list
+**
+** Returns          1, if added, 0 if otherwise
+**
+*******************************************************************************/
+int listAdd(struct listHead *pList, void *pData) {
+  struct listNode *pNode;
+  struct listNode *pLastNode;
+  int result;
+
+  /* Create node */
+  pNode = (struct listNode *)malloc(sizeof(struct listNode));
+  if (pNode == NULL) {
+    result = 0;
+    NXPLOG_NCIHAL_E("Failed to malloc");
+    goto clean_and_return;
+  }
+  pNode->pData = pData;
+  pNode->pNext = NULL;
+  pthread_mutex_lock(&pList->mutex);
+
+  /* Add the node to the list */
+  if (pList->pFirst == NULL) {
+    /* Set the node as the head */
+    pList->pFirst = pNode;
+  } else {
+    /* Seek to the end of the list */
+    pLastNode = pList->pFirst;
+    while (pLastNode->pNext != NULL) {
+      pLastNode = pLastNode->pNext;
+    }
+
+    /* Add the node to the current list */
+    pLastNode->pNext = pNode;
+  }
+
+  result = 1;
+
+clean_and_return:
+  pthread_mutex_unlock(&pList->mutex);
+  return result;
+}
+
+/*******************************************************************************
+**
+** Function         listRemove
+**
+** Description      Remove node from the list
+**
+** Returns          1, if removed, 0 if otherwise
+**
+*******************************************************************************/
+int listRemove(struct listHead *pList, void *pData) {
+  struct listNode *pNode;
+  struct listNode *pRemovedNode;
+  int result;
+
+  pthread_mutex_lock(&pList->mutex);
+
+  if (pList->pFirst == NULL) {
+    /* Empty list */
+    NXPLOG_NCIHAL_D("Failed to deallocate (list empty)");
+    result = 0;
+    goto clean_and_return;
+  }
+
+  pNode = pList->pFirst;
+  if (pList->pFirst->pData == pData) {
+    /* Get the removed node */
+    pRemovedNode = pNode;
+
+    /* Remove the first node */
+    pList->pFirst = pList->pFirst->pNext;
+  } else {
+    while (pNode->pNext != NULL) {
+      if (pNode->pNext->pData == pData) {
+        /* Node found ! */
+        break;
+      }
+      pNode = pNode->pNext;
+    }
+
+    if (pNode->pNext == NULL) {
+      /* Node not found */
+      result = 0;
+      NXPLOG_NCIHAL_E("Failed to deallocate (not found %8p)", pData);
+      goto clean_and_return;
+    }
+
+    /* Get the removed node */
+    pRemovedNode = pNode->pNext;
+
+    /* Remove the node from the list */
+    pNode->pNext = pNode->pNext->pNext;
+  }
+
+  /* Deallocate the node */
+  free(pRemovedNode);
+
+  result = 1;
+
+clean_and_return:
+  pthread_mutex_unlock(&pList->mutex);
+  return result;
+}
+
+/*******************************************************************************
+**
+** Function         listGetAndRemoveNext
+**
+** Description      Get next node on the list and remove it
+**
+** Returns          1, if successful, 0 if otherwise
+**
+*******************************************************************************/
+int listGetAndRemoveNext(struct listHead *pList, void **ppData) {
+  struct listNode *pNode;
+  int result;
+
+  pthread_mutex_lock(&pList->mutex);
+
+  if (pList->pFirst == NULL) {
+    /* Empty list */
+    NXPLOG_NCIHAL_D("Failed to deallocate (list empty)");
+    result = 0;
+    goto clean_and_return;
+  }
+
+  /* Work on the first node */
+  pNode = pList->pFirst;
+
+  /* Return the data */
+  if (ppData != NULL) {
+    *ppData = pNode->pData;
+  }
+
+  /* Remove and deallocate the node */
+  pList->pFirst = pNode->pNext;
+  free(pNode);
+
+  result = 1;
+
+clean_and_return:
+  listDump(pList);
+  pthread_mutex_unlock(&pList->mutex);
+  return result;
+}
+
+/*******************************************************************************
+**
+** Function         listDump
+**
+** Description      Dump list information
+**
+** Returns          None
+**
+*******************************************************************************/
+void listDump(struct listHead *pList) {
+  struct listNode *pNode = pList->pFirst;
+
+  NXPLOG_NCIHAL_D("Node dump:");
+  while (pNode != NULL) {
+    NXPLOG_NCIHAL_D("- %8p (%8p)", pNode, pNode->pData);
+    pNode = pNode->pNext;
+  }
+
+  return;
+}
+
+/* END Linked list source code */
+
+/****************** Semaphore and mutex helper functions **********************/
+
+static phNxpNciHal_Monitor_t *nxpncihal_monitor = NULL;
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_init_monitor
+**
+** Description      Initialize the semaphore monitor
+**
+** Returns          Pointer to monitor, otherwise NULL if failed
+**
+*******************************************************************************/
+phNxpNciHal_Monitor_t *phNxpNciHal_init_monitor(void) {
+  NXPLOG_NCIHAL_D("Entering phNxpNciHal_init_monitor");
+
+  if (nxpncihal_monitor == NULL) {
+    nxpncihal_monitor =
+        (phNxpNciHal_Monitor_t *)malloc(sizeof(phNxpNciHal_Monitor_t));
+  }
+
+  if (nxpncihal_monitor != NULL) {
+    memset(nxpncihal_monitor, 0x00, sizeof(phNxpNciHal_Monitor_t));
+
+    if (pthread_mutex_init(&nxpncihal_monitor->reentrance_mutex, NULL) != 0) {
+      NXPLOG_NCIHAL_E("reentrance_mutex creation returned 0x%08x", errno);
+      goto clean_and_return;
+    }
+
+    if (pthread_mutex_init(&nxpncihal_monitor->concurrency_mutex, NULL) != 0) {
+      NXPLOG_NCIHAL_E("concurrency_mutex creation returned 0x%08x", errno);
+      pthread_mutex_destroy(&nxpncihal_monitor->reentrance_mutex);
+      goto clean_and_return;
+    }
+
+    if (listInit(&nxpncihal_monitor->sem_list) != 1) {
+      NXPLOG_NCIHAL_E("Semaphore List creation failed");
+      pthread_mutex_destroy(&nxpncihal_monitor->concurrency_mutex);
+      pthread_mutex_destroy(&nxpncihal_monitor->reentrance_mutex);
+      goto clean_and_return;
+    }
+  } else {
+    NXPLOG_NCIHAL_E("nxphal_monitor creation failed");
+    goto clean_and_return;
+  }
+
+  NXPLOG_NCIHAL_D("Returning with SUCCESS");
+
+  return nxpncihal_monitor;
+
+clean_and_return:
+  NXPLOG_NCIHAL_D("Returning with FAILURE");
+
+  if (nxpncihal_monitor != NULL) {
+    free(nxpncihal_monitor);
+    nxpncihal_monitor = NULL;
+  }
+
+  return NULL;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_cleanup_monitor
+**
+** Description      Clean up semaphore monitor
+**
+** Returns          None
+**
+*******************************************************************************/
+void phNxpNciHal_cleanup_monitor(void) {
+  if (nxpncihal_monitor != NULL) {
+    pthread_mutex_destroy(&nxpncihal_monitor->concurrency_mutex);
+    REENTRANCE_UNLOCK();
+    pthread_mutex_destroy(&nxpncihal_monitor->reentrance_mutex);
+    phNxpNciHal_releaseall_cb_data();
+    listDestroy(&nxpncihal_monitor->sem_list);
+  }
+
+  free(nxpncihal_monitor);
+  nxpncihal_monitor = NULL;
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_get_monitor
+**
+** Description      Get monitor
+**
+** Returns          Pointer to monitor
+**
+*******************************************************************************/
+phNxpNciHal_Monitor_t *phNxpNciHal_get_monitor(void) {
+  if (nxpncihal_monitor == NULL) {
+    NXPLOG_NCIHAL_E("nxpncihal_monitor is null");
+  }
+  return nxpncihal_monitor;
+}
+
+/* Initialize the callback data */
+NFCSTATUS phNxpNciHal_init_cb_data(phNxpNciHal_Sem_t *pCallbackData,
+                                   void *pContext) {
+  /* Create semaphore */
+  if (sem_init(&pCallbackData->sem, 0, 0) == -1) {
+    NXPLOG_NCIHAL_E("Semaphore creation failed (errno=0x%08x)", errno);
+    return NFCSTATUS_FAILED;
+  }
+
+  /* Set default status value */
+  pCallbackData->status = NFCSTATUS_FAILED;
+
+  /* Copy the context */
+  pCallbackData->pContext = pContext;
+
+  /* Add to active semaphore list */
+  if (listAdd(&phNxpNciHal_get_monitor()->sem_list, pCallbackData) != 1) {
+    NXPLOG_NCIHAL_E("Failed to add the semaphore to the list");
+  }
+
+  return NFCSTATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_cleanup_cb_data
+**
+** Description      Clean up callback data
+**
+** Returns          None
+**
+*******************************************************************************/
+void phNxpNciHal_cleanup_cb_data(phNxpNciHal_Sem_t *pCallbackData) {
+  /* Destroy semaphore */
+  if (sem_destroy(&pCallbackData->sem)) {
+    NXPLOG_NCIHAL_E("phNxpNciHal_cleanup_cb_data: Failed to destroy semaphore "
+                    "(errno=0x%08x)",
+                    errno);
+  }
+
+  /* Remove from active semaphore list */
+  if (listRemove(&phNxpNciHal_get_monitor()->sem_list, pCallbackData) != 1) {
+    NXPLOG_NCIHAL_E(
+        "phNxpNciHal_cleanup_cb_data: Failed to remove semaphore from the "
+        "list");
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_releaseall_cb_data
+**
+** Description      Release all callback data
+**
+** Returns          None
+**
+*******************************************************************************/
+void phNxpNciHal_releaseall_cb_data(void) {
+  phNxpNciHal_Sem_t *pCallbackData;
+
+  while (listGetAndRemoveNext(&phNxpNciHal_get_monitor()->sem_list,
+                              (void **)&pCallbackData)) {
+    pCallbackData->status = NFCSTATUS_FAILED;
+    sem_post(&pCallbackData->sem);
+  }
+
+  return;
+}
+
+/* END Semaphore and mutex helper functions */
+
+/**************************** Other functions *********************************/
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_print_packet
+**
+** Description      Print packet
+**
+** Returns          None
+**
+*******************************************************************************/
+void phNxpNciHal_print_packet(const char *pString, const uint8_t *p_data,
+                              uint16_t len) {
+  uint32_t i;
+#if (NXP_EXTNS == TRUE)
+  char *print_buffer = (char *)calloc((len * 3 + 1), sizeof(char));
+  if (NULL != print_buffer) {
+#else
+  char print_buffer[len * 3 + 1];
+
+  memset(print_buffer, 0, sizeof(print_buffer));
+#endif
+    for (i = 0; i < len; i++) {
+      snprintf(&print_buffer[i * 2], 3, "%02X", p_data[i]);
+    }
+    if (0 == memcmp(pString, "SEND", 0x04)) {
+      NXPLOG_NCIX_D("len = %3d > %s", len, print_buffer);
+    } else if (0 == memcmp(pString, "RECV", 0x04)) {
+      NXPLOG_NCIR_D("len = %3d > %s", len, print_buffer);
+    } else if (0 == memcmp(pString, "DEBUG", 0x05)) {
+      NXPLOG_NCIHAL_D(" Debug Info > len = %3d > %s", len, print_buffer);
+    }
+#if (NXP_EXTNS == TRUE)
+    free(print_buffer);
+  } else {
+    NXPLOG_NCIX_E("\nphNxpNciHal_print_packet:Failed to Allocate memory\n");
+  }
+#endif
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpNciHal_emergency_recovery
+**
+** Description      Abort the process in case of ESE_OVER_TEMP_ERROR, FW Assert,
+*Watchdog Reset,
+**                  Input Clock lost and unrecoverable error.
+**                  Ignore the other status.
+**
+** Returns          None
+**
+*******************************************************************************/
+
+void phNxpNciHal_emergency_recovery(uint8_t status) {
+  NXPLOG_NCIHAL_D("%s: %d", __func__, status);
+
+  switch (status) {
+  case NCI2_0_CORE_RESET_TRIGGER_TYPE_OVER_TEMPERATURE:
+  case CORE_RESET_TRIGGER_TYPE_FW_ASSERT:
+  case CORE_RESET_TRIGGER_TYPE_WATCHDOG_RESET:
+  case CORE_RESET_TRIGGER_TYPE_INPUT_CLOCK_LOST:
+  case CORE_RESET_TRIGGER_TYPE_UNRECOVERABLE_ERROR: {
+    NXPLOG_NCIHAL_E("abort()");
+    abort();
+  }
+  case CORE_RESET_TRIGGER_TYPE_POWERED_ON: {
+    if (nxpncihal_ctrl.hal_open_status == true) {
+      NXPLOG_NCIHAL_E("abort()");
+      abort();
+    }
+  } break;
+  default:
+    NXPLOG_NCIHAL_E("%s: Core reset with Invalid status : %d ", __func__,
+                    status);
+    break;
+  }
+}
diff --git a/pn72xx/halimpl/utils/phNxpNciHal_utils.h b/pn72xx/halimpl/utils/phNxpNciHal_utils.h
new file mode 100644
index 00000000..4e43750d
--- /dev/null
+++ b/pn72xx/halimpl/utils/phNxpNciHal_utils.h
@@ -0,0 +1,111 @@
+/*
+ *
+ *  Copyright 2013-2018, 2021,2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef _PHNXPNCIHAL_UTILS_H_
+#define _PHNXPNCIHAL_UTILS_H_
+
+#include <assert.h>
+#include <errno.h>
+#include <phNfcStatus.h>
+#include <pthread.h>
+#include <semaphore.h>
+
+/********************* Definitions and structures *****************************/
+
+/* List structures */
+struct listNode {
+  void *pData;
+  struct listNode *pNext;
+};
+
+struct listHead {
+  struct listNode *pFirst;
+  pthread_mutex_t mutex;
+};
+
+/* Semaphore handling structure */
+typedef struct phNxpNciHal_Sem {
+  /* Semaphore used to wait for callback */
+  sem_t sem;
+
+  /* Used to store the status sent by the callback */
+  NFCSTATUS status;
+
+  /* Used to provide a local context to the callback */
+  void *pContext;
+
+} phNxpNciHal_Sem_t;
+
+/* Semaphore helper macros */
+#define SEM_WAIT(cb_data)                                                      \
+  ((sem_wait(&((cb_data).sem)) == 0) ? 0                                       \
+   : (errno == EINTR)                ? sem_wait(&((cb_data).sem))              \
+                                     : -1)
+
+#define SEM_POST(p_cb_data) sem_post(&((p_cb_data)->sem))
+
+/* Semaphore and mutex monitor */
+typedef struct phNxpNciHal_Monitor {
+  /* Mutex protecting native library against reentrance */
+  pthread_mutex_t reentrance_mutex;
+
+  /* Mutex protecting native library against concurrency */
+  pthread_mutex_t concurrency_mutex;
+
+  /* List used to track pending semaphores waiting for callback */
+  struct listHead sem_list;
+
+} phNxpNciHal_Monitor_t;
+
+/************************ Exposed functions ***********************************/
+/* List functions */
+int listInit(struct listHead *pList);
+int listDestroy(struct listHead *pList);
+int listAdd(struct listHead *pList, void *pData);
+int listRemove(struct listHead *pList, void *pData);
+int listGetAndRemoveNext(struct listHead *pList, void **ppData);
+void listDump(struct listHead *pList);
+
+/* NXP NCI HAL utility functions */
+phNxpNciHal_Monitor_t *phNxpNciHal_init_monitor(void);
+void phNxpNciHal_cleanup_monitor(void);
+phNxpNciHal_Monitor_t *phNxpNciHal_get_monitor(void);
+NFCSTATUS phNxpNciHal_init_cb_data(phNxpNciHal_Sem_t *pCallbackData,
+                                   void *pContext);
+void phNxpNciHal_cleanup_cb_data(phNxpNciHal_Sem_t *pCallbackData);
+void phNxpNciHal_releaseall_cb_data(void);
+void phNxpNciHal_print_packet(const char *pString, const uint8_t *p_data,
+                              uint16_t len);
+void phNxpNciHal_emergency_recovery(uint8_t status);
+
+/* Lock unlock helper macros */
+/* Lock unlock helper macros */
+#define REENTRANCE_LOCK()                                                      \
+  if (phNxpNciHal_get_monitor())                                               \
+  pthread_mutex_lock(&phNxpNciHal_get_monitor()->reentrance_mutex)
+#define REENTRANCE_UNLOCK()                                                    \
+  if (phNxpNciHal_get_monitor())                                               \
+  pthread_mutex_unlock(&phNxpNciHal_get_monitor()->reentrance_mutex)
+#define CONCURRENCY_LOCK()                                                     \
+  if (phNxpNciHal_get_monitor())                                               \
+  pthread_mutex_lock(&phNxpNciHal_get_monitor()->concurrency_mutex)
+#define CONCURRENCY_UNLOCK()                                                   \
+  if (phNxpNciHal_get_monitor())                                               \
+  pthread_mutex_unlock(&phNxpNciHal_get_monitor()->concurrency_mutex)
+
+#endif /* _PHNXPNCIHAL_UTILS_H_ */
diff --git a/pn72xx/halimpl/utils/sparse_crc32.cc b/pn72xx/halimpl/utils/sparse_crc32.cc
new file mode 100644
index 00000000..ac243d24
--- /dev/null
+++ b/pn72xx/halimpl/utils/sparse_crc32.cc
@@ -0,0 +1,108 @@
+/*-
+ *  COPYRIGHT (C) 1986 Gary S. Brown.  You may use this program, or
+ *  code or tables extracted from it, as desired without restriction.
+ */
+
+/*
+ *  First, the polynomial itself and its table of feedback terms.  The
+ *  polynomial is
+ *  X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0
+ *
+ *  Note that we take it "backwards" and put the highest-order term in
+ *  the lowest-order bit.  The X^32 term is "implied"; the LSB is the
+ *  X^31 term, etc.  The X^0 term (usually shown as "+1") results in
+ *  the MSB being 1
+ *
+ *  Note that the usual hardware shift register implementation, which
+ *  is what we're using (we're merely optimizing it by doing eight-bit
+ *  chunks at a time) shifts bits into the lowest-order term.  In our
+ *  implementation, that means shifting towards the right.  Why do we
+ *  do it this way?  Because the calculated CRC must be transmitted in
+ *  order from highest-order term to lowest-order term.  UARTs transmit
+ *  characters in order from LSB to MSB.  By storing the CRC this way
+ *  we hand it to the UART in the order low-byte to high-byte; the UART
+ *  sends each low-bit to hight-bit; and the result is transmission bit
+ *  by bit from highest- to lowest-order term without requiring any bit
+ *  shuffling on our part.  Reception works similarly
+ *
+ *  The feedback terms table consists of 256, 32-bit entries.  Notes
+ *
+ *      The table can be generated at runtime if desired; code to do so
+ *      is shown later.  It might not be obvious, but the feedback
+ *      terms simply represent the results of eight shift/xor opera
+ *      tions for all combinations of data and CRC register values
+ *
+ *      The values must be right-shifted by eight bits by the "updcrc
+ *      logic; the shift must be unsigned (bring in zeroes).  On some
+ *      hardware you could probably optimize the shift in assembler by
+ *      using byte-swap instructions
+ *      polynomial $edb88320
+ *
+ *
+ * CRC32 code derived from work by Gary S. Brown.
+ */
+
+/* Code taken from FreeBSD 8 */
+#include <stdint.h>
+
+static uint32_t crc32_tab[] = {
+    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
+    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
+    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
+    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
+    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
+    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
+    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
+    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
+    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
+    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
+    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
+    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
+    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
+    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
+    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
+    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
+    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
+    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
+    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
+    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
+    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
+    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
+    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
+    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
+    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
+    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
+    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
+    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
+    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
+    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
+    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
+    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
+    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
+    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
+    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
+    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
+    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
+    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
+    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
+    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d};
+
+/*
+ * A function that calculates the CRC-32 based on the table above is
+ * given below for documentation purposes. An equivalent implementation
+ * of this function that's actually used in the kernel can be found
+ * in sys/libkern.h, where it can be inlined.
+ */
+
+uint32_t sparse_crc32(uint32_t crc_in, const void *buf, int size) {
+  const uint8_t *p = (const uint8_t *)buf;
+  uint32_t crc;
+
+  crc = crc_in ^ ~0U;
+  while (size--)
+    crc = crc32_tab[(crc ^ *p++) & 0xFF] ^ (crc >> 8);
+  return crc ^ ~0U;
+}
diff --git a/pn72xx/halimpl/utils/sparse_crc32.h b/pn72xx/halimpl/utils/sparse_crc32.h
new file mode 100644
index 00000000..d788a202
--- /dev/null
+++ b/pn72xx/halimpl/utils/sparse_crc32.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _LIBSPARSE_SPARSE_CRC32_H_
+#define _LIBSPARSE_SPARSE_CRC32_H_
+
+#include <stdint.h>
+
+uint32_t sparse_crc32(uint32_t crc, const void *buf, int size);
+
+#endif
