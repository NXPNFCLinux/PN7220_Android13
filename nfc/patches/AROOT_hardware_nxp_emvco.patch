diff --git a/Android.bp b/Android.bp
new file mode 100644
index 0000000..f8f7aab
--- /dev/null
+++ b/Android.bp
@@ -0,0 +1,4 @@
+subdirs = [
+    "*"
+]
+
diff --git a/SCR.txt b/SCR.txt
new file mode 100644
index 0000000..77a81ed
--- /dev/null
+++ b/SCR.txt
@@ -0,0 +1,49 @@
+NXP Software Content Register
+Outgoing License: LA_OPT_NXP_Software_License v33 Jan 2022
+License File:     LA_OPT_NXP_Software_License.pdf
+â€‹
+--------------------------------------------
+Outgoing License:          Apache Version 2.0
+License Files:             COPYING
+Package Category:          NFC Middleware
+Type of content:           Source
+Description and comments:  NCI based NFC stack
+Release Location:          
+Origin:                    The Android Open Source Project (Apache-2.0) - https://source.android.com/
+                           NXP (Apache-2.0)
+--------------------------------------------
+Outgoing License:          Apache Version 2.0
+License Files:             COPYING
+Package Category:          NFC Middleware
+Type of content:           Source
+Description and comments:  JNI NCI NFC
+Release Location:          
+Origin:                    The Android Open Source Project (Apache-2.0) - https://source.android.com/
+                           NXP (Apache-2.0)
+--------------------------------------------
+Outgoing License:          Apache Version 2.0
+License Files:             COPYING
+Package Category:          NFC SE Middleware
+Type of content:           Source
+Description and comments:  Hardware abstraction layer for NXP specific controllers
+Release Location:          
+Origin:                    The Android Open Source Project (Apache-2.0) - https://source.android.com/
+                           The Android Open Source Project (MIT) - https://source.android.com/
+                           NXP (Apache-2.0)
+--------------------------------------------
+Outgoing License:          Apache Version 2.0
+License Files:             COPYING
+Package Category:          NFC Middleware and Test Application
+Type of content:           Source
+Description and comments:  Device Test Application (DTA) used for NFC Forum testing
+Release Location:          https://github.com/NXPNFCProject/NXPAndroidDTA
+Origin:                    NXP (Apache-2.0)
+--------------------------------------------
+Outgoing License:          LA_OPT_NXP_Software_License
+License File:              COPYING
+Package Category:          NFC Firmware
+Type of content:           Binariy
+Description and comments:  NFC controller firmware
+Release Location:          
+Origin:                    NXP (proprietary)
+--------------------------------------------
\ No newline at end of file
diff --git a/aidl/Android.bp b/aidl/Android.bp
new file mode 100644
index 0000000..a6fb43e
--- /dev/null
+++ b/aidl/Android.bp
@@ -0,0 +1,21 @@
+aidl_interface {
+    name: "android.hardware.emvco",
+    vendor_available: true,
+    srcs: ["android/hardware/emvco/*.aidl"],
+    stability: "vintf",
+    backend: {
+        ndk: {
+            vndk: {
+                enabled: true,
+            },
+        },
+        java: {
+            sdk_version: "module_current",
+            enabled: true,
+        },
+        cpp: {
+            enabled: false,
+        },
+    },
+    versions: ["1"],
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/1/.hash b/aidl/aidl_api/android.hardware.emvco/1/.hash
new file mode 100755
index 0000000..47e258f
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/1/.hash
@@ -0,0 +1 @@
+398a616108b08affcf3b83a9ee0cb734c9d45af9
diff --git a/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/ConfigType.aidl b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/ConfigType.aidl
new file mode 100644
index 0000000..042879e
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/ConfigType.aidl
@@ -0,0 +1,40 @@
+/******************************************************************************
+ *
+ *  Copyright 2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@Backing(type="int") @VintfStability
+enum ConfigType {
+  POLL_PROFILE_SEL = 0,
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/DeactivationType.aidl b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/DeactivationType.aidl
new file mode 100644
index 0000000..3b56cbf
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/DeactivationType.aidl
@@ -0,0 +1,41 @@
+/******************************************************************************
+ *
+ *  Copyright 2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@Backing(type="int") @VintfStability
+enum DeactivationType {
+  IDLE = 0,
+  DISCOVER = 3,
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/DiscoveryMode.aidl b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/DiscoveryMode.aidl
new file mode 100755
index 0000000..949da6d
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/DiscoveryMode.aidl
@@ -0,0 +1,42 @@
+/******************************************************************************
+ *
+ *  Copyright 2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@Backing(type="int") @VintfStability
+enum DiscoveryMode {
+  NFC = 1,
+  EMVCO = 2,
+  UN_KNOWN = 3,
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/EmvcoEvent.aidl b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/EmvcoEvent.aidl
new file mode 100644
index 0000000..e104270
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/EmvcoEvent.aidl
@@ -0,0 +1,46 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@Backing(type="int") @VintfStability
+enum EmvcoEvent {
+  EMVCO_OPEN_CHNL_CPLT_EVT = 0,
+  EMVCO_OPEN_CHNL_ERROR_EVT = 1,
+  EMVCO_CLOSE_CHNL_CPLT_EVT = 2,
+  EMVCO_POOLING_START_EVT = 3,
+  EMVCO_POLLING_STARTED_EVT = 4,
+  EMVCO_POLLING_STOP_EVT = 5,
+  EMVCO_UN_SUPPORTED_CARD_EVT = 6,
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/EmvcoStatus.aidl b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/EmvcoStatus.aidl
new file mode 100644
index 0000000..9b899b5
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/EmvcoStatus.aidl
@@ -0,0 +1,44 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@Backing(type="int") @VintfStability
+enum EmvcoStatus {
+  EMVCO_STATUS_OK = 0,
+  EMVCO_STATUS_INVALID_PARAMETER = 1,
+  EMVCO_STATUS_INVALID_STATE = 11,
+  EMVCO_STATUS_FEATURE_NOT_SUPPORTED = 33,
+  EMVCO_STATUS_FAILED = 255,
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/IEmvco.aidl b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/IEmvco.aidl
new file mode 100644
index 0000000..527f936
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/IEmvco.aidl
@@ -0,0 +1,42 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@VintfStability
+interface IEmvco {
+  android.hardware.emvco.IEmvcoProfileDiscovery getEmvcoProfileDiscoveryInterface();
+  android.hardware.emvco.IEmvcoContactlessCard getEmvcoContactlessCard();
+  android.hardware.emvco.IEmvcoContactCard getEmvcoContactCard();
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/IEmvcoClientCallback.aidl b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/IEmvcoClientCallback.aidl
new file mode 100644
index 0000000..2693151
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/IEmvcoClientCallback.aidl
@@ -0,0 +1,41 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@VintfStability
+interface IEmvcoClientCallback {
+  oneway void sendData(in byte[] data);
+  oneway void sendEvent(in android.hardware.emvco.EmvcoEvent event, in android.hardware.emvco.EmvcoStatus status);
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/IEmvcoContactCard.aidl b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/IEmvcoContactCard.aidl
new file mode 100644
index 0000000..b7847d6
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/IEmvcoContactCard.aidl
@@ -0,0 +1,40 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@VintfStability
+interface IEmvcoContactCard {
+  boolean registerEMVCoEventListener(in android.hardware.emvco.IEmvcoClientCallback clientCallback);
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/IEmvcoContactlessCard.aidl b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/IEmvcoContactlessCard.aidl
new file mode 100644
index 0000000..4801683
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/IEmvcoContactlessCard.aidl
@@ -0,0 +1,43 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@VintfStability
+interface IEmvcoContactlessCard {
+  boolean registerEMVCoEventListener(in android.hardware.emvco.IEmvcoClientCallback clientCallback);
+  int transceive(in byte[] in_data);
+  void setEMVCoMode(in byte in_config, boolean in_isStartEMVCo);
+  android.hardware.emvco.EmvcoStatus stopRFDisovery(in android.hardware.emvco.DeactivationType deactivationType);
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/IEmvcoProfileDiscovery.aidl b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/IEmvcoProfileDiscovery.aidl
new file mode 100644
index 0000000..f240a82
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/IEmvcoProfileDiscovery.aidl
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@VintfStability
+interface IEmvcoProfileDiscovery {
+  boolean registerEMVCoEventListener(in android.hardware.emvco.IEmvcoClientCallback emvcoClientCallback);
+  void setEMVCoMode(in byte config, boolean isStartEMVCo);
+  void onNfcStateChange(android.hardware.emvco.NfcState nfcState);
+  boolean registerNFCStateChangeCallback(in android.hardware.emvco.INfcStateChangeRequestCallback nfcStateChangeCallback);
+  android.hardware.emvco.DiscoveryMode getCurrentDiscoveryMode();
+  android.hardware.emvco.EmvcoStatus setLed(in android.hardware.emvco.LedControl ledControl);
+  android.hardware.emvco.EmvcoStatus setByteConfig(in android.hardware.emvco.ConfigType type, in int length, in byte value);
+  android.hardware.emvco.EmvcoStatus setByteArrayConfig(in android.hardware.emvco.ConfigType type, in int length, in byte[] value);
+  android.hardware.emvco.EmvcoStatus setStringConfig(in android.hardware.emvco.ConfigType type, in int length, in String value);
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/INfcStateChangeRequestCallback.aidl b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/INfcStateChangeRequestCallback.aidl
new file mode 100644
index 0000000..c693c7a
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/INfcStateChangeRequestCallback.aidl
@@ -0,0 +1,40 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@VintfStability
+interface INfcStateChangeRequestCallback {
+  oneway void enableNfc(boolean turnOn);
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/LedControl.aidl b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/LedControl.aidl
new file mode 100644
index 0000000..db02f28
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/LedControl.aidl
@@ -0,0 +1,43 @@
+/******************************************************************************
+ *
+ *  Copyright 2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@Backing(type="int") @VintfStability
+enum LedControl {
+  RED_LED_OFF = 0,
+  RED_LED_ON = 1,
+  GREEN_LED_OFF = 2,
+  GREEN_LED_ON = 3,
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/NfcState.aidl b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/NfcState.aidl
new file mode 100644
index 0000000..efb3dcc
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/1/android/hardware/emvco/NfcState.aidl
@@ -0,0 +1,43 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@Backing(type="int") @VintfStability
+enum NfcState {
+  STATE_OFF = 1,
+  STATE_TURNING_ON = 2,
+  STATE_ON = 3,
+  STATE_TURNING_OFF = 4,
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/ConfigType.aidl b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/ConfigType.aidl
new file mode 100644
index 0000000..042879e
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/ConfigType.aidl
@@ -0,0 +1,40 @@
+/******************************************************************************
+ *
+ *  Copyright 2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@Backing(type="int") @VintfStability
+enum ConfigType {
+  POLL_PROFILE_SEL = 0,
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/DeactivationType.aidl b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/DeactivationType.aidl
new file mode 100644
index 0000000..3b56cbf
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/DeactivationType.aidl
@@ -0,0 +1,41 @@
+/******************************************************************************
+ *
+ *  Copyright 2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@Backing(type="int") @VintfStability
+enum DeactivationType {
+  IDLE = 0,
+  DISCOVER = 3,
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/DiscoveryMode.aidl b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/DiscoveryMode.aidl
new file mode 100755
index 0000000..949da6d
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/DiscoveryMode.aidl
@@ -0,0 +1,42 @@
+/******************************************************************************
+ *
+ *  Copyright 2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@Backing(type="int") @VintfStability
+enum DiscoveryMode {
+  NFC = 1,
+  EMVCO = 2,
+  UN_KNOWN = 3,
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/EmvcoEvent.aidl b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/EmvcoEvent.aidl
new file mode 100644
index 0000000..e104270
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/EmvcoEvent.aidl
@@ -0,0 +1,46 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@Backing(type="int") @VintfStability
+enum EmvcoEvent {
+  EMVCO_OPEN_CHNL_CPLT_EVT = 0,
+  EMVCO_OPEN_CHNL_ERROR_EVT = 1,
+  EMVCO_CLOSE_CHNL_CPLT_EVT = 2,
+  EMVCO_POOLING_START_EVT = 3,
+  EMVCO_POLLING_STARTED_EVT = 4,
+  EMVCO_POLLING_STOP_EVT = 5,
+  EMVCO_UN_SUPPORTED_CARD_EVT = 6,
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/EmvcoStatus.aidl b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/EmvcoStatus.aidl
new file mode 100644
index 0000000..9b899b5
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/EmvcoStatus.aidl
@@ -0,0 +1,44 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@Backing(type="int") @VintfStability
+enum EmvcoStatus {
+  EMVCO_STATUS_OK = 0,
+  EMVCO_STATUS_INVALID_PARAMETER = 1,
+  EMVCO_STATUS_INVALID_STATE = 11,
+  EMVCO_STATUS_FEATURE_NOT_SUPPORTED = 33,
+  EMVCO_STATUS_FAILED = 255,
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/IEmvco.aidl b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/IEmvco.aidl
new file mode 100644
index 0000000..527f936
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/IEmvco.aidl
@@ -0,0 +1,42 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@VintfStability
+interface IEmvco {
+  android.hardware.emvco.IEmvcoProfileDiscovery getEmvcoProfileDiscoveryInterface();
+  android.hardware.emvco.IEmvcoContactlessCard getEmvcoContactlessCard();
+  android.hardware.emvco.IEmvcoContactCard getEmvcoContactCard();
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/IEmvcoClientCallback.aidl b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/IEmvcoClientCallback.aidl
new file mode 100644
index 0000000..2693151
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/IEmvcoClientCallback.aidl
@@ -0,0 +1,41 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@VintfStability
+interface IEmvcoClientCallback {
+  oneway void sendData(in byte[] data);
+  oneway void sendEvent(in android.hardware.emvco.EmvcoEvent event, in android.hardware.emvco.EmvcoStatus status);
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/IEmvcoContactCard.aidl b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/IEmvcoContactCard.aidl
new file mode 100644
index 0000000..b7847d6
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/IEmvcoContactCard.aidl
@@ -0,0 +1,40 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@VintfStability
+interface IEmvcoContactCard {
+  boolean registerEMVCoEventListener(in android.hardware.emvco.IEmvcoClientCallback clientCallback);
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/IEmvcoContactlessCard.aidl b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/IEmvcoContactlessCard.aidl
new file mode 100644
index 0000000..4801683
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/IEmvcoContactlessCard.aidl
@@ -0,0 +1,43 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@VintfStability
+interface IEmvcoContactlessCard {
+  boolean registerEMVCoEventListener(in android.hardware.emvco.IEmvcoClientCallback clientCallback);
+  int transceive(in byte[] in_data);
+  void setEMVCoMode(in byte in_config, boolean in_isStartEMVCo);
+  android.hardware.emvco.EmvcoStatus stopRFDisovery(in android.hardware.emvco.DeactivationType deactivationType);
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/IEmvcoProfileDiscovery.aidl b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/IEmvcoProfileDiscovery.aidl
new file mode 100644
index 0000000..f240a82
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/IEmvcoProfileDiscovery.aidl
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@VintfStability
+interface IEmvcoProfileDiscovery {
+  boolean registerEMVCoEventListener(in android.hardware.emvco.IEmvcoClientCallback emvcoClientCallback);
+  void setEMVCoMode(in byte config, boolean isStartEMVCo);
+  void onNfcStateChange(android.hardware.emvco.NfcState nfcState);
+  boolean registerNFCStateChangeCallback(in android.hardware.emvco.INfcStateChangeRequestCallback nfcStateChangeCallback);
+  android.hardware.emvco.DiscoveryMode getCurrentDiscoveryMode();
+  android.hardware.emvco.EmvcoStatus setLed(in android.hardware.emvco.LedControl ledControl);
+  android.hardware.emvco.EmvcoStatus setByteConfig(in android.hardware.emvco.ConfigType type, in int length, in byte value);
+  android.hardware.emvco.EmvcoStatus setByteArrayConfig(in android.hardware.emvco.ConfigType type, in int length, in byte[] value);
+  android.hardware.emvco.EmvcoStatus setStringConfig(in android.hardware.emvco.ConfigType type, in int length, in String value);
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/INfcStateChangeRequestCallback.aidl b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/INfcStateChangeRequestCallback.aidl
new file mode 100644
index 0000000..c693c7a
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/INfcStateChangeRequestCallback.aidl
@@ -0,0 +1,40 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@VintfStability
+interface INfcStateChangeRequestCallback {
+  oneway void enableNfc(boolean turnOn);
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/LedControl.aidl b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/LedControl.aidl
new file mode 100644
index 0000000..db02f28
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/LedControl.aidl
@@ -0,0 +1,43 @@
+/******************************************************************************
+ *
+ *  Copyright 2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@Backing(type="int") @VintfStability
+enum LedControl {
+  RED_LED_OFF = 0,
+  RED_LED_ON = 1,
+  GREEN_LED_OFF = 2,
+  GREEN_LED_ON = 3,
+}
diff --git a/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/NfcState.aidl b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/NfcState.aidl
new file mode 100644
index 0000000..efb3dcc
--- /dev/null
+++ b/aidl/aidl_api/android.hardware.emvco/current/android/hardware/emvco/NfcState.aidl
@@ -0,0 +1,43 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package android.hardware.emvco;
+@Backing(type="int") @VintfStability
+enum NfcState {
+  STATE_OFF = 1,
+  STATE_TURNING_ON = 2,
+  STATE_ON = 3,
+  STATE_TURNING_OFF = 4,
+}
diff --git a/aidl/android/hardware/emvco/ConfigType.aidl b/aidl/android/hardware/emvco/ConfigType.aidl
new file mode 100644
index 0000000..52e3c72
--- /dev/null
+++ b/aidl/android/hardware/emvco/ConfigType.aidl
@@ -0,0 +1,38 @@
+/******************************************************************************
+ *
+ *  Copyright 2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+package android.hardware.emvco;
+/** \addtogroup EMVCO_HAL_API_INTERFACE
+ *  @{
+ */
+
+/**
+ * @brief config types allowed to be set through EMVCO HAL
+ *
+ * The EMVCo Hal uses this config type as key to set the config value.
+ */
+@VintfStability
+@Backing(type="int")
+enum ConfigType {
+   /**
+    * POLL_PROFILE_SEL - Discovery profile selection in poll mode
+    */
+   POLL_PROFILE_SEL = 0,
+}
+
+/** @} */
\ No newline at end of file
diff --git a/aidl/android/hardware/emvco/DeactivationType.aidl b/aidl/android/hardware/emvco/DeactivationType.aidl
new file mode 100644
index 0000000..0577093
--- /dev/null
+++ b/aidl/android/hardware/emvco/DeactivationType.aidl
@@ -0,0 +1,45 @@
+/******************************************************************************
+ *
+ *  Copyright 2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+package android.hardware.emvco;
+
+/** \addtogroup EMVCO_HAL_API_INTERFACE
+ *  @{
+ */
+
+/**
+ * @brief Deactivation types to be handled by EMVCo HAL
+ *
+ * The EMVCo Hal uses this event to specify the deactivation type as part of
+ * RF deactivation.
+ */
+@VintfStability
+@Backing(type="int")
+enum DeactivationType {
+    /**
+     * Deactivates the RF field and move to IDLE state
+     *
+     */
+    IDLE                    = 0,
+    /**
+     * Deactivates the RF field and move to Discover state
+     */
+    DISCOVER                = 3,
+
+}
+/** @}*/
diff --git a/aidl/android/hardware/emvco/DiscoveryMode.aidl b/aidl/android/hardware/emvco/DiscoveryMode.aidl
new file mode 100755
index 0000000..a4574ca
--- /dev/null
+++ b/aidl/android/hardware/emvco/DiscoveryMode.aidl
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ *  Copyright 2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+package android.hardware.emvco;
+
+/** \addtogroup EMVCO_HAL_API_INTERFACE
+ *  @{
+ */
+
+/**
+ * @brief Pofile types to be handled by EMVCo HAL
+ *
+ * The EMVCo Hal uses this event to determine the current active profile.
+ */
+@VintfStability
+@Backing(type="int")
+enum DiscoveryMode {
+    /**
+     * NFC event to notify NFC as current active state to EMVCo HAL
+     *
+     */
+    NFC                       = 1,
+    /**
+     * EMVCO event to notify NFC as current active state to EMVCo HAL
+     */
+    EMVCO                = 2,
+    /**
+     * UN_KNOWN event to notify UN_KNOWN as current active state to EMVCo HAL
+     */
+    UN_KNOWN                       = 3,
+
+}
+/** @}*/
diff --git a/aidl/android/hardware/emvco/EmvcoEvent.aidl b/aidl/android/hardware/emvco/EmvcoEvent.aidl
new file mode 100644
index 0000000..0326042
--- /dev/null
+++ b/aidl/android/hardware/emvco/EmvcoEvent.aidl
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+package android.hardware.emvco;
+
+/** \addtogroup EMVCO_HAL_API_INTERFACE
+ *  @{
+ */
+
+/**
+ * @brief Event codes to be handled by Application
+ *
+ * The EMVCo Hal notifies application with below event codes.
+ */
+@VintfStability
+@Backing(type="int")
+enum EmvcoEvent {
+   /** @brief  Event to indicate EMVCo HAL open complete state*/
+   EMVCO_OPEN_CHNL_CPLT_EVT = 0,
+   /** @brief  Event to indicate EMVCo HAL open error state*/
+   EMVCO_OPEN_CHNL_ERROR_EVT = 1,
+   /** @brief  Event to indicate EMVCo HAL close complete state*/
+   EMVCO_CLOSE_CHNL_CPLT_EVT = 2,
+   /** @brief  Event to indicate the start of EMVCo mode*/
+   EMVCO_POOLING_START_EVT = 3,
+   /** @brief  Event to indicate EMVCo polling activated state*/
+   EMVCO_POLLING_STARTED_EVT = 4,
+   /** @brief  Event to indicate the stop of EMVCo mode*/
+   EMVCO_POLLING_STOP_EVT = 5,
+   /** @brief  Event to indicate the Non EMV card*/
+   EMVCO_UN_SUPPORTED_CARD_EVT = 6,
+}
+/** @}*/
\ No newline at end of file
diff --git a/aidl/android/hardware/emvco/EmvcoStatus.aidl b/aidl/android/hardware/emvco/EmvcoStatus.aidl
new file mode 100644
index 0000000..09d0c23
--- /dev/null
+++ b/aidl/android/hardware/emvco/EmvcoStatus.aidl
@@ -0,0 +1,57 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+package android.hardware.emvco;
+
+/** \addtogroup EMVCO_HAL_API_INTERFACE
+ *  @{
+ */
+
+/**
+ * @brief EMVCo Hal return status code as below
+ */
+@VintfStability
+@Backing(type="int")
+enum EmvcoStatus {
+    /**
+     * Indicates success status.
+     */
+    EMVCO_STATUS_OK = 0,
+
+    /**
+     * Indicates invalid input parameter status.
+     */
+    EMVCO_STATUS_INVALID_PARAMETER = 1,
+
+    /**
+     * Indicates action requested on invalid state
+     */
+    EMVCO_STATUS_INVALID_STATE = 11,
+
+    /**
+     * Indicates feature not supported yet.
+     */
+    EMVCO_STATUS_FEATURE_NOT_SUPPORTED = 33,
+
+    /**
+     * Indicates failure status.
+     */
+    EMVCO_STATUS_FAILED = 255,
+}
+
+/** @}*/
\ No newline at end of file
diff --git a/aidl/android/hardware/emvco/IEmvco.aidl b/aidl/android/hardware/emvco/IEmvco.aidl
new file mode 100644
index 0000000..572587e
--- /dev/null
+++ b/aidl/android/hardware/emvco/IEmvco.aidl
@@ -0,0 +1,67 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+package android.hardware.emvco;
+
+import android.hardware.emvco.IEmvcoProfileDiscovery;
+import android.hardware.emvco.IEmvcoContactlessCard;
+import android.hardware.emvco.IEmvcoContactCard;
+
+/** \addtogroup EMVCO_HAL_API_INTERFACE
+ *  @{
+ */
+
+ /**
+  * @brief Interface to EMVCo HAL.
+  *
+  * The android application calls this interface to get the EMVCo functionality specific interface.
+  *
+  */
+@VintfStability
+interface IEmvco {
+    /**
+    * @brief Provides the EMVCo mode switch HAL interface.
+    *
+    * @param  none
+    *
+    * @return IEmvcoProfileDiscovery EMVCo mode switch HAL interface
+    *
+    */
+    IEmvcoProfileDiscovery getEmvcoProfileDiscoveryInterface();
+
+    /**
+    * @brief Provides the EMVCo contact less HAL interface.
+    *
+    * @param  none
+    *
+    * @return IEmvcoContactlessCard EMVCo contact less HAL interface
+    *
+    */
+    IEmvcoContactlessCard getEmvcoContactlessCard();
+
+    /**
+    * @brief Provides the EMVCo contact HAL interface.
+    *
+    * @param  none
+    *
+    * @return IEmvcoContactCard EMVCo contact HAL interface
+    *
+    */
+    IEmvcoContactCard getEmvcoContactCard();
+}
+/** @}*/
\ No newline at end of file
diff --git a/aidl/android/hardware/emvco/IEmvcoClientCallback.aidl b/aidl/android/hardware/emvco/IEmvcoClientCallback.aidl
new file mode 100644
index 0000000..f794547
--- /dev/null
+++ b/aidl/android/hardware/emvco/IEmvcoClientCallback.aidl
@@ -0,0 +1,42 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+package android.hardware.emvco;
+
+import android.hardware.emvco.EmvcoEvent;
+import android.hardware.emvco.EmvcoStatus;
+
+/** \addtogroup EMVCO_HAL_API_INTERFACE
+ *  @{
+ */
+
+/**
+ * @brief Provides a callback functionality to App.
+ */
+@VintfStability
+interface IEmvcoClientCallback {
+   /**
+    * EMVCo Data Callback Function
+    */
+    oneway void sendData(in byte[] data);
+    /**
+    * EMVCo Event Callback Function
+    */
+    oneway void sendEvent(in EmvcoEvent event, in EmvcoStatus status);
+}
+/** @}*/
\ No newline at end of file
diff --git a/aidl/android/hardware/emvco/IEmvcoContactCard.aidl b/aidl/android/hardware/emvco/IEmvcoContactCard.aidl
new file mode 100644
index 0000000..f5e098c
--- /dev/null
+++ b/aidl/android/hardware/emvco/IEmvcoContactCard.aidl
@@ -0,0 +1,37 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+package android.hardware.emvco;
+
+import android.hardware.emvco.IEmvcoClientCallback;
+
+@VintfStability
+interface IEmvcoContactCard {
+    /**
+    *
+    * @brief Register EMVCo callback function to receive the events from a listener device.
+    *
+    * @note This function is must to call before invoking any other api.
+    *
+    * @param[in]  *in_clientCallback has EMVCo client HAL callback
+    * @param[in]  *in_aidl_return indicates register status in return to caller
+    *
+    * @return ::ndk::ScopedAStatus indicates doRegisterEMVCoEventListener request processed by EMVCo HAL successfully or not
+    */
+    boolean registerEMVCoEventListener(in IEmvcoClientCallback clientCallback);
+}
diff --git a/aidl/android/hardware/emvco/IEmvcoContactlessCard.aidl b/aidl/android/hardware/emvco/IEmvcoContactlessCard.aidl
new file mode 100644
index 0000000..7f0c801
--- /dev/null
+++ b/aidl/android/hardware/emvco/IEmvcoContactlessCard.aidl
@@ -0,0 +1,96 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+package android.hardware.emvco;
+
+import android.hardware.emvco.IEmvcoClientCallback;
+import android.hardware.emvco.DeactivationType;
+import android.hardware.emvco.EmvcoStatus;
+
+/** \addtogroup EMVCO_HAL_API_INTERFACE
+ *  @{
+ */
+
+ /**
+  * @brief Interface to EMVCo Contactless card HAL.
+  *
+  * The android application calls this interface to utilize EMVCo
+  * Contact less functionality of the underlying device.
+  * The android device, which supports Wireless Charging, implements INxpEmvcoContactlessCard
+  * interface as @ref EMVCo_POLLER_LIB "EMVCo HAL" to provide functionalities to
+  * Android application.
+  *
+  */
+
+@VintfStability
+interface IEmvcoContactlessCard {
+    /**
+    *
+    * @brief Register callback function to receive the events from a listener device.
+    *
+    * @note This function is must to call before invoking any other api.
+    *
+    * @param cb IEmvcoClientCallback the event callback function to be
+             passed by caller
+    *
+    * @return boolean returns true, if success and returns false, if failed to register
+    */
+    boolean registerEMVCoEventListener(in IEmvcoClientCallback clientCallback);
+
+    /**
+    * @brief send application data with the Device-Controller.
+    *
+    * @note In case if send data is failed, Application shall again invoke
+    *          @ref open "open()" before
+    *          invoking @ref open "this" API.
+    *
+    * @param[in] in_data Application data buffer
+    *
+    * @return int indicating execution status
+    *
+    */
+    int transceive(in byte[] in_data);
+
+    /**
+    * @brief starts the EMVCo mode with the Device-Controller.
+    *
+    * Once the @ref open "Application Data Channel is "
+    * established, the Application may send start the EMVCo mode with the
+    * Device-Controller.
+    *
+    * @param[in] in_config EMVCo polling technologies are configured through this parameter
+    * @param[in] in_isStartEMVCo specifies to start or stop the EMVCo mode
+    *
+    * @return void
+    *
+    */
+    void setEMVCoMode(in byte in_config,boolean in_isStartEMVCo);
+
+    /**
+    * @brief stops the RF field and moves in to the specified deactivation state.
+    *
+    * @param[in] in_deactivationType specifies the state to be in after RF deactivation
+    *
+    * @return EmvcoStatus returns EMVCO_STATUS_OK, if command processed successfully and returns EMVCO_STATUS_FAILED, if command
+	*         is not processed due to in-valid state. EMVCo mode should be ON to call this API
+    *
+    */
+    EmvcoStatus stopRFDisovery(in DeactivationType deactivationType);
+}
+
+/** @}*/
\ No newline at end of file
diff --git a/aidl/android/hardware/emvco/IEmvcoProfileDiscovery.aidl b/aidl/android/hardware/emvco/IEmvcoProfileDiscovery.aidl
new file mode 100644
index 0000000..2860b18
--- /dev/null
+++ b/aidl/android/hardware/emvco/IEmvcoProfileDiscovery.aidl
@@ -0,0 +1,139 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+package android.hardware.emvco;
+
+import android.hardware.emvco.IEmvcoClientCallback;
+import android.hardware.emvco.INfcStateChangeRequestCallback;
+import android.hardware.emvco.NfcState;
+import android.hardware.emvco.DiscoveryMode;
+import android.hardware.emvco.LedControl;
+import android.hardware.emvco.EmvcoStatus;
+import android.hardware.emvco.ConfigType;
+
+@VintfStability
+interface IEmvcoProfileDiscovery {
+    /**
+    *
+    * @brief Register EMVCo callback function to receive the events from a listener device.
+    *
+    * @note This function is must to call before invoking any other api.
+    *
+    * @param[in]  *in_clientCallback has EMVCo client HAL callback
+    * @param[in]  *in_aidl_return indicates register status in return to caller
+    *
+    * @return boolean returns true, if success and returns false, if failed to register
+    */
+    boolean registerEMVCoEventListener(in IEmvcoClientCallback emvcoClientCallback);
+
+    /**
+    * @brief starts the EMVCo mode with the Device-Controller.
+    *
+    * Once the @ref open "Application Data Channel is "
+    * established, the Application may send start the EMVCo mode with the
+    * Device-Controller.
+    *
+    * @param[in] in_config EMVCo polling technologies are configured through this parameter
+    * @param[in] in_isStartEMVCo specifies to start or stop the EMVCo mode
+    *
+    * @return void
+    *
+    */
+    void setEMVCoMode(in byte config, boolean isStartEMVCo);
+
+    /**
+    *
+    * @brief updates NFC state to EMVCo HAL.
+    *
+    *
+    * @param[in] in_nfcState specifies the NFC state
+    *
+    * @return void
+    */
+    void onNfcStateChange(NfcState nfcState);
+
+    /**
+    *
+    * @brief Register NFC callback function to receive the events from a listener device.
+    *
+    * @note This function is must to call before invoking any other api.
+    *
+    * @param[in] in_nfcStateChangeCallback INfcStateChangeRequestCallback the event callback function to be passed by caller
+    *
+    * @return boolean returns true, if success and returns false, if failed to register
+    */
+    boolean registerNFCStateChangeCallback(in INfcStateChangeRequestCallback nfcStateChangeCallback);
+
+    /**
+    * @brief returns the current active profile type.
+    *
+    * @return DiscoveryMode - NFC/EMVCo/Unknown
+    *
+    */
+    DiscoveryMode getCurrentDiscoveryMode();
+
+    /**
+    * @brief allows to turn ON/OFF the specified LED.
+    *
+    * @param[in] ledControl specifies the LED to be turned ON or OFF
+    *
+    * @return EmvcoStatus returns EMVCO_STATUS_OK, if command processed successfully and returns EMVCO_STATUS_FAILED, if command
+    *         is not processed due to in-valid state. EMVCo mode should be ON to call this API
+    *
+    */
+    EmvcoStatus setLed(in LedControl ledControl);
+
+    /**
+    * @brief allows to set the single byte value.
+    *
+    * @param[in] type - name of the config
+    * @param[in] length - length of the config value
+    * @param[in] value - actual byte value to be set
+    *
+    * @return EmvcoStatus returns EMVCO_STATUS_OK, if command processed successfully and returns EMVCO_STATUS_FAILED, if command
+    *         is not processed successfully.
+    *
+    */
+    EmvcoStatus setByteConfig(in ConfigType type, in int length, in byte value);
+
+    /**
+    * @brief allows to set the byte array value.
+    *
+    * @param[in] type - name of the config
+    * @param[in] length - length of the config value
+    * @param[in] value - actual byte array value to be set
+    *
+    * @return EmvcoStatus returns EMVCO_STATUS_OK, if command processed successfully and returns EMVCO_STATUS_FAILED, if command
+    *         is not processed successfully
+    *
+    */
+    EmvcoStatus setByteArrayConfig(in ConfigType type, in int length, in byte[] value);
+
+    /**
+    * @brief allows to set the string value.
+    *
+    * @param[in] type - name of the config
+    * @param[in] length - length of the config value
+    * @param[in] value - actual string value to be set
+    *
+    * @return EmvcoStatus returns EMVCO_STATUS_OK, if command processed successfully and returns EMVCO_STATUS_FAILED, if command
+    *         is not processed successfully
+    *
+    */
+    EmvcoStatus setStringConfig(in ConfigType type, in int length, in String value);
+}
diff --git a/aidl/android/hardware/emvco/INfcStateChangeRequestCallback.aidl b/aidl/android/hardware/emvco/INfcStateChangeRequestCallback.aidl
new file mode 100644
index 0000000..b122ad5
--- /dev/null
+++ b/aidl/android/hardware/emvco/INfcStateChangeRequestCallback.aidl
@@ -0,0 +1,42 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+package android.hardware.emvco;
+
+/** \addtogroup EMVCO_HAL_API_INTERFACE
+ *  @{
+ */
+
+/**
+ * @brief Provides a callback functionality to App.
+ */
+@VintfStability
+interface INfcStateChangeRequestCallback {
+    /**
+    *
+    * @brief request NFC module to turn ON or OFF the NFC
+    *
+    *
+    * @param[in]  turnOn true to turn on NFC. False to turn off NFC
+    *
+    * @return void
+    */
+    oneway void enableNfc(boolean turnOn);
+
+}
+/** @}*/
\ No newline at end of file
diff --git a/aidl/android/hardware/emvco/LedControl.aidl b/aidl/android/hardware/emvco/LedControl.aidl
new file mode 100644
index 0000000..635ca0c
--- /dev/null
+++ b/aidl/android/hardware/emvco/LedControl.aidl
@@ -0,0 +1,53 @@
+/******************************************************************************
+ *
+ *  Copyright 2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+package android.hardware.emvco;
+
+/** \addtogroup EMVCO_HAL_API_INTERFACE
+ *  @{
+ */
+
+/**
+ * @brief LED types to be handled by EMVCo HAL
+ *
+ * The EMVCo Hal uses this event to control the Red and Green LED state
+ */
+@VintfStability
+@Backing(type="int")
+enum LedControl {
+    /**
+     * Turns off GREEN LED
+     */
+    RED_LED_OFF                  = 0,
+
+    /**
+     * Turns on RED LED
+     *
+     */
+    RED_LED_ON                   = 1,
+    /**
+     * Turns off GREEN LED
+     */
+    GREEN_LED_OFF                = 2,
+    /**
+     * Turns on GREEN LED
+     *
+     */
+    GREEN_LED_ON                 = 3,
+}
+/** @}*/
diff --git a/aidl/android/hardware/emvco/NfcState.aidl b/aidl/android/hardware/emvco/NfcState.aidl
new file mode 100644
index 0000000..7835c68
--- /dev/null
+++ b/aidl/android/hardware/emvco/NfcState.aidl
@@ -0,0 +1,52 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+package android.hardware.emvco;
+
+/** \addtogroup EMVCO_HAL_API_INTERFACE
+ *  @{
+ */
+
+/**
+ * @brief Event codes to be handled by EMVCo HAL
+ *
+ * The EMVCo Hal uses this event codes to map the NFC event codes.
+ */
+@VintfStability
+@Backing(type="int")
+enum NfcState {
+    /**
+     * STATE_OFF event to notify NFC state off event to EMVCo HAL
+     *
+     */
+    STATE_OFF                       = 1,
+    /**
+     * STATE_TURNING_ON event to notify NFC state turning on event to EMVCo HAL
+     */
+    STATE_TURNING_ON                = 2,
+    /**
+     * STATE_ON event to notify NFC state on event to EMVCo HAL
+     */
+    STATE_ON                       = 3,
+    /**
+     * STATE_TURNING_OFF event to notify NFC state turning OFF event to EMVCo HAL
+     */
+    STATE_TURNING_OFF              = 4,
+
+}
+/** @}*/
\ No newline at end of file
diff --git a/aidl/default/Android.bp b/aidl/default/Android.bp
new file mode 100644
index 0000000..0c2a3e0
--- /dev/null
+++ b/aidl/default/Android.bp
@@ -0,0 +1,32 @@
+cc_binary {
+    name: "android.hardware.emvco-service",
+    relative_install_path: "hw",
+    init_rc: ["android.hardware.emvco-service.rc"],
+    vintf_fragments: ["android.hardware.emvco-service.xml"],
+    vendor: true,
+
+    include_dirs: [
+        "hardware/nxp/emvco/emvco_hal_impl/api",
+    ],
+
+    local_include_dirs: ["."],
+
+    shared_libs: [
+        "libhardware",
+        "libbase",
+        "liblog",
+        "libutils",
+        "libbinder_ndk",
+        "android.hardware.emvco-V1-ndk",
+        "emvco_poller",
+    ],
+
+    srcs: [
+        "EmvcoService.cpp",
+        "Emvco.cpp",
+        "LinkedCallback.cpp",
+        "EmvcoContactCard.cpp",
+        "EmvcoContactlessCard.cpp",
+        "EmvcoProfileDiscovery.cpp",
+    ],
+}
diff --git a/aidl/default/Emvco.cpp b/aidl/default/Emvco.cpp
new file mode 100644
index 0000000..8ebe94b
--- /dev/null
+++ b/aidl/default/Emvco.cpp
@@ -0,0 +1,294 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#include "Emvco.h"
+#include "LinkedCallback.h"
+#include <emvco_hal.h>
+#define CHK_STATUS(x)                                                          \
+  ((x) == EMVCO_STATUS_SUCCESS)                                                \
+      ? (::ndk::ScopedAStatus::ok())                                           \
+      : (::ndk::ScopedAStatus::fromStatus(STATUS_FAILED_TRANSACTION))
+
+namespace aidl {
+namespace android {
+namespace hardware {
+namespace emvco {
+
+using ::aidl::android::hardware::emvco::DiscoveryMode;
+using ::aidl::android::hardware::emvco::EmvcoEvent;
+using ::aidl::android::hardware::emvco::EmvcoStatus;
+
+std::vector<std::unique_ptr<LinkedCallback>> Emvco::callbacks_;
+std::mutex Emvco::callbacks_lock_;
+std::shared_ptr<Emvco> Emvco::emvco_service_;
+std::shared_ptr<INfcStateChangeRequestCallback>
+    Emvco::nfc_State_change_callback = nullptr;
+
+void Emvco::setNfcState(bool enableNfc) {
+  if (Emvco::nfc_State_change_callback != nullptr) {
+    auto ret = Emvco::nfc_State_change_callback->enableNfc(enableNfc);
+    if (!ret.isOk()) {
+      LOG(ERROR) << "Failed to send event!";
+    }
+  }
+}
+
+void Emvco::eventCallback(uint8_t event, uint8_t status) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  std::lock_guard<std::mutex> lock(callbacks_lock_);
+  for (auto &it : callbacks_) {
+    it->callback()->sendEvent((EmvcoEvent)event, (EmvcoStatus)status);
+  }
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Exit", __func__);
+}
+
+void Emvco::dataCallback(uint16_t data_len, uint8_t *p_data) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  std::lock_guard<std::mutex> lock(callbacks_lock_);
+  std::vector<uint8_t> data(p_data, p_data + data_len);
+  for (auto &it : callbacks_) {
+    it->callback()->sendData(data);
+  }
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Exit", __func__);
+}
+
+void OnCallbackDiedWrapped(void *cookie) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  LinkedCallback *linked = reinterpret_cast<LinkedCallback *>(cookie);
+  linked->OnCallbackDied();
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Exit", __func__);
+}
+
+std::shared_ptr<Emvco> Emvco::getInstance() {
+  if (emvco_service_ == nullptr) {
+    emvco_service_ = ::ndk::SharedRefBase::make<Emvco>();
+    ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  }
+  return emvco_service_;
+}
+
+Emvco::Emvco()
+    : death_recipient_(AIBinder_DeathRecipient_new(&OnCallbackDiedWrapped)) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  open();
+}
+
+::ndk::ScopedAStatus Emvco::getEmvcoProfileDiscoveryInterface(
+    std::shared_ptr<::aidl::android::hardware::emvco::IEmvcoProfileDiscovery>
+        *_aidl_return) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  if (nxp_emvco_profile_discovery_ == nullptr) {
+    nxp_emvco_profile_discovery_ =
+        ::ndk::SharedRefBase::make<EmvcoProfileDiscovery>();
+  }
+  *_aidl_return = nxp_emvco_profile_discovery_;
+  return ndk::ScopedAStatus::ok();
+}
+::ndk::ScopedAStatus Emvco::getEmvcoContactlessCard(
+    std::shared_ptr<::aidl::android::hardware::emvco::IEmvcoContactlessCard>
+        *_aidl_return) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  if (nxp_emvco_contactless_card == nullptr) {
+    nxp_emvco_contactless_card =
+        ::ndk::SharedRefBase::make<EmvcoContactlessCard>();
+  }
+  *_aidl_return = nxp_emvco_contactless_card;
+  return ndk::ScopedAStatus::ok();
+}
+::ndk::ScopedAStatus Emvco::getEmvcoContactCard(
+    std::shared_ptr<::aidl::android::hardware::emvco::IEmvcoContactCard>
+        *_aidl_return) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  if (nxp_emvco_contact_card_ == nullptr) {
+    nxp_emvco_contact_card_ = ::ndk::SharedRefBase::make<EmvcoContactCard>();
+  }
+  *_aidl_return = nxp_emvco_contact_card_;
+  return ndk::ScopedAStatus::ok();
+}
+
+::ndk::ScopedAStatus Emvco::registerEMVCoEventListener(
+    const std::shared_ptr<
+        ::aidl::android::hardware::emvco::IEmvcoClientCallback>
+        &in_clientCallback,
+    bool *_aidl_return) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  registerCallback(in_clientCallback);
+  *_aidl_return = true;
+  return ndk::ScopedAStatus::ok();
+}
+
+::ndk::ScopedAStatus Emvco::getCurrentDiscoveryMode(
+    ::aidl::android::hardware::emvco::DiscoveryMode *_aidl_return) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  *_aidl_return = (DiscoveryMode)get_current_discovery_mode();
+  return ndk::ScopedAStatus::ok();
+}
+
+binder_status_t Emvco::dump(int fd, const char **p, uint32_t q) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s", __func__);
+  (void)fd;
+  (void)p;
+  (void)q;
+  return STATUS_OK;
+}
+
+::ndk::ScopedAStatus Emvco::onNfcStateChange(NfcState in_nfcState) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s onNfcStateChange nfcState:%d", __func__,
+           (int)in_nfcState);
+  on_nfc_state_change((int)in_nfcState);
+  return ndk::ScopedAStatus::ok();
+}
+
+::ndk::ScopedAStatus Emvco::registerNFCStateChangeCallback(
+    const std::shared_ptr<
+        ::aidl::android::hardware::emvco::INfcStateChangeRequestCallback>
+        &in_nfcStateChangeCallback,
+    bool *_aidl_return) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s", __func__);
+  Emvco::nfc_State_change_callback = in_nfcStateChangeCallback;
+  *_aidl_return = true;
+  return ndk::ScopedAStatus::ok();
+}
+::ndk::ScopedAStatus Emvco::setEMVCoMode(int8_t in_config,
+                                         bool in_isStartEMVCo) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter in_config:%d, in_isStartEMVCo:%d",
+           __func__, in_config, in_isStartEMVCo);
+
+  set_emvco_mode(in_config, in_isStartEMVCo);
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: phNxpNciHal_doSetEMVCoMode returned",
+           __func__);
+  return ndk::ScopedAStatus::ok();
+}
+
+::ndk::ScopedAStatus Emvco::open() {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  EMVCO_STATUS status =
+      open_emvco_app_data_channel(eventCallback, dataCallback, setNfcState);
+
+  return CHK_STATUS(status);
+}
+::ndk::ScopedAStatus Emvco::transceive(const std::vector<uint8_t> &in_data,
+                                       int32_t *_aidl_return) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  std::vector<uint8_t> data(in_data.begin(), in_data.end());
+  *_aidl_return = send_emvco_app_data(data.size(), (uint8_t *)data.data());
+  return ndk::ScopedAStatus::ok();
+}
+
+::ndk::ScopedAStatus
+Emvco::close(const std::shared_ptr<IEmvcoClientCallback> &in_clientCallback) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  if (in_clientCallback == nullptr) {
+    LOG(ERROR) << __func__ << "Client callback is NULL";
+  } else {
+    unregisterCallback(in_clientCallback);
+  }
+  EMVCO_STATUS status = close_emvco_app_data_channel(false);
+  return CHK_STATUS(status);
+}
+
+void Emvco::registerCallback(
+    const std::shared_ptr<IEmvcoClientCallback> &callback) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  if (callback == nullptr) {
+    LOG(ERROR) << __func__ << "Client callback is NULL";
+    return;
+  }
+  {
+    std::lock_guard<std::mutex> lock(callbacks_lock_);
+    callbacks_.emplace_back(LinkedCallback::Make(ref<Emvco>(), callback));
+    ALOGD_IF(EMVCO_HAL_DEBUG, "Total clients=%d", (int)callbacks_.size());
+  }
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Exit", __func__);
+}
+
+void Emvco::unregisterCallback(
+    const std::shared_ptr<IEmvcoClientCallback> &callback) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  if (callback == nullptr) {
+    LOG(ERROR) << __func__ << "Client callback is NULL";
+    return;
+  }
+  std::lock_guard<std::mutex> lock(callbacks_lock_);
+  auto matches = [callback](const auto &linked) {
+    return linked->callback()->asBinder() == callback->asBinder();
+  };
+  auto it1 = std::remove_if(callbacks_.begin(), callbacks_.end(), matches);
+  bool removed = (it1 != callbacks_.end());
+  if (removed) {
+    callbacks_.erase(it1, callbacks_.end());
+  } else {
+    LOG(ERROR) << __func__ << "unregisterCallback failed";
+  }
+  ALOGD_IF(EMVCO_HAL_DEBUG, "Total clients = %d", (int)callbacks_.size());
+}
+
+::ndk::ScopedAStatus Emvco::stopRFDisovery(
+    ::aidl::android::hardware::emvco::DeactivationType in_deactivationType,
+    ::aidl::android::hardware::emvco::EmvcoStatus *emvco_status) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: in_deactivationType:%d", __func__,
+           in_deactivationType);
+  *emvco_status = (EmvcoStatus)stop_rf_discovery((int)in_deactivationType);
+  return ndk::ScopedAStatus::ok();
+}
+::ndk::ScopedAStatus
+Emvco::setLed(::aidl::android::hardware::emvco::LedControl in_ledControl,
+              ::aidl::android::hardware::emvco::EmvcoStatus *emvco_status) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: in_ledControl:%d", __func__, in_ledControl);
+
+  *emvco_status = (EmvcoStatus)set_led((int)in_ledControl);
+  return ndk::ScopedAStatus::ok();
+}
+
+::ndk::ScopedAStatus Emvco::setByteConfig(
+    ::aidl::android::hardware::emvco::ConfigType in_type, int32_t in_length,
+    int8_t in_value,
+    ::aidl::android::hardware::emvco::EmvcoStatus *emvco_status) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: in_value:%d", __func__, in_value);
+
+  *emvco_status =
+      (EmvcoStatus)set_byte_config((config_type_t)in_type, in_length, in_value);
+  return ndk::ScopedAStatus::ok();
+}
+
+::ndk::ScopedAStatus Emvco::setByteArrayConfig(
+    ::aidl::android::hardware::emvco::ConfigType in_type, int32_t in_length,
+    const std::vector<uint8_t> &in_value,
+    ::aidl::android::hardware::emvco::EmvcoStatus *emvco_status) {
+  (void)in_length;
+  std::vector<uint8_t> data(in_value.begin(), in_value.end());
+  for (int8_t value : data) {
+    ALOGD_IF(EMVCO_HAL_DEBUG, "%s: value:%d", __func__, value);
+  }
+  *emvco_status = (EmvcoStatus)set_byte_array_config(
+      (config_type_t)in_type, data.size(), (uint8_t *)data.data());
+  return ndk::ScopedAStatus::ok();
+}
+::ndk::ScopedAStatus Emvco::setStringConfig(
+    ::aidl::android::hardware::emvco::ConfigType in_type, int32_t in_length,
+    const std::string &in_value,
+    ::aidl::android::hardware::emvco::EmvcoStatus *emvco_status) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: in_value:%s", __func__, in_value.c_str());
+
+  *emvco_status = (EmvcoStatus)set_string_config((config_type_t)in_type,
+                                                 in_length, in_value.c_str());
+  return ndk::ScopedAStatus::ok();
+}
+} // namespace emvco
+} // namespace hardware
+} // namespace android
+} // namespace aidl
diff --git a/aidl/default/Emvco.h b/aidl/default/Emvco.h
new file mode 100644
index 0000000..beb9099
--- /dev/null
+++ b/aidl/default/Emvco.h
@@ -0,0 +1,158 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#pragma once
+#ifndef EMVCO_HAL_DEBUG
+#define EMVCO_HAL_DEBUG true
+#endif
+/** @defgroup EMVCO_HAL_API_INTERFACE.
+ * The android application calls this interface to get the EMVCo mode switch and
+ * Contact less Transaction functionality
+ */
+
+/** \addtogroup EMVCO_STACK_HAL_API_INTERFACE
+ *  @brief interface to EMVCo mode switch, contact and contact interfaces.
+ *           The android device, which supports EMVCo feature, implements
+ * IEmvcoProfileDiscovery, IEmvcoContactlessCard, IEmvcoContactCard interface as
+ * @ref EMVCo_POLLER_LIB to provide functionalities to Android application.
+ *  @{
+ */
+
+#include "EmvcoContactCard.h"
+#include "EmvcoContactlessCard.h"
+#include "EmvcoProfileDiscovery.h"
+#include <aidl/android/hardware/emvco/BnEmvco.h>
+#include <aidl/android/hardware/emvco/DiscoveryMode.h>
+#include <aidl/android/hardware/emvco/IEmvcoClientCallback.h>
+#include <aidl/android/hardware/emvco/INfcStateChangeRequestCallback.h>
+#include <android-base/logging.h>
+#include <log/log.h>
+
+namespace aidl {
+namespace android {
+namespace hardware {
+namespace emvco {
+
+using ::ndk::ICInterface;
+class LinkedCallback;
+
+class Emvco : public BnEmvco {
+public:
+  Emvco();
+
+  /**
+   * @brief Provides the EMVCo mode switch HAL interface.
+   *
+   * @param  none
+   *
+   * @return IEmvcoProfileDiscovery EMVCo mode switch HAL interface
+   *
+   */
+  ::ndk::ScopedAStatus getEmvcoProfileDiscoveryInterface(
+      std::shared_ptr<::aidl::android::hardware::emvco::IEmvcoProfileDiscovery>
+          *_aidl_return) override;
+
+  /**
+   * @brief Provides the EMVCo contact less HAL interface.
+   *
+   * @param  none
+   *
+   * @return IEmvcoContactlessCard EMVCo contact less HAL interface
+   *
+   */
+  ::ndk::ScopedAStatus getEmvcoContactlessCard(
+      std::shared_ptr<::aidl::android::hardware::emvco::IEmvcoContactlessCard>
+          *_aidl_return) override;
+
+  /**
+   * @brief Provides the EMVCo contact HAL interface.
+   *
+   * @param  none
+   *
+   * @return IEmvcoContactCard EMVCo contact HAL interface
+   *
+   */
+  ::ndk::ScopedAStatus getEmvcoContactCard(
+      std::shared_ptr<::aidl::android::hardware::emvco::IEmvcoContactCard>
+          *_aidl_return) override;
+  ::ndk::ScopedAStatus onNfcStateChange(NfcState in_nfcState);
+
+  ::ndk::ScopedAStatus registerEMVCoEventListener(
+      const std::shared_ptr<IEmvcoClientCallback> &in_clientCallback,
+      bool *_aidl_return);
+  ::ndk::ScopedAStatus setEMVCoMode(int8_t in_config, bool in_isStartEMVCo);
+  ::ndk::ScopedAStatus transceive(const std::vector<uint8_t> &in_data,
+                                  int32_t *_aidl_return);
+  binder_status_t dump(int fd, const char **args, uint32_t num_args) override;
+  ::ndk::ScopedAStatus open();
+  ::ndk::ScopedAStatus
+  close(const std::shared_ptr<IEmvcoClientCallback> &in_clientCallback);
+  ::ndk::ScopedAStatus registerNFCStateChangeCallback(
+      const std::shared_ptr<
+          ::aidl::android::hardware::emvco::INfcStateChangeRequestCallback>
+          &in_nfcStateChangeCallback,
+      bool *_aidl_return);
+  ::ndk::ScopedAStatus getCurrentDiscoveryMode(
+      ::aidl::android::hardware::emvco::DiscoveryMode *_aidl_return);
+  ::ndk::ScopedAStatus stopRFDisovery(
+      ::aidl::android::hardware::emvco::DeactivationType in_deactivationType,
+      ::aidl::android::hardware::emvco::EmvcoStatus *emvco_status);
+  ::ndk::ScopedAStatus
+  setLed(::aidl::android::hardware::emvco::LedControl in_ledControl,
+         ::aidl::android::hardware::emvco::EmvcoStatus *emvco_status);
+  ::ndk::ScopedAStatus
+  setByteConfig(::aidl::android::hardware::emvco::ConfigType in_type,
+                int32_t in_length, int8_t in_value,
+                ::aidl::android::hardware::emvco::EmvcoStatus *_aidl_return);
+  ::ndk::ScopedAStatus setByteArrayConfig(
+      ::aidl::android::hardware::emvco::ConfigType in_type, int32_t in_length,
+      const std::vector<uint8_t> &in_value,
+      ::aidl::android::hardware::emvco::EmvcoStatus *_aidl_return);
+  ::ndk::ScopedAStatus
+  setStringConfig(::aidl::android::hardware::emvco::ConfigType in_type,
+                  int32_t in_length, const std::string &in_value,
+                  ::aidl::android::hardware::emvco::EmvcoStatus *_aidl_return);
+
+  static void eventCallback(uint8_t event, uint8_t status);
+  static void dataCallback(uint16_t data_len, uint8_t *p_data);
+  static std::shared_ptr<Emvco> getInstance();
+  static void setNfcState(bool enableNfc);
+  static std::shared_ptr<INfcStateChangeRequestCallback>
+      nfc_State_change_callback;
+
+private:
+  friend LinkedCallback;
+  static std::shared_ptr<Emvco> emvco_service_;
+  static std::vector<std::unique_ptr<LinkedCallback>> callbacks_;
+  static std::mutex callbacks_lock_;
+  ndk::ScopedAIBinder_DeathRecipient death_recipient_;
+  std::shared_ptr<IEmvcoProfileDiscovery> nxp_emvco_profile_discovery_;
+  std::shared_ptr<IEmvcoContactCard> nxp_emvco_contact_card_;
+  std::shared_ptr<IEmvcoContactlessCard> nxp_emvco_contactless_card;
+
+  void registerCallback(const std::shared_ptr<IEmvcoClientCallback> &callback);
+  void
+  unregisterCallback(const std::shared_ptr<IEmvcoClientCallback> &callback);
+  void setEMVCoModeImpl(int8_t in_config);
+};
+
+} // namespace emvco
+} // namespace hardware
+} // namespace android
+} // namespace aidl
+
+/** @}*/
\ No newline at end of file
diff --git a/aidl/default/EmvcoContactCard.cpp b/aidl/default/EmvcoContactCard.cpp
new file mode 100644
index 0000000..6125dfe
--- /dev/null
+++ b/aidl/default/EmvcoContactCard.cpp
@@ -0,0 +1,39 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#include "EmvcoContactCard.h"
+#include "Emvco.h"
+
+namespace aidl {
+namespace android {
+namespace hardware {
+namespace emvco {
+
+::ndk::ScopedAStatus EmvcoContactCard::registerEMVCoEventListener(
+    const std::shared_ptr<
+        ::aidl::android::hardware::emvco::IEmvcoClientCallback>
+        &in_clientCallback,
+    bool *_aidl_return) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  return Emvco::getInstance()->registerEMVCoEventListener(in_clientCallback,
+                                                          _aidl_return);
+}
+
+} // namespace emvco
+} // namespace hardware
+} // namespace android
+} // namespace aidl
diff --git a/aidl/default/EmvcoContactCard.h b/aidl/default/EmvcoContactCard.h
new file mode 100644
index 0000000..a5b15f6
--- /dev/null
+++ b/aidl/default/EmvcoContactCard.h
@@ -0,0 +1,60 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#pragma once
+
+/** \addtogroup EMVCO_STACK_HAL_CT_API_INTERFACE
+ *  @brief The android application calls this interface to use the EMVCo Contact
+ *   card functionality.
+ *  @{
+ */
+#include <aidl/android/hardware/emvco/BnEmvcoContactCard.h>
+#include <aidl/android/hardware/emvco/IEmvcoClientCallback.h>
+#include <android-base/logging.h>
+#include <log/log.h>
+
+namespace aidl {
+namespace android {
+namespace hardware {
+namespace emvco {
+
+class EmvcoContactCard : public BnEmvcoContactCard {
+
+public:
+  /**
+   *
+   * @brief Register EMVCo callback function to receive the events from a
+   * listener device.
+   *
+   * @note This function is must to call before invoking any other api.
+   *
+   * @param[in]  *in_clientCallback has EMVCo client HAL callback
+   * @param[in]  *in_aidl_return indicates register status in return to caller
+   *
+   * @return ::ndk::ScopedAStatus indicates registerEMVCoEventListener request
+   * processed by EMVCo HAL successfully or not
+   */
+  ::ndk::ScopedAStatus registerEMVCoEventListener(
+      const std::shared_ptr<IEmvcoClientCallback> &in_clientCallback,
+      bool *_aidl_return) override;
+};
+
+} // namespace emvco
+} // namespace hardware
+} // namespace android
+} // namespace aidl
+  /** @}*/
\ No newline at end of file
diff --git a/aidl/default/EmvcoContactlessCard.cpp b/aidl/default/EmvcoContactlessCard.cpp
new file mode 100644
index 0000000..050d79f
--- /dev/null
+++ b/aidl/default/EmvcoContactlessCard.cpp
@@ -0,0 +1,60 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#include "EmvcoContactlessCard.h"
+#include "Emvco.h"
+
+namespace aidl {
+namespace android {
+namespace hardware {
+namespace emvco {
+
+::ndk::ScopedAStatus EmvcoContactlessCard::registerEMVCoEventListener(
+    const std::shared_ptr<
+        ::aidl::android::hardware::emvco::IEmvcoClientCallback>
+        &in_clientCallback,
+    bool *_aidl_return) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  return Emvco::getInstance()->registerEMVCoEventListener(in_clientCallback,
+                                                          _aidl_return);
+}
+
+::ndk::ScopedAStatus
+EmvcoContactlessCard::transceive(const std::vector<uint8_t> &in_data,
+                                 int32_t *_aidl_return) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  return Emvco::getInstance()->transceive(in_data, _aidl_return);
+}
+
+::ndk::ScopedAStatus EmvcoContactlessCard::setEMVCoMode(int8_t in_config,
+                                                        bool in_isStartEMVCo) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter in_config:%d", __func__, in_config);
+  return Emvco::getInstance()->setEMVCoMode(in_config, in_isStartEMVCo);
+}
+
+::ndk::ScopedAStatus EmvcoContactlessCard::stopRFDisovery(
+    ::aidl::android::hardware::emvco::DeactivationType in_deactivationType,
+    ::aidl::android::hardware::emvco::EmvcoStatus *emvco_status) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  return Emvco::getInstance()->stopRFDisovery(in_deactivationType,
+                                              emvco_status);
+}
+
+} // namespace emvco
+} // namespace hardware
+} // namespace android
+} // namespace aidl
diff --git a/aidl/default/EmvcoContactlessCard.h b/aidl/default/EmvcoContactlessCard.h
new file mode 100644
index 0000000..b437aa8
--- /dev/null
+++ b/aidl/default/EmvcoContactlessCard.h
@@ -0,0 +1,105 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#pragma once
+
+/** \addtogroup EMVCO_STACK_HAL_CL_API_INTERFACE
+ *  @brief The android application calls this interface to use the EMVCo
+ *   Contactless card functionality.
+ *  @{
+ */
+
+#include <aidl/android/hardware/emvco/BnEmvcoContactlessCard.h>
+#include <aidl/android/hardware/emvco/IEmvcoClientCallback.h>
+
+namespace aidl {
+namespace android {
+namespace hardware {
+namespace emvco {
+
+class EmvcoContactlessCard : public BnEmvcoContactlessCard {
+
+public:
+  /**
+   *
+   * @brief Register EMVCo callback function to receive the events from a
+   * listener device.
+   *
+   * @note This function is must to call before invoking any other api.
+   *
+   * @param[in]  *in_clientCallback has EMVCo client HAL callback
+   * @param[in]  *in_aidl_return indicates register status in return to caller
+   *
+   * @return boolean returns true, if success and returns false, if failed to
+   * register
+   */
+  ::ndk::ScopedAStatus registerEMVCoEventListener(
+      const std::shared_ptr<IEmvcoClientCallback> &in_clientCallback,
+      bool *_aidl_return) override;
+
+  /**
+   * @brief send application data with the Device-Controller.
+   *
+   * @note In case if send data is failed, Application shall again invoke
+   *          @ref open "open()" before
+   *          invoking @ref open "this" API.
+   *
+   * @param[in] in_data Application data buffer
+   *
+   * @return EmvcoStatus indicating execution status
+   *
+   */
+  ::ndk::ScopedAStatus transceive(const std::vector<uint8_t> &in_data,
+                                  int32_t *_aidl_return) override;
+
+  /**
+   * @brief starts the EMVCo mode with the Device-Controller.
+   *
+   * Once the @ref open "Application Data Channel is "
+   * established, the Application may send start the EMVCo mode with the
+   * Device-Controller.
+   *
+   * @param[in] in_config EMVCo polling technologies are configured through this
+   * parameter
+   * @param[in] in_isStartEMVCo specifies to start or stop the EMVCo mode
+   *
+   * @return void
+   *
+   */
+  ::ndk::ScopedAStatus setEMVCoMode(int8_t in_config, bool in_isStartEMVCo);
+
+  /**
+   * @brief stops the RF field and moves in to the specified deactivation state.
+   *
+   * @param[in] in_deactivationType specifies the state to be in after RF
+   * deactivation
+   *
+   * @return EmvcoStatus returns EMVCO_STATUS_OK, if command processed
+   * successfully and returns EMVCO_STATUS_FAILED, if command is not processed
+   * due to in-valid state. EMVCo mode should be ON to call this API
+   *
+   */
+  ::ndk::ScopedAStatus stopRFDisovery(
+      ::aidl::android::hardware::emvco::DeactivationType in_deactivationType,
+      ::aidl::android::hardware::emvco::EmvcoStatus *emvco_status) override;
+};
+
+} // namespace emvco
+} // namespace hardware
+} // namespace android
+} // namespace aidl
+  /** @}*/
\ No newline at end of file
diff --git a/aidl/default/EmvcoProfileDiscovery.cpp b/aidl/default/EmvcoProfileDiscovery.cpp
new file mode 100644
index 0000000..2d43a63
--- /dev/null
+++ b/aidl/default/EmvcoProfileDiscovery.cpp
@@ -0,0 +1,95 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#include "EmvcoProfileDiscovery.h"
+
+namespace aidl {
+namespace android {
+namespace hardware {
+namespace emvco {
+
+::ndk::ScopedAStatus EmvcoProfileDiscovery::registerEMVCoEventListener(
+    const std::shared_ptr<
+        ::aidl::android::hardware::emvco::IEmvcoClientCallback>
+        &in_clientCallback,
+    bool *_aidl_return) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  return Emvco::getInstance()->registerEMVCoEventListener(in_clientCallback,
+                                                          _aidl_return);
+}
+
+::ndk::ScopedAStatus EmvcoProfileDiscovery::setEMVCoMode(int8_t in_config,
+                                                         bool in_isStartEMVCo) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  return Emvco::getInstance()->setEMVCoMode(in_config, in_isStartEMVCo);
+}
+
+::ndk::ScopedAStatus EmvcoProfileDiscovery::registerNFCStateChangeCallback(
+    const std::shared_ptr<
+        ::aidl::android::hardware::emvco::INfcStateChangeRequestCallback>
+        &in_nfcStateChangeCallback,
+    bool *_aidl_return) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  return Emvco::getInstance()->registerNFCStateChangeCallback(
+      in_nfcStateChangeCallback, _aidl_return);
+}
+::ndk::ScopedAStatus
+EmvcoProfileDiscovery::onNfcStateChange(NfcState in_nfcState) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  return Emvco::getInstance()->onNfcStateChange(in_nfcState);
+}
+
+::ndk::ScopedAStatus EmvcoProfileDiscovery::getCurrentDiscoveryMode(
+    ::aidl::android::hardware::emvco::DiscoveryMode *_aidl_return) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  return Emvco::getInstance()->getCurrentDiscoveryMode(_aidl_return);
+}
+
+::ndk::ScopedAStatus EmvcoProfileDiscovery::setLed(
+    ::aidl::android::hardware::emvco::LedControl in_ledControl,
+    ::aidl::android::hardware::emvco::EmvcoStatus *emvco_status) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  return Emvco::getInstance()->setLed(in_ledControl, emvco_status);
+}
+::ndk::ScopedAStatus EmvcoProfileDiscovery::setByteConfig(
+    ::aidl::android::hardware::emvco::ConfigType in_type, int32_t in_length,
+    int8_t in_value,
+    ::aidl::android::hardware::emvco::EmvcoStatus *_aidl_return) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  return Emvco::getInstance()->setByteConfig(in_type, in_length, in_value,
+                                             _aidl_return);
+}
+::ndk::ScopedAStatus EmvcoProfileDiscovery::setByteArrayConfig(
+    ::aidl::android::hardware::emvco::ConfigType in_type, int32_t in_length,
+    const std::vector<uint8_t> &in_value,
+    ::aidl::android::hardware::emvco::EmvcoStatus *_aidl_return) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  return Emvco::getInstance()->setByteArrayConfig(in_type, in_length, in_value,
+                                                  _aidl_return);
+}
+::ndk::ScopedAStatus EmvcoProfileDiscovery::setStringConfig(
+    ::aidl::android::hardware::emvco::ConfigType in_type, int32_t in_length,
+    const std::string &in_value,
+    ::aidl::android::hardware::emvco::EmvcoStatus *_aidl_return) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  return Emvco::getInstance()->setStringConfig(in_type, in_length, in_value,
+                                               _aidl_return);
+}
+} // namespace emvco
+} // namespace hardware
+} // namespace android
+} // namespace aidl
diff --git a/aidl/default/EmvcoProfileDiscovery.h b/aidl/default/EmvcoProfileDiscovery.h
new file mode 100644
index 0000000..58a6e57
--- /dev/null
+++ b/aidl/default/EmvcoProfileDiscovery.h
@@ -0,0 +1,133 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#pragma once
+#include "Emvco.h"
+#include <aidl/android/hardware/emvco/BnEmvcoProfileDiscovery.h>
+#include <aidl/android/hardware/emvco/IEmvcoClientCallback.h>
+#include <aidl/android/hardware/emvco/INfcStateChangeRequestCallback.h>
+
+/** \addtogroup EMVCO_STACK_HAL_MODE_SWITCH_API_INTERFACE
+ *  @brief   The android application calls this interface to utilize EMVCo
+ *           mode switch functionality of the underlying device.
+ *  @{
+ */
+
+namespace aidl {
+namespace android {
+namespace hardware {
+namespace emvco {
+
+class EmvcoProfileDiscovery : public BnEmvcoProfileDiscovery {
+
+public:
+  /**
+   *
+   * @brief Register EMVCo callback function to receive the events from a
+   * listener device.
+   *
+   * @note This function is must to call before invoking any other api.
+   *
+   * @param[in]  *in_clientCallback has EMVCo client HAL callback
+   * @param[in]  *in_aidl_return indicates register status in return to caller
+   *
+   * @return boolean returns true, if success and returns false, if failed to
+   * register
+   */
+  ::ndk::ScopedAStatus registerEMVCoEventListener(
+      const std::shared_ptr<IEmvcoClientCallback> &in_clientCallback,
+      bool *in_aidl_return) override;
+
+  /**
+   * @brief starts the EMVCo mode with the Device-Controller.
+   *
+   * Once the @ref open "Application Data Channel is "
+   * established, the Application may send start the EMVCo mode with the
+   * Device-Controller.
+   *
+   * @param[in] in_disc_mask EMVCo polling technologies are configured through
+   * this parameter
+   * @param[in] in_isStartEMVCo specifies to start or stop the EMVCo mode
+   *
+   * @return void
+   *
+   */
+  ::ndk::ScopedAStatus setEMVCoMode(int8_t in_disc_mask,
+                                    bool in_isStartEMVCo) override;
+
+  /**
+   *
+   * @brief Register NFC callback function to receive the events from a listener
+   * device.
+   *
+   * @note This function is must to call before invoking any other api.
+   *
+   * @param[in] in_nfcStateChangeCallback INfcStateChangeRequestCallback the
+   * event callback function to be passed by caller. It should implement to turn
+   * ON/OFF NFC based on the request received.
+   *
+   * @return boolean returns true, if success and returns false, if failed to
+   * register
+   */
+  ::ndk::ScopedAStatus registerNFCStateChangeCallback(
+      const std::shared_ptr<
+          ::aidl::android::hardware::emvco::INfcStateChangeRequestCallback>
+          &in_nfcStateChangeRequestCallback,
+      bool *_aidl_return) override;
+
+  /**
+   *
+   * @brief updates NFC state to EMVCo HAL.
+   *
+   *
+   * @param[in] in_nfcState specifies the NFC state
+   *
+   * @return void
+   */
+  ::ndk::ScopedAStatus onNfcStateChange(NfcState in_nfcState) override;
+
+  /**
+   * @brief returns the current active profile type.
+   *
+   * @return DiscoveryMode - NFC/EMVCo/Unknown
+   *
+   */
+  ::ndk::ScopedAStatus getCurrentDiscoveryMode(
+      ::aidl::android::hardware::emvco::DiscoveryMode *_aidl_return) override;
+
+  ::ndk::ScopedAStatus
+  setLed(::aidl::android::hardware::emvco::LedControl in_ledControl,
+         ::aidl::android::hardware::emvco::EmvcoStatus *emvco_status) override;
+  ::ndk::ScopedAStatus setByteConfig(
+      ::aidl::android::hardware::emvco::ConfigType in_type, int32_t in_length,
+      int8_t in_value,
+      ::aidl::android::hardware::emvco::EmvcoStatus *_aidl_return) override;
+  ::ndk::ScopedAStatus setByteArrayConfig(
+      ::aidl::android::hardware::emvco::ConfigType in_type, int32_t in_length,
+      const std::vector<uint8_t> &in_value,
+      ::aidl::android::hardware::emvco::EmvcoStatus *_aidl_return) override;
+  ::ndk::ScopedAStatus setStringConfig(
+      ::aidl::android::hardware::emvco::ConfigType in_type, int32_t in_length,
+      const std::string &in_value,
+      ::aidl::android::hardware::emvco::EmvcoStatus *_aidl_return) override;
+};
+
+} // namespace emvco
+} // namespace hardware
+} // namespace android
+} // namespace aidl
+  /** @}*/
\ No newline at end of file
diff --git a/aidl/default/EmvcoService.cpp b/aidl/default/EmvcoService.cpp
new file mode 100644
index 0000000..6da24d0
--- /dev/null
+++ b/aidl/default/EmvcoService.cpp
@@ -0,0 +1,45 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include "Emvco.h"
+#include <android-base/logging.h>
+#include <android/binder_manager.h>
+#include <android/binder_process.h>
+//#include <cstring>
+
+using ::aidl::android::hardware::emvco::Emvco;
+
+int main() {
+  LOG(INFO) << "EMVCO HAL starting up";
+  if (!ABinderProcess_setThreadPoolMaxThreadCount(1)) {
+    LOG(INFO) << "failed to set thread pool max thread count";
+    return 1;
+  }
+  std::shared_ptr<Emvco> emvco_service = Emvco::getInstance();
+
+  const std::string instance = std::string() + Emvco::descriptor + "/default";
+  ALOGD_IF(EMVCO_HAL_DEBUG, "EMVCo Registering service: %s", instance.c_str());
+  binder_status_t status = AServiceManager_addService(
+      emvco_service->asBinder().get(), instance.c_str());
+  ALOGD_IF(EMVCO_HAL_DEBUG, "EMVCo Registered IEMVCo service status: %d",
+           status);
+  CHECK(status == STATUS_OK);
+  ABinderProcess_joinThreadPool();
+
+  return EXIT_FAILURE; // should not reach
+}
diff --git a/aidl/default/LinkedCallback.cpp b/aidl/default/LinkedCallback.cpp
new file mode 100644
index 0000000..92d5636
--- /dev/null
+++ b/aidl/default/LinkedCallback.cpp
@@ -0,0 +1,68 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#include "LinkedCallback.h"
+#include <android/binder_ibinder.h>
+#include <utils/Errors.h>
+
+namespace aidl::android::hardware::emvco {
+
+LinkedCallback::LinkedCallback() = default;
+
+LinkedCallback::~LinkedCallback() {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  if (callback_ == nullptr) {
+    return;
+  }
+  auto status = AIBinder_unlinkToDeath(callback_->asBinder().get(),
+                                       service()->death_recipient_.get(),
+                                       reinterpret_cast<void *>(this));
+  if (status != STATUS_OK && status != STATUS_DEAD_OBJECT) {
+    LOG(WARNING) << __func__ << "Cannot unlink to death: "
+                 << ::android::statusToString(status);
+  }
+}
+
+std::unique_ptr<LinkedCallback>
+LinkedCallback::Make(std::shared_ptr<Emvco> service,
+                     std::shared_ptr<IEmvcoClientCallback> callback) {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  std::unique_ptr<LinkedCallback> ret(new LinkedCallback());
+  binder_status_t linkRet = AIBinder_linkToDeath(
+      callback->asBinder().get(), service->death_recipient_.get(),
+      reinterpret_cast<void *>(ret.get()));
+  if (linkRet != ::STATUS_OK) {
+    LOG(WARNING) << __func__ << "Cannot link to death: " << linkRet;
+    return nullptr;
+  }
+  ret->service_ = service;
+  ret->callback_ = std::move(callback);
+  return ret;
+}
+
+std::shared_ptr<Emvco> LinkedCallback::service() {
+  auto service_sp = service_.lock();
+  CHECK_NE(nullptr, service_sp);
+  return service_sp;
+}
+
+void LinkedCallback::OnCallbackDied() {
+  ALOGD_IF(EMVCO_HAL_DEBUG, "%s: Enter", __func__);
+  service()->unregisterCallback(callback_);
+}
+
+} // namespace aidl::android::hardware::emvco
diff --git a/aidl/default/LinkedCallback.h b/aidl/default/LinkedCallback.h
new file mode 100644
index 0000000..29d1f41
--- /dev/null
+++ b/aidl/default/LinkedCallback.h
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#pragma once
+
+#include <Emvco.h>
+#include <aidl/android/hardware/emvco/IEmvcoClientCallback.h>
+#include <android-base/macros.h>
+#include <android/binder_auto_utils.h>
+#include <memory>
+
+namespace aidl::android::hardware::emvco {
+
+class LinkedCallback {
+public:
+  static std::unique_ptr<LinkedCallback>
+  Make(std::shared_ptr<Emvco> service,
+       std::shared_ptr<IEmvcoClientCallback> callback);
+  ~LinkedCallback();
+  const std::shared_ptr<IEmvcoClientCallback> &callback() const {
+    return callback_;
+  }
+  void OnCallbackDied();
+
+private:
+  LinkedCallback();
+  DISALLOW_COPY_AND_ASSIGN(LinkedCallback);
+  std::shared_ptr<Emvco> service();
+  std::weak_ptr<Emvco> service_;
+  std::shared_ptr<IEmvcoClientCallback> callback_;
+};
+
+} // namespace aidl::android::hardware::emvco
diff --git a/aidl/default/android.hardware.emvco-service.rc b/aidl/default/android.hardware.emvco-service.rc
new file mode 100644
index 0000000..3715639
--- /dev/null
+++ b/aidl/default/android.hardware.emvco-service.rc
@@ -0,0 +1,4 @@
+service emvco_hal_service /vendor/bin/hw/android.hardware.emvco-service
+    class hal
+    user nfc
+    group nfc
\ No newline at end of file
diff --git a/aidl/default/android.hardware.emvco-service.xml b/aidl/default/android.hardware.emvco-service.xml
new file mode 100644
index 0000000..9434ee2
--- /dev/null
+++ b/aidl/default/android.hardware.emvco-service.xml
@@ -0,0 +1,7 @@
+<manifest version="1.0" type="device">
+    <hal format="aidl">
+        <name>android.hardware.emvco</name>
+        <version>1</version>
+        <fqname>IEmvco/default</fqname>
+    </hal>
+</manifest>
diff --git a/emvco_hal_impl/Android.bp b/emvco_hal_impl/Android.bp
new file mode 100644
index 0000000..0e598dd
--- /dev/null
+++ b/emvco_hal_impl/Android.bp
@@ -0,0 +1,69 @@
+//
+//
+//  Copyright 2022 NXP
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//  http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+//
+//
+cc_library_shared {
+    name: "emvco_poller",
+    proprietary: true,
+    cflags: [
+        "-Wall",
+        "-Werror",
+        "-Wextra",
+        "-Wno-implicit-fallthrough",
+        "-DNXP_EXTNS=TRUE",
+    ],
+
+    srcs: [
+        "api/emvco_hal.c",
+        "dm/emvco_dm.c",
+        "emvco/cl/emvco_cl.c",
+        "emvco/ct/emvco_ct.c",
+        "log/emvco_log.c",
+        "nci/emvco_nci_ext.c",
+        "nci/emvco_ncif.c",
+        "osal/osal_memory.c",
+        "osal/osal_message_queue_lib.c",
+        "osal/osal_thread.c",
+        "osal/osal_timer.c",
+        "osal/osal_tml.c",
+        "peripherals/peripherals.c",
+        "tml/emvco_tml.c",
+        "tml/emvco_tml_i2c.c",
+        "utils/emvco_config.c",
+        "utils/emvco_util.c",
+        "utils/sparse_crc32.c",
+        "utils/map.c",
+    ],
+
+    local_include_dirs: [
+        "api",
+        "dm",
+        "emvco/ct",
+        "emvco/cl",
+        "inc/common",
+        "log",
+        "nci",
+        "osal",
+        "peripherals",
+        "tml",
+        "utils",
+    ],
+
+    shared_libs: [
+        "liblog",
+        "libcutils",
+    ],
+}
diff --git a/emvco_hal_impl/api/emvco_common.h b/emvco_hal_impl/api/emvco_common.h
new file mode 100644
index 0000000..e625045
--- /dev/null
+++ b/emvco_hal_impl/api/emvco_common.h
@@ -0,0 +1,73 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef _EMVCO_COMMON_H_
+#define _EMVCO_COMMON_H_
+
+#include "emvco_status.h"
+#include <stdbool.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief  boolean data type
+ */
+typedef uint8_t bool_t;
+
+/**
+ * @brief  EMVCo status specifies EMVCO_STATUS_SUCCESS or EMVCO_STATUS_FAILED
+ */
+typedef uint16_t EMVCO_STATUS; /* Return values */
+
+/**
+ * @brief emvco_event_t EMVCo data event
+ *
+ */
+typedef uint8_t emvco_event_t;
+/**
+ * @brief emvco_event_t EMVCo statuc event
+ *
+ */
+typedef uint8_t emvco_status_t;
+/**
+ * @brief discovery_mode_t stores the current active profile. NFC/EMVCO/UNKNOWN
+ *
+ */
+typedef enum { NFC = 1, EMVCO, UNKNOWN } discovery_mode_t;
+
+discovery_mode_t discovery_mode;
+/**
+ * @brief config_type_t defines the supported config key types
+ *        can be configured through setConfig API
+ *
+ */
+typedef enum { POLL_PROFILE_SEL = 0 } config_type_t;
+/**
+ * @brief deactivation_type_t defines the supported deactivation
+ *        types which will be used along with deactivation command.
+ *
+ */
+typedef enum { IDLE = 0, DISCOVER = 3 } deactivation_type_t;
+
+#ifdef __cplusplus
+}
+#endif /*  C++ Compilation guard */
+#endif /* _EMVCO_COMMON_H_ */
diff --git a/emvco_hal_impl/api/emvco_hal.c b/emvco_hal_impl/api/emvco_hal.c
new file mode 100644
index 0000000..0e8acb2
--- /dev/null
+++ b/emvco_hal_impl/api/emvco_hal.c
@@ -0,0 +1,101 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <emvco_cl.h>
+#include <emvco_config.h>
+#include <emvco_dm.h>
+#include <emvco_hal.h>
+#include <emvco_log.h>
+#include <emvco_ncif.h>
+#include <map.h>
+#include <peripherals.h>
+#define MAX_KEY_LENGTH 3
+extern emvco_args_t *modeSwitchArgs;
+
+int open_emvco_app_data_channel(
+    emvco_stack_callback_t *p_cback, emvco_stack_data_callback_t *p_data_cback,
+    emvco_state_change_callback_t *p_nfc_state_cback) {
+  LOG_EMVCOHAL_D("open_emvco_app_data_channel");
+  return open_app_data_channel(*p_cback, *p_data_cback, *p_nfc_state_cback);
+}
+
+int send_emvco_app_data(uint16_t data_len, const uint8_t *p_data) {
+  LOG_EMVCOHAL_D("send_emvco_app_data");
+  return send_app_data(data_len, p_data);
+}
+
+int close_emvco_app_data_channel(bool isShutdown) {
+  LOG_EMVCOHAL_D("close_emvco_app_data_channel");
+  return close_app_data_channel(isShutdown);
+}
+
+void set_emvco_mode(const int8_t emvco_config, bool_t is_start_emvco) {
+  LOG_EMVCOHAL_D("set_emvco_mode");
+  handle_set_emvco_mode(emvco_config, is_start_emvco);
+}
+discovery_mode_t get_current_discovery_mode() {
+  LOG_EMVCOHAL_D("get_current_discovery_mode");
+  return get_current_mode();
+}
+void on_nfc_state_change(int32_t nfc_state) {
+  LOG_EMVCOHAL_D("on_nfc_state_change");
+  handle_nfc_state_change(nfc_state);
+}
+
+EMVCO_STATUS stop_rf_discovery(uint8_t deactivation_type) {
+  LOG_EMVCOHAL_D("stop_rf_discovery");
+  return rf_deactivate(deactivation_type);
+}
+EMVCO_STATUS set_led(uint8_t led_control) {
+  LOG_EMVCOHAL_D("set_led");
+  if (EMVCO != modeSwitchArgs->current_discovery_mode) {
+    LOG_EMVCOHAL_E("set_led_state failed - Not in EMVCo mode");
+    return EMVCO_STATUS_FAILED;
+  } else {
+    return led_switch_control(led_control);
+  }
+}
+
+EMVCO_STATUS set_byte_config(config_type_t type, const int32_t length,
+                             const int8_t value) {
+  char token[MAX_KEY_LENGTH];
+  sprintf(token, "%d", (int)type);
+  LOG_EMVCOHAL_D("set_byte_config token:%s, value:%x", token, value);
+
+  struct map *m = get_config_map();
+  map_set(m, &token, strlen(token) + 1, &value, length);
+  return EMVCO_STATUS_SUCCESS;
+}
+
+EMVCO_STATUS set_byte_array_config(config_type_t type, const int32_t in_length,
+                                   const uint8_t *in_value) {
+  LOG_EMVCOHAL_D("set_byte_array_config not supported yet");
+  (void)type;
+  (void)in_length;
+  (void)in_value;
+  return EMVCO_STATUS_FEATURE_NOT_SUPPORTED;
+}
+
+EMVCO_STATUS set_string_config(config_type_t type, const int32_t in_length,
+                               const char *p_value) {
+  LOG_EMVCOHAL_D("set_string_config not supported yet");
+  (void)type;
+  (void)in_length;
+  (void)p_value;
+  return EMVCO_STATUS_FEATURE_NOT_SUPPORTED;
+}
\ No newline at end of file
diff --git a/emvco_hal_impl/api/emvco_hal.h b/emvco_hal_impl/api/emvco_hal.h
new file mode 100644
index 0000000..f716d8b
--- /dev/null
+++ b/emvco_hal_impl/api/emvco_hal.h
@@ -0,0 +1,215 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef _EMVCO_HAL_H_
+#define _EMVCO_HAL_H_
+
+/** \addtogroup EMVCO_DATA_EXCHANGE_STACK_HAL_API_INTERFACE
+ *  @brief interface to HAL Client to realize the EMVCo functionality.
+ *  @{
+ */
+
+#include <emvco_common.h>
+#include <stdbool.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief
+ * The callback passed in from the EMVCo HAL to get the
+ * EMVCo status EMVCo stack .
+ */
+typedef void(emvco_stack_callback_t)(emvco_event_t event,
+                                     emvco_status_t event_status);
+
+/**
+ * @brief
+ * The callback passed in from the EMVCo HAL that EMVCo
+ * stack can use to pass status to EMVCo HAL.
+ */
+typedef void(emvco_stack_data_callback_t)(uint16_t data_len, uint8_t *p_data);
+
+/**
+ * @brief
+ * The callback passed in from the EMVCo HAL that EMVCo
+ * stack can use to pass data to EMVCo HAL.
+ */
+typedef void(emvco_state_change_callback_t)(bool enableNfc);
+
+/**
+
+ *
+ * @brief           This function is called by EMVCo HAL during the
+ *                  initialization of the NFCC. It opens the physical connection
+ *                  with NFCC (PN7220) and creates required client thread for
+ *                  operation.
+ *                  After open is complete, status is informed to EMVCo HAL
+ *                  through callback function.
+ *
+ * @param[in]       p_cback provides EMVCo event status to client
+ * @param[in]       p_data_cback provides EMVCo data to client
+ * @param[in]       p_nfc_state_change_req_cback EMVCo HAL requests NFC module
+ to turn ON or OFF the NFC through this callback
+ *
+ * @return          int status of the operation performed
+ *
+ */
+int open_emvco_app_data_channel(
+    emvco_stack_callback_t *p_cback, emvco_stack_data_callback_t *p_data_cback,
+    emvco_state_change_callback_t *p_nfc_state_cback);
+
+/**
+ *
+ * @brief           This function write the data to NFCC through physical
+ *                  interface (e.g. I2C) using the PN7220 driver interface.
+ *                  Before sending the data to NFCC, phEMVCoHal_write_ext
+ *                  is called to check if there is any extension processing
+ *                  is required for the NCI packet being sent out.
+ *
+ * @param[in]       data_len length of the data to be written
+ * @param[in]       p_data actual data to be written
+ *
+ * @return          int status of the write operation performed
+ *
+ */
+int send_emvco_app_data(uint16_t data_len, const uint8_t *p_data);
+
+/**
+ *
+ * @brief       This function close the NFCC interface and free all
+ *              resources.This is called by EMVCo HAL on EMVCo service stop.
+ *
+ * @param[in]   bShutdown true, if host is going to shutdown mode. false if host
+ * is not going to shutdown mode.
+ *
+ * @return      int status of the close operation performed
+ *
+ */
+int close_emvco_app_data_channel(bool);
+
+/**
+ * @brief starts the EMVCo mode with the Device-Controller.
+ *
+ * @param[in] dm_disc_mask EMVCo polling technologies are configured through
+ * this parameter
+ * @param[in] is_start_emvco specifies to start or stop the EMVCo mode
+ *
+ * @return void
+ *
+ */
+void set_emvco_mode(const int8_t emvco_config, bool_t is_start_emvco);
+
+/**
+ * @brief returns the current active profile type.
+ * @param[in] void
+ * @return discovery_mode_t - NFC/EMVCo/Unknown
+ *
+ */
+discovery_mode_t get_current_discovery_mode();
+
+/**
+ *
+ * @brief updates NFC state to EMVCo Stack.
+ *
+ *
+ * @param[in] in_nfcState specifies the NFC state
+ *
+ * @return void
+ */
+void on_nfc_state_change(int32_t nfc_state);
+
+/**
+ *
+ * @brief stops the RF field and moves in to the specified deactivation state.
+ *
+ *
+ * @param[in] deactivation_type specifies the state to be in after RF
+ * deactivation
+ *
+ * @return EMVCO_STATUS returns 0, if command processed successfully and returns
+ * 1, if command is not processed due to in-valid state. EMVCo mode should be ON
+ * to call this API
+ */
+EMVCO_STATUS stop_rf_discovery(uint8_t deactivation_type);
+
+/**
+ *
+ * @brief allows to turn ON/OFF the specified LED.
+ *
+ *
+ * @param[in] led_control specifies the LED to be turned ON or OFF
+ *
+ * @return EMVCO_STATUS returns 0, if command processed successfully and returns
+ * 1, if command is not processed due to in-valid state. EMVCo mode should be ON
+ * to call this API
+ */
+EMVCO_STATUS set_led(uint8_t led_control);
+
+/**
+ * @brief allows to set the single byte value.
+ *
+ * @param[in] type - name of the config
+ * @param[in] length - length of the config value
+ * @param[in] value - actual byte value to be set
+ *
+ * @return EmvcoStatus returns EMVCO_STATUS_OK, if command processed
+ * successfully and returns EMVCO_STATUS_FAILED, if command is not processed
+ * successfully.
+ *
+ */
+EMVCO_STATUS set_byte_config(config_type_t type, const int32_t in_length,
+                             const int8_t in_value);
+
+/**
+ * @brief allows to set the byte array value.
+ *
+ * @param[in] type - name of the config
+ * @param[in] length - length of the config value
+ * @param[in] value - actual byte array value to be set
+ *
+ * @return EmvcoStatus returns EMVCO_STATUS_OK, if command processed
+ * successfully and returns EMVCO_STATUS_FAILED, if command is not processed
+ * successfully
+ *
+ */
+EMVCO_STATUS set_byte_array_config(config_type_t type, const int32_t in_length,
+                                   const uint8_t *in_value);
+
+/**
+ * @brief allows to set the string value.
+ *
+ * @param[in] type - name of the config
+ * @param[in] length - length of the config value
+ * @param[in] value - actual string value to be set
+ *
+ * @return EmvcoStatus returns EMVCO_STATUS_OK, if command processed
+ * successfully and returns EMVCO_STATUS_FAILED, if command is not processed
+ * successfully
+ *
+ */
+EMVCO_STATUS set_string_config(config_type_t type, const int32_t in_length,
+                               const char *p_value);
+
+#ifdef __cplusplus
+}
+#endif /*  C++ Compilation guard */
+/** @}*/
+#endif /* _EMVCO_HAL_H_ */
diff --git a/emvco_hal_impl/api/emvco_status.h b/emvco_hal_impl/api/emvco_status.h
new file mode 100644
index 0000000..4a87701
--- /dev/null
+++ b/emvco_hal_impl/api/emvco_status.h
@@ -0,0 +1,367 @@
+/******************************************************************************
+ *
+ *  Copyright 2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/*
+ * EMVCO Status Values - Function Return Codes
+ */
+
+#ifndef _EMVCO_STATUS_H_
+#define _EMVCO_STATUS_H_
+
+#include <emvco_common.h>
+/* Internally required by EMVCOSTVAL. */
+#define EMVCOSTSHL8 (8U)
+/* Required by EMVCOSTVAL. */
+#define EMVCOSTBLOWER ((EMVCO_STATUS)(0x00FFU))
+
+/*
+ *  EMVCO Status Composition Macro
+ *
+ *  This is the macro which must be used to compose status values.
+ *
+ *  emvco_comp_id Component ID, as defined in emvco_comp_id.h .
+ *  emvco_status Status values, as defined in emvco_status.h .
+ *
+ *  The macro is not required for the EMVCO_STATUS_SUCCESS value.
+ *  This is the only return value to be used directly.
+ *  For all other values it shall be used in assignment and conditional
+ * statements, e.g.:
+ *     EMVCO_STATUS status = EMVCOSTVAL(emvco_comp_id, emvco_status); ...
+ *     if (status == EMVCOSTVAL(emvco_comp_id, emvco_status)) ...
+ */
+#define EMVCOSTVAL(emvco_comp_id, emvco_status)                                \
+  (((emvco_status) == (EMVCO_STATUS_SUCCESS))                                  \
+       ? (EMVCO_STATUS_SUCCESS)                                                \
+       : ((((EMVCO_STATUS)(emvco_status)) & (EMVCOSTBLOWER)) |                 \
+          (((uint16_t)(emvco_comp_id)) << (EMVCOSTSHL8))))
+
+/*
+ * PHEMVCO_STATUS
+ * Get grp_retval from Status Code
+ */
+#define PHEMVCO_STATUS(emvco_status) ((emvco_status)&0x00FFU)
+#define PHNFCCID(emvco_status) (((emvco_status)&0xFF00U) >> 8)
+
+#define EMVCO_I2C_FRAGMENT_SIZE 512
+
+/*
+ * Indicates the NFC state
+ */
+typedef enum {
+  STATE_OFF = 1,
+  STATE_TURNING_ON,
+  STATE_ON,
+  STATE_TURNING_OFF
+} nfc_status_t;
+
+nfc_status_t nfc_status;
+
+/*
+ * The function indicates successful completion
+ */
+#define EMVCO_STATUS_SUCCESS (0x0000)
+
+/*
+ *  The function indicates successful completion
+ */
+#define EMVCO_STATUS_OK (EMVCO_STATUS_SUCCESS)
+
+/*
+ * At least one parameter could not be properly interpreted
+ */
+#define EMVCO_STATUS_INVALID_PARAMETER (0x0001)
+
+/*
+ * The buffer provided by the caller is too small
+ */
+#define EMVCO_STATUS_BUFFER_TOO_SMALL (0x0003)
+
+/*
+ * Device specifier/handle value is invalid for the operation
+ */
+#define EMVCO_STATUS_INVALID_DEVICE (0x0006)
+
+/*
+ * The function executed successfully but could have returned
+ * more information than space provided by the caller
+ */
+#define EMVCO_STATUS_MORE_INFORMATION (0x0008)
+
+/*
+ * No response from the remote device received: Time-out
+ */
+#define EMVCO_STATUS_RF_TIMEOUT (0x0009)
+
+/*
+ * RF Error during data transaction with the remote device
+ */
+#define EMVCO_STATUS_RF_ERROR (0x000A)
+
+/*
+ * Not enough resources Memory, Timer etc(e.g. allocation failed.)
+ */
+#define EMVCO_STATUS_INSUFFICIENT_RESOURCES (0x000C)
+
+/*
+ * A non-blocking function returns this immediately to indicate
+ * that an internal operation is in progress
+ */
+#define EMVCO_STATUS_PENDING (0x000D)
+
+/*
+ * A board communication error occurred
+ * (e.g. Configuration went wrong)
+ */
+#define EMVCO_STATUS_BOARD_COMMUNICATION_ERROR (0x000F)
+
+/*
+ * Invalid State of the particular state machine
+ */
+#define EMVCO_STATUS_INVALID_STATE (0x0011)
+
+/*
+ * This Layer is Not initialized, hence initialization required.
+ */
+#define EMVCO_STATUS_NOT_INITIALISED (0x0031)
+
+/*
+ * The Layer is already initialized, hence initialization repeated.
+ */
+#define EMVCO_STATUS_ALREADY_INITIALISED (0x0032)
+
+/*
+ * Feature not supported
+ */
+#define EMVCO_STATUS_FEATURE_NOT_SUPPORTED (0x0033)
+
+/*  The Unregistration command has failed because the user wants to unregister
+ * on
+ * an element for which he was not registered
+ */
+#define EMVCO_STATUS_NOT_REGISTERED (0x0034)
+
+/* The Registration command has failed because the user wants to register on
+ * an element for which he is already registered
+ */
+#define EMVCO_STATUS_ALREADY_REGISTERED (0x0035)
+
+/*  Single Tag with Multiple
+    Protocol support detected */
+#define EMVCO_STATUS_MULTIPLE_PROTOCOLS (0x0036)
+
+/*
+ * Feature not supported
+ */
+#define EMVCO_STATUS_MULTIPLE_TAGS (0x0037)
+
+/*
+ * A DESELECT event has occurred
+ */
+#define EMVCO_STATUS_DESELECTED (0x0038)
+
+/*
+ * A RELEASE event has occurred
+ */
+#define EMVCO_STATUS_RELEASED (0x0039)
+
+/*
+ * The operation is currently not possible or not allowed
+ */
+#define EMVCO_STATUS_NOT_ALLOWED (0x003A)
+
+/*
+ *  The system is busy with the previous operation.
+ */
+#define EMVCO_STATUS_BUSY (0x006F)
+
+/* NDEF Mapping error codes */
+
+/* The remote device (type) is not valid for this request. */
+#define EMVCO_STATUS_INVALID_REMOTE_DEVICE (0x001D)
+
+/* Read operation failed */
+#define EMVCO_STATUS_READ_FAILED (0x0014)
+
+/*
+ * Write operation failed
+ */
+#define EMVCO_STATUS_WRITE_FAILED (0x0015)
+
+/* Non Ndef Compliant */
+#define EMVCO_STATUS_NO_NDEF_SUPPORT (0x0016)
+
+/* Could not proceed further with the write operation: reached card EOF*/
+#define EMVCO_STATUS_EOF_NDEF_CONTAINER_REACHED (0x001A)
+
+/* Incorrect number of bytes received from the card*/
+#define EMVCO_STATUS_INVALID_RECEIVE_LENGTH (0x001B)
+
+/* The data format/composition is not understood/correct. */
+#define EMVCO_STATUS_INVALID_FORMAT (0x001C)
+
+/* There is not sufficient storage available. */
+#define EMVCO_STATUS_INSUFFICIENT_STORAGE (0x001F)
+
+/* The Ndef Format procedure has failed. */
+#define EMVCO_STATUS_FORMAT_ERROR (0x0023)
+
+/* The NCI Cedit error */
+#define EMVCO_STATUS_CREDIT_TIMEOUT (0x0024)
+
+/*
+ * Response Time out for the control message(NFCC not responded)
+ */
+#define EMVCO_STATUS_RESPONSE_TIMEOUT (0x0025)
+
+/*
+ * Device is already connected
+ */
+#define EMVCO_STATUS_ALREADY_CONNECTED (0x0026)
+
+/*
+ * Device is already connected
+ */
+#define EMVCO_STATUS_ANOTHER_DEVICE_CONNECTED (0x0027)
+
+/*
+ * Single Target Detected and Activated
+ */
+#define EMVCO_STATUS_SINGLE_TAG_ACTIVATED (0x0028)
+
+/*
+ * Single Target Detected
+ */
+#define EMVCO_STATUS_SINGLE_TAG_DISCOVERED (0x0029)
+
+/*
+ * Secure element Detected and Activated
+ */
+#define EMVCO_STATUS_SECURE_ELEMENT_ACTIVATED (0x0028)
+
+/*
+ * Unknown error Status Codes
+ */
+#define EMVCO_STATUS_UNKNOWN_ERROR (0x00FE)
+
+/*
+ * Status code for failure
+ */
+#define EMVCO_STATUS_FAILED (0x00FF)
+
+/*
+ * The function/command has been aborted
+ */
+#define EMVCO_STATUS_CMD_ABORTED (0x0002)
+
+/*
+ * No target found after poll
+ */
+#define EMVCO_STATUS_NO_TARGET_FOUND (0x000A)
+
+/* Attempt to disconnect a not connected remote device. */
+#define EMVCO_STATUS_NO_DEVICE_CONNECTED (0x000B)
+
+/* External RF field detected. */
+#define EMVCO_STATUS_EXTERNAL_RF_DETECTED (0x000E)
+
+/* Message is not allowed by the state machine
+ * (e.g. configuration went wrong)
+ */
+#define EMVCO_STATUS_MSG_NOT_ALLOWED_BY_FSM (0x0010)
+
+/*
+ * No access has been granted
+ */
+#define EMVCO_STATUS_ACCESS_DENIED (0x001E)
+
+/* No registry node matches the specified input data. */
+#define EMVCO_STATUS_NODE_NOT_FOUND (0x0017)
+
+/* The current module is busy ; one might retry later */
+#define EMVCO_STATUS_SMX_BAD_STATE (0x00F0)
+
+/* The Abort mechanism has failed for unexpected reason: user can try again*/
+#define EMVCO_STATUS_ABORT_FAILED (0x00F2)
+
+/* The Registration command has failed because the user wants to register as
+ * target
+ * on a operating mode not supported
+ */
+#define EMVCO_STATUS_REG_OPMODE_NOT_SUPPORTED (0x00F5)
+
+/*
+ * Shutdown in progress, cannot handle the request at this time.
+ */
+#define EMVCO_STATUS_SHUTDOWN (0x0091)
+
+/*
+ * Target is no more in RF field
+ */
+#define EMVCO_STATUS_TARGET_LOST (0x0092)
+
+/*
+ * Request is rejected
+ */
+#define EMVCO_STATUS_REJECTED (0x0093)
+
+/*
+ * Target is not connected
+ */
+#define EMVCO_STATUS_TARGET_NOT_CONNECTED (0x0094)
+
+/*
+ * Invalid handle for the operation
+ */
+#define EMVCO_STATUS_INVALID_HANDLE (0x0095)
+
+/*
+ * Process aborted
+ */
+#define EMVCO_STATUS_ABORTED (0x0096)
+
+/*
+ * Requested command is not supported
+ */
+#define EMVCO_STATUS_COMMAND_NOT_SUPPORTED (0x0097)
+
+/*
+ * Tag is not NDEF compilant
+ */
+#define EMVCO_STATUS_NON_NDEF_COMPLIANT (0x0098)
+
+/*
+ * Not enough memory available to complete the requested operation
+ */
+#define EMVCO_STATUS_NOT_ENOUGH_MEMORY (0x001F)
+
+/*
+ * Indicates incoming connection
+ */
+#define EMVCO_STATUS_INCOMING_CONNECTION (0x0045)
+
+/*
+ * Indicates Connection was successful
+ */
+#define EMVCO_STATUS_CONNECTION_SUCCESS (0x0046)
+
+/*
+ * Indicates Connection failed
+ */
+#define EMVCO_STATUS_CONNECTION_FAILED (0x0047)
+
+#endif /* _EMVCO_STATUS_H_ */
diff --git a/emvco_hal_impl/dm/emvco_dm.c b/emvco_hal_impl/dm/emvco_dm.c
new file mode 100644
index 0000000..879a608
--- /dev/null
+++ b/emvco_hal_impl/dm/emvco_dm.c
@@ -0,0 +1,1074 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include "emvco_tml_i2c.h"
+#include <cutils/properties.h>
+#include <emvco_cl.h>
+#include <emvco_config.h>
+#include <emvco_dm.h>
+#include <emvco_log.h>
+#include <emvco_nci_ext.h>
+#include <emvco_ncif.h>
+#include <emvco_tml.h>
+#include <errno.h>
+#include <log/log.h>
+#include <nci_parser.h>
+#include <osal_memory.h>
+#include <osal_message_queue_lib.h>
+#include <osal_thread.h>
+#include <peripherals.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+
+/*********************** Global Variables *************************************/
+#define PN547C2_CLOCK_SETTING
+#define CORE_RES_STATUS_BYTE 3
+
+static void get_set_config_impl(const char *p_nxp_conf);
+
+/* Processing of ISO 15693 EOF */
+extern uint8_t icode_send_eof;
+extern uint8_t icode_detected;
+static uint8_t cmd_icode_eof[] = {0x00, 0x00, 0x00};
+
+static uint8_t config_access = false;
+static uint8_t config_success = true;
+
+extern nci_clock_t nci_clock;
+extern emvco_args_t *modeSwitchArgs;
+
+/* NCI HAL Control structure */
+nci_hal_ctrl_t nci_hal_ctrl;
+
+/* NXP Poll Profile structure */
+nci_profile_Control_t nxpprofile_ctrl;
+
+/* TML Context */
+extern tml_emvco_context_t *gptml_emvco_context;
+uint32_t wFwVerRsp;
+
+extern uint16_t wFwVer;
+extern uint16_t rom_version;
+
+uint32_t timeoutTimerId = 0;
+bool emvco_debug_enabled;
+
+/*  Used to send Callback Transceive data during Mifare Write.
+ *  If this flag is enabled, no need to send response to Upper layer */
+bool sendRspToUpperLayer = true;
+
+nci_hal_sem config_data;
+
+nci_clock_t nci_clock = {0, {0}, false};
+
+rf_setting_t phNxpNciRfSet = {false, {0}};
+
+eeprom_area_t eeprom_area = {false, {0}};
+
+/**************** local methods used in this file only ************************/
+static void open_app_data_channel_complete(EMVCO_STATUS status);
+static int min_open_app_data_channel();
+static int handle_power_cycle(void);
+int min_close_app_data_channel(void);
+static void min_open_app_data_channel_complete(EMVCO_STATUS status);
+static int check_ncicmd_write_window(uint16_t cmd_len, uint8_t *p_cmd);
+static void read_app_data_complete(void *p_context,
+                                   osal_transact_info_t *pInfo);
+static void close_app_data_channel_complete(EMVCO_STATUS status);
+static void power_cycle_complete(EMVCO_STATUS status);
+static void kill_emvco_hal_client_thread(nci_hal_ctrl_t *p_nxpncihal_ctrl);
+static void *emvco_hal_client_thread(void *arg);
+static void print_res_status(uint8_t *p_rx_data, uint16_t *p_len);
+
+static void initialize_debug_enabled_flag();
+
+/******************************************************************************
+ * Function         initialize_debug_enabled_flag
+ *
+ * Description      This function gets the value for emvco_debug_enabled
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void initialize_debug_enabled_flag() {
+  unsigned long num = 0;
+  unsigned int num_len = 0;
+  if (get_byte_value(NAME_NXP_EMVCO_DEBUG_ENABLED, &num, &num_len)) {
+    LOG_EMVCOHAL_D("emvco_debug_enabled conf from file: %lu", num);
+    emvco_debug_enabled = (num == 0) ? false : true;
+  }
+  LOG_EMVCOHAL_D("emvco_debug_enabled : %d", emvco_debug_enabled);
+}
+
+/******************************************************************************
+ * Function         emvco_hal_client_thread
+ *
+ * Description      This function is a thread handler which handles all TML and
+ *                  NCI messages.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void *emvco_hal_client_thread(void *arg) {
+  nci_hal_ctrl_t *p_nci_hal_ctrl = (nci_hal_ctrl_t *)arg;
+  lib_emvco_message_t msg;
+
+  LOG_EMVCOHAL_D("thread started");
+
+  p_nci_hal_ctrl->thread_running = 1;
+
+  while (p_nci_hal_ctrl->thread_running == 1) {
+    /* Fetch next message from the NFC stack message queue */
+    if (osal_msg_rcv(p_nci_hal_ctrl->gDrvCfg.n_client_id, &msg, 0, 0) == -1) {
+      LOG_EMVCOHAL_E("NFC client received bad message");
+      continue;
+    }
+
+    if (p_nci_hal_ctrl->thread_running == 0) {
+      break;
+    }
+
+    switch (msg.e_msgType) {
+    case EMVCO_DEFERRED_CALL_MSG: {
+      REENTRANCE_LOCK();
+      lib_emvco_deferred_call_t *deferCall =
+          (lib_emvco_deferred_call_t *)(msg.p_msg_data);
+
+      deferCall->p_callback(deferCall->p_parameter);
+
+      osal_transact_info_t *pTransactionInfo =
+          (osal_transact_info_t *)deferCall->p_parameter;
+      process_emvco_mode_rsp(pTransactionInfo);
+      REENTRANCE_UNLOCK();
+
+      break;
+    }
+
+    case EMVCO_OPEN_CHNL_CPLT_MSG: {
+      REENTRANCE_LOCK();
+      if (nci_hal_ctrl.p_nfc_stack_cback != NULL) {
+        /* Send the event */
+        (*nci_hal_ctrl.p_nfc_stack_cback)(EMVCO_OPEN_CHNL_CPLT_EVT, STATUS_OK);
+      }
+      REENTRANCE_UNLOCK();
+      break;
+    }
+
+    case EMVCO_CLOSE_CHNL_CPLT_MSG: {
+      REENTRANCE_LOCK();
+      modeSwitchArgs->is_start_emvco = false;
+      if (nci_hal_ctrl.p_nfc_stack_cback != NULL) {
+        /* Send the event */
+        (*nci_hal_ctrl.p_nfc_stack_cback)(EMVCO_POLLING_STOP_EVT, STATUS_OK);
+        (*nci_hal_ctrl.p_nfc_stack_cback)(EMVCO_CLOSE_CHNL_CPLT_EVT, STATUS_OK);
+      }
+      kill_emvco_hal_client_thread(&nci_hal_ctrl);
+      REENTRANCE_UNLOCK();
+      break;
+    }
+
+    case EMVCO_OPEN_CHNL_ERROR_MSG: {
+      REENTRANCE_LOCK();
+      if (nci_hal_ctrl.p_nfc_stack_cback != NULL) {
+        /* Send the event */
+        (*nci_hal_ctrl.p_nfc_stack_cback)(EMVCO_OPEN_CHNL_ERROR_EVT,
+                                          STATUS_FAILED);
+      }
+      REENTRANCE_UNLOCK();
+      break;
+    }
+
+    case EMVCO_DATA_RX_EVT: {
+      REENTRANCE_LOCK();
+      if (nci_hal_ctrl.p_nfc_stack_data_cback != NULL) {
+        (*nci_hal_ctrl.p_nfc_stack_data_cback)(nci_hal_ctrl.rsp_len,
+                                               nci_hal_ctrl.p_rsp_data);
+      }
+      REENTRANCE_UNLOCK();
+      break;
+    }
+    case EMVCO_POLLING_STARTED_MSG: {
+      REENTRANCE_LOCK();
+      if (nci_hal_ctrl.p_nfc_stack_cback != NULL) {
+        /* Send the event */
+        LOG_EMVCOHAL_E("EMVCO_POLLING_STARTED_EVT propagted to upper layer");
+        (*nci_hal_ctrl.p_nfc_stack_cback)(EMVCO_POLLING_STARTED_EVT, STATUS_OK);
+      }
+      REENTRANCE_UNLOCK();
+      break;
+    }
+    case EMVCO_POOLING_STARTING_MSG: {
+      REENTRANCE_LOCK();
+      if (nci_hal_ctrl.p_nfc_stack_cback != NULL) {
+        /* Send the event */
+        (*nci_hal_ctrl.p_nfc_stack_cback)(EMVCO_POOLING_START_EVT, STATUS_OK);
+      }
+      REENTRANCE_UNLOCK();
+      break;
+    }
+    case EMVCO_POOLING_START_FAILED_MSG: {
+      REENTRANCE_LOCK();
+      if (nci_hal_ctrl.p_nfc_stack_cback != NULL) {
+        /* Send the event */
+        (*nci_hal_ctrl.p_nfc_stack_cback)(EMVCO_POOLING_START_EVT,
+                                          STATUS_FAILED);
+      }
+      REENTRANCE_UNLOCK();
+      break;
+    }
+    case EMVCO_UN_SUPPORTED_CARD_MSG: {
+      REENTRANCE_LOCK();
+      if (nci_hal_ctrl.p_nfc_stack_cback != NULL) {
+        (*nci_hal_ctrl.p_nfc_stack_cback)(EMVCO_UN_SUPPORTED_CARD_EVT,
+                                          STATUS_OK);
+      }
+      REENTRANCE_UNLOCK();
+      break;
+    }
+    }
+  }
+
+  return NULL;
+}
+
+/******************************************************************************
+ * Function         kill_emvco_hal_client_thread
+ *
+ * Description      This function safely kill the client thread and clean all
+ *                  resources.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static void kill_emvco_hal_client_thread(nci_hal_ctrl_t *p_nci_hal_ctrl) {
+  LOG_EMVCOHAL_D("Terminating phNxpNciHal client thread...");
+  p_nci_hal_ctrl->p_nfc_stack_cback = NULL;
+  p_nci_hal_ctrl->p_nfc_stack_data_cback = NULL;
+  p_nci_hal_ctrl->p_nfc_state_cback = NULL;
+  p_nci_hal_ctrl->thread_running = 0;
+
+  return;
+}
+
+int open_app_data_channelImpl(
+    emvco_stack_callback_t *p_cback, emvco_stack_data_callback_t *p_data_cback,
+    emvco_state_change_callback_t *p_nfc_state_cback) {
+  EMVCO_STATUS wConfigStatus = EMVCO_STATUS_SUCCESS;
+  EMVCO_STATUS status = EMVCO_STATUS_SUCCESS;
+  LOG_EMVCOHAL_D("open_app_data_channel nfc_status:%d", nfc_status);
+  read_config(emvco_hal_config_path);
+
+  if (nci_hal_ctrl.halStatus == HAL_STATUS_OPEN) {
+    LOG_EMVCOHAL_D("open_app_data_channel already open");
+    return EMVCO_STATUS_SUCCESS;
+  } else if (nci_hal_ctrl.halStatus == HAL_STATUS_CLOSE) {
+    status = min_open_app_data_channel();
+    if (status != EMVCO_STATUS_SUCCESS) {
+      LOG_EMVCOHAL_E("min_open_app_data_channel failed");
+      goto clean_and_return;
+    }
+  }
+  nci_hal_ctrl.p_nfc_stack_cback = p_cback;
+  nci_hal_ctrl.p_nfc_stack_data_cback = p_data_cback;
+  nci_hal_ctrl.p_nfc_state_cback = p_nfc_state_cback;
+  open_app_data_channel_complete(wConfigStatus);
+
+  return wConfigStatus;
+
+clean_and_return:
+  CONCURRENCY_UNLOCK();
+  if (p_cback != NULL) {
+    (*p_cback)(EMVCO_OPEN_CHNL_CPLT_EVT, STATUS_FAILED);
+  }
+
+  nci_hal_ctrl.p_nfc_stack_cback = NULL;
+  nci_hal_ctrl.p_nfc_stack_data_cback = NULL;
+  cleanup_monitor();
+  nci_hal_ctrl.halStatus = HAL_STATUS_CLOSE;
+  return EMVCO_STATUS_FAILED;
+}
+
+/******************************************************************************
+ * Function         min_open_app_data_channel
+ *
+ * Description      This function initializes the least required resources to
+ *                  communicate to NFCC.This is mainly used to communicate to
+ *                  NFCC when NFC service is not available.
+ *
+ *
+ * Returns          This function return EMVCO_STATUS_SUCCESS (0) in case of
+ *                  success. In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+int min_open_app_data_channel() {
+  osal_emvco_config_t tOsalConfig;
+  tml_emvco_Config_t tTmlConfig;
+  char *p_nfc_dev_node = NULL;
+  unsigned int dev_node_size = 0;
+  uint32_t mode_switch_status;
+  EMVCO_STATUS wConfigStatus = EMVCO_STATUS_SUCCESS;
+  EMVCO_STATUS status = EMVCO_STATUS_SUCCESS;
+  LOG_EMVCOHAL_D("phNxpNci_MinOpen(): enter");
+
+  if (nci_hal_ctrl.halStatus == HAL_STATUS_MIN_OPEN) {
+    LOG_EMVCOHAL_D("min_open_app_data_channel(): already open");
+    return EMVCO_STATUS_SUCCESS;
+  }
+
+  int init_retry_cnt = 0;
+  int8_t ret_val = 0x00;
+
+  /*Create the timer for extns write response*/
+  timeoutTimerId = osal_timer_create();
+
+  if (init_monitor() == NULL) {
+    LOG_EMVCOHAL_E("Init monitor failed");
+    return EMVCO_STATUS_FAILED;
+  }
+
+  CONCURRENCY_LOCK();
+  osal_memset(&nci_hal_ctrl, 0x00, sizeof(nci_hal_ctrl));
+  osal_memset(&tOsalConfig, 0x00, sizeof(tOsalConfig));
+  osal_memset(&tTmlConfig, 0x00, sizeof(tTmlConfig));
+  osal_memset(&nxpprofile_ctrl, 0, sizeof(nci_profile_Control_t));
+
+  /*Init binary semaphore to handle back to back NCI write synchronization*/
+  if (0 != osal_sem_init(&nci_hal_ctrl.sync_nci_write, 0, 1)) {
+    LOG_EMVCOHAL_E("osal_sem_init() FAiled for sync_nci_write, errno = 0x%02X",
+                   errno);
+    goto clean_and_return;
+  }
+
+  /* By default HAL status is HAL_STATUS_OPEN */
+  nci_hal_ctrl.halStatus = HAL_STATUS_OPEN;
+
+  /*nci version NCI_VERSION_UNKNOWN version by default*/
+  nci_hal_ctrl.nci_info.nci_version = NCI_VERSION_UNKNOWN;
+
+  /* Read the nfc device node name */
+  if (!get_byte_array_value(NAME_NXP_EMVCO_DEV_NODE, &p_nfc_dev_node,
+                            &dev_node_size)) {
+    LOG_EMVCOHAL_D(
+        "Invalid nfc device node name keeping the default device node "
+        "/dev/nxpnfc");
+    int len = (sizeof(char) * strlen(DEF_NFC_DEV_NODE) + 1);
+    p_nfc_dev_node = (char *)osal_malloc(len);
+    if (p_nfc_dev_node == NULL) {
+      LOG_EMVCOHAL_E("malloc of p_nfc_dev_node failed ");
+      goto clean_and_return;
+    }
+    strlcpy(p_nfc_dev_node, DEF_NFC_DEV_NODE, len);
+  }
+
+  /* Configure hardware link */
+  nci_hal_ctrl.gDrvCfg.n_client_id = osal_msg_get(0, 0600);
+  nci_hal_ctrl.gDrvCfg.n_link_type = ENUM_LINK_TYPE_I2C;
+  tTmlConfig.p_dev_name = (int8_t *)p_nfc_dev_node;
+  tOsalConfig.dw_callback_thread_id =
+      (uintptr_t)nci_hal_ctrl.gDrvCfg.n_client_id;
+  tOsalConfig.p_log_file = NULL;
+  tTmlConfig.dw_get_msg_thread_id = (uintptr_t)nci_hal_ctrl.gDrvCfg.n_client_id;
+
+  /* Initialize TML layer */
+  wConfigStatus = tml_init(&tTmlConfig);
+  if (wConfigStatus != EMVCO_STATUS_SUCCESS) {
+    LOG_EMVCOHAL_E("tml_init Failed");
+    goto clean_and_return;
+  } else {
+    if (p_nfc_dev_node != NULL) {
+      osal_free(p_nfc_dev_node);
+      p_nfc_dev_node = NULL;
+    }
+  }
+
+  /* Create the client thread */
+  ret_val = osal_thread_create(&nci_hal_ctrl.emvco_hal_client_thread, NULL,
+                               emvco_hal_client_thread, &nci_hal_ctrl);
+  if (ret_val != 0) {
+    LOG_EMVCOHAL_E("osal_thread_create failed");
+    wConfigStatus = tml_shutdown_cleanup();
+    goto clean_and_return;
+  }
+
+  CONCURRENCY_UNLOCK();
+
+  /* call read pending */
+  status =
+      tml_read(nci_hal_ctrl.p_cmd_data, NCI_MAX_DATA_LEN,
+               (transact_completion_callback_t)&read_app_data_complete, NULL);
+  if (status != EMVCO_STATUS_PENDING) {
+    LOG_EMVCOHAL_E("TML Read status error status = %x", status);
+    wConfigStatus = tml_shutdown_cleanup();
+    wConfigStatus = EMVCO_STATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  nci_ext_init();
+
+init_retry:
+
+  mode_switch_status = tml_ioctl(NFCCModeSwitchOn);
+  LOG_EMVCOHAL_D("%s modeswitch IOCTL status:%d", __func__, mode_switch_status);
+  led_switch_control(GREEN_LED_ON);
+  status = send_core_reset(NCI_RESET_TYPE_KEEP_CFG);
+  if (status != EMVCO_STATUS_SUCCESS) {
+    LOG_EMVCOHAL_E("NCI_CORE_RESET: Failed");
+    if (init_retry_cnt < 3) {
+      init_retry_cnt++;
+      (void)handle_power_cycle();
+      goto init_retry;
+    } else
+      init_retry_cnt = 0;
+    wConfigStatus = tml_shutdown_cleanup();
+    wConfigStatus = EMVCO_STATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  if (nci_hal_ctrl.nci_info.nci_version == NCI_VERSION_2_0) {
+    status = send_core_init(NCI_VERSION_2_0);
+  } else {
+    status = send_core_init(NCI_VERSION_UNKNOWN);
+  }
+  if (status != EMVCO_STATUS_SUCCESS) {
+    LOG_EMVCOHAL_E("NCI_CORE_INIT : Failed");
+    if (init_retry_cnt < 3) {
+      init_retry_cnt++;
+      (void)handle_power_cycle();
+      goto init_retry;
+    } else
+      init_retry_cnt = 0;
+    wConfigStatus = tml_shutdown_cleanup();
+    wConfigStatus = EMVCO_STATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  get_set_config_impl(NAME_NXP_PCD_SETTINGS);
+  get_set_config_impl(NAME_NXP_SET_CONFIG);
+  get_set_config_impl(NAME_NXP_GET_CONFIG);
+
+  /* Call open complete */
+  min_open_app_data_channel_complete(wConfigStatus);
+  LOG_EMVCOHAL_D("min_open_app_data_channel(): exit");
+  return wConfigStatus;
+
+clean_and_return:
+  min_close_app_data_channel();
+  CONCURRENCY_UNLOCK();
+  if (p_nfc_dev_node != NULL) {
+    osal_free(p_nfc_dev_node);
+    p_nfc_dev_node = NULL;
+  }
+  return EMVCO_STATUS_FAILED;
+}
+
+/******************************************************************************
+ * Function         get_set_config_impl
+ *
+ * Description      This function gets/sets the configuration command using
+ *config key and sends the set config command to controller
+ *
+ * Parameter        Takes the configuration key as input
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static void get_set_config_impl(const char *p_conf_key) {
+  LOG_EMVCOHAL_D("%s", __func__);
+  int retry_cnt = 0;
+  char *buffer = NULL;
+  unsigned int bufflen = 0;
+
+  if ((get_byte_array_value(p_conf_key, &buffer, &bufflen)) &&
+      (buffer != NULL)) {
+    do {
+      if (EMVCO_STATUS_SUCCESS == send_ext_cmd(bufflen, (uint8_t *)buffer)) {
+        retry_cnt = 0;
+        break;
+      } else {
+        LOG_EMVCOHAL_E("Failed to set %s configuration\n ", p_conf_key);
+        ++retry_cnt;
+      }
+    } while (retry_cnt < 3);
+  } else {
+    LOG_EMVCOHAL_E("Failed to set %s configuration. Please re-try by updating "
+                   "the configuration file with proper value \n ",
+                   p_conf_key);
+  }
+  free(buffer);
+  buffer = NULL;
+}
+
+int open_app_data_channel(emvco_stack_callback_t *p_cback,
+                          emvco_stack_data_callback_t *p_data_cback,
+                          emvco_state_change_callback_t *p_nfc_state_cback) {
+  LOG_EMVCOHAL_D("%s:", __func__);
+  read_config(emvco_hal_config_path);
+  if (modeSwitchArgs == NULL) {
+    modeSwitchArgs =
+        (struct emvco_args *)osal_malloc(sizeof(struct emvco_args));
+    modeSwitchArgs->current_discovery_mode = UNKNOWN;
+    modeSwitchArgs->emvco_config = -1;
+    modeSwitchArgs->is_start_emvco = false;
+  }
+  m_p_nfc_stack_cback = p_cback;
+  m_p_nfc_stack_data_cback = p_data_cback;
+  m_p_nfc_state_cback = p_nfc_state_cback;
+
+  /* initialize log levels */
+  initialize_debug_enabled_flag();
+  initialize_log_level();
+  return EMVCO_STATUS_SUCCESS;
+}
+
+/******************************************************************************
+ * Function         min_open_app_data_channel_complete
+ *
+ * Description      This function updates the status of
+ *min_open_app_data_channel_complete to halstatus.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static void min_open_app_data_channel_complete(EMVCO_STATUS status) {
+  if (status == EMVCO_STATUS_SUCCESS) {
+    nci_hal_ctrl.halStatus = HAL_STATUS_MIN_OPEN;
+  }
+
+  return;
+}
+
+/******************************************************************************
+ * Function         open_app_data_channel_complete
+ *
+ * Description      This function inform the status of open_app_data_channel
+ *                  function to libnfc-nci.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static void open_app_data_channel_complete(EMVCO_STATUS status) {
+  static lib_emvco_message_t msg;
+
+  if (status == EMVCO_STATUS_SUCCESS) {
+    msg.e_msgType = EMVCO_OPEN_CHNL_CPLT_MSG;
+    nci_hal_ctrl.hal_open_status = true;
+    nci_hal_ctrl.halStatus = HAL_STATUS_OPEN;
+  } else {
+    msg.e_msgType = EMVCO_OPEN_CHNL_ERROR_MSG;
+  }
+
+  msg.p_msg_data = NULL;
+  msg.size = 0;
+
+  tml_deferred_call(gptml_emvco_context->dw_callback_thread_id,
+                    (lib_emvco_message_t *)&msg);
+
+  return;
+}
+
+int send_app_data(uint16_t data_len, const uint8_t *p_data) {
+  return send_app_data_internal(data_len, p_data);
+}
+
+int send_app_data_internal(uint16_t data_len, const uint8_t *p_data) {
+  EMVCO_STATUS status = EMVCO_STATUS_FAILED;
+  static lib_emvco_message_t msg;
+  if (nci_hal_ctrl.halStatus != HAL_STATUS_OPEN) {
+    LOG_EMVCOHAL_E("cmd_len exceeds limit NCI_MAX_DATA_LEN");
+    return EMVCO_STATUS_FAILED;
+  }
+  if ((p_data[0] & (NCI_MSG_TYPE_CMD << NCI_MT_SHIFT))) {
+    LOG_EMVCOHAL_E("NCI command not allowed to send to controller");
+    return EMVCO_STATUS_FEATURE_NOT_SUPPORTED;
+  }
+
+  /* Create local copy of cmd_data */
+  osal_memcpy(nci_hal_ctrl.p_cmd_data, p_data, data_len);
+  nci_hal_ctrl.cmd_len = data_len;
+
+  /* Check for NXP ext before sending write */
+  status = send_app_data_ext(&nci_hal_ctrl.cmd_len, nci_hal_ctrl.p_cmd_data,
+                             &nci_hal_ctrl.rsp_len, nci_hal_ctrl.p_rsp_data);
+  if (status != EMVCO_STATUS_SUCCESS) {
+    /* Do not send packet to controller, send response directly */
+    msg.e_msgType = EMVCO_DATA_RX_EVT;
+    msg.p_msg_data = NULL;
+    msg.size = 0;
+
+    tml_deferred_call(gptml_emvco_context->dw_callback_thread_id,
+                      (lib_emvco_message_t *)&msg);
+    goto clean_and_return;
+  }
+
+  CONCURRENCY_LOCK();
+  data_len =
+      send_app_data_unlocked(nci_hal_ctrl.cmd_len, nci_hal_ctrl.p_cmd_data);
+  CONCURRENCY_UNLOCK();
+
+  if (icode_send_eof == 1) {
+    usleep(10000);
+    icode_send_eof = 2;
+    status = send_ext_cmd(3, cmd_icode_eof);
+    if (status != EMVCO_STATUS_SUCCESS) {
+      LOG_EMVCOHAL_E("ICODE end of frame command failed");
+    }
+  }
+
+clean_and_return:
+  /* No data written */
+  return data_len;
+}
+
+int send_app_data_unlocked(uint16_t data_len, const uint8_t *p_data) {
+  nci_hal_sem cb_data;
+  /* Create the local semaphore */
+  if (init_cb_data(&cb_data, NULL) != EMVCO_STATUS_SUCCESS) {
+    LOG_EMVCOHAL_D("send_app_data_unlocked Create cb data failed");
+    data_len = 0;
+    goto clean_and_return;
+  }
+
+  /* Create local copy of cmd_data */
+  osal_memcpy(nci_hal_ctrl.p_cmd_data, p_data, data_len);
+  nci_hal_ctrl.cmd_len = data_len;
+
+  /* check for write synchronyztion */
+  if (check_ncicmd_write_window(nci_hal_ctrl.cmd_len,
+                                nci_hal_ctrl.p_cmd_data) !=
+      EMVCO_STATUS_SUCCESS) {
+    LOG_EMVCOHAL_D("send_app_data_unlocked check nci write window failed");
+    data_len = 0;
+    goto clean_and_return;
+  }
+  send_emvco_data(nci_hal_ctrl.p_cmd_data, nci_hal_ctrl.cmd_len);
+
+clean_and_return:
+  cleanup_cb_data(&cb_data);
+  return data_len;
+}
+static bool is_data_credit_received(osal_transact_info_t *pInfo) {
+  if ((6 == pInfo->w_length) &&
+      (pInfo->p_buff[0] == NCI_MT_NTF &&
+       pInfo->p_buff[1] == NCI_CORE_CONN_CREDITS_NTF &&
+       pInfo->p_buff[2] == NCI_CORE_CONN_CREDITS_NTF_LEN &&
+       pInfo->p_buff[3] == NCI_CORE_CONN_CREDITS_NTF_NO_OF_ENTRY &&
+       pInfo->p_buff[4] == NCI_CORE_CONN_CREDITS_NTF_CONN_ID &&
+       pInfo->p_buff[5] == NCI_CORE_CONN_CREDITS_NTF_CONN_CREDITS)) {
+    return true;
+  } else {
+    return false;
+  }
+}
+
+static bool is_rf_link_loss_received(osal_transact_info_t *pInfo) {
+  if ((5 == pInfo->w_length) &&
+      (pInfo->p_buff[0] == NCI_RF_NTF &&
+       pInfo->p_buff[1] == NCI_RF_DEACTIVATE_RES_NTF &&
+       pInfo->p_buff[2] == NCI_DEACTIVATE_NTF_LEN &&
+       pInfo->p_buff[3] == NCI_DEACT_TYPE_DISCOVERY &&
+       pInfo->p_buff[4] == NCI_DEACT_RESON_RF_LINK_LOSS)) {
+    nci_hal_ctrl.frag_rsp.data_pos = 0;
+    RESET_CHAINED_DATA();
+    return true;
+  } else {
+    return false;
+  }
+}
+
+static void read_app_data_complete(void *p_context,
+                                   osal_transact_info_t *pInfo) {
+  EMVCO_STATUS status = EMVCO_STATUS_FAILED;
+  int sem_val;
+  UNUSED(p_context);
+  if (nci_hal_ctrl.read_retry_cnt == 1) {
+    nci_hal_ctrl.read_retry_cnt = 0;
+  }
+  if (pInfo->w_status == EMVCO_STATUS_SUCCESS) {
+
+    osal_sem_getvalue(&(nci_hal_ctrl.sync_nci_write), &sem_val);
+
+    if (((pInfo->p_buff[0] & NCI_MT_MASK) == NCI_MT_RSP ||
+         is_data_credit_received(pInfo) || is_rf_link_loss_received(pInfo)) &&
+        sem_val == 0) {
+      osal_sem_post(&(nci_hal_ctrl.sync_nci_write));
+    }
+    /*Check the Omapi command response and store in dedicated buffer to solve
+     * sync issue*/
+    if (pInfo->p_buff[0] == 0x4F && pInfo->p_buff[1] == 0x01 &&
+        pInfo->p_buff[2] == 0x01) {
+      nci_hal_ctrl.p_rx_ese_data = pInfo->p_buff;
+      nci_hal_ctrl.rx_ese_data_len = pInfo->w_length;
+      SEM_POST(&(nci_hal_ctrl.ext_cb_data));
+    } else {
+      nci_hal_ctrl.p_rx_data = pInfo->p_buff;
+      nci_hal_ctrl.rx_data_len = pInfo->w_length;
+      status =
+          process_ext_rsp(nci_hal_ctrl.p_rx_data, &nci_hal_ctrl.rx_data_len);
+    }
+
+    print_res_status(pInfo->p_buff, &pInfo->w_length);
+    /* Check if response should go to hal module only */
+    if (nci_hal_ctrl.hal_ext_enabled == TRUE &&
+        (nci_hal_ctrl.p_rx_data[0x00] & NCI_MT_MASK) == NCI_MT_RSP) {
+      if (status == EMVCO_STATUS_FAILED) {
+        nci_hal_ctrl.ext_cb_data.status = status;
+      }
+      /* Unlock semaphore only for responses*/
+      if ((nci_hal_ctrl.p_rx_data[0x00] & NCI_MT_MASK) == NCI_MT_RSP ||
+          ((icode_detected == true) && (icode_send_eof == 3))) {
+        /* Unlock semaphore */
+        SEM_POST(&(nci_hal_ctrl.ext_cb_data));
+      }
+    } // Notification Checking
+    else if ((nci_hal_ctrl.hal_ext_enabled == TRUE) &&
+             ((nci_hal_ctrl.p_rx_data[0x00] & NCI_MT_MASK) == NCI_MT_NTF) &&
+             (nci_hal_ctrl.nci_info.wait_for_ntf == TRUE)) {
+      /* Unlock semaphore waiting for only  ntf*/
+      SEM_POST(&(nci_hal_ctrl.ext_cb_data));
+      nci_hal_ctrl.nci_info.wait_for_ntf = FALSE;
+    }
+    /* Read successful send the event to higher layer */
+    else if ((nci_hal_ctrl.p_nfc_stack_data_cback != NULL) &&
+             (status == EMVCO_STATUS_SUCCESS)) {
+      process_emvco_data(nci_hal_ctrl.p_rx_data, nci_hal_ctrl.rx_data_len);
+    }
+  } else {
+    LOG_EMVCOHAL_E("read error status = 0x%x", pInfo->w_status);
+  }
+
+  if (nci_hal_ctrl.halStatus == HAL_STATUS_CLOSE &&
+      nci_hal_ctrl.nci_info.wait_for_ntf == FALSE) {
+    return;
+  }
+  /* Read again because read must be pending always.*/
+  status = tml_read(
+      // Rx_data, NCI_MAX_DATA_LEN,
+      nci_hal_ctrl.p_rsp_data, NCI_MAX_DATA_LEN,
+      (transact_completion_callback_t)&read_app_data_complete, NULL);
+  if (status != EMVCO_STATUS_PENDING) {
+    LOG_EMVCOHAL_E("read status error status = %x", status);
+    /* TODO: Not sure how to handle this ? */
+  }
+
+  return;
+}
+
+int close_app_data_channel(bool bShutdown) {
+  EMVCO_STATUS status;
+  const uint8_t cmd_ven_disable_nci[] = {0x05, 0x01, 0xA0, 0x07, 0x01, 0x02};
+  uint8_t *p_cmd_ven_disable_nci = (uint8_t *)cmd_ven_disable_nci;
+  if (nci_hal_ctrl.halStatus == HAL_STATUS_CLOSE) {
+    LOG_EMVCOHAL_D("close_app_data_channel is already closed, ignoring close");
+    return EMVCO_STATUS_FAILED;
+  }
+
+  CONCURRENCY_LOCK();
+
+  int sem_val;
+  osal_sem_getvalue(&(nci_hal_ctrl.sync_nci_write), &sem_val);
+  if (sem_val == 0) {
+    osal_sem_post(&(nci_hal_ctrl.sync_nci_write));
+  }
+  if (!bShutdown) {
+    status = send_core_set_config(&p_cmd_ven_disable_nci[0],
+                                  p_cmd_ven_disable_nci[1]);
+    if (status != EMVCO_STATUS_SUCCESS) {
+      LOG_EMVCOHAL_E("CMD_VEN_DISABLE_NCI: Failed");
+    }
+  }
+  nci_hal_ctrl.halStatus = HAL_STATUS_CLOSE;
+  status = send_core_reset(NCI_RESET_TYPE_KEEP_CFG);
+  if (status != EMVCO_STATUS_SUCCESS) {
+    LOG_EMVCOHAL_E("NCI_CORE_RESET: Failed");
+  }
+  osal_sem_destroy(&nci_hal_ctrl.sync_nci_write);
+  if (NULL != gptml_emvco_context->p_dev_handle) {
+    close_app_data_channel_complete(EMVCO_STATUS_SUCCESS);
+    /* Abort any pending read and write */
+    status = tml_read_abort();
+
+    osal_timer_cleanup();
+
+    status = tml_shutdown();
+
+    if (0 !=
+        osal_thread_join(nci_hal_ctrl.emvco_hal_client_thread, (void **)NULL)) {
+      LOG_EMVCO_TML_E("Fail to kill client thread!");
+    }
+
+    tml_cleanup();
+
+    osal_msg_release(nci_hal_ctrl.gDrvCfg.n_client_id);
+
+    osal_memset(&nci_hal_ctrl, 0x00, sizeof(nci_hal_ctrl));
+
+    LOG_EMVCOHAL_D("close_app_data_channel - phOsalNfc_DeInit completed");
+  }
+  CONCURRENCY_UNLOCK();
+  cleanup_monitor();
+  /* Return success always */
+  return EMVCO_STATUS_SUCCESS;
+}
+/******************************************************************************
+ * Function         min_close_app_data_channel
+ *
+ * Description      This function close the NFCC interface and free all
+ *                  resources.This is called by libnfc-nci on NFC service stop.
+ *
+ * Returns          Always return EMVCO_STATUS_SUCCESS (0).
+ *
+ ******************************************************************************/
+int min_close_app_data_channel(void) {
+  EMVCO_STATUS status;
+  /*NCI_RESET_CMD*/
+  uint8_t cmd_reset_nci[] = {0x20, 0x00, 0x01, 0x00};
+  CONCURRENCY_LOCK();
+  nci_hal_ctrl.halStatus = HAL_STATUS_CLOSE;
+  status = send_ext_cmd(sizeof(cmd_reset_nci), cmd_reset_nci);
+  if (status != EMVCO_STATUS_SUCCESS) {
+    LOG_EMVCOHAL_E("NCI_CORE_RESET: Failed");
+  }
+  osal_sem_destroy(&nci_hal_ctrl.sync_nci_write);
+  if (NULL != gptml_emvco_context->p_dev_handle) {
+    close_app_data_channel_complete(EMVCO_STATUS_SUCCESS);
+    /* Abort any pending read and write */
+    status = tml_read_abort();
+
+    osal_timer_cleanup();
+
+    status = tml_shutdown();
+
+    if (0 !=
+        pthread_join(nci_hal_ctrl.emvco_hal_client_thread, (void **)NULL)) {
+      LOG_EMVCO_TML_E("Fail to kill client thread!");
+    }
+
+    tml_cleanup();
+
+    osal_msg_release(nci_hal_ctrl.gDrvCfg.n_client_id);
+
+    osal_memset(&nci_hal_ctrl, 0x00, sizeof(nci_hal_ctrl));
+
+    LOG_EMVCOHAL_D("close_app_data_channel - phOsalNfc_DeInit completed");
+  }
+
+  CONCURRENCY_UNLOCK();
+
+  cleanup_monitor();
+
+  return EMVCO_STATUS_SUCCESS;
+}
+/******************************************************************************
+ * Function         close_app_data_channel_complete
+ *
+ * Description      This function inform libnfc-nci about result of
+ *                  close_app_data_channel.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+void close_app_data_channel_complete(EMVCO_STATUS status) {
+  static lib_emvco_message_t msg;
+
+  if (status == EMVCO_STATUS_SUCCESS) {
+    msg.e_msgType = EMVCO_CLOSE_CHNL_CPLT_MSG;
+  } else {
+    msg.e_msgType = EMVCO_OPEN_CHNL_ERROR_MSG;
+  }
+  msg.p_msg_data = NULL;
+  msg.size = 0;
+
+  tml_deferred_call(gptml_emvco_context->dw_callback_thread_id, &msg);
+
+  return;
+}
+
+/******************************************************************************
+ * Function         handle_power_cycle
+ *
+ * Description      This function is called by libnfc-nci when power cycling is
+ *                  performed. When processing is complete it is notified to
+ *                  libnfc-nci through power_cycle_complete.
+ *
+ * Returns          Always return EMVCO_STATUS_SUCCESS (0).
+ *
+ ******************************************************************************/
+int handle_power_cycle(void) {
+  LOG_EMVCOHAL_D("Power Cycle");
+  EMVCO_STATUS status = EMVCO_STATUS_FAILED;
+  if (nci_hal_ctrl.halStatus != HAL_STATUS_OPEN) {
+    LOG_EMVCOHAL_D("Power Cycle failed due to hal status not open");
+    return EMVCO_STATUS_FAILED;
+  }
+  status = tml_ioctl(ResetDevice);
+
+  if (EMVCO_STATUS_SUCCESS == status) {
+    LOG_EMVCOHAL_D("Controller Reset - SUCCESS\n");
+  } else {
+    LOG_EMVCOHAL_D("Controller Reset - FAILED\n");
+  }
+  power_cycle_complete(EMVCO_STATUS_SUCCESS);
+  return EMVCO_STATUS_SUCCESS;
+}
+
+/******************************************************************************
+ * Function         power_cycle_complete
+ *
+ * Description      This function is called to provide the status of
+ *                  handle_power_cycle to libnfc-nci through callback.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static void power_cycle_complete(EMVCO_STATUS status) {
+  static lib_emvco_message_t msg;
+
+  if (status == EMVCO_STATUS_SUCCESS) {
+    msg.e_msgType = EMVCO_OPEN_CHNL_CPLT_MSG;
+  } else {
+    msg.e_msgType = EMVCO_OPEN_CHNL_ERROR_MSG;
+  }
+  msg.p_msg_data = NULL;
+  msg.size = 0;
+
+  tml_deferred_call(gptml_emvco_context->dw_callback_thread_id, &msg);
+
+  return;
+}
+/******************************************************************************
+ * Function         check_ncicmd_write_window
+ *
+ * Description      This function is called to check the write synchroniztion
+ *                  status if write already aquired then wait for corresponding
+                    read to complete.
+ *
+ * Returns          return 0 on success and -1 on fail.
+ *
+ ******************************************************************************/
+
+int check_ncicmd_write_window(uint16_t cmd_len, uint8_t *p_cmd) {
+  EMVCO_STATUS status = EMVCO_STATUS_FAILED;
+  int sem_timedout = 2, s;
+  struct timespec ts;
+
+  if (cmd_len < 1) {
+    android_errorWriteLog(0x534e4554, "153880357");
+    return EMVCO_STATUS_FAILED;
+  }
+
+  if ((p_cmd[0] & 0xF0) == 0x20 || (p_cmd[0] & 0xF0) == 0x00) {
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    ts.tv_sec += sem_timedout;
+
+    while ((s = osal_sem_timedwait_monotonic_np(&nci_hal_ctrl.sync_nci_write,
+                                                &ts)) == -1 &&
+           errno == EINTR)
+      continue; /* Restart if interrupted by handler */
+
+    if (s != -1) {
+      status = EMVCO_STATUS_SUCCESS;
+    }
+  } else {
+    /* cmd window check not required for writing non nci cmd and data packet */
+    status = EMVCO_STATUS_SUCCESS;
+  }
+  return status;
+}
+
+/******************************************************************************
+ * Function         print_res_status
+ *
+ * Description      This function is called to process the response status
+ *                  and print the status byte.
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static void print_res_status(uint8_t *p_rx_data, uint16_t *p_len) {
+  static uint8_t response_buf[][30] = {"STATUS_OK",
+                                       "STATUS_REJECTED",
+                                       "STATUS_RF_FRAME_CORRUPTED",
+                                       "STATUS_FAILED",
+                                       "STATUS_NOT_INITIALIZED",
+                                       "STATUS_SYNTAX_ERROR",
+                                       "STATUS_SEMANTIC_ERROR",
+                                       "RFU",
+                                       "RFU",
+                                       "STATUS_INVALID_PARAM",
+                                       "STATUS_MESSAGE_SIZE_EXCEEDED",
+                                       "STATUS_UNDEFINED"};
+  int status_byte;
+  if (p_rx_data[0] == 0x40 && (p_rx_data[1] == 0x02 || p_rx_data[1] == 0x03)) {
+    if (p_rx_data[2] && p_rx_data[3] <= 10) {
+      status_byte = p_rx_data[CORE_RES_STATUS_BYTE];
+      LOG_EMVCOHAL_D("%s: response status =%s", __func__,
+                     response_buf[status_byte]);
+    } else {
+      LOG_EMVCOHAL_D("%s: response status =%s", __func__, response_buf[11]);
+    }
+    if (nci_clock.is_clock_set) {
+      int i, len = sizeof(nci_clock.p_rx_data);
+      if (*p_len > len) {
+        __osal_log_error_write(0x534e4554, "169257710");
+      } else {
+        len = *p_len;
+      }
+      for (i = 0; i < len; i++) {
+        nci_clock.p_rx_data[i] = p_rx_data[i];
+      }
+    }
+
+    else if (phNxpNciRfSet.is_get_config) {
+      int i, len = sizeof(phNxpNciRfSet.p_rx_data);
+      if (*p_len > len) {
+        __osal_log_error_write(0x534e4554, "169258733");
+      } else {
+        len = *p_len;
+      }
+      for (i = 0; i < len; i++) {
+        phNxpNciRfSet.p_rx_data[i] = p_rx_data[i];
+        // LOG_EMVCOHAL_D("%s: response status =0x%x",__func__,p_rx_data[i]);
+      }
+    } else if (eeprom_area.is_get_eeprom_area) {
+      int i, len = sizeof(eeprom_area.p_rx_data) + 8;
+      if (*p_len > len) {
+        __osal_log_error_write(0x534e4554, "169258884");
+      } else {
+        len = *p_len;
+      }
+      for (i = 8; i < len; i++) {
+        eeprom_area.p_rx_data[i - 8] = p_rx_data[i];
+      }
+    } else if (nci_hal_ctrl.gpio_info.state == GPIO_STORE) {
+      LOG_EMVCOHAL_D("%s: Storing GPIO Values...", __func__);
+      nci_hal_ctrl.gpio_info.values[0] = p_rx_data[9];
+      nci_hal_ctrl.gpio_info.values[1] = p_rx_data[8];
+    } else if (nci_hal_ctrl.gpio_info.state == GPIO_RESTORE) {
+      LOG_EMVCOHAL_D("%s: Restoring GPIO Values...", __func__);
+      nci_hal_ctrl.gpio_info.values[0] = p_rx_data[9];
+      nci_hal_ctrl.gpio_info.values[1] = p_rx_data[8];
+    }
+  }
+
+  if (p_rx_data[2] && (config_access == true)) {
+    if (p_rx_data[3] != EMVCO_STATUS_SUCCESS) {
+      LOG_EMVCOHAL_W("Invalid Data from config file.");
+      config_success = false;
+    }
+  }
+}
diff --git a/emvco_hal_impl/dm/emvco_dm.h b/emvco_hal_impl/dm/emvco_dm.h
new file mode 100644
index 0000000..7abcd39
--- /dev/null
+++ b/emvco_hal_impl/dm/emvco_dm.h
@@ -0,0 +1,340 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _EMVCO_DM_H_
+#define _EMVCO_DM_H_
+
+/** \addtogroup EMVCO_DATA_EXCHANGE_STACK_DM_API_INTERFACE
+ *  @brief interface to EMVCO stack HAL to realize the EMVCo functionality.
+ *  @{
+ */
+
+#include <emvco_hal.h>
+#include <emvco_util.h>
+#include <pthread.h>
+/********************* Definitions and structures *****************************/
+#define DEF_NFC_DEV_NODE "/dev/nxpnfc"
+#define MAX_INIT_RETRY_COUNT 3
+#define MAX_RETRY_COUNT 5
+#define NCI_MAX_DATA_LEN 300
+#define FRAG_MAX_DATA_LEN 1024
+#define NCI_POLL_DURATION 500
+#define HAL_EMVCO_ENABLE_I2C_FRAGMENTATION_EVT 0x07
+#undef P2P_PRIO_LOGIC_HAL_IMP
+#define NCI_VERSION_2_0 0x20
+#define NCI_VERSION_1_1 0x11
+#define NCI_VERSION_1_0 0x10
+#define NCI_VERSION_UNKNOWN 0x00
+typedef void(control_granted_callback_t)();
+
+/*ROM CODE VERSION FW*/
+#define FW_MOBILE_ROM_VERSION_PN548AD 0x10
+#define FW_MOBILE_ROM_VERSION_PN551 0x10
+#define FW_MOBILE_ROM_VERSION_PN553 0x11
+#define FW_MOBILE_ROM_VERSION_PN557 0x12
+
+#define CORE_RESET_TRIGGER_TYPE_CORE_RESET_CMD_RECEIVED 0x02
+#define CORE_RESET_TRIGGER_TYPE_POWERED_ON 0x01
+#define CORE_RESET_NTF_MODE_SWITCH_TO_NFC_FORUM 0xA8
+#define CORE_RESET_NTF_MODE_SWITCH_TO_EMVCO 0xA9
+
+#define NCI_MSG_CORE_RESET 0x00
+#define NCI_MSG_CORE_INIT 0x01
+#define NCI_MT_MASK 0xE0
+#define NCI_OID_MASK 0x3F
+
+#define NXP_MAX_CONFIG_STRING_LEN 260
+#define NCI_HEADER_SIZE 3
+
+#define NFC_A_PASSIVE_POLL_MODE 1
+#define NFC_B_PASSIVE_POLL_MODE 2
+#define NFC_AB_PASSIVE_POLL_MODE 3
+#define NFC_F_PASSIVE_POLL_MODE 4
+#define NFC_AF_PASSIVE_POLL_MODE 5
+#define NFC_BF_PASSIVE_POLL_MODE 6
+#define NFC_ABF_PASSIVE_POLL_MODE 7
+#define NFC_VAS_PASSIVE_POLL_MODE 8
+#define NFC_AVAS_PASSIVE_POLL_MODE 9
+#define NFC_BVAS_PASSIVE_POLL_MODE 10
+#define NFC_ABVAS_PASSIVE_POLL_MODE 11
+#define NFC_FVAS_PASSIVE_POLL_MODE 12
+#define NFC_AFVAS_PASSIVE_POLL_MODE 13
+#define NFC_BFVAS_PASSIVE_POLL_MODE 14
+#define NFC_ABFVAS_PASSIVE_POLL_MODE 15
+
+/**********************************************
+ * NCI Core Group Params
+ **********************************************/
+#define NCI_CORE_PARAM_SIZE_RESET 0x01
+#define NCI_RESET_TYPE_KEEP_CFG 0x00
+
+sem_t nfc_status_semaphore;
+
+/*
+ * EMVCo stack events that can be passed back to the EMVCo HAL
+ */
+enum {
+  /** @brief  Event to indicate EMVCo HAL open complete state*/
+  EMVCO_OPEN_CHNL_CPLT_EVT = 0u,
+  /** @brief  Event to indicate EMVCo HAL open error state*/
+  EMVCO_OPEN_CHNL_ERROR_EVT = 1u,
+  /** @brief  Event to indicate EMVCo HAL close complete state*/
+  EMVCO_CLOSE_CHNL_CPLT_EVT = 2u,
+  /** @brief  Event to indicate the start of EMVCo mode*/
+  EMVCO_POOLING_START_EVT = 3u,
+  /** @brief  Event to indicate EMVCo polling activated state*/
+  EMVCO_POLLING_STARTED_EVT = 4u,
+  /** @brief  Event to indicate the stop of EMVCo mode*/
+  EMVCO_POLLING_STOP_EVT = 5u,
+  /** @brief  Event to indicate the Non EMV card*/
+  EMVCO_UN_SUPPORTED_CARD_EVT = 6u,
+};
+
+/*
+ * Status corresponds to EMVCo stack events
+ */
+enum {
+  STATUS_OK = 0u,
+  STATUS_FAILED = 1u,
+};
+
+emvco_stack_callback_t *m_p_nfc_stack_cback;
+emvco_stack_data_callback_t *m_p_nfc_stack_data_cback;
+emvco_state_change_callback_t *m_p_nfc_state_cback;
+
+typedef struct nci_data {
+  uint16_t len;
+  uint8_t p_data[NCI_MAX_DATA_LEN];
+} nci_data_t;
+
+typedef enum {
+  HAL_STATUS_CLOSE = 0,
+  HAL_STATUS_OPEN,
+  HAL_STATUS_MIN_OPEN
+} emvco_hal_status;
+
+typedef enum {
+  GPIO_UNKNOWN = 0x00,
+  GPIO_STORE = 0x01,
+  GPIO_STORE_DONE = 0x02,
+  GPIO_RESTORE = 0x10,
+  GPIO_RESTORE_DONE = 0x20,
+  GPIO_CLEAR = 0xFF
+} gpio_info_state;
+
+typedef struct gpio_info {
+  gpio_info_state state;
+  uint8_t values[2];
+} gpio_info_t;
+
+/* Macros to enable and disable extensions */
+#define HAL_ENABLE_EXT() (nci_hal_ctrl.hal_ext_enabled = 1)
+#define HAL_DISABLE_EXT() (nci_hal_ctrl.hal_ext_enabled = 0)
+
+/**
+ * @brief Structure representing Fragmented data and its properties.
+ *
+ * @param[in] p_data Pointer to the start of the Fragmented data.
+ * @param[in] data_size Total size of the Fragmented data
+ * @param[in] data_pos Current position in the Fragmented data.
+ * @param[in] is_chained Indicates whether there is chained data or not.
+ */
+
+typedef struct frag_rsp {
+  uint8_t p_data[FRAG_MAX_DATA_LEN];
+  uint16_t data_size;
+  uint16_t data_pos;
+  uint8_t is_chained;
+} frag_rsp_t;
+
+typedef struct nci_info {
+  uint8_t nci_version;
+  bool_t wait_for_ntf;
+} nci_info_t;
+/* NCI Control structure */
+typedef struct nci_hal_ctrl {
+  emvco_hal_status halStatus;        /* Indicate if hal is open or closed */
+  pthread_t emvco_hal_client_thread; /* Integration thread handle */
+  uint8_t thread_running;     /* Thread running if set to 1, else set to 0 */
+  driver_config_data gDrvCfg; /* Driver config data */
+
+  /* Rx data */
+  uint8_t *p_rx_data;
+  uint16_t rx_data_len;
+
+  /* Rx data */
+  uint8_t *p_rx_ese_data;
+  uint16_t rx_ese_data_len;
+
+  frag_rsp_t frag_rsp;
+
+  /* libnfc-nci callbacks */
+  emvco_stack_callback_t *p_nfc_stack_cback;
+  emvco_stack_data_callback_t *p_nfc_stack_data_cback;
+  emvco_state_change_callback_t *p_nfc_state_cback;
+
+  /* control granted callback */
+  control_granted_callback_t *p_control_granted_cback;
+
+  /* HAL open status */
+  bool_t hal_open_status;
+
+  /* HAL extensions */
+  uint8_t hal_ext_enabled;
+
+  /* Waiting semaphore */
+  nci_hal_sem ext_cb_data;
+  sem_t sync_nci_write;
+
+  uint16_t cmd_len;
+  uint8_t p_cmd_data[NCI_MAX_DATA_LEN];
+  uint16_t rsp_len;
+  uint8_t p_rsp_data[NCI_MAX_DATA_LEN];
+
+  /* retry count used to force download */
+  uint16_t retry_cnt;
+  uint8_t read_retry_cnt;
+  nci_info_t nci_info;
+
+  /* to store and restore gpio values */
+  gpio_info_t gpio_info;
+} nci_hal_ctrl_t;
+
+typedef struct nci_clock {
+  bool_t is_clock_set;
+  uint8_t p_rx_data[20];
+  bool_t is_set_config;
+} nci_clock_t;
+
+typedef struct rf_setting {
+  bool_t is_get_config;
+  uint8_t p_rx_data[20];
+} rf_setting_t;
+
+typedef struct eeprom_area {
+  bool_t is_get_eeprom_area;
+  uint8_t p_rx_data[32];
+} eeprom_area_t;
+
+typedef enum {
+  NFC_FORUM_PROFILE,
+  EMV_CO_PROFILE,
+  INVALID_PROFILe
+} nci_profile_t;
+/* NXP Poll Profile control structure */
+typedef struct nci_profile_Control {
+  nci_profile_t profile_type;
+  uint8_t
+      b_clk_src_val; /* Holds the System clock source read from config file */
+  uint8_t b_clk_freq_val; /* Holds the System clock frequency read from config
+                             file */
+  uint8_t b_timeout;      /* Holds the Timeout Value */
+} nci_profile_Control_t;
+
+/* Internal messages to handle callbacks */
+#define EMVCO_OPEN_CHNL_CPLT_MSG 0x411
+#define EMVCO_OPEN_CHNL_ERROR_MSG 0x412
+#define EMVCO_CLOSE_CHNL_CPLT_MSG 0x413
+#define EMVCO_POOLING_STARTING_MSG 0x414
+#define EMVCO_POOLING_START_FAILED_MSG 0x415
+#define EMVCO_POLLING_STARTED_MSG 0x416
+#define EMVCO_UN_SUPPORTED_CARD_MSG 0x417
+
+#define EMVCO_DATA_RX_EVT 0xF01
+
+#define NCIHAL_CMD_CODE_LEN_BYTE_OFFSET (2U)
+#define NCIHAL_CMD_CODE_BYTE_LEN (3U)
+
+/**
+ *
+ * @brief           This function is called by EMVCo HAL during the
+ *                  initialization of the NFCC. It opens the physical connection
+ *                  with NFCC (PN7220) and creates required client thread for
+ *                  operation.
+ *                  After open is complete, status is informed to EMVCo HAL
+ *                  through callback function.
+ *
+ * @param[in]       p_cback provides EMVCo event status to client
+ * @param[in]       p_data_cback provides EMVCo data to client
+ * @param[in]       p_nfc_state_change_req_cback EMVCo HAL requests NFC module
+ * to turn ON or OFF the NFC through this callback
+ *
+ * @return          int status of the operation performed
+ *
+ */
+int open_app_data_channel(emvco_stack_callback_t *p_cback,
+                          emvco_stack_data_callback_t *p_data_cback,
+                          emvco_state_change_callback_t *p_nfc_state_cback);
+
+/**
+ *
+ * @brief       This function close the NFCC interface and free all
+ *              resources.This is called by EMVCo HAL on EMVCo service stop.
+ *
+ * @param[in]   bShutdown true, if host is going to shutdown mode. false if host
+ * is not going to shutdown mode.
+ *
+ * @return      int status of the close operation performed
+ *
+ */
+int close_app_data_channel(bool shutdown);
+
+/**
+ * @brief           This function write the data to NFCC through physical
+ *                  interface (e.g. I2C) using the driver interface.
+ *                  Before sending the data to NFCC, send_app_data_ext
+ *                  is called to check if there is any extension processing
+ *                  is required for the NCI packet being sent out.
+ *
+ * @return          int It returns number of bytes successfully written to NFCC.
+ *
+ ******************************************************************************/
+int send_app_data_internal(uint16_t data_len, const uint8_t *p_data);
+
+/**
+ *
+ * @brief           This function write the data to NFCC through physical
+ *                  interface (e.g. I2C) using the PN7220 driver interface.
+ *                  Before sending the data to NFCC, phEMVCoHal_write_ext
+ *                  is called to check if there is any extension processing
+ *                  is required for the NCI packet being sent out.
+ *
+ * @param[in]       data_len length of the data to be written
+ * @param[in]       p_data actual data to be written
+ *
+ * @return          int status of the write operation performed
+ *
+ */
+int send_app_data(uint16_t data_len, const uint8_t *p_data);
+
+/**
+ * @brief           This is the actual function which is being called by
+ *                  send_app_data. This function writes the data to NFCC.
+ *                  It waits till write callback provide the result of write
+ *                  process.
+ *
+ * @param[in]       data_len length of the data to be written
+ * @param[in]       p_data actual data to be written
+ *
+ * @return          int It returns number of bytes successfully written to NFCC.
+ *
+ ******************************************************************************/
+int send_app_data_unlocked(uint16_t data_len, const uint8_t *p_data);
+int open_app_data_channelImpl(emvco_stack_callback_t *p_cback,
+                              emvco_stack_data_callback_t *p_data_cback,
+                              emvco_state_change_callback_t *p_nfc_state_cback);
+#endif /* _EMVCO_DM_H_ */
diff --git a/emvco_hal_impl/doxygen/EMVCOHostExchangeStackMainPage.txt b/emvco_hal_impl/doxygen/EMVCOHostExchangeStackMainPage.txt
new file mode 100755
index 0000000..31c0c07
--- /dev/null
+++ b/emvco_hal_impl/doxygen/EMVCOHostExchangeStackMainPage.txt
@@ -0,0 +1,47 @@
+/*! \mainpage NXP's EMVCO Host Exchange Stack Archutecture and Directory Structure
+
+\section intro_sec Introduction
+
+This document describes interfaces and scenarios details of NXP's EMVCO Host Exchange Stack.
+NXP Semiconductors does not give any representations or warranties as to the accuracy or completeness of information 
+included herein and shall have no liability for the consequences of use of such information.
+
+\section Scope
+The scope of the specified details are limited to NXP's PN7220 NFC Controller.
+
+\section Architecture EMVCo Middleware Acrhitecture
+
+This diagram depicts layered architecture view of EMVCo middleware components and interface between them.
+
+\image html EMVCO_MW_ARCHITECTURE.png
+ 
+\section DocStruct EMVCo Host Data Exchange Stack Directory Structure
+
+This diagram depicts the directory structure of EMVCo host data exchange stack
+
+\image html EMVCO_DIRECTORY_STRUCTURE.png
+
+<br/>
+
+<strong>Please read</strong> also the \ref grp_liability. 
+
+<br/><br/><br/><br/>
+
+*/
+
+/*!
+
+  \defgroup grp_liability Liability Information
+
+<small>
+
+General Information in this document is believed to be accurate and reliable. However, NXP Semiconductors does not give any representations or warranties, expressed or implied, as to the accuracy or completeness of such information and shall have no liability for the consequences of use of such information. Right to make changes NXP Semiconductors reserves the right to make changes to 
+
+information published in this document, including without limitation specifications and product descriptions, at any time and without notice. This document supersedes and replaces all information supplied prior to the publication hereof. Suitability for use NXP Semiconductors products are not designed, authorized or warranted to be suitable for use in medical, military, aircraft, space or life support equipment, nor in applications where failure or malfunction of a NXP Semiconductors product can reasonably be expected to result in personal injury, death or severe property or environmental damage. NXP Semiconductors accepts no liability for inclusion and/or
+
+ use of NXP Semiconductors products in such equipment or applications and therefore such inclusion and/or use is for the customer’s own risk. Applications that are described herein for any of these products are for illustrative purposes only. NXP Semiconductors makes no representation or warranty that such applications will be suitable for the specified use without further testing or modification.
+
+</small><br/><br/>
+
+
+*/
diff --git a/emvco_hal_impl/doxygen/EMVCo_Stack_Doxygen_Sample_Configuration b/emvco_hal_impl/doxygen/EMVCo_Stack_Doxygen_Sample_Configuration
new file mode 100755
index 0000000..302ff3e
--- /dev/null
+++ b/emvco_hal_impl/doxygen/EMVCo_Stack_Doxygen_Sample_Configuration
@@ -0,0 +1,2566 @@
+# Doxyfile 1.8.15
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project.
+#
+# All text after a double hash (##) is considered a comment and is placed in
+# front of the TAG it is preceding.
+#
+# All text after a single hash (#) is considered a comment and will be ignored.
+# The format is:
+# TAG = value [value, ...]
+# For lists, items can also be appended using:
+# TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (\" \").
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the configuration
+# file that follow. The default is UTF-8 which is also the encoding used for all
+# text before the first occurrence of this tag. Doxygen uses libiconv (or the
+# iconv built into libc) for the transcoding. See
+# https://www.gnu.org/software/libiconv/ for the list of possible encodings.
+# The default value is: UTF-8.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
+# double-quotes, unless you are using Doxywizard) that should identify the
+# project for which the documentation is generated. This name is used in the
+# title of most generated pages and in a few other places.
+# The default value is: My Project.
+
+PROJECT_NAME           = "EMVCo Middleware"
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
+# could be handy for archiving the generated documentation or if some version
+# control system is used.
+
+PROJECT_NUMBER         = 1.0.1
+
+# Using the PROJECT_BRIEF tag one can provide an optional one line description
+# for a project that appears at the top of each page and should give viewer a
+# quick idea about the purpose of the project. Keep the description short.
+
+PROJECT_BRIEF          = "EMVCo Host Data Exchange Stack"
+
+# With the PROJECT_LOGO tag one can specify a logo or an icon that is included
+# in the documentation. The maximum height of the logo should not exceed 55
+# pixels and the maximum width should not exceed 200 pixels. Doxygen will copy
+# the logo to the output directory.
+
+PROJECT_LOGO           = "./images/NXP_LOGO.png"
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
+# into which the generated documentation will be written. If a relative path is
+# entered, it will be relative to the location where doxygen was started. If
+# left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = "C:\Users\nxf83910\OneDrive - NXP\RampUp\Pallas\Design_review_rework\Documentation\Document_output\RC2_Arch"
+
+# If the CREATE_SUBDIRS tag is set to YES then doxygen will create 4096 sub-
+# directories (in 2 levels) under the output directory of each output format and
+# will distribute the generated files over these directories. Enabling this
+# option can be useful when feeding doxygen a huge amount of source files, where
+# putting all generated files in the same directory would otherwise causes
+# performance problems for the file system.
+# The default value is: NO.
+
+CREATE_SUBDIRS         = NO
+
+# If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII
+# characters to appear in the names of generated files. If set to NO, non-ASCII
+# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode
+# U+3044.
+# The default value is: NO.
+
+ALLOW_UNICODE_NAMES    = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all constant output in the proper language.
+# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,
+# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),
+# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,
+# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),
+# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,
+# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,
+# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,
+# Ukrainian and Vietnamese.
+# The default value is: English.
+
+OUTPUT_LANGUAGE        = English
+
+# The OUTPUT_TEXT_DIRECTION tag is used to specify the direction in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all generated output in the proper direction.
+# Possible values are: None, LTR, RTL and Context.
+# The default value is: None.
+
+OUTPUT_TEXT_DIRECTION  = None
+
+# If the BRIEF_MEMBER_DESC tag is set to YES, doxygen will include brief member
+# descriptions after the members that are listed in the file and class
+# documentation (similar to Javadoc). Set to NO to disable this.
+# The default value is: YES.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES, doxygen will prepend the brief
+# description of a member or function before the detailed description
+#
+# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
+# brief descriptions will be completely suppressed.
+# The default value is: YES.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator that is
+# used to form the text in various listings. Each string in this list, if found
+# as the leading text of the brief description, will be stripped from the text
+# and the result, after processing the whole list, is used as the annotated
+# text. Otherwise, the brief description is used as-is. If left blank, the
+# following values are used ($name is automatically replaced with the name of
+# the entity):The $name class, The $name widget, The $name file, is, provides,
+# specifies, contains, represents, a, an and the.
+
+ABBREVIATE_BRIEF       = "The $name class" \
+                         "The $name widget" \
+                         "The $name file" \
+                         is \
+                         provides \
+                         specifies \
+                         contains \
+                         represents \
+                         a \
+                         an \
+                         the
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
+# doxygen will generate a detailed section even if there is only a brief
+# description.
+# The default value is: NO.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
+# inherited members of a class in the documentation of that class as if those
+# members were ordinary class members. Constructors, destructors and assignment
+# operators of the base classes will not be shown.
+# The default value is: NO.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES, doxygen will prepend the full path
+# before files name in the file list and in the header files. If set to NO the
+# shortest path that makes the file name unique will be used
+# The default value is: YES.
+
+FULL_PATH_NAMES        = YES
+
+# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
+# Stripping is only done if one of the specified strings matches the left-hand
+# part of the path. The tag can be used to show relative paths in the file list.
+# If left blank the directory from which doxygen is run is used as the path to
+# strip.
+#
+# Note that you can specify absolute paths here, but also relative paths, which
+# will be relative from the directory where doxygen is started.
+# This tag requires that the tag FULL_PATH_NAMES is set to YES.
+
+STRIP_FROM_PATH        =
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
+# path mentioned in the documentation of a class, which tells the reader which
+# header file to include in order to use a class. If left blank only the name of
+# the header file containing the class definition is used. Otherwise one should
+# specify the list of include paths that are normally passed to the compiler
+# using the -I flag.
+
+STRIP_FROM_INC_PATH    =
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
+# less readable) file names. This can be useful is your file systems doesn't
+# support long names like on DOS, Mac, or CD-ROM.
+# The default value is: NO.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
+# first line (until the first dot) of a Javadoc-style comment as the brief
+# description. If set to NO, the Javadoc-style will behave just like regular Qt-
+# style comments (thus requiring an explicit @brief command for a brief
+# description.)
+# The default value is: NO.
+
+JAVADOC_AUTOBRIEF      = NO
+
+# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
+# line (until the first dot) of a Qt-style comment as the brief description. If
+# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
+# requiring an explicit \brief command for a brief description.)
+# The default value is: NO.
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
+# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
+# a brief description. This used to be the default behavior. The new default is
+# to treat a multi-line C++ comment block as a detailed description. Set this
+# tag to YES if you prefer the old behavior instead.
+#
+# Note that setting this tag to YES also means that rational rose comments are
+# not recognized any more.
+# The default value is: NO.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
+# documentation from any documented member that it re-implements.
+# The default value is: YES.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES then doxygen will produce a new
+# page for each member. If set to NO, the documentation of a member will be part
+# of the file/class/namespace that contains it.
+# The default value is: NO.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
+# uses this value to replace tabs by spaces in code fragments.
+# Minimum value: 1, maximum value: 16, default value: 4.
+
+TAB_SIZE               = 4
+
+# This tag can be used to specify a number of aliases that act as commands in
+# the documentation. An alias has the form:
+# name=value
+# For example adding
+# "sideeffect=@par Side Effects:\n"
+# will allow you to put the command \sideeffect (or @sideeffect) in the
+# documentation, which will result in a user-defined paragraph with heading
+# "Side Effects:". You can put \n's in the value part of an alias to insert
+# newlines (in the resulting output). You can put ^^ in the value part of an
+# alias to insert a newline as if a physical newline was in the original file.
+# When you need a literal { or } or , in the value part of an alias you have to
+# escape them by means of a backslash (\), this can lead to conflicts with the
+# commands \{ and \} for these it is advised to use the version @{ and @} or use
+# a double escape (\\{ and \\})
+
+ALIASES                =
+
+# This tag can be used to specify a number of word-keyword mappings (TCL only).
+# A mapping has the form "name=value". For example adding "class=itcl::class"
+# will allow you to use the command class in the itcl::class meaning.
+
+TCL_SUBST              =
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
+# only. Doxygen will then generate output that is more tailored for C. For
+# instance, some of the names that are used will be different. The list of all
+# members will be omitted, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_FOR_C  = YES
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
+# Python sources only. Doxygen will then generate output that is more tailored
+# for that language. For instance, namespaces will be presented as packages,
+# qualified scopes will look different, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
+# sources. Doxygen will then generate output that is tailored for Fortran.
+# The default value is: NO.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
+# sources. Doxygen will then generate output that is tailored for VHDL.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Set the OPTIMIZE_OUTPUT_SLICE tag to YES if your project consists of Slice
+# sources only. Doxygen will then generate output that is more tailored for that
+# language. For instance, namespaces will be presented as modules, types will be
+# separated into more groups, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_SLICE  = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it
+# parses. With this tag you can assign which parser to use for a given
+# extension. Doxygen has a built-in mapping, but you can override or extend it
+# using this tag. The format is ext=language, where ext is a file extension, and
+# language is one of the parsers supported by doxygen: IDL, Java, Javascript,
+# Csharp (C#), C, C++, D, PHP, md (Markdown), Objective-C, Python, Slice,
+# Fortran (fixed format Fortran: FortranFixed, free formatted Fortran:
+# FortranFree, unknown formatted Fortran: Fortran. In the later case the parser
+# tries to guess whether the code is fixed or free formatted code, this is the
+# default for Fortran type files), VHDL, tcl. For instance to make doxygen treat
+# .inc files as Fortran files (default is PHP), and .f files as C (default is
+# Fortran), use: inc=Fortran f=C.
+#
+# Note: For files without extension you can use no_extension as a placeholder.
+#
+# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
+# the files are not read by doxygen.
+
+EXTENSION_MAPPING      =
+
+# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
+# according to the Markdown format, which allows for more readable
+# documentation. See https://daringfireball.net/projects/markdown/ for details.
+# The output of markdown processing is further processed by doxygen, so you can
+# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
+# case of backward compatibilities issues.
+# The default value is: YES.
+
+MARKDOWN_SUPPORT       = YES
+
+# When the TOC_INCLUDE_HEADINGS tag is set to a non-zero value, all headings up
+# to that level are automatically included in the table of contents, even if
+# they do not have an id attribute.
+# Note: This feature currently applies only to Markdown headings.
+# Minimum value: 0, maximum value: 99, default value: 0.
+# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.
+
+TOC_INCLUDE_HEADINGS   = 0
+
+# When enabled doxygen tries to link words that correspond to documented
+# classes, or namespaces to their corresponding documentation. Such a link can
+# be prevented in individual cases by putting a % sign in front of the word or
+# globally by setting AUTOLINK_SUPPORT to NO.
+# The default value is: YES.
+
+AUTOLINK_SUPPORT       = YES
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
+# to include (a tag file for) the STL sources as input, then you should set this
+# tag to YES in order to let doxygen match functions declarations and
+# definitions whose arguments contain STL classes (e.g. func(std::string);
+# versus func(std::string) {}). This also make the inheritance and collaboration
+# diagrams that involve STL classes more complete and accurate.
+# The default value is: NO.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to
+# enable parsing support.
+# The default value is: NO.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
+# https://www.riverbankcomputing.com/software/sip/intro) sources only. Doxygen
+# will parse them like normal C++ but will assume all classes use public instead
+# of private inheritance when no explicit protection keyword is present.
+# The default value is: NO.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate
+# getter and setter methods for a property. Setting this option to YES will make
+# doxygen to replace the get and set methods by a property in the documentation.
+# This will only work if the methods are indeed getting or setting a simple
+# type. If this is not the case, or you want to show the methods anyway, you
+# should set this option to NO.
+# The default value is: YES.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
+# tag is set to YES then doxygen will reuse the documentation of the first
+# member in the group (if any) for the other members of the group. By default
+# all members of a group must be documented explicitly.
+# The default value is: NO.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# If one adds a struct or class to a group and this option is enabled, then also
+# any nested class or struct is added to the same group. By default this option
+# is disabled and one has to add nested compounds explicitly via \ingroup.
+# The default value is: NO.
+
+GROUP_NESTED_COMPOUNDS = NO
+
+# Set the SUBGROUPING tag to YES to allow class member groups of the same type
+# (for instance a group of public functions) to be put as a subgroup of that
+# type (e.g. under the Public Functions section). Set it to NO to prevent
+# subgrouping. Alternatively, this can be done per class using the
+# \nosubgrouping command.
+# The default value is: YES.
+
+SUBGROUPING            = YES
+
+# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
+# are shown inside the group in which they are included (e.g. using \ingroup)
+# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
+# and RTF).
+#
+# Note that this feature does not work in combination with
+# SEPARATE_MEMBER_PAGES.
+# The default value is: NO.
+
+INLINE_GROUPED_CLASSES = NO
+
+# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
+# with only public data fields or simple typedef fields will be shown inline in
+# the documentation of the scope in which they are defined (i.e. file,
+# namespace, or group documentation), provided this scope is documented. If set
+# to NO, structs, classes, and unions are shown on a separate page (for HTML and
+# Man pages) or section (for LaTeX and RTF).
+# The default value is: NO.
+
+INLINE_SIMPLE_STRUCTS  = NO
+
+# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
+# enum is documented as struct, union, or enum with the name of the typedef. So
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
+# with name TypeT. When disabled the typedef will appear as a member of a file,
+# namespace, or class. And the struct will be named TypeS. This can typically be
+# useful for C code in case the coding convention dictates that all compound
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+# The default value is: NO.
+
+TYPEDEF_HIDES_STRUCT   = NO
+
+# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
+# cache is used to resolve symbols given their name and scope. Since this can be
+# an expensive process and often the same symbol appears multiple times in the
+# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
+# doxygen will become slower. If the cache is too large, memory is wasted. The
+# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
+# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
+# symbols. At the end of a run doxygen will report the cache usage and suggest
+# the optimal cache size from a speed point of view.
+# Minimum value: 0, maximum value: 9, default value: 0.
+
+LOOKUP_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES, doxygen will assume all entities in
+# documentation are documented, even if no documentation was available. Private
+# class members and static file members will be hidden unless the
+# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
+# Note: This will also disable the warnings about undocumented members that are
+# normally produced when WARNINGS is set to YES.
+# The default value is: NO.
+
+EXTRACT_ALL            = YES
+
+# If the EXTRACT_PRIVATE tag is set to YES, all private members of a class will
+# be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal
+# scope will be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PACKAGE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES, all static members of a file will be
+# included in the documentation.
+# The default value is: NO.
+
+EXTRACT_STATIC         = YES
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES, classes (and structs) defined
+# locally in source files will be included in the documentation. If set to NO,
+# only classes defined in header files are included. Does not have any effect
+# for Java sources.
+# The default value is: YES.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. If set to YES, local methods,
+# which are defined in the implementation section but not in the interface are
+# included in the documentation. If set to NO, only methods in the interface are
+# included.
+# The default value is: NO.
+
+EXTRACT_LOCAL_METHODS  = YES
+
+# If this flag is set to YES, the members of anonymous namespaces will be
+# extracted and appear in the documentation as a namespace called
+# 'anonymous_namespace{file}', where file will be replaced with the base name of
+# the file that contains the anonymous namespace. By default anonymous namespace
+# are hidden.
+# The default value is: NO.
+
+EXTRACT_ANON_NSPACES   = YES
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
+# undocumented members inside documented classes or files. If set to NO these
+# members will be included in the various overviews, but no documentation
+# section is generated. This option has no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
+# undocumented classes that are normally visible in the class hierarchy. If set
+# to NO, these classes will be included in the various overviews. This option
+# has no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
+# (class|struct|union) declarations. If set to NO, these declarations will be
+# included in the documentation.
+# The default value is: NO.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
+# documentation blocks found inside the body of a function. If set to NO, these
+# blocks will be appended to the function's detailed documentation block.
+# The default value is: NO.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation that is typed after a
+# \internal command is included. If the tag is set to NO then the documentation
+# will be excluded. Set it to YES to include the internal documentation.
+# The default value is: NO.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file
+# names in lower-case letters. If set to YES, upper-case letters are also
+# allowed. This is useful if you have classes or files whose names only differ
+# in case and if your file system supports case sensitive file names. Windows
+# and Mac users are advised to set this option to NO.
+# The default value is: system dependent.
+
+CASE_SENSE_NAMES       = NO
+
+# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
+# their full class and namespace scopes in the documentation. If set to YES, the
+# scope will be hidden.
+# The default value is: NO.
+
+HIDE_SCOPE_NAMES       = YES
+
+# If the HIDE_COMPOUND_REFERENCE tag is set to NO (default) then doxygen will
+# append additional text to a page's title, such as Class Reference. If set to
+# YES the compound reference will be hidden.
+# The default value is: NO.
+
+HIDE_COMPOUND_REFERENCE= NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
+# the files that are included by a file in the documentation of that file.
+# The default value is: YES.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
+# grouped member an include statement to the documentation, telling the reader
+# which file to include in order to use the member.
+# The default value is: NO.
+
+SHOW_GROUPED_MEMB_INC  = NO
+
+# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
+# files with double quotes in the documentation rather than with sharp brackets.
+# The default value is: NO.
+
+FORCE_LOCAL_INCLUDES   = NO
+
+# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
+# documentation for inline members.
+# The default value is: YES.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
+# (detailed) documentation of file and class members alphabetically by member
+# name. If set to NO, the members will appear in declaration order.
+# The default value is: YES.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
+# descriptions of file, namespace and class members alphabetically by member
+# name. If set to NO, the members will appear in declaration order. Note that
+# this will also influence the order of the classes in the class list.
+# The default value is: NO.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
+# (brief and detailed) documentation of class members so that constructors and
+# destructors are listed first. If set to NO the constructors will appear in the
+# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
+# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
+# member documentation.
+# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
+# detailed member documentation.
+# The default value is: NO.
+
+SORT_MEMBERS_CTORS_1ST = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
+# of group names into alphabetical order. If set to NO the group names will
+# appear in their defined order.
+# The default value is: NO.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
+# fully-qualified names, including namespaces. If set to NO, the class list will
+# be sorted only by class name, not including the namespace part.
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the alphabetical
+# list.
+# The default value is: NO.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
+# type resolution of all parameters of a function it will reject a match between
+# the prototype and the implementation of a member function even if there is
+# only one candidate or it is obvious which candidate to choose by doing a
+# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
+# accept a match between prototype and implementation in such cases.
+# The default value is: NO.
+
+STRICT_PROTO_MATCHING  = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or disable (NO) the todo
+# list. This list is created by putting \todo commands in the documentation.
+# The default value is: YES.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or disable (NO) the test
+# list. This list is created by putting \test commands in the documentation.
+# The default value is: YES.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or disable (NO) the bug
+# list. This list is created by putting \bug commands in the documentation.
+# The default value is: YES.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or disable (NO)
+# the deprecated list. This list is created by putting \deprecated commands in
+# the documentation.
+# The default value is: YES.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional documentation
+# sections, marked by \if <section_label> ... \endif and \cond <section_label>
+# ... \endcond blocks.
+
+ENABLED_SECTIONS       =
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
+# initial value of a variable or macro / define can have for it to appear in the
+# documentation. If the initializer consists of more lines than specified here
+# it will be hidden. Use a value of 0 to hide initializers completely. The
+# appearance of the value of individual variables and macros / defines can be
+# controlled using \showinitializer or \hideinitializer command in the
+# documentation regardless of this setting.
+# Minimum value: 0, maximum value: 10000, default value: 30.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
+# the bottom of the documentation of classes and structs. If set to YES, the
+# list will mention the files that were used to generate the documentation.
+# The default value is: YES.
+
+SHOW_USED_FILES        = YES
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
+# will remove the Files entry from the Quick Index and from the Folder Tree View
+# (if specified).
+# The default value is: YES.
+
+SHOW_FILES             = YES
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
+# page. This will remove the Namespaces entry from the Quick Index and from the
+# Folder Tree View (if specified).
+# The default value is: YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that
+# doxygen should invoke to get the current version for each file (typically from
+# the version control system). Doxygen will invoke the program by executing (via
+# popen()) the command command input-file, where command is the value of the
+# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
+# by doxygen. Whatever the program writes to standard output is used as the file
+# version. For an example see the documentation.
+
+FILE_VERSION_FILTER    =
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
+# by doxygen. The layout file controls the global structure of the generated
+# output files in an output format independent way. To create the layout file
+# that represents doxygen's defaults, run doxygen with the -l option. You can
+# optionally specify a file name after the option, if omitted DoxygenLayout.xml
+# will be used as the name of the layout file.
+#
+# Note that if you run doxygen from a directory containing a file called
+# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
+# tag is left empty.
+
+LAYOUT_FILE            =
+
+# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
+# the reference definitions. This must be a list of .bib files. The .bib
+# extension is automatically appended if omitted. This requires the bibtex tool
+# to be installed. See also https://en.wikipedia.org/wiki/BibTeX for more info.
+# For LaTeX the style of the bibliography can be controlled using
+# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
+# search path. See also \cite for info how to create references.
+
+CITE_BIB_FILES         =
+
+#---------------------------------------------------------------------------
+# Configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated to
+# standard output by doxygen. If QUIET is set to YES this implies that the
+# messages are off.
+# The default value is: NO.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are
+# generated to standard error (stderr) by doxygen. If WARNINGS is set to YES
+# this implies that the warnings are on.
+#
+# Tip: Turn warnings on while writing the documentation.
+# The default value is: YES.
+
+WARNINGS               = YES
+
+# If the WARN_IF_UNDOCUMENTED tag is set to YES then doxygen will generate
+# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
+# will automatically be disabled.
+# The default value is: YES.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
+# potential errors in the documentation, such as not documenting some parameters
+# in a documented function, or documenting parameters that don't exist or using
+# markup commands wrongly.
+# The default value is: YES.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
+# are documented, but have no documentation for their parameters or return
+# value. If set to NO, doxygen will only warn about wrong or incomplete
+# parameter documentation, but not about the absence of documentation. If
+# EXTRACT_ALL is set to YES then this flag will automatically be disabled.
+# The default value is: NO.
+
+WARN_NO_PARAMDOC       = NO
+
+# If the WARN_AS_ERROR tag is set to YES then doxygen will immediately stop when
+# a warning is encountered.
+# The default value is: NO.
+
+WARN_AS_ERROR          = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that doxygen
+# can produce. The string should contain the $file, $line, and $text tags, which
+# will be replaced by the file and line number from which the warning originated
+# and the warning text. Optionally the format may contain $version, which will
+# be replaced by the version of the file (if it could be obtained via
+# FILE_VERSION_FILTER)
+# The default value is: $file:$line: $text.
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning and error
+# messages should be written. If left blank the output is written to standard
+# error (stderr).
+
+WARN_LOGFILE           =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag is used to specify the files and/or directories that contain
+# documented source files. You may enter file names like myfile.cpp or
+# directories like /usr/src/myproject. Separate the files or directories with
+# spaces. See also FILE_PATTERNS and EXTENSION_MAPPING
+# Note: If this tag is empty the current directory is searched.
+
+INPUT                  = "C:\Users\nxf83910\OneDrive - NXP\RampUp\Pallas\Design_review_rework\Design_from_scratch\RC2_doxygen_final_doc_src\emvco_hal_impl"
+
+# This tag can be used to specify the character encoding of the source files
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
+# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
+# documentation (see: https://www.gnu.org/software/libiconv/) for the list of
+# possible encodings.
+# The default value is: UTF-8.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the
+# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
+# *.h) to filter out the source-files in the directories.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# read by doxygen.
+#
+# If left blank the following patterns are tested:*.c, *.cc, *.cxx, *.cpp,
+# *.c++, *.java, *.ii, *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h,
+# *.hh, *.hxx, *.hpp, *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc,
+# *.m, *.markdown, *.md, *.mm, *.dox, *.py, *.pyw, *.f90, *.f95, *.f03, *.f08,
+# *.f, *.for, *.tcl, *.vhd, *.vhdl, *.ucf, *.qsf and *.ice.
+
+FILE_PATTERNS          = EMVCOHostExchangeStackMainPage.txt \
+                         *.c \
+                         *.cc \
+                         *.cxx \
+                         *.cpp \
+                         *.c++ \
+                         *.java \
+                         *.ii \
+                         *.ixx \
+                         *.ipp \
+                         *.i++ \
+                         *.inl \
+                         *.idl \
+                         *.ddl \
+                         *.odl \
+                         *.h \
+                         *.hh \
+                         *.hxx \
+                         *.hpp \
+                         *.h++ \
+                         *.cs \
+                         *.d \
+                         *.php \
+                         *.php4 \
+                         *.php5 \
+                         *.phtml \
+                         *.inc \
+                         *.m \
+                         *.markdown \
+                         *.md \
+                         *.mm \
+                         *.dox \
+                         *.py \
+                         *.pyw \
+                         *.f90 \
+                         *.f95 \
+                         *.f03 \
+                         *.f08 \
+                         *.f \
+                         *.for \
+                         *.tcl \
+                         *.vhd \
+                         *.vhdl \
+                         *.ucf \
+                         *.qsf \
+                         *.ice
+
+# The RECURSIVE tag can be used to specify whether or not subdirectories should
+# be searched for input files as well.
+# The default value is: NO.
+
+RECURSIVE              = YES
+
+# The EXCLUDE tag can be used to specify files and/or directories that should be
+# excluded from the INPUT source files. This way you can easily exclude a
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+#
+# Note that relative paths are relative to the directory from which doxygen is
+# run.
+
+EXCLUDE                =
+
+# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
+# directories that are symbolic links (a Unix file system feature) are excluded
+# from the input.
+# The default value is: NO.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
+# certain files from those directories.
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       =
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
+# (namespaces, classes, functions, etc.) that should be excluded from the
+# output. The symbol name can be a fully qualified name, a word, or if the
+# wildcard * is used, a substring. Examples: ANamespace, AClass,
+# AClass::ANamespace, ANamespace::*Test
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories use the pattern */test/*
+
+EXCLUDE_SYMBOLS        =
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or directories
+# that contain example code fragments that are included (see the \include
+# command).
+
+EXAMPLE_PATH           =
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
+# *.h) to filter out the source-files in the directories. If left blank all
+# files are included.
+
+EXAMPLE_PATTERNS       = *
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
+# searched for input files to be used with the \include or \dontinclude commands
+# irrespective of the value of the RECURSIVE tag.
+# The default value is: NO.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or directories
+# that contain images that are to be included in the documentation (see the
+# \image command).
+
+IMAGE_PATH             = ./images/
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should
+# invoke to filter for each input file. Doxygen will invoke the filter program
+# by executing (via popen()) the command:
+#
+# <filter> <input-file>
+#
+# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
+# name of an input file. Doxygen will then use the output that the filter
+# program writes to standard output. If FILTER_PATTERNS is specified, this tag
+# will be ignored.
+#
+# Note that the filter must not add or remove lines; it is applied before the
+# code is scanned, but not when the output code is generated. If lines are added
+# or removed, the anchors will not be placed correctly.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# properly processed by doxygen.
+
+INPUT_FILTER           =
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
+# basis. Doxygen will compare the file name with each pattern and apply the
+# filter if there is a match. The filters are a list of the form: pattern=filter
+# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
+# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
+# patterns match the file name, INPUT_FILTER is applied.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# properly processed by doxygen.
+
+FILTER_PATTERNS        =
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
+# INPUT_FILTER) will also be used to filter the input files that are used for
+# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
+# The default value is: NO.
+
+FILTER_SOURCE_FILES    = NO
+
+# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
+# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
+# it is also possible to disable source filtering for a specific pattern using
+# *.ext= (so without naming a filter).
+# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.
+
+FILTER_SOURCE_PATTERNS =
+
+# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
+# is part of the input, its contents will be placed on the main page
+# (index.html). This can be useful if you have a project on for instance GitHub
+# and want to reuse the introduction page also for the doxygen output.
+
+USE_MDFILE_AS_MAINPAGE =
+
+#---------------------------------------------------------------------------
+# Configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
+# generated. Documented entities will be cross-referenced with these sources.
+#
+# Note: To get rid of all source code in the generated output, make sure that
+# also VERBATIM_HEADERS is set to NO.
+# The default value is: NO.
+
+SOURCE_BROWSER         = NO
+
+# Setting the INLINE_SOURCES tag to YES will include the body of functions,
+# classes and enums directly into the documentation.
+# The default value is: NO.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
+# special comment blocks from generated source code fragments. Normal C, C++ and
+# Fortran comments will always remain visible.
+# The default value is: YES.
+
+STRIP_CODE_COMMENTS    = NO
+
+# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
+# entity all documented functions referencing it will be listed.
+# The default value is: NO.
+
+REFERENCED_BY_RELATION = NO
+
+# If the REFERENCES_RELATION tag is set to YES then for each documented function
+# all documented entities called/used by that function will be listed.
+# The default value is: NO.
+
+REFERENCES_RELATION    = NO
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
+# to YES then the hyperlinks from functions in REFERENCES_RELATION and
+# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
+# link to the documentation.
+# The default value is: YES.
+
+REFERENCES_LINK_SOURCE = NO
+
+# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
+# source code will show a tooltip with additional information such as prototype,
+# brief description and links to the definition and documentation. Since this
+# will make the HTML file larger and loading of large files a bit slower, you
+# can opt to disable this feature.
+# The default value is: YES.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+SOURCE_TOOLTIPS        = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code will
+# point to the HTML generated by the htags(1) tool instead of doxygen built-in
+# source browser. The htags tool is part of GNU's global source tagging system
+# (see https://www.gnu.org/software/global/global.html). You will need version
+# 4.8.6 or higher.
+#
+# To use it do the following:
+# - Install the latest version of global
+# - Enable SOURCE_BROWSER and USE_HTAGS in the configuration file
+# - Make sure the INPUT points to the root of the source tree
+# - Run doxygen as normal
+#
+# Doxygen will invoke htags (and that will in turn invoke gtags), so these
+# tools must be available from the command line (i.e. in the search path).
+#
+# The result: instead of the source browser generated by doxygen, the links to
+# source code will now point to the output of htags.
+# The default value is: NO.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
+# verbatim copy of the header file for each class for which an include is
+# specified. Set to NO to disable this.
+# See also: Section \class.
+# The default value is: YES.
+
+VERBATIM_HEADERS       = NO
+
+# If the CLANG_ASSISTED_PARSING tag is set to YES then doxygen will use the
+# clang parser (see: http://clang.llvm.org/) for more accurate parsing at the
+# cost of reduced performance. This can be particularly helpful with template
+# rich C++ code for which doxygen's built-in parser lacks the necessary type
+# information.
+# Note: The availability of this option depends on whether or not doxygen was
+# generated with the -Duse_libclang=ON option for CMake.
+# The default value is: NO.
+
+CLANG_ASSISTED_PARSING = NO
+
+# If clang assisted parsing is enabled you can provide the compiler with command
+# line options that you would normally use when invoking the compiler. Note that
+# the include paths will already be set by doxygen for the files and directories
+# specified with INPUT and INCLUDE_PATH.
+# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.
+
+CLANG_OPTIONS          =
+
+# If clang assisted parsing is enabled you can provide the clang parser with the
+# path to the compilation database (see:
+# http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html) used when the files
+# were built. This is equivalent to specifying the "-p" option to a clang tool,
+# such as clang-check. These options will then be passed to the parser.
+# Note: The availability of this option depends on whether or not doxygen was
+# generated with the -Duse_libclang=ON option for CMake.
+
+CLANG_DATABASE_PATH    =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
+# compounds will be generated. Enable this if the project contains a lot of
+# classes, structs, unions or interfaces.
+# The default value is: YES.
+
+ALPHABETICAL_INDEX     = NO
+
+# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in
+# which the alphabetical index list will be split.
+# Minimum value: 1, maximum value: 20, default value: 5.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all classes will
+# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
+# can be used to specify a prefix (or a list of prefixes) that should be ignored
+# while generating the index headers.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+IGNORE_PREFIX          =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES, doxygen will generate HTML output
+# The default value is: YES.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
+# generated HTML page (for example: .htm, .php, .asp).
+# The default value is: .html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
+# each generated HTML page. If the tag is left blank doxygen will generate a
+# standard header.
+#
+# To get valid HTML the header file that includes any scripts and style sheets
+# that doxygen needs, which is dependent on the configuration options used (e.g.
+# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
+# default header using
+# doxygen -w html new_header.html new_footer.html new_stylesheet.css
+# YourConfigFile
+# and then modify the file new_header.html. See also section "Doxygen usage"
+# for information on how to generate the default header that doxygen normally
+# uses.
+# Note: The header is subject to change so you typically have to regenerate the
+# default header when upgrading to a newer version of doxygen. For a description
+# of the possible markers and block names see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_HEADER            =
+
+# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
+# generated HTML page. If the tag is left blank doxygen will generate a standard
+# footer. See HTML_HEADER for more information on how to generate a default
+# footer and what special commands can be used inside the footer. See also
+# section "Doxygen usage" for information on how to generate the default footer
+# that doxygen normally uses.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FOOTER            =
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
+# sheet that is used by each HTML page. It can be used to fine-tune the look of
+# the HTML output. If left blank doxygen will generate a default style sheet.
+# See also section "Doxygen usage" for information on how to generate the style
+# sheet that doxygen normally uses.
+# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
+# it is more robust and this tag (HTML_STYLESHEET) will in the future become
+# obsolete.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_STYLESHEET        =
+
+# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined
+# cascading style sheets that are included after the standard style sheets
+# created by doxygen. Using this option one can overrule certain style aspects.
+# This is preferred over using HTML_STYLESHEET since it does not replace the
+# standard style sheet and is therefore more robust against future updates.
+# Doxygen will copy the style sheet files to the output directory.
+# Note: The order of the extra style sheet files is of importance (e.g. the last
+# style sheet in the list overrules the setting of the previous ones in the
+# list). For an example see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_STYLESHEET  =
+
+# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the HTML output directory. Note
+# that these files will be copied to the base HTML output directory. Use the
+# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
+# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
+# files will be copied as-is; there are no commands or markers available.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_FILES       =
+
+# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
+# will adjust the colors in the style sheet and background images according to
+# this color. Hue is specified as an angle on a colorwheel, see
+# https://en.wikipedia.org/wiki/Hue for more information. For instance the value
+# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
+# purple, and 360 is red again.
+# Minimum value: 0, maximum value: 359, default value: 220.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_HUE    = 220
+
+# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
+# in the HTML output. For a value of 0 the output will use grayscales only. A
+# value of 255 will produce the most vivid colors.
+# Minimum value: 0, maximum value: 255, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_SAT    = 100
+
+# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
+# luminance component of the colors in the HTML output. Values below 100
+# gradually make the output lighter, whereas values above 100 make the output
+# darker. The value divided by 100 is the actual gamma applied, so 80 represents
+# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
+# change the gamma.
+# Minimum value: 40, maximum value: 240, default value: 80.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_GAMMA  = 80
+
+# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
+# page will contain the date and time when the page was generated. Setting this
+# to YES can help to show when doxygen was last run and thus if the
+# documentation is up to date.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_TIMESTAMP         = NO
+
+# If the HTML_DYNAMIC_MENUS tag is set to YES then the generated HTML
+# documentation will contain a main index with vertical navigation menus that
+# are dynamically created via Javascript. If disabled, the navigation index will
+# consists of multiple levels of tabs that are statically embedded in every HTML
+# page. Disable this option to support browsers that do not have Javascript,
+# like the Qt help browser.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_DYNAMIC_MENUS     = YES
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
+# documentation will contain sections that can be hidden and shown after the
+# page has loaded.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_DYNAMIC_SECTIONS  = NO
+
+# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
+# shown in the various tree structured indices initially; the user can expand
+# and collapse entries dynamically later on. Doxygen will expand the tree to
+# such a level that at most the specified number of entries are visible (unless
+# a fully collapsed tree already exceeds this amount). So setting the number of
+# entries 1 will produce a full collapsed tree by default. 0 is a special value
+# representing an infinite number of entries and will result in a full expanded
+# tree by default.
+# Minimum value: 0, maximum value: 9999, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_INDEX_NUM_ENTRIES = 100
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files will be
+# generated that can be used as input for Apple's Xcode 3 integrated development
+# environment (see: https://developer.apple.com/xcode/), introduced with OSX
+# 10.5 (Leopard). To create a documentation set, doxygen will generate a
+# Makefile in the HTML output directory. Running make will produce the docset in
+# that directory and running make install will install the docset in
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
+# startup. See https://developer.apple.com/library/archive/featuredarticles/Doxy
+# genXcode/_index.html for more information.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_DOCSET        = NO
+
+# This tag determines the name of the docset feed. A documentation feed provides
+# an umbrella under which multiple documentation sets from a single provider
+# (such as a company or product suite) can be grouped.
+# The default value is: Doxygen generated docs.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# This tag specifies a string that should uniquely identify the documentation
+# set bundle. This should be a reverse domain-name style string, e.g.
+# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
+# the documentation publisher. This should be a reverse domain-name style
+# string, e.g. com.mycompany.MyDocSet.documentation.
+# The default value is: org.doxygen.Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
+
+# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
+# The default value is: Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_NAME  = Publisher
+
+# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
+# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
+# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
+# (see: https://www.microsoft.com/en-us/download/details.aspx?id=21138) on
+# Windows.
+#
+# The HTML Help Workshop contains a compiler that can convert all HTML output
+# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
+# files are now used as the Windows 98 help format, and will replace the old
+# Windows help format (.hlp) on all Windows platforms in the future. Compressed
+# HTML files also contain an index, a table of contents, and you can search for
+# words in the documentation. The HTML workshop also contains a viewer for
+# compressed HTML files.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_HTMLHELP      = NO
+
+# The CHM_FILE tag can be used to specify the file name of the resulting .chm
+# file. You can add a path in front of the file if the result should not be
+# written to the html output directory.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_FILE               =
+
+# The HHC_LOCATION tag can be used to specify the location (absolute path
+# including file name) of the HTML help compiler (hhc.exe). If non-empty,
+# doxygen will try to run the HTML help compiler on the generated index.hhp.
+# The file has to be specified with full path.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+HHC_LOCATION           =
+
+# The GENERATE_CHI flag controls if a separate .chi index file is generated
+# (YES) or that it should be included in the master .chm file (NO).
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+GENERATE_CHI           = NO
+
+# The CHM_INDEX_ENCODING is used to encode HtmlHelp index (hhk), content (hhc)
+# and project file content.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_INDEX_ENCODING     =
+
+# The BINARY_TOC flag controls whether a binary table of contents is generated
+# (YES) or a normal table of contents (NO) in the .chm file. Furthermore it
+# enables the Previous and Next buttons.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members to
+# the table of contents of the HTML help documentation and to the tree view.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
+# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
+# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
+# (.qch) of the generated HTML documentation.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
+# the file name of the resulting .qch file. The path specified is relative to
+# the HTML output folder.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QCH_FILE               =
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
+# Project output. For more information please see Qt Help Project / Namespace
+# (see: http://doc.qt.io/archives/qt-4.8/qthelpproject.html#namespace).
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_NAMESPACE          = org.doxygen.Project
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
+# Help Project output. For more information please see Qt Help Project / Virtual
+# Folders (see: http://doc.qt.io/archives/qt-4.8/qthelpproject.html#virtual-
+# folders).
+# The default value is: doc.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
+# filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: http://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-
+# filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_NAME   =
+
+# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
+# custom filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: http://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-
+# filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_ATTRS  =
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
+# project's filter section matches. Qt Help Project / Filter Attributes (see:
+# http://doc.qt.io/archives/qt-4.8/qthelpproject.html#filter-attributes).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_SECT_FILTER_ATTRS  =
+
+# The QHG_LOCATION tag can be used to specify the location of Qt's
+# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the
+# generated .qhp file.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHG_LOCATION           =
+
+# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
+# generated, together with the HTML files, they form an Eclipse help plugin. To
+# install this plugin and make it available under the help contents menu in
+# Eclipse, the contents of the directory containing the HTML and XML files needs
+# to be copied into the plugins directory of eclipse. The name of the directory
+# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
+# After copying Eclipse needs to be restarted before the help appears.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_ECLIPSEHELP   = NO
+
+# A unique identifier for the Eclipse help plugin. When installing the plugin
+# the directory name containing the HTML and XML files should also have this
+# name. Each documentation set should have its own identifier.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.
+
+ECLIPSE_DOC_ID         = org.doxygen.Project
+
+# If you want full control over the layout of the generated HTML pages it might
+# be necessary to disable the index and replace it with your own. The
+# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
+# of each HTML page. A value of NO enables the index and the value YES disables
+# it. Since the tabs in the index contain the same information as the navigation
+# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+DISABLE_INDEX          = YES
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
+# structure should be generated to display hierarchical information. If the tag
+# value is set to YES, a side panel will be generated containing a tree-like
+# index structure (just like the one that is generated for HTML Help). For this
+# to work a browser that supports JavaScript, DHTML, CSS and frames is required
+# (i.e. any modern browser). Windows users are probably better off using the
+# HTML help feature. Via custom style sheets (see HTML_EXTRA_STYLESHEET) one can
+# further fine-tune the look of the index. As an example, the default style
+# sheet generated by doxygen has an example that shows how to put an image at
+# the root of the tree instead of the PROJECT_NAME. Since the tree basically has
+# the same information as the tab index, you could consider setting
+# DISABLE_INDEX to YES when enabling this option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_TREEVIEW      = YES
+
+# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
+# doxygen will group on one line in the generated HTML documentation.
+#
+# Note that a value of 0 will completely suppress the enum values from appearing
+# in the overview section.
+# Minimum value: 0, maximum value: 20, default value: 4.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
+# to set the initial width (in pixels) of the frame in which the tree is shown.
+# Minimum value: 0, maximum value: 1500, default value: 250.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+TREEVIEW_WIDTH         = 250
+
+# If the EXT_LINKS_IN_WINDOW option is set to YES, doxygen will open links to
+# external symbols imported via tag files in a separate window.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+EXT_LINKS_IN_WINDOW    = NO
+
+# Use this tag to change the font size of LaTeX formulas included as images in
+# the HTML documentation. When you change the font size after a successful
+# doxygen run you need to manually remove any form_*.png images from the HTML
+# output directory to force them to be regenerated.
+# Minimum value: 8, maximum value: 50, default value: 10.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_FONTSIZE       = 10
+
+# Use the FORMULA_TRANSPARENT tag to determine whether or not the images
+# generated for formulas are transparent PNGs. Transparent PNGs are not
+# supported properly for IE 6.0, but are supported on all modern browsers.
+#
+# Note that when changing this option you need to delete any form_*.png files in
+# the HTML output directory before the changes have effect.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_TRANSPARENT    = YES
+
+# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
+# https://www.mathjax.org) which uses client side Javascript for the rendering
+# instead of using pre-rendered bitmaps. Use this if you do not have LaTeX
+# installed or if you want to formulas look prettier in the HTML output. When
+# enabled you may also need to install MathJax separately and configure the path
+# to it using the MATHJAX_RELPATH option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+USE_MATHJAX            = NO
+
+# When MathJax is enabled you can set the default output format to be used for
+# the MathJax output. See the MathJax site (see:
+# http://docs.mathjax.org/en/latest/output.html) for more details.
+# Possible values are: HTML-CSS (which is slower, but has the best
+# compatibility), NativeMML (i.e. MathML) and SVG.
+# The default value is: HTML-CSS.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_FORMAT         = HTML-CSS
+
+# When MathJax is enabled you need to specify the location relative to the HTML
+# output directory using the MATHJAX_RELPATH option. The destination directory
+# should contain the MathJax.js script. For instance, if the mathjax directory
+# is located at the same level as the HTML output directory, then
+# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
+# Content Delivery Network so you can quickly see the result without installing
+# MathJax. However, it is strongly recommended to install a local copy of
+# MathJax from https://www.mathjax.org before deployment.
+# The default value is: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_RELPATH        = https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/
+
+# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
+# extension names that should be enabled during MathJax rendering. For example
+# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_EXTENSIONS     =
+
+# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
+# of code that will be used on startup of the MathJax code. See the MathJax site
+# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an
+# example see the documentation.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_CODEFILE       =
+
+# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
+# the HTML output. The underlying search engine uses javascript and DHTML and
+# should work on any modern browser. Note that when using HTML help
+# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
+# there is already a search function so this one should typically be disabled.
+# For large projects the javascript based search engine can be slow, then
+# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
+# search using the keyboard; to jump to the search box use <access key> + S
+# (what the <access key> is depends on the OS and browser, but it is typically
+# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
+# key> to jump into the search results window, the results can be navigated
+# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
+# the search. The filter options can be selected when the cursor is inside the
+# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
+# to select a filter and <Enter> or <escape> to activate or cancel the filter
+# option.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+SEARCHENGINE           = YES
+
+# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
+# implemented using a web server instead of a web client using Javascript. There
+# are two flavors of web server based searching depending on the EXTERNAL_SEARCH
+# setting. When disabled, doxygen will generate a PHP script for searching and
+# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing
+# and searching needs to be provided by external tools. See the section
+# "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SERVER_BASED_SEARCH    = NO
+
+# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
+# script for searching. Instead the search results are written to an XML file
+# which needs to be processed by an external indexer. Doxygen will invoke an
+# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
+# search results.
+#
+# Doxygen ships with an example indexer (doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: https://xapian.org/).
+#
+# See the section "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH        = NO
+
+# The SEARCHENGINE_URL should point to a search engine hosted by a web server
+# which will return the search results when EXTERNAL_SEARCH is enabled.
+#
+# Doxygen ships with an example indexer (doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: https://xapian.org/). See the section "External Indexing and
+# Searching" for details.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHENGINE_URL       =
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
+# search data is written to a file for indexing by an external tool. With the
+# SEARCHDATA_FILE tag the name of this file can be specified.
+# The default file is: searchdata.xml.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHDATA_FILE        = searchdata.xml
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
+# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
+# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
+# projects and redirect the results back to the right project.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH_ID     =
+
+# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
+# projects other than the one defined by this configuration file, but that are
+# all added to the same external search index. Each project needs to have a
+# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
+# to a relative location where the documentation can be found. The format is:
+# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTRA_SEARCH_MAPPINGS  =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES, doxygen will generate LaTeX output.
+# The default value is: YES.
+
+GENERATE_LATEX         = NO
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: latex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
+# invoked.
+#
+# Note that when not enabling USE_PDFLATEX the default is latex when enabling
+# USE_PDFLATEX the default is pdflatex and when in the later case latex is
+# chosen this is overwritten by pdflatex. For specific output languages the
+# default can have been set differently, this depends on the implementation of
+# the output language.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_CMD_NAME         =
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
+# index for LaTeX.
+# Note: This tag is used in the Makefile / make.bat.
+# See also: LATEX_MAKEINDEX_CMD for the part in the generated output file
+# (.tex).
+# The default file is: makeindex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# The LATEX_MAKEINDEX_CMD tag can be used to specify the command name to
+# generate index for LaTeX.
+# Note: This tag is used in the generated output file (.tex).
+# See also: MAKEINDEX_CMD_NAME for the part in the Makefile / make.bat.
+# The default value is: \makeindex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_MAKEINDEX_CMD    = \makeindex
+
+# If the COMPACT_LATEX tag is set to YES, doxygen generates more compact LaTeX
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used by the
+# printer.
+# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
+# 14 inches) and executive (7.25 x 10.5 inches).
+# The default value is: a4.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PAPER_TYPE             = a4
+
+# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
+# that should be included in the LaTeX output. The package can be specified just
+# by its name or with the correct syntax as to be used with the LaTeX
+# \usepackage command. To get the times font for instance you can specify :
+# EXTRA_PACKAGES=times or EXTRA_PACKAGES={times}
+# To use the option intlimits with the amsmath package you can specify:
+# EXTRA_PACKAGES=[intlimits]{amsmath}
+# If left blank no extra packages will be included.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+EXTRA_PACKAGES         =
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the
+# generated LaTeX document. The header should contain everything until the first
+# chapter. If it is left blank doxygen will generate a standard header. See
+# section "Doxygen usage" for information on how to let doxygen write the
+# default header to a separate file.
+#
+# Note: Only use a user-defined header if you know what you are doing! The
+# following commands have a special meaning inside the header: $title,
+# $datetime, $date, $doxygenversion, $projectname, $projectnumber,
+# $projectbrief, $projectlogo. Doxygen will replace $title with the empty
+# string, for the replacement values of the other commands the user is referred
+# to HTML_HEADER.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HEADER           =
+
+# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the
+# generated LaTeX document. The footer should contain everything after the last
+# chapter. If it is left blank doxygen will generate a standard footer. See
+# LATEX_HEADER for more information on how to generate a default footer and what
+# special commands can be used inside the footer.
+#
+# Note: Only use a user-defined footer if you know what you are doing!
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_FOOTER           =
+
+# The LATEX_EXTRA_STYLESHEET tag can be used to specify additional user-defined
+# LaTeX style sheets that are included after the standard style sheets created
+# by doxygen. Using this option one can overrule certain style aspects. Doxygen
+# will copy the style sheet files to the output directory.
+# Note: The order of the extra style sheet files is of importance (e.g. the last
+# style sheet in the list overrules the setting of the previous ones in the
+# list).
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EXTRA_STYLESHEET =
+
+# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the LATEX_OUTPUT output
+# directory. Note that the files will be copied as-is; there are no commands or
+# markers available.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EXTRA_FILES      =
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
+# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
+# contain links (just like the HTML output) instead of page references. This
+# makes the output suitable for online browsing using a PDF viewer.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PDF_HYPERLINKS         = YES
+
+# If the USE_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate
+# the PDF file directly from the LaTeX files. Set this option to YES, to get a
+# higher quality PDF documentation.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \batchmode
+# command to the generated LaTeX files. This will instruct LaTeX to keep running
+# if errors occur, instead of asking the user for help. This option is also used
+# when generating formulas in HTML.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BATCHMODE        = NO
+
+# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
+# index chapters (such as File Index, Compound Index, etc.) in the output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HIDE_INDICES     = NO
+
+# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source
+# code with syntax highlighting in the LaTeX output.
+#
+# Note that which sources are shown also depends on other settings such as
+# SOURCE_BROWSER.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_SOURCE_CODE      = NO
+
+# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
+# bibliography, e.g. plainnat, or ieeetr. See
+# https://en.wikipedia.org/wiki/BibTeX and \cite for more info.
+# The default value is: plain.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BIB_STYLE        = plain
+
+# If the LATEX_TIMESTAMP tag is set to YES then the footer of each generated
+# page will contain the date and time when the page was generated. Setting this
+# to NO can help when comparing the output of multiple runs.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_TIMESTAMP        = NO
+
+# The LATEX_EMOJI_DIRECTORY tag is used to specify the (relative or absolute)
+# path from which the emoji images will be read. If a relative path is entered,
+# it will be relative to the LATEX_OUTPUT directory. If left blank the
+# LATEX_OUTPUT directory will be used.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EMOJI_DIRECTORY  =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES, doxygen will generate RTF output. The
+# RTF output is optimized for Word 97 and may not look too pretty with other RTF
+# readers/editors.
+# The default value is: NO.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: rtf.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES, doxygen generates more compact RTF
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
+# contain hyperlink fields. The RTF file will contain links (just like the HTML
+# output) instead of page references. This makes the output suitable for online
+# browsing using Word or some other Word compatible readers that support those
+# fields.
+#
+# Note: WordPad (write) and others do not support links.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's
+# configuration file, i.e. a series of assignments. You only have to provide
+# replacements, missing definitions are set to their default value.
+#
+# See also section "Doxygen usage" for information on how to generate the
+# default style sheet that doxygen normally uses.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_STYLESHEET_FILE    =
+
+# Set optional variables used in the generation of an RTF document. Syntax is
+# similar to doxygen's configuration file. A template extensions file can be
+# generated using doxygen -e rtf extensionFile.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_EXTENSIONS_FILE    =
+
+# If the RTF_SOURCE_CODE tag is set to YES then doxygen will include source code
+# with syntax highlighting in the RTF output.
+#
+# Note that which sources are shown also depends on other settings such as
+# SOURCE_BROWSER.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_SOURCE_CODE        = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES, doxygen will generate man pages for
+# classes and files.
+# The default value is: NO.
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it. A directory man3 will be created inside the directory specified by
+# MAN_OUTPUT.
+# The default directory is: man.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to the generated
+# man pages. In case the manual section does not start with a number, the number
+# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
+# optional.
+# The default value is: .3.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_EXTENSION          = .3
+
+# The MAN_SUBDIR tag determines the name of the directory created within
+# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by
+# MAN_EXTENSION with the initial . removed.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_SUBDIR             =
+
+# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
+# will generate one additional man file for each entity documented in the real
+# man page(s). These additional files only source the real man page, but without
+# them the man command would be unable to find the correct page.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES, doxygen will generate an XML file that
+# captures the structure of the code including all documentation.
+# The default value is: NO.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: xml.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_OUTPUT             = xml
+
+# If the XML_PROGRAMLISTING tag is set to YES, doxygen will dump the program
+# listings (including syntax highlighting and cross-referencing information) to
+# the XML output. Note that enabling this will significantly increase the size
+# of the XML output.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_PROGRAMLISTING     = YES
+
+# If the XML_NS_MEMB_FILE_SCOPE tag is set to YES, doxygen will include
+# namespace members in file scope as well, matching the HTML output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_NS_MEMB_FILE_SCOPE = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the DOCBOOK output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_DOCBOOK tag is set to YES, doxygen will generate Docbook files
+# that can be used to generate PDF.
+# The default value is: NO.
+
+GENERATE_DOCBOOK       = NO
+
+# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
+# front of it.
+# The default directory is: docbook.
+# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+
+DOCBOOK_OUTPUT         = docbook
+
+# If the DOCBOOK_PROGRAMLISTING tag is set to YES, doxygen will include the
+# program listings (including syntax highlighting and cross-referencing
+# information) to the DOCBOOK output. Note that enabling this will significantly
+# increase the size of the DOCBOOK output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+
+DOCBOOK_PROGRAMLISTING = NO
+
+#---------------------------------------------------------------------------
+# Configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES, doxygen will generate an
+# AutoGen Definitions (see http://autogen.sourceforge.net/) file that captures
+# the structure of the code including all documentation. Note that this feature
+# is still experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES, doxygen will generate a Perl module
+# file that captures the structure of the code including all documentation.
+#
+# Note that this feature is still experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES, doxygen will generate the necessary
+# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
+# output from the Perl module output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES, the Perl module output will be nicely
+# formatted so it can be parsed by a human reader. This is useful if you want to
+# understand what is going on. On the other hand, if this tag is set to NO, the
+# size of the Perl module output will be much smaller and Perl will parse it
+# just the same.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file are
+# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
+# so different doxyrules.make files included by the same Makefile don't
+# overwrite each other's variables.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_MAKEVAR_PREFIX =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES, doxygen will evaluate all
+# C-preprocessor directives found in the sources and include files.
+# The default value is: YES.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES, doxygen will expand all macro names
+# in the source code. If set to NO, only conditional compilation will be
+# performed. Macro expansion can be done in a controlled way by setting
+# EXPAND_ONLY_PREDEF to YES.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
+# the macro expansion is limited to the macros specified with the PREDEFINED and
+# EXPAND_AS_DEFINED tags.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES, the include files in the
+# INCLUDE_PATH will be searched if a #include is found.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that
+# contain include files that are not input files but should be processed by the
+# preprocessor.
+# This tag requires that the tag SEARCH_INCLUDES is set to YES.
+
+INCLUDE_PATH           =
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
+# patterns (like *.h and *.hpp) to filter out the header-files in the
+# directories. If left blank, the patterns specified with FILE_PATTERNS will be
+# used.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+INCLUDE_FILE_PATTERNS  =
+
+# The PREDEFINED tag can be used to specify one or more macro names that are
+# defined before the preprocessor is started (similar to the -D option of e.g.
+# gcc). The argument of the tag is a list of macros of the form: name or
+# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
+# is assumed. To prevent a macro definition from being undefined via #undef or
+# recursively expanded use the := operator instead of the = operator.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+PREDEFINED             =
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
+# tag can be used to specify a list of macro names that should be expanded. The
+# macro definition that is found in the sources will be used. Use the PREDEFINED
+# tag if you want to use a different macro definition that overrules the
+# definition found in the source code.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_AS_DEFINED      =
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
+# remove all references to function-like macros that are alone on a line, have
+# an all uppercase name, and do not end with a semicolon. Such function macros
+# are typically used for boiler-plate code, and will confuse the parser if not
+# removed.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to external references
+#---------------------------------------------------------------------------
+
+# The TAGFILES tag can be used to specify one or more tag files. For each tag
+# file the location of the external documentation should be added. The format of
+# a tag file without this location is as follows:
+# TAGFILES = file1 file2 ...
+# Adding location for the tag files is done as follows:
+# TAGFILES = file1=loc1 "file2 = loc2" ...
+# where loc1 and loc2 can be relative or absolute paths or URLs. See the
+# section "Linking to external documentation" for more information about the use
+# of tag files.
+# Note: Each tag file must have a unique name (where the name does NOT include
+# the path). If a tag file is not located in the directory in which doxygen is
+# run, you must also specify the path to the tagfile here.
+
+TAGFILES               =
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
+# tag file that is based on the input files it reads. See section "Linking to
+# external documentation" for more information about the usage of tag files.
+
+GENERATE_TAGFILE       =
+
+# If the ALLEXTERNALS tag is set to YES, all external class will be listed in
+# the class index. If set to NO, only the inherited external classes will be
+# listed.
+# The default value is: NO.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES, all external groups will be listed
+# in the modules index. If set to NO, only the current project's groups will be
+# listed.
+# The default value is: YES.
+
+EXTERNAL_GROUPS        = YES
+
+# If the EXTERNAL_PAGES tag is set to YES, all external pages will be listed in
+# the related pages index. If set to NO, only the current project's pages will
+# be listed.
+# The default value is: YES.
+
+EXTERNAL_PAGES         = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script
+# interpreter (i.e. the result of 'which perl').
+# The default file (with absolute path) is: /usr/bin/perl.
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES, doxygen will generate a class diagram
+# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to
+# NO turns the diagrams off. Note that this option also works with HAVE_DOT
+# disabled, but it is recommended to install and use dot, since it yields more
+# powerful graphs.
+# The default value is: YES.
+
+CLASS_DIAGRAMS         = YES
+
+# You can define message sequence charts within doxygen comments using the \msc
+# command. Doxygen will then run the mscgen tool (see:
+# http://www.mcternan.me.uk/mscgen/)) to produce the chart and insert it in the
+# documentation. The MSCGEN_PATH tag allows you to specify the directory where
+# the mscgen tool resides. If left empty the tool is assumed to be found in the
+# default search path.
+
+MSCGEN_PATH            =
+
+# You can include diagrams made with dia in doxygen documentation. Doxygen will
+# then run dia to produce the diagram and insert it in the documentation. The
+# DIA_PATH tag allows you to specify the directory where the dia binary resides.
+# If left empty dia is assumed to be found in the default search path.
+
+DIA_PATH               =
+
+# If set to YES the inheritance and collaboration graphs will hide inheritance
+# and usage relations if the target is undocumented or is not a class.
+# The default value is: YES.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
+# available from the path. This tool is part of Graphviz (see:
+# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
+# Bell Labs. The other options in this section have no effect if this option is
+# set to NO
+# The default value is: NO.
+
+HAVE_DOT               = YES
+
+# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
+# to run in parallel. When set to 0 doxygen will base this on the number of
+# processors available in the system. You can set it explicitly to a value
+# larger than 0 to get control over the balance between CPU load and processing
+# speed.
+# Minimum value: 0, maximum value: 32, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_NUM_THREADS        = 0
+
+# When you want a differently looking font in the dot files that doxygen
+# generates you can specify the font name using DOT_FONTNAME. You need to make
+# sure dot is able to find the font, which can be done by putting it in a
+# standard location or by setting the DOTFONTPATH environment variable or by
+# setting DOT_FONTPATH to the directory containing the font.
+# The default value is: Helvetica.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTNAME           = Helvetica
+
+# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of
+# dot graphs.
+# Minimum value: 4, maximum value: 24, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the default font as specified with
+# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set
+# the path where dot can find it using this tag.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTPATH           =
+
+# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for
+# each documented class showing the direct and indirect inheritance relations.
+# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
+# graph for each documented class showing the direct and indirect implementation
+# dependencies (inheritance, containment, and class references variables) of the
+# class with other documented classes.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
+# groups, showing the direct groups dependencies.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES, doxygen will generate inheritance and
+# collaboration diagrams in a style similar to the OMG's Unified Modeling
+# Language.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LOOK               = YES
+
+# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
+# class node. If there are many fields or methods and many nodes the graph may
+# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
+# number of items for each type to make the size more manageable. Set this to 0
+# for no limit. Note that the threshold may be exceeded by 50% before the limit
+# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
+# but if the number exceeds 15, the total amount of fields shown is limited to
+# 10.
+# Minimum value: 0, maximum value: 100, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LIMIT_NUM_FIELDS   = 10
+
+# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
+# collaboration graphs will show the relations between templates and their
+# instances.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
+# YES then doxygen will generate a graph for each documented file showing the
+# direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDE_GRAPH          = YES
+
+# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
+# set to YES then doxygen will generate a graph for each documented file showing
+# the direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable call graphs for selected
+# functions only using the \callgraph command. Disabling a call graph can be
+# accomplished by means of the command \hidecallgraph.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALL_GRAPH             = NO
+
+# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable caller graphs for selected
+# functions only using the \callergraph command. Disabling a caller graph can be
+# accomplished by means of the command \hidecallergraph.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
+# hierarchy of all classes instead of a textual one.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
+# dependencies a directory has on other directories in a graphical way. The
+# dependency relations are determined by the #include relations between the
+# files in the directories.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
+# generated by dot. For an explanation of the image formats see the section
+# output formats in the documentation of the dot tool (Graphviz (see:
+# http://www.graphviz.org/)).
+# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
+# to make the SVG files visible in IE 9+ (other browsers do not have this
+# requirement).
+# Possible values are: png, jpg, gif, svg, png:gd, png:gd:gd, png:cairo,
+# png:cairo:gd, png:cairo:cairo, png:cairo:gdiplus, png:gdiplus and
+# png:gdiplus:gdiplus.
+# The default value is: png.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_IMAGE_FORMAT       = png
+
+# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
+# enable generation of interactive SVG images that allow zooming and panning.
+#
+# Note that this requires a modern browser other than Internet Explorer. Tested
+# and working are Firefox, Chrome, Safari, and Opera.
+# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
+# the SVG files visible. Older versions of IE do not have SVG support.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INTERACTIVE_SVG        = NO
+
+# The DOT_PATH tag can be used to specify the path where the dot tool can be
+# found. If left blank, it is assumed the dot tool can be found in the path.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_PATH               = "C:\Program Files (x86)\Graphviz2.38\bin"
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that
+# contain dot files that are included in the documentation (see the \dotfile
+# command).
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOTFILE_DIRS           =
+
+# The MSCFILE_DIRS tag can be used to specify one or more directories that
+# contain msc files that are included in the documentation (see the \mscfile
+# command).
+
+MSCFILE_DIRS           =
+
+# The DIAFILE_DIRS tag can be used to specify one or more directories that
+# contain dia files that are included in the documentation (see the \diafile
+# command).
+
+DIAFILE_DIRS           =
+
+# When using plantuml, the PLANTUML_JAR_PATH tag should be used to specify the
+# path where java can find the plantuml.jar file. If left blank, it is assumed
+# PlantUML is not used or called during a preprocessing step. Doxygen will
+# generate a warning when it encounters a \startuml command in this case and
+# will not generate output for the diagram.
+
+PLANTUML_JAR_PATH      =
+
+# When using plantuml, the PLANTUML_CFG_FILE tag can be used to specify a
+# configuration file for plantuml.
+
+PLANTUML_CFG_FILE      =
+
+# When using plantuml, the specified paths are searched for files specified by
+# the !include statement in a plantuml block.
+
+PLANTUML_INCLUDE_PATH  =
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
+# that will be shown in the graph. If the number of nodes in a graph becomes
+# larger than this value, doxygen will truncate the graph, which is visualized
+# by representing a node as a red box. Note that doxygen if the number of direct
+# children of the root node in a graph is already larger than
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
+# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+# Minimum value: 0, maximum value: 10000, default value: 50.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
+# generated by dot. A depth value of 3 means that only nodes reachable from the
+# root by following a path via at most 3 edges will be shown. Nodes that lay
+# further from the root node will be omitted. Note that setting this option to 1
+# or 2 may greatly reduce the computation time needed for large code bases. Also
+# note that the size of a graph can be further restricted by
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+# Minimum value: 0, maximum value: 1000, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
+# background. This is disabled by default, because dot on Windows does not seem
+# to support this out of the box.
+#
+# Warning: Depending on the platform used, enabling this option may lead to
+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to
+# read).
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES to allow dot to generate multiple output
+# files in one run (i.e. multiple -o and -T options on the command line). This
+# makes dot run faster, but since only newer versions of dot (>1.8.10) support
+# this, this feature is disabled by default.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
+# explaining the meaning of the various boxes and arrows in the dot generated
+# graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate dot
+# files that are used to generate the various graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_CLEANUP            = YES
diff --git a/emvco_hal_impl/doxygen/HowToUseDoxygen.txt b/emvco_hal_impl/doxygen/HowToUseDoxygen.txt
new file mode 100755
index 0000000..2f2c7c2
--- /dev/null
+++ b/emvco_hal_impl/doxygen/HowToUseDoxygen.txt
@@ -0,0 +1,51 @@
+This is a readme file to create a EMVCO Host Data Exchange Stack HTML document using Doxygen tool.
+
+Prerequisites:
+  1. Install the Doxygen Tool.
+     [https://www.doxygen.nl/files/doxygen-1.9.2-setup.exe]
+  2. Install the GraphViz package.
+     [http://www.graphviz.org/]
+
+Open the DoxyWizard tool installed in your system.
+   Apart from default settings, do below configurations: Please refer the sample configuration
+
+   A) Wizard --> Projects
+    - Project Name           = EMVCo Host Data Exchange Stack
+    - Project Synopsis       = Contactless and Contact EMVCo Card payment support for Android devices
+    - Project version or ID  = 1.0.1
+    - Project Logo           = Give a path of NXP logo(image file)
+    - Source code directory  = Select the EMVCo Data Exchange Stack Source code directory
+    - Destination Directory  = Select a output directory where output document shall be generated
+   B) Wizard --> Output
+    - From the output format to generate, Uncheck the LaTeX box.
+   C) Wizard --> Diagrams
+    - Select this option --> 'Use dot tool from the GraphViz package'
+      and enable the dot graphs options as per requirement.
+   D) Expert --> Project
+    - EXTENTION_MAPPING --> add  aidl=java
+    - enable the checkbox of DISTRIBUTE_GROUP_DOC.
+   E) Expert --> build :
+    - Enable checkbox for below configs
+      EXTRACT_ALL, EXTRACT_PRIVATE, EXTRACT_PRIV_VIRTUAL, EXTRACT_LOCAL_METHODS, INTERNAL_DOCS, , SHOW_GROUPED_MEMBER_INC
+    - Disable checkbox below configs:
+      SHOW_HEADRFILE, SHOW_INCLUDE_FILES, SHOW_USED_FILE, SHOW_FILES, SHOW_NAMESPACES
+   F) Expert --> input:
+    - File patterns -> *.aidl shall be added
+    - EXCLUDE_PATTERNS: add below patterns
+      *\aidl_api\*, *\utils\*, *\tml\*, *\log\*, *\common\*
+   G) Expert --> source browser:
+    - SOURCE_BROWSER(Check only if doc has to be used internally)
+   H) Expert --> HTML:
+    - Check below configs:
+      GENERATE_TREE_VIEW, DISABLE_INDEX
+   I) Specify the working directory from which the doxygen will run
+    - Specify the bin directory of doxygen
+Finally, click on the 'Run doxygen' tab from 'Run' window.
+
+Limitation:
+Currently image files are not getting copied automatically to output directory so document may not shown the images by default.
+To resolve this issue manually, please copy all the images from "emvco_hal_impl\doxygen\images" 
+to doxygen output directory (under html directory)
+
+
+Note: To create a PDF document, enable LaTeX Output from Wizard window and use it as imput with other avaialable tools.
diff --git a/emvco_hal_impl/doxygen/images/EMVCO_DIRECTORY_STRUCTURE.png b/emvco_hal_impl/doxygen/images/EMVCO_DIRECTORY_STRUCTURE.png
new file mode 100755
index 0000000..249d6a6
Binary files /dev/null and b/emvco_hal_impl/doxygen/images/EMVCO_DIRECTORY_STRUCTURE.png differ
diff --git a/emvco_hal_impl/doxygen/images/EMVCO_MW_ARCHITECTURE.png b/emvco_hal_impl/doxygen/images/EMVCO_MW_ARCHITECTURE.png
new file mode 100755
index 0000000..c378ae5
Binary files /dev/null and b/emvco_hal_impl/doxygen/images/EMVCO_MW_ARCHITECTURE.png differ
diff --git a/emvco_hal_impl/doxygen/images/NXP_LOGO.png b/emvco_hal_impl/doxygen/images/NXP_LOGO.png
new file mode 100755
index 0000000..cd71b54
Binary files /dev/null and b/emvco_hal_impl/doxygen/images/NXP_LOGO.png differ
diff --git a/emvco_hal_impl/emvco/cl/emvco_cl.c b/emvco_hal_impl/emvco/cl/emvco_cl.c
new file mode 100644
index 0000000..7b54d2b
--- /dev/null
+++ b/emvco_hal_impl/emvco/cl/emvco_cl.c
@@ -0,0 +1,287 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <emvco_cl.h>
+#include <emvco_common.h>
+#include <emvco_config.h>
+#include <emvco_dm.h>
+#include <emvco_log.h>
+#include <emvco_nci_ext.h>
+#include <emvco_ncif.h>
+#include <errno.h>
+#include <nci_parser.h>
+#include <osal_memory.h>
+#include <osal_thread.h>
+#include <peripherals.h>
+
+extern tml_emvco_context_t *gptml_emvco_context;
+extern nci_hal_ctrl_t nci_hal_ctrl;
+emvco_args_t *modeSwitchArgs;
+
+pthread_mutex_t emvco_lock = PTHREAD_MUTEX_INITIALIZER;
+
+/* the RF Discovery Frequency for each technology */
+const tDISC_FREQ_CFG rf_disc_freq_cfg = {
+    1, /* Frequency for EMVCo Technology A               */
+    1, /* Frequency for EMVCo Technology B               */
+    1, /* Frequency for EMVCo Technology F               */
+    1  /* Frequency for EMVCo Technology VAS             */
+};
+
+tDISC_FREQ_CFG *p_rf_disc_freq_cfg = (tDISC_FREQ_CFG *)&rf_disc_freq_cfg;
+
+void open_app_data_channel_internal() {
+  int hal_open_status = open_app_data_channelImpl(
+      m_p_nfc_stack_cback, m_p_nfc_stack_data_cback, m_p_nfc_state_cback);
+  LOG_EMVCOHAL_D("%s EMVCo HAL open status:%d", __func__, hal_open_status);
+  if (hal_open_status == EMVCO_STATUS_SUCCESS) {
+    lib_emvco_message_t msg;
+    msg.e_msgType = EMVCO_POOLING_STARTING_MSG;
+    msg.p_msg_data = NULL;
+    msg.size = 0;
+    tml_deferred_call(gptml_emvco_context->dw_callback_thread_id, &msg);
+    start_emvco_mode();
+  } else {
+    lib_emvco_message_t msg;
+    msg.e_msgType = EMVCO_POOLING_START_FAILED_MSG;
+    msg.p_msg_data = NULL;
+    msg.size = 0;
+    tml_deferred_call(gptml_emvco_context->dw_callback_thread_id, &msg);
+  }
+}
+
+void handle_nfc_state_change(int32_t nfc_state) {
+  LOG_EMVCOHAL_D("%s nfc_state:%d", __func__, nfc_state);
+  nfc_status = nfc_state;
+  if (nfc_status == STATE_OFF) {
+    modeSwitchArgs->current_discovery_mode = UNKNOWN;
+    if (modeSwitchArgs->is_start_emvco) {
+      open_app_data_channel_internal();
+    }
+  } else if (nfc_status == STATE_ON) {
+    modeSwitchArgs->current_discovery_mode = NFC;
+  }
+  return;
+}
+
+uint32_t mode_switch_control(emvco_control_code_t e_ctrl_code) {
+  int mode_switch_status;
+  LOG_EMVCOHAL_D("%s e_ctrl_code:%d", __func__, e_ctrl_code);
+  mode_switch_status = tml_ioctl(e_ctrl_code);
+  LOG_EMVCOHAL_D("%s modeswitch IOCTL status:%d", __func__, mode_switch_status);
+  return mode_switch_status;
+}
+
+bool is_valid_emvco_polling_tech(int8_t emvco_config) {
+  if (emvco_config >= NFC_A_PASSIVE_POLL_MODE &&
+      emvco_config <= NFC_ABFVAS_PASSIVE_POLL_MODE &&
+      emvco_config != NFC_A_PASSIVE_POLL_MODE &&
+      emvco_config != NFC_B_PASSIVE_POLL_MODE &&
+      emvco_config != NFC_AF_PASSIVE_POLL_MODE &&
+      emvco_config != NFC_BF_PASSIVE_POLL_MODE &&
+      emvco_config != NFC_VAS_PASSIVE_POLL_MODE &&
+      emvco_config != NFC_AVAS_PASSIVE_POLL_MODE &&
+      emvco_config != NFC_BVAS_PASSIVE_POLL_MODE &&
+      emvco_config != NFC_FVAS_PASSIVE_POLL_MODE &&
+      emvco_config != NFC_AFVAS_PASSIVE_POLL_MODE &&
+      emvco_config != NFC_BFVAS_PASSIVE_POLL_MODE) {
+    return true;
+  } else {
+    return false;
+  }
+}
+
+void handle_set_emvco_mode(const int8_t emvco_config, bool_t is_start_emvco) {
+  LOG_EMVCOHAL_D(
+      "%s emvco_config:%d, is_start_emvco:%d, current_discovery_mode:%d",
+      __func__, emvco_config, is_start_emvco,
+      modeSwitchArgs->current_discovery_mode);
+  pthread_mutex_lock(&emvco_lock);
+  modeSwitchArgs->is_start_emvco = is_start_emvco;
+  modeSwitchArgs->emvco_config = emvco_config;
+  if (is_start_emvco) {
+    if (is_valid_emvco_polling_tech(emvco_config)) {
+      if (EMVCO == modeSwitchArgs->current_discovery_mode) {
+        uint8_t num_params;
+        tEMVCO_DISCOVER_PARAMS disc_params[MAX_DISC_PARAMS];
+        num_params = get_rf_discover_config(modeSwitchArgs->emvco_config,
+                                            disc_params, MAX_DISC_PARAMS);
+        LOG_EMVCOHAL_D("RFDiscover num_params:%d", num_params);
+        send_discover_cmd(num_params, disc_params);
+      } else {
+        if (nfc_status == STATE_OFF) {
+          open_app_data_channel_internal();
+        } else {
+          m_p_nfc_state_cback(false);
+        }
+      }
+    } else {
+      LOG_EMVCOHAL_D("%s In-valid polling technlogy", __func__);
+      (*m_p_nfc_stack_cback)(EMVCO_POOLING_START_EVT, STATUS_FAILED);
+    }
+  } else {
+    if (nci_hal_ctrl.halStatus == HAL_STATUS_OPEN) {
+      LOG_EMVCOHAL_D("%s HAL is open, stop_emvco_mode", __func__);
+      stop_emvco_mode();
+    } else {
+      LOG_EMVCOHAL_D("%s HAL is not open, No need to clean up", __func__);
+    }
+  }
+  pthread_mutex_unlock(&emvco_lock);
+  return;
+}
+
+discovery_mode_t get_current_mode() {
+  LOG_EMVCOHAL_D("%s current_discovery_mode:%d", __func__,
+                 modeSwitchArgs->current_discovery_mode);
+  return modeSwitchArgs->current_discovery_mode;
+}
+/**
+ *
+ * Description      Build RF discovery configurations from
+ *                  tNFA_DM_DISC_TECH_PROTO_MASK
+ *
+ * Returns          number of RF discovery configurations
+ *
+ */
+uint8_t get_rf_discover_config(tDISC_TECH_PROTO_MASK dm_disc_mask,
+                               tEMVCO_DISCOVER_PARAMS disc_params[],
+                               uint8_t max_params) {
+  uint8_t num_params = 0;
+  /* Check polling A */
+  if (dm_disc_mask & DISC_MASK_EMVCO_A_PASSIVE_POLL_MODE) {
+    disc_params[num_params].type = NCI_DISCOVERY_TYPE_POLL_A;
+    disc_params[num_params].frequency = p_rf_disc_freq_cfg->pa;
+    num_params++;
+  }
+  if (dm_disc_mask & DISC_MASK_EMVCO_B_PASSIVE_POLL_MODE) {
+    disc_params[num_params].type = NCI_DISCOVERY_TYPE_POLL_B;
+    disc_params[num_params].frequency = p_rf_disc_freq_cfg->pb;
+    num_params++;
+  }
+  if (dm_disc_mask & DISC_MASK_EMVCO_F_PASSIVE_POLL_MODE) {
+    disc_params[num_params].type = NCI_DISCOVERY_TYPE_POLL_F;
+    disc_params[num_params].frequency = p_rf_disc_freq_cfg->pb;
+    num_params++;
+  }
+  if (dm_disc_mask & DISC_MASK_EMVCO_VAS_PASSIVE_POLL_MODE) {
+    disc_params[num_params].type = NCI_DISCOVERY_TYPE_POLL_VAS;
+    disc_params[num_params].frequency = p_rf_disc_freq_cfg->pb;
+    num_params++;
+  }
+  if (num_params >= max_params)
+    return num_params;
+
+  return num_params;
+}
+
+EMVCO_STATUS start_emvco_mode() {
+  LOG_EMVCOHAL_D("%s", __func__);
+  send_dynamic_set_config();
+  uint8_t cmd_prop_act[] = {0x2F, 0x02, 0x00};
+  send_proprietary_act_cmd(sizeof(cmd_prop_act), cmd_prop_act);
+  return EMVCO_STATUS_SUCCESS;
+}
+
+EMVCO_STATUS stop_emvco_mode() {
+  LOG_EMVCOHAL_D("stop_emvco_mode nci_stop_discovery without modeswitch");
+  led_switch_control(GREEN_LED_OFF);
+  int hal_close_status = close_app_data_channel(true);
+  LOG_EMVCOHAL_D("%s EMVCO HAL close status:%d", __func__, hal_close_status);
+
+  modeSwitchArgs->current_discovery_mode = UNKNOWN;
+  (*m_p_nfc_state_cback)(true);
+  return EMVCO_STATUS_SUCCESS;
+}
+void static send_poll_event_to_upper_layer() {
+  LOG_EMVCOHAL_D("EMVCO_POLLING_STARTED_MSG");
+  nci_hal_ctrl.frag_rsp.data_pos = 0;
+  RESET_CHAINED_DATA();
+
+  modeSwitchArgs->current_discovery_mode = EMVCO;
+  lib_emvco_message_t msg;
+  msg.e_msgType = EMVCO_POLLING_STARTED_MSG;
+  msg.p_msg_data = NULL;
+  msg.size = 0;
+  tml_deferred_call(gptml_emvco_context->dw_callback_thread_id, &msg);
+}
+
+EMVCO_STATUS process_emvco_mode_rsp(osal_transact_info_t *pTransactionInfo) {
+  LOG_EMVCOHAL_D("process_emvco_mode_rsp");
+  uint8_t *p_ntf = pTransactionInfo->p_buff;
+  uint16_t p_len = pTransactionInfo->w_length;
+  if (!modeSwitchArgs->is_start_emvco) {
+    return EMVCO_STATUS_FAILED;
+  }
+  LOG_EMVCOHAL_D("process_emvco_mode_rsp data_len:%d "
+                 "modeSwitchArgs->is_start_emvco:%d",
+                 p_len, modeSwitchArgs->is_start_emvco);
+  uint8_t msg_type, pbf, group_id, op_code, *p_data;
+
+  p_data = p_ntf;
+  NCI_MSG_PRS_HDR0(p_data, msg_type, pbf, group_id);
+  LOG_EMVCOHAL_D("process_emvco_mode_rsp msg_type:%d group_id:%d ", msg_type,
+                 group_id);
+
+  if (!(NCI_GID_CORE == group_id || NCI_GID_PROP == group_id ||
+        NCI_GID_RF_MANAGE == group_id)) {
+    return EMVCO_STATUS_FAILED;
+  }
+  NCI_MSG_PRS_HDR1(p_data, op_code);
+  LOG_EMVCOHAL_D("process_emvco_mode_rsp op_code:%d", op_code);
+  p_data = p_ntf;
+
+  switch (msg_type) {
+  case NCI_MSG_TYPE_RSP:
+    switch (group_id) {
+    case NCI_GID_PROP:
+      switch (op_code) {
+      case MSG_CORE_PROPRIETARY_RSP:
+        if (p_len == 8) {
+          uint8_t num_params;
+          tEMVCO_DISCOVER_PARAMS disc_params[MAX_DISC_PARAMS];
+          num_params = get_rf_discover_config(modeSwitchArgs->emvco_config,
+                                              disc_params, MAX_DISC_PARAMS);
+          LOG_EMVCOHAL_D("RFDiscover num_params:%d", num_params);
+          send_discover_cmd(num_params, disc_params);
+        }
+        break;
+      }
+      break;
+    case NCI_GID_RF_MANAGE:
+      switch (op_code) {
+      case RF_DEACTIVATE_NTF:
+      case MSG_RF_DISCOVER_RSP: {
+        send_poll_event_to_upper_layer();
+      } break;
+      }
+    }
+    break;
+  }
+  return EMVCO_STATUS_SUCCESS;
+}
+
+EMVCO_STATUS rf_deactivate(uint8_t deactivation_type) {
+  LOG_EMVCOHAL_D("rf_deactivate");
+  if (EMVCO != modeSwitchArgs->current_discovery_mode) {
+    LOG_EMVCOHAL_E("rf_deactivate failed - Not in EMVCo mode");
+    return EMVCO_STATUS_FAILED;
+  } else {
+    return send_deactivate_cmd(deactivation_type);
+  }
+}
diff --git a/emvco_hal_impl/emvco/cl/emvco_cl.h b/emvco_hal_impl/emvco/cl/emvco_cl.h
new file mode 100644
index 0000000..6825f4c
--- /dev/null
+++ b/emvco_hal_impl/emvco/cl/emvco_cl.h
@@ -0,0 +1,164 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _EMVCO_CL_H_
+#define _EMVCO_CL_H_
+
+/** \addtogroup EMVCO_STACK_CONTACT_LESS_CARD_API_INTERFACE
+ *  @brief  interface to perform the EMVCo mode switch and start the EMVCo
+ * polling.
+ *  @{
+ */
+
+#include <emvco_common.h>
+#include <emvco_tml.h>
+
+/* max discovery technology parameters */
+#define MAX_DISC_PARAMS 16
+
+#define DISC_MASK_PA_NFC_DEP 0x00000008
+
+/* Discovery Types/Detected Technology and Mode */
+#define NCI_DISCOVERY_TYPE_POLL_A 0x00
+#define NCI_DISCOVERY_TYPE_POLL_B 0x01
+#define NCI_DISCOVERY_TYPE_POLL_F 0x02
+#define NCI_DISCOVERY_TYPE_POLL_VAS 0x74
+
+#define DISC_MASK_EMVCO_A_PASSIVE_POLL_MODE 0x01
+#define DISC_MASK_EMVCO_B_PASSIVE_POLL_MODE 0x02
+#define DISC_MASK_EMVCO_F_PASSIVE_POLL_MODE 0x04
+#define DISC_MASK_EMVCO_VAS_PASSIVE_POLL_MODE 0x08
+
+/**
+ * @brief compile-time configuration structure for the RF Discovery Frequency
+ * for each technology
+ */
+typedef struct {
+  uint8_t pa;   /* Frequency for EMVCo Technology A   */
+  uint8_t pb;   /* Frequency for EMVCo Technology B   */
+  uint8_t pf;   /* Frequency for EMVCo Technology F   */
+  uint8_t pvas; /* Frequency for EMVCo Technology VAS */
+} tDISC_FREQ_CFG;
+
+/**
+ * @brief EMVCo polling type structure species type value and frequency value
+ * technology
+ */
+typedef struct {
+  uint8_t type;
+  uint8_t frequency;
+} tEMVCO_DISCOVER_PARAMS;
+
+/**
+ * @brief EMVCo polling discovery mask
+ *
+ */
+typedef uint32_t tDISC_TECH_PROTO_MASK;
+
+/**
+ * @brief emvco discovery configuration structure for emvco polling
+ * contains emvco polling type mask and start/stop flag
+ */
+typedef struct emvco_args {
+  int8_t emvco_config;
+  bool_t is_start_emvco;
+  int8_t current_discovery_mode;
+} emvco_args_t;
+
+void nfc_state_changed(int32_t nfc_state);
+
+uint8_t get_rf_discover_config(tDISC_TECH_PROTO_MASK dm_disc_mask,
+                               tEMVCO_DISCOVER_PARAMS disc_params[],
+                               uint8_t max_params);
+
+uint32_t mode_switch_control(emvco_control_code_t e_ctrl_code);
+
+void set_emvco_mode_impl(const int8_t emvco_config, bool_t is_start_emvco);
+/**
+ * @brief starts the EMVCo mode with the Device-Controller.
+ *
+ * @return EMVCO_STATUS indicates success or failure
+ *
+ */
+EMVCO_STATUS start_emvco_mode();
+
+/**
+ * @brief stops the EMVCo mode with the Device-Controller.
+ *
+ * @return EMVCO_STATUS indicates success or failure
+ *
+ */
+EMVCO_STATUS stop_emvco_mode();
+
+/**
+ * @brief process the NCI response and notification and ensures to do EMVCo
+ * polling from EMVCo mode switch start.
+ *
+ * @param[in] osal_transact_info NCI response or ntf to be processed
+ *
+ * @return EMVCO_STATUS indicates success or failure
+ *
+ */
+EMVCO_STATUS process_emvco_mode_rsp(osal_transact_info_t *osal_transact_info);
+
+/**
+ * @brief starts/stops the EMVCo mode with the Device-Controller.
+ *
+ * @param[in] in_disc_mask EMVCo polling technologies are configured through
+ * this parameter
+ * @param[in] is_start_emvco specifies to start or stop the EMVCo mode
+ *
+ * @return void
+ *
+ */
+void handle_set_emvco_mode(const int8_t in_disc_mask, bool_t is_start_emvco);
+
+/**
+ * @brief returns the current active profile type.
+ * @param[in] void
+ * @return discovery_mode_t - NFC/EMVCo/Unknown
+ *
+ */
+discovery_mode_t get_current_mode();
+
+/**
+ *
+ * @brief updates NFC state to EMVCo Stack.
+ *
+ *
+ * @param[in] nfc_state specifies the NFC state
+ *
+ * @return void
+ */
+void handle_nfc_state_change(int32_t nfc_state);
+
+/**
+ *
+ * @brief stops the RF field and moves in to the specified deactivation state.
+ *
+ *
+ * @param[in] deactivation_type specifies the state to be in after RF
+ * deactivation
+ *
+ * @return EMVCO_STATUS returns 0, if command processed successfully and returns
+ * 1, if command is not processed due to in-valid state. EMVCo mode should be ON
+ * to call this API
+ */
+EMVCO_STATUS rf_deactivate(uint8_t deactivation_type);
+
+/** @}*/
+#endif /* _EMVCO_CL_H_ */
diff --git a/emvco_hal_impl/emvco/ct/emvco_ct.c b/emvco_hal_impl/emvco/ct/emvco_ct.c
new file mode 100644
index 0000000..e08ed9b
--- /dev/null
+++ b/emvco_hal_impl/emvco/ct/emvco_ct.c
@@ -0,0 +1,17 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
diff --git a/emvco_hal_impl/emvco/ct/emvco_ct.h b/emvco_hal_impl/emvco/ct/emvco_ct.h
new file mode 100644
index 0000000..d49d3c6
--- /dev/null
+++ b/emvco_hal_impl/emvco/ct/emvco_ct.h
@@ -0,0 +1,33 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef _EMVCO_CT_H_
+#define _EMVCO_CT_H_
+/** \addtogroup EMVCO_STACK_CONTACT_LESS_CARD_API_INTERFACE
+ *  @brief  interface to perform the EMVCo mode switch.
+ *  @{
+ */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __cplusplus
+}
+#endif /*  C++ Compilation guard */
+/** @}*/
+#endif /* _EMVCO_CT_H_ */
diff --git a/emvco_hal_impl/inc/common/emvco_comp_id.h b/emvco_hal_impl/inc/common/emvco_comp_id.h
new file mode 100644
index 0000000..76d6513
--- /dev/null
+++ b/emvco_hal_impl/inc/common/emvco_comp_id.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2022 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * EMVCO Component ID Values - Used for Function Return Codes
+ */
+
+#ifndef _EMVCO_COMP_ID_H_
+#define _EMVCO_COMP_ID_H_
+
+/*
+ *  Component IDs
+ *
+ *  IDs for all EMVCO components. Combined with the Status Code they build the
+ * value (status)
+ *  returned by each function.
+ *
+ *  ID Number Spaces:
+ *  - 01..1F: HAL
+ *  - 20..3F: EMVCO-MW (Local Device)
+ *  - 40..5F: EMVCO-MW (Remote Device)
+ *  .
+ *
+ *         The value CID_EMVCO_NONE does not exist for Component IDs. Do not use
+ * this value except
+ *         for EMVCO_STATUS_SUCCESS. The enumeration function uses
+ * CID_EMVCO_NONE to mark unassigned "References".
+ */
+/* Unassigned or doesn't apply (see #EMVCO_STATUS_SUCCESS) */
+#define CID_EMVCO_NONE 0x00
+#define CID_EMVCO_TML 0x01 /* Transport Mapping Layer */
+#define CID_EMVCO_LLC 0x07 /* Logical Link Control Layer */
+/* EMVCO Controller Interface Layer */
+#define CID_EMVCO_NCI 0x08
+/* Firmware Download Management Layer */
+#define CID_EMVCO_DNLD 0x09
+#define CID_EMVCO_HAL 0x10 /* Hardware Abstraction Layer */
+/* Operating System Abstraction Layer*/
+#define CID_EMVCO_OSAL CID_EMVCO_NONE
+#define CID_FRI_EMVCO_OVR_HAL 0x20       /* EMVCO-Device, HAL-based */
+#define CID_FRI_EMVCO_NDEF_RECORD 0x22   /* NDEF Record Tools Library. */
+#define CID_FRI_EMVCO_NDEF_MAP 0x23      /* NDEF Mapping. */
+#define CID_FRI_EMVCO_NDEF_REGISTRY 0x24 /* NDEF_REGISTRY. */
+/* Automatic Device Discovery. */
+#define CID_FRI_EMVCO_AUTO_DEV_DIS 0x25
+#define CID_FRI_EMVCO_NDEF_SMTCRDFMT 0x26 /* Smart Card Formatting */
+#define CID_EMVCO_LIB 0x30                /* EMVCO Library Layer*/
+/* The maximum CID value that is defined. */
+#define CID_MAX_VALUE 0xF0
+/* Logical Link Control Protocol */
+#define CID_FRI_EMVCO_LLCP 0x40
+#define CID_FRI_EMVCO_LLCP_TRANSPORT 0x50
+#define CID_FRI_EMVCO_LLCP_MAC 0x60
+
+#endif /* _EMVCO_COMP_ID_H_ */
diff --git a/emvco_hal_impl/inc/common/emvco_osal_common.h b/emvco_hal_impl/inc/common/emvco_osal_common.h
new file mode 100644
index 0000000..7131dc2
--- /dev/null
+++ b/emvco_hal_impl/inc/common/emvco_osal_common.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2010-2021,2022 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ *  OSAL header files related to memory, debug, random, semaphore and mutex
+ * functions.
+ */
+
+#ifndef _EMVCO_OSAL_COMMON_H_
+#define _EMVCO_OSAL_COMMON_H_
+
+/*
+************************* Include Files ****************************************
+*/
+
+#include <emvco_comp_id.h>
+#include <emvco_status.h>
+#include <emvco_types.h>
+#include <osal_timer.h>
+#include <pthread.h>
+#include <semaphore.h>
+
+#ifndef FW_LIB_ROOT_DIR
+#if (defined(__arm64__) || defined(__aarch64__) || defined(_M_ARM64))
+#define FW_LIB_ROOT_DIR "/vendor/lib64/"
+#else
+#define FW_LIB_ROOT_DIR "/vendor/lib/"
+#endif
+#endif
+
+/*
+ *  information to configure OSAL
+ */
+typedef struct osal_emvco_config {
+  uint8_t *p_log_file;             /* Log File Name*/
+  uintptr_t dw_callback_thread_id; /* Client ID to which message is posted */
+} osal_emvco_config_t,
+    *posal_emvco_config_t /* Pointer to #osal_emvco_config_t */;
+
+/*
+ * Deferred call declaration.
+ * This type of API is called from ClientApplication (main thread) to notify
+ * specific callback.
+ */
+typedef void (*osal_emvco_defer_func_pointer)(void *);
+
+/*
+ * Deferred message specific info declaration.
+ */
+typedef struct osal_emvco_defer_call_info {
+  osal_emvco_defer_func_pointer pDeferedCall; /* pointer to Deferred callback */
+  void *pParam; /* contains timer message specific details*/
+} osal_emvco_defer_call_info_t;
+
+/*
+ * States in which a OSAL timer exist.
+ */
+typedef enum {
+  eTimerIdle = 0,            /* Indicates Initial state of timer */
+  eTimerRunning = 1,         /* Indicate timer state when started */
+  eTimerStopped = 2          /* Indicates timer state when stopped */
+} osal_emvco_timer_states_t; /* Variable representing State of timer */
+
+/*
+ **Timer Handle structure containing details of a timer.
+ */
+typedef struct osal_emvco_timer_handle {
+  uint32_t timer_id;    /* ID of the timer */
+  timer_t timer_handle; /* Handle of the timer */
+  /* Timer callback function to be invoked */
+  p_osal_emvco_timer_callback_t Application_callback;
+  void *p_context; /* Parameter to be passed to the callback function */
+  osal_emvco_timer_states_t eState; /* Timer states */
+  /* Osal Timer message posted on User Thread */
+  lib_emvco_message_t tOsalMessage;
+  /* Deferred Call structure to Invoke Callback function */
+  osal_emvco_defer_call_info_t tDeferedCallInfo;
+  /* Variables for Structure Instance and Structure Ptr */
+} osal_emvco_timer_handle_t, *posal_emvco_timer_handle_t;
+
+#endif /*  _EMVCO_OSAL_COMMON_H_  */
diff --git a/emvco_hal_impl/inc/common/emvco_types.h b/emvco_hal_impl/inc/common/emvco_types.h
new file mode 100644
index 0000000..c6d11e2
--- /dev/null
+++ b/emvco_hal_impl/inc/common/emvco_types.h
@@ -0,0 +1,130 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef _EMVCO_TYPES_H_
+#define _EMVCO_TYPES_H_
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <emvco_common.h>
+
+#ifndef TRUE
+#define TRUE (0x01) /* Logical True Value */
+#endif
+#ifndef FALSE
+#define FALSE (0x00) /* Logical False Value */
+#endif
+
+#define STATIC static
+
+#define EMVCO_MAX_UID_LENGTH 0x0AU /* Maximum UID length expected */
+/* Maximum ATR_RES (General Bytes) length expected */
+//#define EMVCO_MAX_ATR_LENGTH 0x30U
+//#define EMVCO_NFCID_LENGTH 0x0AU /* Maximum length of NFCID 1.3*/
+//#define EMVCO_ATQA_LENGTH 0x02U  /* ATQA length */
+
+/*
+ * Possible Hardware Configuration exposed to upper layer.
+ * Typically this should be port name (Ex:"COM1","COM2") to which Controller is
+ * connected.
+ */
+typedef enum {
+  ENUM_LINK_TYPE_COM1,
+  ENUM_LINK_TYPE_COM2,
+  ENUM_LINK_TYPE_COM3,
+  ENUM_LINK_TYPE_COM4,
+  ENUM_LINK_TYPE_COM5,
+  ENUM_LINK_TYPE_COM6,
+  ENUM_LINK_TYPE_COM7,
+  ENUM_LINK_TYPE_COM8,
+  ENUM_LINK_TYPE_I2C,
+  ENUM_LINK_TYPE_SPI,
+  ENUM_LINK_TYPE_USB,
+  ENUM_LINK_TYPE_TCP,
+  ENUM_LINK_TYPE_NB
+} config_link_type;
+
+/*
+ * Deferred message. This message type will be posted to the client application
+ * thread
+ * to notify that a deferred call must be invoked.
+ */
+#define EMVCO_DEFERRED_CALL_MSG (0x311)
+
+/*
+ * Deferred call declaration.
+ * This type of API is called from ClientApplication ( main thread) to notify
+ * specific callback.
+ */
+typedef void (*p_lib_emvco_deferred_callback_t)(void *);
+
+/*
+ * Deferred parameter declaration.
+ * This type of data is passed as parameter from ClientApplication (main thread)
+ * to the
+ * callback.
+ */
+typedef void *p_lib_emvco_deferred_parameter_t;
+
+/*
+ * Possible Hardware Configuration exposed to upper layer.
+ * Typically this should be at least the communication link (Ex:"COM1","COM2")
+ * the controller is connected to.
+ */
+typedef struct lib_emvco_hw_conf {
+  uint8_t *p_log_file; /* Log File Name*/
+  /* Hardware communication link to the controller */
+  config_link_type n_link_type;
+  /* The client ID (thread ID or message queue ID) */
+  uintptr_t n_client_id;
+} driver_config_data, *pdriver_config_data;
+
+/**
+ * @brief EMVCO Message structure contains message specific details like
+ *        message type, message specific data block details, etc.
+ */
+typedef struct lib_emvco_message {
+  uint32_t e_msgType; /* Type of the message to be posted*/
+  void *p_msg_data;   /* Pointer to message specific data block in case any*/
+  uint32_t size;      /* Size of the datablock*/
+} lib_emvco_message_t, *plib_emvco_message_t;
+
+/**
+ * @brief Deferred message specific info declaration.
+ * This type of information is packed as message data when
+ * EMVCO_DEFERRED_CALL_MSG
+ * type message is posted to message handler thread.
+ */
+typedef struct lib_emvco_deferred_call {
+  p_lib_emvco_deferred_callback_t p_callback; /* pointer to Deferred callback */
+  p_lib_emvco_deferred_parameter_t
+      p_parameter; /* pointer to Deferred parameter */
+} lib_emvco_deferred_call_t;
+
+/*
+ *  Enumerated MIFARE Commands
+ */
+
+#define UNUSED(X) (void)(X);
+
+#endif /* _EMVCO_TYPES_H_ */
diff --git a/emvco_hal_impl/inc/common/nci_parser.h b/emvco_hal_impl/inc/common/nci_parser.h
new file mode 100644
index 0000000..06d25c0
--- /dev/null
+++ b/emvco_hal_impl/inc/common/nci_parser.h
@@ -0,0 +1,68 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef _NCI_PARSER_H_
+#define _NCI_PARSER_H_
+
+#define NCI_MT_MASK 0xE0
+#define NCI_MT_SHIFT 5
+
+/* PBF: Packet Boundary Flag (byte 0) */
+#define NCI_PBF_MASK 0x10
+#define NCI_PBF_SHIFT 4
+
+/* GID: Group Identifier (byte 0) */
+#define NCI_GID_MASK 0x0F
+#define NCI_GID_CORE 0x00      /* 0000b NCI Core group */
+#define NCI_GID_RF_MANAGE 0x01 /* 0001b RF Management group */
+#define NCI_GID_EE_MANAGE 0x02 /* 0010b NFCEE Management group */
+#define NCI_GID_PROP 0x0F      /* 1111b Proprietary */
+/* 0111b - 1110b RFU */
+
+/* OID: Opcode Identifier (byte 1) */
+#define NCI_OID_MASK 0x3F
+
+#define NCI_BYTE_0_MASK 0x0F
+#define NCI_BYTE_1_MASK 0x1F
+#define NCI_BYTE_2_MASK 0x2F
+#define NCI_BYTE_3_MASK 0x3F
+
+#define NCI_MSG_TYPE_DATA 0
+#define NCI_MSG_TYPE_CMD 1 /* (NCI_MSG_TYPE_CMD << NCI_MT_SHIFT) = 0x20 */
+#define NCI_MSG_TYPE_RSP 2 /* (NCI_MSG_TYPE_RSP << NCI_MT_SHIFT) = 0x40 */
+#define NCI_MSG_TYPE_NTF 3 /* (NCI_MSG_TYPE_NTF << NCI_MT_SHIFT) = 0x60 */
+
+/* parse byte0 of NCI packet */
+#define NCI_MSG_PRS_HDR0(p, mt, pbf, gid)                                      \
+  mt = (*(p)&NCI_MT_MASK) >> NCI_MT_SHIFT;                                     \
+  (pbf) = (*(p)&NCI_PBF_MASK) >> NCI_PBF_SHIFT;                                \
+  (gid) = *(p)++ & NCI_GID_MASK;
+
+/* parse byte1 of NCI Cmd/Ntf */
+#define NCI_MSG_PRS_HDR1(p, oid)                                               \
+  (oid) = (*(p)&NCI_OID_MASK);                                                 \
+  (p)++;
+
+#define NCI_MSG_PRS_BYTE(p, oid)                                               \
+  (oid) = (*(p)&NCI_OID_MASK);                                                 \
+  (p)++;
+
+#define MSG_CORE_PROPRIETARY_RSP 2
+#define MSG_RF_DISCOVER_RSP 3
+#define RF_DEACTIVATE_NTF 6
+#endif /* _NCI_PARSER_H_ */
diff --git a/emvco_hal_impl/log/emvco_log.c b/emvco_hal_impl/log/emvco_log.c
new file mode 100644
index 0000000..2c77558
--- /dev/null
+++ b/emvco_hal_impl/log/emvco_log.c
@@ -0,0 +1,206 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#define LOG_TAG "NxpNfcHal"
+#include <stdio.h>
+#include <string.h>
+#if !defined(LOG__H_INCLUDED)
+#include "emvco_config.h"
+#include "emvco_log.h"
+#endif
+#include <cutils/properties.h>
+#include <log/log.h>
+
+const char *LOG_ITEM_EXTNS = "EMVCoExtns";
+const char *LOG_ITEM_NCIHAL = "EMVCoHal";
+const char *LOG_ITEM_NCIX = "EMVCoNciX";
+const char *LOG_ITEM_NCIR = "EMVCoNciR";
+const char *LOG_ITEM_TML = "EMVCoTml";
+
+/* global log level structure */
+nci_log_level_t gLog_level;
+
+extern bool emvco_debug_enabled;
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetGlobalLogLevel
+ *
+ * Description      Sets the global log level for all modules.
+ *                  This value is set by Android property
+ *nfc.log_level_global.
+ *                  If value can be overridden by module log level.
+ *
+ * Returns          The value of global log level
+ *
+ ******************************************************************************/
+static uint8_t set_global_log_level(void) {
+  uint8_t level = LOG_DEFAULT_LOGLEVEL;
+  unsigned long num = 0;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+
+  int len = property_get(PROP_NAME_LOG_GLOBAL_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    level = (unsigned char)num;
+  }
+  memset(&gLog_level, level, sizeof(nci_log_level_t));
+  return level;
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetHALLogLevel
+ *
+ * Description      Sets the HAL layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void set_hal_log_level(uint8_t level) {
+  unsigned long num = 0;
+  unsigned int num_len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+
+  if (get_byte_value(NAME_NXP_LOG_NCIHAL_LOGLEVEL, &num, &num_len)) {
+    gLog_level.hal_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+  }
+
+  LOG_EMVCOHAL_D("gLog_level.hal_log_level : %d", gLog_level.hal_log_level);
+
+  num_len = property_get(PROP_NAME_LOG_HAL_LOGLEVEL, valueStr, "");
+  if (num_len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.hal_log_level = (unsigned char)num;
+    LOG_EMVCOHAL_D("Android prop gLog_level.hal_log_level : %d",
+                   gLog_level.hal_log_level);
+  }
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetExtnsLogLevel
+ *
+ * Description      Sets the Extensions layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void set_extn_log_level(uint8_t level) {
+  unsigned long num = 0;
+  unsigned int num_len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  if (get_byte_value(NAME_NXP_LOG_EXTNS_LOGLEVEL, &num, &num_len)) {
+    gLog_level.extns_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+    ;
+  }
+  LOG_EMVCOHAL_D("gLog_level.extns_log_level : %d", gLog_level.extns_log_level);
+
+  num_len = property_get(PROP_NAME_LOG_EXTNS_LOGLEVEL, valueStr, "");
+  if (num_len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.extns_log_level = (unsigned char)num;
+    LOG_EMVCOHAL_D("Android prop gLog_level.extns_log_level : %d",
+                   gLog_level.extns_log_level);
+  }
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetTmlLogLevel
+ *
+ * Description      Sets the Tml layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void set_tml_log_level(uint8_t level) {
+  unsigned long num = 0;
+  unsigned int num_len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  if (get_byte_value(NAME_NXP_LOG_TML_LOGLEVEL, &num, &num_len)) {
+    gLog_level.tml_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+    ;
+  }
+  LOG_EMVCOHAL_D("gLog_level.tml_log_level : %d", gLog_level.tml_log_level);
+  num_len = property_get(PROP_NAME_LOG_TML_LOGLEVEL, valueStr, "");
+  if (num_len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.tml_log_level = (unsigned char)num;
+    LOG_EMVCOHAL_D("Android prop gLog_level.tml_log_level : %d",
+                   gLog_level.tml_log_level);
+  }
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetNciTxLogLevel
+ *
+ * Description      Sets the NCI transaction layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void set_nci_tx_log_level(uint8_t level) {
+  unsigned long num = 0;
+  unsigned int num_len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  if (get_byte_value(NAME_NXP_LOG_NCIX_LOGLEVEL, &num, &num_len)) {
+    gLog_level.ncix_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+  }
+
+  if (get_byte_value(NAME_NXP_LOG_NCIR_LOGLEVEL, &num, &num_len)) {
+    gLog_level.ncir_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+  }
+  LOG_EMVCOHAL_D("ncix_log_level : %d , gLog_level.ncir_log_level : %d",
+                 gLog_level.ncix_log_level, gLog_level.ncir_log_level);
+  num_len = property_get(PROP_NAME_LOG_NCI_LOGLEVEL, valueStr, "");
+  if (num_len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.ncix_log_level = (unsigned char)num;
+    gLog_level.ncir_log_level = (unsigned char)num;
+    LOG_EMVCOHAL_D(
+        "Android ncix_log_level : %d , gLog_level.ncir_log_level : %d",
+        gLog_level.ncix_log_level, gLog_level.ncir_log_level);
+  }
+}
+
+void initialize_log_level(void) {
+  uint8_t level = set_global_log_level();
+  set_hal_log_level(level);
+  set_extn_log_level(level);
+  set_tml_log_level(level);
+  set_nci_tx_log_level(level);
+
+  ALOGD_IF(emvco_debug_enabled, "%s: global =%u, Fwdnld =%u, extns =%u, \
+                hal =%u, tml =%u, ncir =%u, \
+                ncix =%u",
+           __func__, gLog_level.global_log_level, gLog_level.dnld_log_level,
+           gLog_level.extns_log_level, gLog_level.hal_log_level,
+           gLog_level.tml_log_level, gLog_level.ncir_log_level,
+           gLog_level.ncix_log_level);
+}
diff --git a/emvco_hal_impl/log/emvco_log.h b/emvco_hal_impl/log/emvco_log.h
new file mode 100644
index 0000000..93363c3
--- /dev/null
+++ b/emvco_hal_impl/log/emvco_log.h
@@ -0,0 +1,263 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/** \addtogroup EMVCO_STACK_LOG_API_INTERFACE
+ *  @brief  interface to control the EMVCo log level
+ *  @{
+ */
+#if !defined(LOG__H_INCLUDED)
+#define LOG__H_INCLUDED
+#include <log/log.h>
+#include <osal_log.h>
+
+typedef struct nci_log_level {
+  uint8_t global_log_level;
+  uint8_t extns_log_level;
+  uint8_t hal_log_level;
+  uint8_t dnld_log_level;
+  uint8_t tml_log_level;
+  uint8_t ncix_log_level;
+  uint8_t ncir_log_level;
+} nci_log_level_t;
+
+/* global log level Ref */
+extern nci_log_level_t gLog_level;
+extern bool emvco_debug_enabled;
+/* define log module included when compile */
+#define ENABLE_EXTNS_TRACES TRUE
+#define ENABLE_HAL_TRACES TRUE
+#define ENABLE_TML_TRACES TRUE
+#define ENABLE_NCIX_TRACES TRUE
+#define ENABLE_NCIR_TRACES TRUE
+
+#define NAME_NXP_LOG_EXTNS_LOGLEVEL "NXP_LOG_EXTNS_LOGLEVEL"
+#define NAME_NXP_LOG_NCIHAL_LOGLEVEL "NXP_LOG_NCIHAL_LOGLEVEL"
+#define NAME_NXP_LOG_NCIX_LOGLEVEL "NXP_LOG_NCIX_LOGLEVEL"
+#define NAME_NXP_LOG_NCIR_LOGLEVEL "NXP_LOG_NCIR_LOGLEVEL"
+#define NAME_NXP_LOG_TML_LOGLEVEL "NXP_LOG_TML_LOGLEVEL"
+#define NAME_NXP_EMVCO_DEBUG_ENABLED "NXP_EMVCO_DEBUG_ENABLED"
+#define NAME_NXP_EMVCO_DEV_NODE "NXP_EMVCO_DEV_NODE"
+#define NAME_NXP_ACT_PROP_EXTN "NXP_ACT_PROP_EXTN"
+#define NAME_NXP_PCD_SETTINGS "NXP_PCD_SETTINGS"
+#define NAME_NXP_SET_CONFIG "NXP_SET_CONFIG"
+#define NAME_NXP_GET_CONFIG "NXP_GET_CONFIG"
+/* ####################### Set the log module name by Android property
+ * ########################## */
+#define PROP_NAME_LOG_GLOBAL_LOGLEVEL "emvco.log_level_global"
+#define PROP_NAME_LOG_EXTNS_LOGLEVEL "emvco.log_level_extns"
+#define PROP_NAME_LOG_HAL_LOGLEVEL "emvco.log_level_hal"
+#define PROP_NAME_LOG_NCI_LOGLEVEL "emvco.log_level_nci"
+#define PROP_NAME_LOG_TML_LOGLEVEL "emvco.log_level_tml"
+
+/* ####################### Set the logging level for EVERY COMPONENT here
+ * ######################## :START: */
+#define LOG_LOG_SILENT_LOGLEVEL 0x00
+#define LOG_LOG_ERROR_LOGLEVEL 0x01
+#define LOG_LOG_WARN_LOGLEVEL 0x02
+#define LOG_LOG_DEBUG_LOGLEVEL 0x03
+/* ####################### Set the default logging level for EVERY COMPONENT
+ * here ########################## :END: */
+
+/* The Default log level for all the modules. */
+#define LOG_DEFAULT_LOGLEVEL LOG_LOG_ERROR_LOGLEVEL
+
+/* ################################################################################################################
+ */
+/* ############################################### Component Names
+ * ################################################ */
+/* ################################################################################################################
+ */
+
+extern const char *LOG_ITEM_EXTNS;  /* Android logging tag for NxpExtns  */
+extern const char *LOG_ITEM_NCIHAL; /* Android logging tag for NxpNciHal */
+extern const char *LOG_ITEM_NCIX;   /* Android logging tag for NxpNciX   */
+extern const char *LOG_ITEM_NCIR;   /* Android logging tag for NxpNciR   */
+extern const char *LOG_ITEM_TML;    /* Android logging tag for NxpTml    */
+
+/* ######################################## Defines used for Logging data
+ * ######################################### */
+#ifdef VRBS_REQ
+#define LOG_FUNC_ENTRY(COMP)                                                   \
+  OSAL_LOG_PRI(ANDROID_LOG_VERBOSE, (COMP), "+:%s", (__func__))
+#define LOG_FUNC_EXIT(COMP)                                                    \
+  OSAL_LOG_PRI(ANDROID_LOG_VERBOSE, (COMP), "-:%s", (__func__))
+#endif /*VRBS_REQ*/
+
+/* ################################################################################################################
+ */
+/* ######################################## Logging APIs of actual modules
+ * ######################################## */
+/* ################################################################################################################
+ */
+/* Logging APIs used by NxpExtns module */
+#if (ENABLE_EXTNS_TRACES == TRUE)
+#define LOG_EXTNS_D(...)                                                       \
+  {                                                                            \
+    if ((emvco_debug_enabled) ||                                               \
+        (gLog_level.extns_log_level >= LOG_LOG_DEBUG_LOGLEVEL))                \
+      OSAL_LOG_PRI(ANDROID_LOG_DEBUG, LOG_ITEM_EXTNS, __VA_ARGS__);            \
+  }
+#define LOG_EXTNS_W(...)                                                       \
+  {                                                                            \
+    if ((emvco_debug_enabled) ||                                               \
+        (gLog_level.extns_log_level >= LOG_LOG_WARN_LOGLEVEL))                 \
+      OSAL_LOG_PRI(ANDROID_LOG_WARN, LOG_ITEM_EXTNS, __VA_ARGS__);             \
+  }
+#define LOG_EXTNS_E(...)                                                       \
+  {                                                                            \
+    if (gLog_level.extns_log_level >= LOG_LOG_ERROR_LOGLEVEL)                  \
+      OSAL_LOG_PRI(ANDROID_LOG_ERROR, LOG_ITEM_EXTNS, __VA_ARGS__);            \
+  }
+#else
+#define LOG_EXTNS_D(...)
+#define LOG_EXTNS_W(...)
+#define LOG_EXTNS_E(...)
+#endif /* Logging APIs used by NxpExtns module */
+
+/* Logging APIs used by NxpNciHal module */
+#if (ENABLE_HAL_TRACES == TRUE)
+#define LOG_EMVCOHAL_D(...)                                                    \
+  {                                                                            \
+    if ((emvco_debug_enabled) ||                                               \
+        (gLog_level.hal_log_level >= LOG_LOG_DEBUG_LOGLEVEL))                  \
+      OSAL_LOG_PRI(ANDROID_LOG_DEBUG, LOG_ITEM_NCIHAL, __VA_ARGS__);           \
+  }
+#define LOG_EMVCOHAL_W(...)                                                    \
+  {                                                                            \
+    if ((emvco_debug_enabled) ||                                               \
+        (gLog_level.hal_log_level >= LOG_LOG_WARN_LOGLEVEL))                   \
+      OSAL_LOG_PRI(ANDROID_LOG_WARN, LOG_ITEM_NCIHAL, __VA_ARGS__);            \
+  }
+#define LOG_EMVCOHAL_E(...)                                                    \
+  {                                                                            \
+    if (gLog_level.hal_log_level >= LOG_LOG_ERROR_LOGLEVEL)                    \
+      OSAL_LOG_PRI(ANDROID_LOG_ERROR, LOG_ITEM_NCIHAL, __VA_ARGS__);           \
+  }
+#else
+#define LOG_EMVCOHAL_D(...)
+#define LOG_EMVCOHAL_W(...)
+#define LOG_EMVCOHAL_E(...)
+#endif /* Logging APIs used by HAL module */
+
+/* Logging APIs used by NxpNciX module */
+#if (ENABLE_NCIX_TRACES == TRUE)
+#define LOG_EMVCOX_D(...)                                                      \
+  {                                                                            \
+    if ((emvco_debug_enabled) ||                                               \
+        (gLog_level.ncix_log_level >= LOG_LOG_DEBUG_LOGLEVEL))                 \
+      OSAL_LOG_PRI(ANDROID_LOG_DEBUG, LOG_ITEM_NCIX, __VA_ARGS__);             \
+  }
+#define LOG_EMVCOX_W(...)                                                      \
+  {                                                                            \
+    if ((emvco_debug_enabled) ||                                               \
+        (gLog_level.ncix_log_level >= LOG_LOG_WARN_LOGLEVEL))                  \
+      OSAL_LOG_PRI(ANDROID_LOG_WARN, LOG_ITEM_NCIX, __VA_ARGS__);              \
+  }
+#define LOG_EMVCOX_E(...)                                                      \
+  {                                                                            \
+    if (gLog_level.ncix_log_level >= LOG_LOG_ERROR_LOGLEVEL)                   \
+      OSAL_LOG_PRI(ANDROID_LOG_ERROR, LOG_ITEM_NCIX, __VA_ARGS__);             \
+  }
+#else
+#define LOG_EMVCOX_D(...)
+#define LOG_EMVCOX_W(...)
+#define LOG_EMVCOX_E(...)
+#endif /* Logging APIs used by NCIx module */
+
+/* Logging APIs used by NxpNciR module */
+#if (ENABLE_NCIR_TRACES == TRUE)
+#define LOG_EMVCOR_D(...)                                                      \
+  {                                                                            \
+    if ((emvco_debug_enabled) ||                                               \
+        (gLog_level.ncir_log_level >= LOG_LOG_DEBUG_LOGLEVEL))                 \
+      OSAL_LOG_PRI(ANDROID_LOG_DEBUG, LOG_ITEM_NCIR, __VA_ARGS__);             \
+  }
+#define LOG_EMVCOR_W(...)                                                      \
+  {                                                                            \
+    if ((emvco_debug_enabled) ||                                               \
+        (gLog_level.ncir_log_level >= LOG_LOG_WARN_LOGLEVEL))                  \
+      OSAL_LOG_PRI(ANDROID_LOG_WARN, LOG_ITEM_NCIR, __VA_ARGS__);              \
+  }
+#define LOG_EMVCOR_E(...)                                                      \
+  {                                                                            \
+    if (gLog_level.ncir_log_level >= LOG_LOG_ERROR_LOGLEVEL)                   \
+      OSAL_LOG_PRI(ANDROID_LOG_ERROR, LOG_ITEM_NCIR, __VA_ARGS__);             \
+  }
+#else
+#define LOG_EMVCOR_D(...)
+#define LOG_EMVCOR_W(...)
+#define LOG_EMVCOR_E(...)
+#endif /* Logging APIs used by NCIR module */
+
+/* Logging APIs used by NxpTml module */
+#if (ENABLE_TML_TRACES == TRUE)
+#define LOG_EMVCO_TML_D(...)                                                   \
+  {                                                                            \
+    if ((emvco_debug_enabled) ||                                               \
+        (gLog_level.tml_log_level >= LOG_LOG_DEBUG_LOGLEVEL))                  \
+      OSAL_LOG_PRI(ANDROID_LOG_DEBUG, LOG_ITEM_TML, __VA_ARGS__);              \
+  }
+#define LOG_EMVCO_TML_W(...)                                                   \
+  {                                                                            \
+    if ((emvco_debug_enabled) ||                                               \
+        (gLog_level.tml_log_level >= LOG_LOG_WARN_LOGLEVEL))                   \
+      OSAL_LOG_PRI(ANDROID_LOG_WARN, LOG_ITEM_TML, __VA_ARGS__);               \
+  }
+#define LOG_EMVCO_TML_E(...)                                                   \
+  {                                                                            \
+    if (gLog_level.tml_log_level >= LOG_LOG_ERROR_LOGLEVEL)                    \
+      OSAL_LOG_PRI(ANDROID_LOG_ERROR, LOG_ITEM_TML, __VA_ARGS__);              \
+  }
+#else
+#define LOG_EMVCO_TML_D(...)
+#define LOG_EMVCO_TML_W(...)
+#define LOG_EMVCO_TML_E(...)
+#endif /* Logging APIs used by NxpTml module */
+
+/**
+ * @brief           Initialize and get log level of module from libemvco.conf
+ *                  or
+ *                  Android runtime properties.
+ *                  The Android property emvco_global_log_level is to
+ *                  define log level for all modules. Modules log level will
+ *                  overwide global level.
+ *                  The Android property will overwide the level
+ *                  in libemvco.conf
+ *
+ *                  Android property names:
+ *                      emvco.log_level_global    * defines log level for all
+ *                      modules
+ *                      emvco.log_level_extns     * extensions module log
+ *                      emvco.log_level_hal       * Hal module log
+ *                      emvco.log_level_tml       * TML module log
+ *                      emvco.log_level_nci       * NCI transaction log
+ *
+ *                      Log Level values:
+ *                      LOG_LOG_SILENT_LOGLEVEL  0        * No trace to show
+ *                      LOG_LOG_ERROR_LOGLEVEL   1        * Show Error trace
+ *                      only
+ *                      LOG_LOG_WARN_LOGLEVEL    2        * Show Warning
+ *                      trace and Error trace
+ *                      LOG_LOG_DEBUG_LOGLEVEL   3        * Show all traces
+ *
+ * @return          void
+ *
+ ******************************************************************************/
+void initialize_log_level(void);
+/** @}*/
+#endif /* LOG__H_INCLUDED */
diff --git a/emvco_hal_impl/nci/emvco_nci_ext.c b/emvco_hal_impl/nci/emvco_nci_ext.c
new file mode 100644
index 0000000..9f388ca
--- /dev/null
+++ b/emvco_hal_impl/nci/emvco_nci_ext.c
@@ -0,0 +1,902 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#include "emvco_cl.h"
+#include <emvco_config.h>
+#include <emvco_dm.h>
+#include <emvco_log.h>
+#include <emvco_nci_ext.h>
+#include <emvco_tml.h>
+#include <log/log.h>
+#include <nci_parser.h>
+#include <osal_log.h>
+#include <osal_memory.h>
+#include <osal_message_queue_lib.h>
+#include <pthread.h>
+
+/* Timeout value to wait for response from PN548AD */
+#define HAL_EXTNS_WRITE_RSP_TIMEOUT (1000)
+
+#define INDEX_OF_NFCID1_LEN 12
+#define SEL_RES_LEN 1
+#define SEL_RES_DATA_LEN 1
+#define PROTOCOL_T3T 0x03
+#define PROTOCOL_ISO_DEP 0x04
+#define TYPE_4A_TAG_MASK 0x20
+#define TYPE_4B_TAG_MASK 0x01
+#define RF_TECH_MODE_NFC_A_PASSIVE_POLL 0x00
+#define RF_TECH_MODE_NFC_B_PASSIVE_POLL 0x01
+#define SENSB_RESP_PROTOCOL_TYPE_INDEX 20
+#define RF_PROTOCOL_INDEX 5
+#define RF_TECH_MODE_INDEX 6
+#define RF_INTF_ACTIVATED_NTF_BYTE_0 0x61
+#define RF_INTF_ACTIVATED_NTF_BYTE_1 0x05
+#undef P2P_PRIO_LOGIC_HAL_IMP
+
+/******************* Global variables *****************************************/
+extern nci_hal_ctrl_t nci_hal_ctrl;
+extern nci_profile_Control_t nxpprofile_ctrl;
+extern tml_emvco_context_t *gptml_emvco_context;
+// extern uint32_t cleanup_timer;
+extern bool emvco_debug_enabled;
+uint8_t icode_detected = 0x00;
+uint8_t icode_send_eof = 0x00;
+uint8_t nfcdep_detected = 0x00;
+static uint8_t ee_disc_done = 0x00;
+uint8_t EnableP2P_PrioLogic = false;
+
+/* NFCEE Set mode */
+static uint8_t setEEModeDone = 0x00;
+uint32_t wFwVerRsp;
+uint16_t wFwVer;
+
+uint16_t rom_version;
+extern uint32_t timeoutTimerId;
+
+/************** HAL extension functions ***************************************/
+static void hal_extns_write_rsp_timeout_cb(uint32_t timer_id, void *p_context);
+
+/*Proprietary cmd sent to HAL to send reader mode flag
+ * Last byte of 4 byte proprietary cmd data contains ReaderMode flag
+ * If this flag is enabled, NFC-DEP protocol is modified to T3T protocol
+ * if FrameRF interface is selected. This needs to be done as the FW
+ * always sends Ntf for FrameRF with NFC-DEP even though FrameRF with T3T is
+ * previously selected with DISCOVER_SELECT_CMD
+ */
+#define PROPRIETARY_CMD_FELICA_READER_MODE 0xFE
+static uint8_t gFelicaReaderMode;
+
+static EMVCO_STATUS process_emvco_init_rsp(uint8_t *p_ntf, uint16_t *p_len);
+/*******************************************************************************
+**
+** Function         nci_ext_init
+**
+** Description      initialize extension function
+**
+*******************************************************************************/
+void nci_ext_init(void) {
+  icode_detected = 0x00;
+  icode_send_eof = 0x00;
+  setEEModeDone = 0x00;
+  EnableP2P_PrioLogic = false;
+}
+
+static void phNxpNciHal_ext_process_non_emvco_card_ntf() {
+  lib_emvco_message_t msg;
+  msg.e_msgType = EMVCO_UN_SUPPORTED_CARD_MSG;
+  msg.p_msg_data = NULL;
+  msg.size = 0;
+  tml_deferred_call(gptml_emvco_context->dw_callback_thread_id, &msg);
+  rf_deactivate(DISCOVER);
+}
+
+EMVCO_STATUS process_ext_rsp(uint8_t *p_ntf, uint16_t *p_len) {
+  EMVCO_STATUS status = EMVCO_STATUS_SUCCESS;
+  int select_index = 0;
+
+  if (p_ntf[0] == 0x61 && p_ntf[1] == 0x05 && *p_len < 14) {
+
+    if (*p_len <= 6) {
+      __osal_log_error_write(0x534e4554, "118152591");
+    }
+    LOG_EMVCOHAL_E("RF_INTF_ACTIVATED_NTF length error!");
+    status = EMVCO_STATUS_FAILED;
+    return status;
+  }
+
+  if (p_ntf[0] == RF_INTF_ACTIVATED_NTF_BYTE_0 &&
+      p_ntf[1] == RF_INTF_ACTIVATED_NTF_BYTE_1) {
+    if (p_ntf[RF_PROTOCOL_INDEX] == PROTOCOL_T3T) {
+      LOG_EMVCOHAL_D("T3T EMVCo card detected in EmvCo profile");
+    } else if ((p_ntf[RF_PROTOCOL_INDEX] == PROTOCOL_ISO_DEP) &&
+               (p_ntf[RF_TECH_MODE_INDEX] == RF_TECH_MODE_NFC_A_PASSIVE_POLL) &&
+               (*p_len >= INDEX_OF_NFCID1_LEN)) {
+      select_index = INDEX_OF_NFCID1_LEN + p_ntf[INDEX_OF_NFCID1_LEN] +
+                     SEL_RES_LEN + SEL_RES_DATA_LEN;
+      /* Checking the SEL_RES Response format byte to confirm T4A Tag Platform
+       * Enablement */
+      if (p_ntf[select_index] & TYPE_4A_TAG_MASK) {
+        LOG_EMVCOHAL_D("Type-A  ISO DEP EMVCo card detected in EmvCo profile");
+      } else {
+        LOG_EMVCOHAL_D("InValid SAK. Non EMVCo card detected in EmvCo profile "
+                       "- Restart polling");
+        phNxpNciHal_ext_process_non_emvco_card_ntf();
+        status = EMVCO_STATUS_FAILED;
+        return status;
+      }
+    } else if ((p_ntf[RF_PROTOCOL_INDEX] == PROTOCOL_ISO_DEP) &&
+               (p_ntf[RF_TECH_MODE_INDEX] == RF_TECH_MODE_NFC_B_PASSIVE_POLL) &&
+               (*p_len >= INDEX_OF_NFCID1_LEN)) {
+      /* Checking the SENSB_RES Response format byte to confirm T4B Tag Platform
+       * Enablement */
+      if (p_ntf[SENSB_RESP_PROTOCOL_TYPE_INDEX] & TYPE_4B_TAG_MASK) {
+        LOG_EMVCOHAL_D("Type-B ISO DEP EMVCo card detected in EmvCo profile");
+      } else {
+        LOG_EMVCOHAL_D("InValid SAK. Non EMVCo card detected in EmvCo profile "
+                       "- Restart polling");
+        phNxpNciHal_ext_process_non_emvco_card_ntf();
+        status = EMVCO_STATUS_FAILED;
+        return status;
+      }
+    } else {
+      LOG_EMVCOHAL_D("RF_INTF_ACTIVATED_NTF length error. Non EMVCo card "
+                     "detected in EmvCo profile - Restart polling");
+      phNxpNciHal_ext_process_non_emvco_card_ntf();
+      status = EMVCO_STATUS_FAILED;
+      return status;
+    }
+  }
+
+  if (p_ntf[0] == 0x61 && p_ntf[1] == 0x05 && p_ntf[4] == 0x03 &&
+      p_ntf[5] == 0x05 && nxpprofile_ctrl.profile_type == EMV_CO_PROFILE) {
+    p_ntf[4] = 0xFF;
+    p_ntf[5] = 0xFF;
+    p_ntf[6] = 0xFF;
+    LOG_EMVCOHAL_D("Nfc-Dep Detect in EmvCo profile - Restart polling");
+  }
+
+  if (p_ntf[0] == 0x61 && p_ntf[1] == 0x05 && p_ntf[4] == 0x01 &&
+      p_ntf[5] == 0x05 && p_ntf[6] == 0x02 && gFelicaReaderMode) {
+    /*If FelicaReaderMode is enabled,Change Protocol to T3T from NFC-DEP
+     * when FrameRF interface is selected*/
+    p_ntf[5] = 0x03;
+    LOG_EMVCOHAL_D("FelicaReaderMode:Activity 1.1");
+  }
+
+#ifdef P2P_PRIO_LOGIC_HAL_IMP
+  if (p_ntf[0] == 0x61 && p_ntf[1] == 0x05 && p_ntf[4] == 0x02 &&
+      p_ntf[5] == 0x04 && nxpprofile_ctrl.profile_type == NFC_FORUM_PROFILE) {
+    EnableP2P_PrioLogic = true;
+  }
+
+  LOG_EMVCOHAL_D("Is EnableP2P_PrioLogic: 0x0%X", EnableP2P_PrioLogic);
+
+#endif
+
+  status = EMVCO_STATUS_SUCCESS;
+
+  if (p_ntf[0] == 0x61 && p_ntf[1] == 0x05) {
+    switch (p_ntf[4]) {
+    case 0x00:
+      LOG_EMVCOHAL_D("NxpNci: RF Interface = NFCEE Direct RF");
+      break;
+    case 0x01:
+      LOG_EMVCOHAL_D("NxpNci: RF Interface = Frame RF");
+      break;
+    case 0x02:
+      LOG_EMVCOHAL_D("NxpNci: RF Interface = ISO-DEP");
+      break;
+    case 0x03:
+      LOG_EMVCOHAL_D("NxpNci: RF Interface = NFC-DEP");
+      break;
+    case 0x80:
+      LOG_EMVCOHAL_D("NxpNci: RF Interface = MIFARE");
+      break;
+    default:
+      LOG_EMVCOHAL_D("NxpNci: RF Interface = Unknown");
+      break;
+    }
+
+    switch (p_ntf[5]) {
+    case 0x01:
+      LOG_EMVCOHAL_D("NxpNci: Protocol = T1T");
+      break;
+    case 0x02:
+      LOG_EMVCOHAL_D("NxpNci: Protocol = T2T");
+      break;
+    case 0x03:
+      LOG_EMVCOHAL_D("NxpNci: Protocol = T3T");
+      break;
+    case 0x04:
+      LOG_EMVCOHAL_D("NxpNci: Protocol = ISO-DEP");
+      break;
+    case 0x05:
+      LOG_EMVCOHAL_D("NxpNci: Protocol = NFC-DEP");
+      break;
+    case 0x06:
+      LOG_EMVCOHAL_D("NxpNci: Protocol = 15693");
+      break;
+    case 0x80:
+      LOG_EMVCOHAL_D("NxpNci: Protocol = MIFARE");
+      break;
+    case 0x81:
+      LOG_EMVCOHAL_D("NxpNci: Protocol = Kovio");
+      break;
+    default:
+      LOG_EMVCOHAL_D("NxpNci: Protocol = Unknown");
+      break;
+    }
+
+    switch (p_ntf[6]) {
+    case 0x00:
+      LOG_EMVCOHAL_D("NxpNci: Mode = A Passive Poll");
+      break;
+    case 0x01:
+      LOG_EMVCOHAL_D("NxpNci: Mode = B Passive Poll");
+      break;
+    case 0x02:
+      LOG_EMVCOHAL_D("NxpNci: Mode = F Passive Poll");
+      break;
+    case 0x03:
+      LOG_EMVCOHAL_D("NxpNci: Mode = A Active Poll");
+      break;
+    case 0x05:
+      LOG_EMVCOHAL_D("NxpNci: Mode = F Active Poll");
+      break;
+    case 0x06:
+      LOG_EMVCOHAL_D("NxpNci: Mode = 15693 Passive Poll");
+      break;
+    case 0x70:
+      LOG_EMVCOHAL_D("NxpNci: Mode = Kovio");
+      break;
+    case 0x80:
+      LOG_EMVCOHAL_D("NxpNci: Mode = A Passive Listen");
+      break;
+    case 0x81:
+      LOG_EMVCOHAL_D("NxpNci: Mode = B Passive Listen");
+      break;
+    case 0x82:
+      LOG_EMVCOHAL_D("NxpNci: Mode = F Passive Listen");
+      break;
+    case 0x83:
+      LOG_EMVCOHAL_D("NxpNci: Mode = A Active Listen");
+      break;
+    case 0x85:
+      LOG_EMVCOHAL_D("NxpNci: Mode = F Active Listen");
+      break;
+    case 0x86:
+      LOG_EMVCOHAL_D("NxpNci: Mode = 15693 Passive Listen");
+      break;
+    default:
+      LOG_EMVCOHAL_D("NxpNci: Mode = Unknown");
+      break;
+    }
+  }
+  process_emvco_init_rsp(p_ntf, p_len);
+
+  if (p_ntf[0] == 0x61 && p_ntf[1] == 0x05 && p_ntf[2] == 0x15 &&
+      p_ntf[4] == 0x01 && p_ntf[5] == 0x06 && p_ntf[6] == 0x06) {
+    LOG_EMVCOHAL_D("> Going through workaround - notification of ISO 15693");
+    icode_detected = 0x01;
+    p_ntf[21] = 0x01;
+    p_ntf[22] = 0x01;
+  } else if (icode_detected == 1 && icode_send_eof == 2) {
+    icode_send_eof = 3;
+  } else if (p_ntf[0] == 0x00 && p_ntf[1] == 0x00 && icode_detected == 1) {
+    if (icode_send_eof == 3) {
+      icode_send_eof = 0;
+    }
+    if (nci_hal_ctrl.nci_info.nci_version != NCI_VERSION_2_0) {
+      if (*p_len <= (p_ntf[2] + 2)) {
+        __osal_log_error_write(0x534e4554, "181660091");
+        LOG_EMVCOHAL_E("length error!");
+        return EMVCO_STATUS_FAILED;
+      }
+      if (p_ntf[p_ntf[2] + 2] == 0x00) {
+        LOG_EMVCOHAL_D("> Going through workaround - data of ISO 15693");
+        p_ntf[2]--;
+        (*p_len)--;
+      } else {
+        p_ntf[p_ntf[2] + 2] |= 0x01;
+      }
+    }
+  } else if (p_ntf[2] == 0x02 && p_ntf[1] == 0x00 && icode_detected == 1) {
+    LOG_EMVCOHAL_D("> ICODE EOF response do not send to upper layer");
+  } else if (p_ntf[0] == 0x61 && p_ntf[1] == 0x06 && icode_detected == 1) {
+    LOG_EMVCOHAL_D("> Polling Loop Re-Started");
+    icode_detected = 0;
+    icode_send_eof = 0;
+  } else if (*p_len == 4 && p_ntf[0] == 0x40 && p_ntf[1] == 0x02 &&
+             p_ntf[2] == 0x01 && p_ntf[3] == 0x06) {
+    LOG_EMVCOHAL_D("> Deinit workaround for LLCP set_config 0x%x 0x%x 0x%x",
+                   p_ntf[21], p_ntf[22], p_ntf[23]);
+    p_ntf[0] = 0x40;
+    p_ntf[1] = 0x02;
+    p_ntf[2] = 0x02;
+    p_ntf[3] = 0x00;
+    p_ntf[4] = 0x00;
+    *p_len = 5;
+  }
+  // 4200 02 00 01
+  else if (p_ntf[0] == 0x42 && p_ntf[1] == 0x00 && ee_disc_done == 0x01) {
+    LOG_EMVCOHAL_D("Going through workaround - NFCEE_DISCOVER_RSP");
+    if (p_ntf[4] == 0x01) {
+      p_ntf[4] = 0x00;
+
+      ee_disc_done = 0x00;
+    }
+    LOG_EMVCOHAL_D("Going through workaround - NFCEE_DISCOVER_RSP - END");
+
+  } else if (*p_len == 4 && p_ntf[0] == 0x4F && p_ntf[1] == 0x11 &&
+             p_ntf[2] == 0x01) {
+    if (p_ntf[3] == 0x00) {
+      LOG_EMVCOHAL_D(
+          ">  Workaround for ISO-DEP Presence Check, ignore response and wait "
+          "for notification");
+      p_ntf[0] = 0x60;
+      p_ntf[1] = 0x06;
+      p_ntf[2] = 0x03;
+      p_ntf[3] = 0x01;
+      p_ntf[4] = 0x00;
+      p_ntf[5] = 0x01;
+      *p_len = 6;
+    } else {
+      LOG_EMVCOHAL_D(
+          ">  Workaround for ISO-DEP Presence Check, presence check return "
+          "failed");
+      p_ntf[0] = 0x60;
+      p_ntf[1] = 0x08;
+      p_ntf[2] = 0x02;
+      p_ntf[3] = 0xB2;
+      p_ntf[4] = 0x00;
+      *p_len = 5;
+    }
+  } else if (*p_len == 4 && p_ntf[0] == 0x6F && p_ntf[1] == 0x11 &&
+             p_ntf[2] == 0x01) {
+    if (p_ntf[3] == 0x01) {
+      LOG_EMVCOHAL_D(
+          ">  Workaround for ISO-DEP Presence Check - Card still in field");
+      p_ntf[0] = 0x00;
+      p_ntf[1] = 0x00;
+      p_ntf[2] = 0x01;
+      p_ntf[3] = 0x7E;
+    } else {
+      LOG_EMVCOHAL_D(
+          ">  Workaround for ISO-DEP Presence Check - Card not in field");
+      p_ntf[0] = 0x60;
+      p_ntf[1] = 0x08;
+      p_ntf[2] = 0x02;
+      p_ntf[3] = 0xB2;
+      p_ntf[4] = 0x00;
+      *p_len = 5;
+    }
+  }
+
+  return status;
+}
+
+/******************************************************************************
+ * Function         process_emvco_init_rsp
+ *
+ * Description      This function is used to process the HAL NFC core reset rsp
+ *                  and ntf and core init rsp of NCI 1.0 or NCI2.0 and update
+ *                  NCI version.
+ *                  It also handles error response such as core_reset_ntf with
+ *                  error status in both NCI2.0 and NCI1.0.
+ *
+ * Returns          Returns EMVCO_STATUS_SUCCESS if parsing response is
+ *successful or returns failure.
+ *
+ *******************************************************************************/
+static EMVCO_STATUS process_emvco_init_rsp(uint8_t *p_ntf, uint16_t *p_len) {
+  EMVCO_STATUS status = EMVCO_STATUS_SUCCESS;
+
+  /* Parsing CORE_RESET_RSP and CORE_RESET_NTF to update NCI version.*/
+  if (p_ntf == NULL || *p_len < 2) {
+    return EMVCO_STATUS_FAILED;
+  }
+  if (p_ntf[0] == NCI_MT_RSP &&
+      ((p_ntf[1] & NCI_OID_MASK) == NCI_MSG_CORE_RESET)) {
+    if (*p_len < 4) {
+      __osal_log_error_write(0x534e4554, "169258455");
+      return EMVCO_STATUS_FAILED;
+    }
+    if (p_ntf[2] == 0x01 && p_ntf[3] == 0x00) {
+      LOG_EMVCOHAL_D("CORE_RESET_RSP NCI2.0");
+      if (nci_hal_ctrl.hal_ext_enabled == TRUE) {
+        nci_hal_ctrl.nci_info.wait_for_ntf = TRUE;
+      }
+    } else if (p_ntf[2] == 0x03 && p_ntf[3] == 0x00) {
+      if (*p_len < 5) {
+        __osal_log_error_write(0x534e4554, "169258455");
+        return EMVCO_STATUS_FAILED;
+      }
+      LOG_EMVCOHAL_D("CORE_RESET_RSP NCI1.0");
+      nci_hal_ctrl.nci_info.nci_version = p_ntf[4];
+    }
+  } else if (p_ntf[0] == NCI_MT_NTF &&
+             ((p_ntf[1] & NCI_OID_MASK) == NCI_MSG_CORE_RESET)) {
+    if (*p_len < 4) {
+      __osal_log_error_write(0x534e4554, "169258455");
+      return EMVCO_STATUS_FAILED;
+    }
+    if (p_ntf[3] == CORE_RESET_TRIGGER_TYPE_CORE_RESET_CMD_RECEIVED ||
+        p_ntf[3] == CORE_RESET_TRIGGER_TYPE_POWERED_ON) {
+      if (*p_len < 6) {
+        __osal_log_error_write(0x534e4554, "169258455");
+        return EMVCO_STATUS_FAILED;
+      }
+      LOG_EMVCOHAL_D("CORE_RESET_NTF NCI2.0 reason CORE_RESET_CMD received !");
+      nci_hal_ctrl.nci_info.nci_version = p_ntf[5];
+      LOG_EMVCOHAL_D("nci_version : 0x%02x", nci_hal_ctrl.nci_info.nci_version);
+      int len = p_ntf[2] + 2; /*include 2 byte header*/
+      if (len != *p_len - 1) {
+        LOG_EMVCOHAL_E("process_emvco_init_rsp invalid NTF length");
+        __osal_log_error_write(0x534e4554, "121263487");
+        return EMVCO_STATUS_FAILED;
+      }
+      wFwVerRsp = (((uint32_t)p_ntf[len - 2]) << 16U) |
+                  (((uint32_t)p_ntf[len - 1]) << 8U) | p_ntf[len];
+      LOG_EMVCOHAL_D("NxpNci> FW Version: %x.%x.%x", p_ntf[len - 2],
+                     p_ntf[len - 1], p_ntf[len]);
+      rom_version = p_ntf[len - 2];
+    } else if (p_ntf[3] == CORE_RESET_NTF_MODE_SWITCH_TO_NFC_FORUM ||
+               p_ntf[3] == CORE_RESET_NTF_MODE_SWITCH_TO_EMVCO) {
+      LOG_EMVCOHAL_D("NFCC MODE SWITCH STATE: %x", p_ntf[3]);
+    } else {
+      uint32_t i;
+      char print_buffer[*p_len * 3 + 1];
+
+      osal_memset(print_buffer, 0, sizeof(print_buffer));
+      for (i = 0; i < *p_len; i++) {
+        snprintf(&print_buffer[i * 2], 3, "%02X", p_ntf[i]);
+      }
+      LOG_EMVCOHAL_D("CORE_RESET_NTF received !");
+      LOG_EMVCOR_E("len = %3d > %s", *p_len, print_buffer);
+      emergency_recovery();
+      status = EMVCO_STATUS_FAILED;
+    } /* Parsing CORE_INIT_RSP*/
+  } else if (p_ntf[0] == NCI_MT_RSP &&
+             ((p_ntf[1] & NCI_OID_MASK) == NCI_MSG_CORE_INIT)) {
+    if (nci_hal_ctrl.nci_info.nci_version == NCI_VERSION_2_0) {
+      LOG_EMVCOHAL_D("CORE_INIT_RSP NCI2.0 received !");
+    } else {
+      LOG_EMVCOHAL_D("CORE_INIT_RSP NCI1.0 received !");
+      if (*p_len < 3) {
+        __osal_log_error_write(0x534e4554, "169258455");
+        return EMVCO_STATUS_FAILED;
+      }
+      int len = p_ntf[2] + 2; /*include 2 byte header*/
+      if (len != *p_len - 1) {
+        LOG_EMVCOHAL_E("process_emvco_init_rsp invalid NTF length");
+        __osal_log_error_write(0x534e4554, "121263487");
+        return EMVCO_STATUS_FAILED;
+      }
+      wFwVerRsp = (((uint32_t)p_ntf[len - 2]) << 16U) |
+                  (((uint32_t)p_ntf[len - 1]) << 8U) | p_ntf[len];
+      if (wFwVerRsp == 0)
+        status = EMVCO_STATUS_FAILED;
+      LOG_EMVCOHAL_D("NxpNci> FW Version: %x.%x.%x", p_ntf[len - 2],
+                     p_ntf[len - 1], p_ntf[len]);
+      rom_version = p_ntf[len - 2];
+    }
+  }
+  return status;
+}
+
+/******************************************************************************
+ * Function         process_ext_cmd_rsp
+ *
+ * Description      This function process the extension command response. It
+ *                  also checks the received response to expected response.
+ *
+ * Returns          returns EMVCO_STATUS_SUCCESS if response is as expected else
+ *                  returns failure.
+ *
+ ******************************************************************************/
+static EMVCO_STATUS process_ext_cmd_rsp(uint16_t cmd_len, uint8_t *p_cmd) {
+  EMVCO_STATUS status = EMVCO_STATUS_FAILED;
+  uint16_t data_written = 0;
+
+  /* Create the local semaphore */
+  if (init_cb_data(&nci_hal_ctrl.ext_cb_data, NULL) != EMVCO_STATUS_SUCCESS) {
+    LOG_EMVCOHAL_D("Create ext_cb_data failed");
+    return EMVCO_STATUS_FAILED;
+  }
+
+  nci_hal_ctrl.ext_cb_data.status = EMVCO_STATUS_SUCCESS;
+
+  /* Send ext command */
+  data_written = send_app_data_unlocked(cmd_len, p_cmd);
+  if (data_written != cmd_len) {
+    LOG_EMVCOHAL_D("send_app_data failed for hal ext");
+    goto clean_and_return;
+  }
+
+  /* Start timer */
+  status = osal_timer_start(timeoutTimerId, HAL_EXTNS_WRITE_RSP_TIMEOUT,
+                            &hal_extns_write_rsp_timeout_cb, NULL);
+  if (EMVCO_STATUS_SUCCESS == status) {
+    LOG_EMVCOHAL_D("Response timer started");
+  } else {
+    LOG_EMVCOHAL_E("Response timer not started!!!");
+    status = EMVCO_STATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  /* Wait for rsp */
+  LOG_EMVCOHAL_D("Waiting after ext cmd sent");
+  if (SEM_WAIT(nci_hal_ctrl.ext_cb_data)) {
+    LOG_EMVCOHAL_E("p_hal_ext->ext_cb_data.sem semaphore error");
+    goto clean_and_return;
+  }
+
+  /* Stop Timer */
+  status = osal_timer_stop(timeoutTimerId);
+  if (EMVCO_STATUS_SUCCESS == status) {
+    LOG_EMVCOHAL_D("Response timer stopped");
+  } else {
+    LOG_EMVCOHAL_E("Response timer stop ERROR!!!");
+    status = EMVCO_STATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  if (cmd_len < 3) {
+    __osal_log_error_write(0x534e4554, "153880630");
+    status = EMVCO_STATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  /* No NTF expected for OMAPI command */
+  if (p_cmd[0] == 0x2F && p_cmd[1] == 0x1 && p_cmd[2] == 0x01) {
+    nci_hal_ctrl.nci_info.wait_for_ntf = FALSE;
+  }
+  /* Start timer to wait for NTF*/
+  if (nci_hal_ctrl.nci_info.wait_for_ntf == TRUE) {
+    status = osal_timer_start(timeoutTimerId, HAL_EXTNS_WRITE_RSP_TIMEOUT,
+                              &hal_extns_write_rsp_timeout_cb, NULL);
+    if (EMVCO_STATUS_SUCCESS == status) {
+      LOG_EMVCOHAL_D("Response timer started");
+    } else {
+      LOG_EMVCOHAL_E("Response timer not started!!!");
+      status = EMVCO_STATUS_FAILED;
+      goto clean_and_return;
+    }
+    if (SEM_WAIT(nci_hal_ctrl.ext_cb_data)) {
+      LOG_EMVCOHAL_E("p_hal_ext->ext_cb_data.sem semaphore error");
+      /* Stop Timer */
+      status = osal_timer_stop(timeoutTimerId);
+      goto clean_and_return;
+    }
+    status = osal_timer_stop(timeoutTimerId);
+    if (EMVCO_STATUS_SUCCESS == status) {
+      LOG_EMVCOHAL_D("Response timer stopped");
+    } else {
+      LOG_EMVCOHAL_E("Response timer stop ERROR!!!");
+      status = EMVCO_STATUS_FAILED;
+      goto clean_and_return;
+    }
+  }
+
+  if (nci_hal_ctrl.ext_cb_data.status != EMVCO_STATUS_SUCCESS &&
+      p_cmd[0] != 0x2F && p_cmd[1] != 0x1 && p_cmd[2] == 0x01) {
+    LOG_EMVCOHAL_E(
+        "Callback Status is failed!! Timer Expired!! Couldn't read it! 0x%x",
+        nci_hal_ctrl.ext_cb_data.status);
+    status = EMVCO_STATUS_FAILED;
+    goto clean_and_return;
+  }
+
+  LOG_EMVCOHAL_D("Checking response");
+  status = EMVCO_STATUS_SUCCESS;
+
+clean_and_return:
+  cleanup_cb_data(&nci_hal_ctrl.ext_cb_data);
+  nci_hal_ctrl.nci_info.wait_for_ntf = FALSE;
+  return status;
+}
+
+EMVCO_STATUS send_app_data_ext(uint16_t *cmd_len, uint8_t *p_cmd_data,
+                               uint16_t *rsp_len, uint8_t *p_rsp_data) {
+  EMVCO_STATUS status = EMVCO_STATUS_SUCCESS;
+
+  if (p_cmd_data[0] == PROPRIETARY_CMD_FELICA_READER_MODE &&
+      p_cmd_data[1] == PROPRIETARY_CMD_FELICA_READER_MODE &&
+      p_cmd_data[2] == PROPRIETARY_CMD_FELICA_READER_MODE) {
+    LOG_EMVCOHAL_D("Received proprietary command to set Felica Reader mode:%d",
+                   p_cmd_data[3]);
+    gFelicaReaderMode = p_cmd_data[3];
+    /* frame the dummy response */
+    *rsp_len = 4;
+    p_rsp_data[0] = 0x00;
+    p_rsp_data[1] = 0x00;
+    p_rsp_data[2] = 0x00;
+    p_rsp_data[3] = 0x00;
+    status = EMVCO_STATUS_FAILED;
+  } else if (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02 &&
+             p_cmd_data[2] == 0x05 && p_cmd_data[3] == 0x01 &&
+             p_cmd_data[4] == 0xA0 && p_cmd_data[5] == 0x44 &&
+             p_cmd_data[6] == 0x01 && p_cmd_data[7] == 0x01) {
+    nxpprofile_ctrl.profile_type = EMV_CO_PROFILE;
+    LOG_EMVCOHAL_D("EMV_CO_PROFILE mode - Enabled");
+    status = EMVCO_STATUS_SUCCESS;
+  } else if (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02 &&
+             p_cmd_data[2] == 0x05 && p_cmd_data[3] == 0x01 &&
+             p_cmd_data[4] == 0xA0 && p_cmd_data[5] == 0x44 &&
+             p_cmd_data[6] == 0x01 && p_cmd_data[7] == 0x00) {
+    LOG_EMVCOHAL_D("NFC_FORUM_PROFILE mode - Enabled");
+    nxpprofile_ctrl.profile_type = NFC_FORUM_PROFILE;
+    status = EMVCO_STATUS_SUCCESS;
+  }
+
+  if (nxpprofile_ctrl.profile_type == EMV_CO_PROFILE) {
+    if (p_cmd_data[0] == 0x21 && p_cmd_data[1] == 0x06 &&
+        p_cmd_data[2] == 0x01 && p_cmd_data[3] == 0x03) {
+#if 0
+            //Needs clarification whether to keep it or not
+            LOG_EMVCOHAL_D ("EmvCo Poll mode - RF Deactivate discard");
+            print_packet("SEND", p_cmd_data, *cmd_len);
+            *rsp_len = 4;
+            p_rsp_data[0] = 0x41;
+            p_rsp_data[1] = 0x06;
+            p_rsp_data[2] = 0x01;
+            p_rsp_data[3] = 0x00;
+            print_packet("RECV", p_rsp_data, 4);
+            status = EMVCO_STATUS_FAILED;
+#endif
+    } else if (p_cmd_data[0] == 0x21 && p_cmd_data[1] == 0x03) {
+      LOG_EMVCOHAL_D("Commented EmvCo Poll mode workaround - Discover map "
+                     "only for A and B");
+      /*p_cmd_data[2] = 0x05;
+      p_cmd_data[3] = 0x02;
+      p_cmd_data[4] = 0x00;
+      p_cmd_data[5] = 0x01;
+      p_cmd_data[6] = 0x01;
+      p_cmd_data[7] = 0x01;
+      *cmd_len = 8;*/
+    }
+  }
+
+  if (p_cmd_data[3] == 0x81 && p_cmd_data[4] == 0x01 && p_cmd_data[5] == 0x03) {
+    if (nci_hal_ctrl.nci_info.nci_version != NCI_VERSION_2_0) {
+      LOG_EMVCOHAL_D("> Going through workaround - set host list");
+
+      *cmd_len = 8;
+
+      p_cmd_data[2] = 0x05;
+      p_cmd_data[6] = 0x02;
+      p_cmd_data[7] = 0xC0;
+
+      LOG_EMVCOHAL_D("> Going through workaround - set host list - END");
+      status = EMVCO_STATUS_SUCCESS;
+    }
+  } else if (icode_detected) {
+    if ((p_cmd_data[3] & 0x40) == 0x40 &&
+        (p_cmd_data[4] == 0x21 || p_cmd_data[4] == 0x22 ||
+         p_cmd_data[4] == 0x24 || p_cmd_data[4] == 0x27 ||
+         p_cmd_data[4] == 0x28 || p_cmd_data[4] == 0x29 ||
+         p_cmd_data[4] == 0x2a)) {
+      LOG_EMVCOHAL_D("> Send EOF set");
+      icode_send_eof = 1;
+    }
+
+    if (p_cmd_data[3] == 0x20 || p_cmd_data[3] == 0x24 ||
+        p_cmd_data[3] == 0x60) {
+      LOG_EMVCOHAL_D("> NFC ISO_15693 Proprietary CMD ");
+      p_cmd_data[3] += 0x02;
+    }
+  } else if (p_cmd_data[0] == 0x21 && p_cmd_data[1] == 0x03) {
+    LOG_EMVCOHAL_D("> Polling Loop Started");
+    icode_detected = 0;
+    icode_send_eof = 0;
+  }
+  // 22000100
+  else if (p_cmd_data[0] == 0x22 && p_cmd_data[1] == 0x00 &&
+           p_cmd_data[2] == 0x01 && p_cmd_data[3] == 0x00) {
+    // ee_disc_done = 0x01;//Reader Over SWP event getting
+    *rsp_len = 0x05;
+    p_rsp_data[0] = 0x42;
+    p_rsp_data[1] = 0x00;
+    p_rsp_data[2] = 0x02;
+    p_rsp_data[3] = 0x00;
+    p_rsp_data[4] = 0x00;
+    print_packet("RECV", p_rsp_data, 5);
+    status = EMVCO_STATUS_FAILED;
+  }
+  // 2002 0904 3000 3100 3200 5000
+  else if ((p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02) &&
+           ((p_cmd_data[2] == 0x09 && p_cmd_data[3] == 0x04) /*||
+            (p_cmd_data[2] == 0x0D && p_cmd_data[3] == 0x04)*/
+            )) {
+    *cmd_len += 0x01;
+    p_cmd_data[2] += 0x01;
+    p_cmd_data[9] = 0x01;
+    p_cmd_data[10] = 0x40;
+    p_cmd_data[11] = 0x50;
+    p_cmd_data[12] = 0x00;
+
+    LOG_EMVCOHAL_D("> Going through workaround - Dirty Set Config ");
+    //        print_packet("SEND", p_cmd_data, *cmd_len);
+    LOG_EMVCOHAL_D("> Going through workaround - Dirty Set Config - End ");
+  }
+  //    20020703300031003200
+  //    2002 0301 3200
+  else if ((p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02) &&
+           ((p_cmd_data[2] == 0x07 && p_cmd_data[3] == 0x03) ||
+            (p_cmd_data[2] == 0x03 && p_cmd_data[3] == 0x01 &&
+             p_cmd_data[4] == 0x32))) {
+    LOG_EMVCOHAL_D("> Going through workaround - Dirty Set Config ");
+    print_packet("SEND", p_cmd_data, *cmd_len);
+    *rsp_len = 5;
+    p_rsp_data[0] = 0x40;
+    p_rsp_data[1] = 0x02;
+    p_rsp_data[2] = 0x02;
+    p_rsp_data[3] = 0x00;
+    p_rsp_data[4] = 0x00;
+
+    print_packet("RECV", p_rsp_data, 5);
+    status = EMVCO_STATUS_FAILED;
+    LOG_EMVCOHAL_D("> Going through workaround - Dirty Set Config - End ");
+  }
+
+  // 2002 0D04 300104 310100 320100 500100
+  // 2002 0401 320100
+  else if ((p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02) &&
+           (
+               /*(p_cmd_data[2] == 0x0D && p_cmd_data[3] == 0x04)*/
+               (p_cmd_data[2] == 0x04 && p_cmd_data[3] == 0x01 &&
+                p_cmd_data[4] == 0x32 && p_cmd_data[5] == 0x00))) {
+    //        p_cmd_data[12] = 0x40;
+
+    LOG_EMVCOHAL_D("> Going through workaround - Dirty Set Config ");
+    print_packet("SEND", p_cmd_data, *cmd_len);
+    p_cmd_data[6] = 0x60;
+
+    print_packet("RECV", p_rsp_data, 5);
+    //        status = EMVCO_STATUS_FAILED;
+    LOG_EMVCOHAL_D("> Going through workaround - Dirty Set Config - End ");
+  } else if (*cmd_len <= (NCI_MAX_DATA_LEN - 3) && p_cmd_data[0] == 0x21 &&
+             p_cmd_data[1] == 0x00) {
+    LOG_EMVCOHAL_D(
+        "> Going through workaround - Add Mifare Classic in Discovery Map");
+    p_cmd_data[*cmd_len] = 0x80;
+    p_cmd_data[*cmd_len + 1] = 0x01;
+    p_cmd_data[*cmd_len + 2] = 0x80;
+    p_cmd_data[5] = 0x01;
+    p_cmd_data[6] = 0x01;
+    p_cmd_data[2] += 3;
+    p_cmd_data[3] += 1;
+    *cmd_len += 3;
+  } else if (*cmd_len == 3 && p_cmd_data[0] == 0x00 && p_cmd_data[1] == 0x00 &&
+             p_cmd_data[2] == 0x00) {
+    LOG_EMVCOHAL_D("> Going through workaround - ISO-DEP Presence Check ");
+    p_cmd_data[0] = 0x2F;
+    p_cmd_data[1] = 0x11;
+    p_cmd_data[2] = 0x00;
+    status = EMVCO_STATUS_SUCCESS;
+    LOG_EMVCOHAL_D("> Going through workaround - ISO-DEP Presence Check - End");
+  }
+#if 0
+    else if ( (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02 ) &&
+                 ((p_cmd_data[2] == 0x09 && p_cmd_data[3] == 0x04) ||
+                     (p_cmd_data[2] == 0x0B && p_cmd_data[3] == 0x05) ||
+                     (p_cmd_data[2] == 0x07 && p_cmd_data[3] == 0x02) ||
+                     (p_cmd_data[2] == 0x0A && p_cmd_data[3] == 0x03) ||
+                     (p_cmd_data[2] == 0x0A && p_cmd_data[3] == 0x04) ||
+                     (p_cmd_data[2] == 0x05 && p_cmd_data[3] == 0x02))
+             )
+    {
+        LOG_EMVCOHAL_D ("> Going through workaround - Dirty Set Config ");
+        print_packet("SEND", p_cmd_data, *cmd_len);
+        *rsp_len = 5;
+        p_rsp_data[0] = 0x40;
+        p_rsp_data[1] = 0x02;
+        p_rsp_data[2] = 0x02;
+        p_rsp_data[3] = 0x00;
+        p_rsp_data[4] = 0x00;
+
+        print_packet("RECV", p_rsp_data, 5);
+        status = EMVCO_STATUS_FAILED;
+        LOG_EMVCOHAL_D ("> Going through workaround - Dirty Set Config - End ");
+    }
+
+    else if((p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02) &&
+           ((p_cmd_data[3] == 0x00) ||
+           ((*cmd_len >= 0x06) && (p_cmd_data[5] == 0x00)))) /*If the length of the first param id is zero don't allow*/
+    {
+        LOG_EMVCOHAL_D ("> Going through workaround - Dirty Set Config ");
+        print_packet("SEND", p_cmd_data, *cmd_len);
+        *rsp_len = 5;
+        p_rsp_data[0] = 0x40;
+        p_rsp_data[1] = 0x02;
+        p_rsp_data[2] = 0x02;
+        p_rsp_data[3] = 0x00;
+        p_rsp_data[4] = 0x00;
+
+        print_packet("RECV", p_rsp_data, 5);
+        status = EMVCO_STATUS_FAILED;
+        LOG_EMVCOHAL_D ("> Going through workaround - Dirty Set Config - End ");
+    }
+#endif
+  else if ((wFwVerRsp & 0x0000FFFF) == wFwVer) {
+    /* skip CORE_RESET and CORE_INIT from Brcm */
+    if (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x00 &&
+        p_cmd_data[2] == 0x01 && p_cmd_data[3] == 0x01) {
+      //            *rsp_len = 6;
+      //
+      //            LOG_EMVCOHAL_D("> Going - core reset optimization");
+      //
+      //            p_rsp_data[0] = 0x40;
+      //            p_rsp_data[1] = 0x00;
+      //            p_rsp_data[2] = 0x03;
+      //            p_rsp_data[3] = 0x00;
+      //            p_rsp_data[4] = 0x10;
+      //            p_rsp_data[5] = 0x01;
+      //
+      //            status = EMVCO_STATUS_FAILED;
+      //            LOG_EMVCOHAL_D("> Going - core reset optimization - END");
+    }
+    /* CORE_INIT */
+    else if (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x01 &&
+             p_cmd_data[2] == 0x00) {
+    }
+  }
+
+  return status;
+}
+
+/******************************************************************************
+ * Function         send_ext_cmd
+ *
+ * Description      This function send the extension command to NFCC. No
+ *                  response is checked by this function but it waits for
+ *                  the response to come.
+ *
+ * Returns          Returns EMVCO_STATUS_SUCCESS if sending cmd is successful
+ *and response is received.
+ *
+ ******************************************************************************/
+EMVCO_STATUS send_ext_cmd(uint16_t cmd_len, uint8_t *p_cmd) {
+  EMVCO_STATUS status = EMVCO_STATUS_FAILED;
+  HAL_ENABLE_EXT();
+  nci_hal_ctrl.cmd_len = cmd_len;
+  memcpy(nci_hal_ctrl.p_cmd_data, p_cmd, cmd_len);
+  status = process_ext_cmd_rsp(nci_hal_ctrl.cmd_len, nci_hal_ctrl.p_cmd_data);
+  HAL_DISABLE_EXT();
+
+  return status;
+}
+
+/******************************************************************************
+ * Function         hal_extns_write_rsp_timeout_cb
+ *
+ * Description      Timer call back function
+ *
+ * Returns          None
+ *
+ ******************************************************************************/
+static void hal_extns_write_rsp_timeout_cb(uint32_t timerId, void *p_context) {
+  UNUSED(timerId);
+  UNUSED(p_context);
+  LOG_EMVCOHAL_D("hal_extns_write_rsp_timeout_cb - write timeout!!!");
+  nci_hal_ctrl.ext_cb_data.status = EMVCO_STATUS_FAILED;
+  usleep(1);
+  osal_sem_post(&(nci_hal_ctrl.sync_nci_write));
+  SEM_POST(&(nci_hal_ctrl.ext_cb_data));
+
+  return;
+}
diff --git a/emvco_hal_impl/nci/emvco_nci_ext.h b/emvco_hal_impl/nci/emvco_nci_ext.h
new file mode 100644
index 0000000..30cc6c0
--- /dev/null
+++ b/emvco_hal_impl/nci/emvco_nci_ext.h
@@ -0,0 +1,89 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _EMVCO_NCI_EXT_H_
+#define _EMVCO_NCI_EXT_H_
+
+/** \addtogroup EMVCO_STACK_NCI_API_INTERFACE
+ *  @brief  interface to send and process the extension command
+ *  @{
+ */
+
+#include <emvco_dm.h>
+#include <emvco_tml.h>
+#include <string.h>
+
+#define NCI_MT_DATA 0x00
+#define NCI_MT_CMD 0x20
+#define NCI_MT_RSP 0x40
+#define NCI_MT_NTF 0x60
+#define NCI_CORE_CONN_CREDITS_NTF 0x06
+#define NCI_CORE_CONN_CREDITS_NTF_LEN 0x03
+#define NCI_CORE_CONN_CREDITS_NTF_NO_OF_ENTRY 0x01
+#define NCI_CORE_CONN_CREDITS_NTF_CONN_ID 0x00
+#define NCI_CORE_CONN_CREDITS_NTF_CONN_CREDITS 0x01
+
+#define NCI_RF_NTF 0x61
+#define NCI_RF_DEACTIVATE_RES_NTF 0x06
+#define NCI_DEACTIVATE_NTF_LEN 0x02
+#define NCI_DEACT_TYPE_DISCOVERY 0x03
+#define NCI_DEACT_RESON_RF_LINK_LOSS 0x02
+
+void nci_ext_init(void);
+
+/**
+ *
+ * @brief        Process extension function response
+ *
+ * @param[in] p_cmd command to be processed
+ * @param[in] p_len command length
+ *
+ * @return          EMVCO_STATUS_SUCCESS if success
+ *
+ */
+EMVCO_STATUS process_ext_rsp(uint8_t *p_data, uint16_t *p_cmd);
+
+/**
+ *
+ * @brief        sends the extension command
+ *
+ * @param[in] p_cmd command to be processed
+ * @param[in] p_len command length
+ *
+ * @return          EMVCO_STATUS_SUCCESS if success
+ *
+ */
+EMVCO_STATUS send_ext_cmd(uint16_t p_len, uint8_t *p_cmd);
+
+/**
+ * @brief      This function inform the status of open_app_data_channel
+ *                  function to EMVCo HAL.
+ *
+ * @param[in] p_cmd_data command
+ * @param[in] cmd_len command length
+ * @param[in] p_rsp_data response data
+ * @param[in] rsp_len response length
+ *
+ * @return          It return EMVCO_STATUS_SUCCESS then continue with send else
+ *                  sends EMVCO_STATUS_FAILED direct response is prepared and
+ *                  do not send anything to NFCC.
+ *
+ ******************************************************************************/
+EMVCO_STATUS send_app_data_ext(uint16_t *cmd_len, uint8_t *p_cmd_data,
+                               uint16_t *rsp_len, uint8_t *p_rsp_data);
+/** @}*/
+#endif /* _PHNXPNICHAL_EXT_H_ */
diff --git a/emvco_hal_impl/nci/emvco_ncif.c b/emvco_hal_impl/nci/emvco_ncif.c
new file mode 100644
index 0000000..1f436a7
--- /dev/null
+++ b/emvco_hal_impl/nci/emvco_ncif.c
@@ -0,0 +1,302 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include "nci_defs.h"
+#include "osal_memory.h"
+#include <emvco_dm.h>
+#include <emvco_log.h>
+#include <emvco_nci_ext.h>
+#include <emvco_ncif.h>
+#include <emvco_util.h>
+
+/* NCI HAL Control structure */
+nci_hal_ctrl_t nci_hal_ctrl;
+uint8_t *p_nci_data = NULL;
+pthread_mutex_t nci_data_lock = PTHREAD_MUTEX_INITIALIZER;
+
+static uint8_t *get_nci_loopback_data(uint8_t pbf, uint8_t *p_data,
+                                      int data_len);
+
+uint8_t send_core_reset(uint8_t reset_type) {
+  uint8_t *pp, *p;
+  int len = NCI_MSG_HDR_SIZE + NCI_CORE_PARAM_SIZE_RESET;
+  p = (uint8_t *)osal_malloc(len);
+  if (p == NULL)
+    return (NCI_STATUS_FAILED);
+  pp = p;
+
+  NCI_MSG_BLD_HDR0(pp, MT_CMD, NCI_GID_CORE);
+  NCI_MSG_BLD_HDR1(pp, MSG_CORE_RESET);
+  UINT8_TO_STREAM(pp, NCI_CORE_PARAM_SIZE_RESET);
+  UINT8_TO_STREAM(pp, reset_type);
+  send_ext_cmd(len, p);
+  free(p);
+  return (NCI_STATUS_OK);
+}
+
+uint8_t send_core_init(uint8_t nci_version) {
+  uint8_t *pp, *p;
+  int len = NCI_MSG_HDR_SIZE + NCI_CORE_PARAM_SIZE_INIT(nci_version);
+  p = (uint8_t *)osal_malloc(len);
+  if (p == NULL)
+    return (NCI_STATUS_FAILED);
+  pp = p;
+
+  NCI_MSG_BLD_HDR0(pp, MT_CMD, NCI_GID_CORE);
+  NCI_MSG_BLD_HDR1(pp, MSG_CORE_INIT);
+  UINT8_TO_STREAM(pp, NCI_CORE_PARAM_SIZE_INIT(nci_version));
+  if (nci_version == NCI_VERSION_2_0) {
+    UINT8_TO_STREAM(pp, NCI2_0_CORE_INIT_CMD_BYTE_0);
+    UINT8_TO_STREAM(pp, NCI2_0_CORE_INIT_CMD_BYTE_1);
+  }
+  send_ext_cmd(len, p);
+  free(p);
+  return (NCI_STATUS_OK);
+}
+
+uint8_t send_core_set_config(uint8_t *p_param_tlvs, uint8_t tlv_size) {
+  uint8_t *p;
+  uint8_t *pp;
+  uint8_t num = 0, ulen, size, *pt;
+  int len = NCI_MSG_HDR_SIZE + tlv_size + 1;
+
+  p = (uint8_t *)osal_malloc(len);
+  if (p == NULL)
+    return (NCI_STATUS_FAILED);
+
+  pp = (uint8_t *)(p);
+
+  NCI_MSG_BLD_HDR0(pp, MT_CMD, NCI_GID_CORE);
+  NCI_MSG_BLD_HDR1(pp, MSG_CORE_SET_CONFIG);
+  UINT8_TO_STREAM(pp, (uint8_t)(tlv_size + 1));
+  size = tlv_size;
+  pt = p_param_tlvs;
+  while (size > 1) {
+
+    if (*pt == 0xA0 || *pt == 0xA1) {
+      size -= 3;
+      pt += 2;
+    } else {
+      size -= 2;
+      pt++;
+    }
+
+    num++;
+    ulen = *pt++;
+    pt += ulen;
+    if (size >= ulen) {
+      size -= ulen;
+    } else {
+      free(p);
+      return NCI_STATUS_FAILED;
+    }
+  }
+
+  UINT8_TO_STREAM(pp, num);
+  ARRAY_TO_STREAM(pp, p_param_tlvs, tlv_size);
+
+  send_ext_cmd(len, p);
+  free(p);
+  return (NCI_STATUS_OK);
+}
+
+uint8_t send_discover_cmd(uint8_t num, tEMVCO_DISCOVER_PARAMS *p_param) {
+  tEMVCO_DISCOVER_PARAMS *p;
+  uint8_t *pp, *p_start, *p_disc_size;
+  int xx;
+  int size;
+  int len;
+
+  size = num * sizeof(tEMVCO_DISCOVER_PARAMS) + 1;
+  p = (tEMVCO_DISCOVER_PARAMS *)osal_malloc(size);
+  if (p == NULL)
+    return (NCI_STATUS_FAILED);
+
+  pp = (uint8_t *)p;
+  p_start = pp;
+
+  NCI_MSG_BLD_HDR0(pp, MT_CMD, NCI_GID_RF_MANAGE);
+  NCI_MSG_BLD_HDR1(pp, NCI_MSG_RF_DISCOVER);
+  p_disc_size = pp;
+  pp++;
+
+  UINT8_TO_STREAM(pp, num);
+  for (xx = 0; xx < num; xx++) {
+    UINT8_TO_STREAM(pp, p_param[xx].type);
+    UINT8_TO_STREAM(pp, p_param[xx].frequency);
+  }
+
+  *p_disc_size = (uint8_t)((pp - p_start) - NCI_MSG_HDR_SIZE);
+  len = NCI_MSG_HDR_SIZE + (*p_disc_size);
+
+  send_app_data_unlocked(len, p_start);
+  free(p);
+  return (NCI_STATUS_OK);
+}
+
+uint8_t send_proprietary_act_cmd(uint16_t data_len, uint8_t *p_data) {
+  send_ext_cmd(data_len, p_data);
+  return (NCI_STATUS_OK);
+}
+
+void process_emvco_data(uint8_t *p_ntf, uint16_t p_len) {
+  LOG_EMVCOHAL_D("%s \n", __func__);
+  if (p_len < 1) {
+    LOG_EMVCOHAL_E("Not valid Non fragment APDU received length less than 1");
+  }
+
+  int apdu_len = (int)p_ntf[2];
+  if (p_ntf[0] == PBF_SEGMENT_MSG) {
+    SET_CHAINED_DATA();
+    memcpy(nci_hal_ctrl.frag_rsp.p_data + nci_hal_ctrl.frag_rsp.data_pos,
+           (p_ntf + NCI_HEADER_SIZE), (p_len - NCI_HEADER_SIZE));
+    nci_hal_ctrl.frag_rsp.data_pos += (p_len - NCI_HEADER_SIZE);
+  } else if (p_ntf[0] == PBF_COMPLETE_MSG) {
+    if (IS_CHAINED_DATA()) {
+      if (nci_hal_ctrl.frag_rsp.data_pos > 0 &&
+          (nci_hal_ctrl.frag_rsp.data_pos + apdu_len) < FRAG_MAX_DATA_LEN) {
+        memcpy(nci_hal_ctrl.frag_rsp.p_data + nci_hal_ctrl.frag_rsp.data_pos,
+               p_ntf + NCI_HEADER_SIZE, apdu_len);
+        nci_hal_ctrl.frag_rsp.data_pos += apdu_len;
+        pthread_mutex_lock(&nci_data_lock);
+        p_nci_data = get_nci_loopback_data(PBF_COMPLETE_MSG,
+                                           nci_hal_ctrl.frag_rsp.p_data,
+                                           nci_hal_ctrl.frag_rsp.data_pos);
+        (*nci_hal_ctrl.p_nfc_stack_data_cback)(
+            nci_hal_ctrl.frag_rsp.data_pos + NCI_HEADER_SIZE, p_nci_data);
+        if (p_nci_data != NULL) {
+          free(p_nci_data);
+          p_nci_data = NULL;
+        }
+        pthread_mutex_unlock(&nci_data_lock);
+      } else {
+        LOG_EMVCOHAL_E("Invalid APDU data length:%d received",
+                       nci_hal_ctrl.frag_rsp.data_pos + apdu_len);
+      }
+      nci_hal_ctrl.frag_rsp.data_pos = 0;
+      RESET_CHAINED_DATA();
+    } else {
+      (*nci_hal_ctrl.p_nfc_stack_data_cback)(nci_hal_ctrl.rx_data_len,
+                                             nci_hal_ctrl.p_rx_data);
+    }
+  } else {
+    (*nci_hal_ctrl.p_nfc_stack_data_cback)(nci_hal_ctrl.rx_data_len,
+                                           nci_hal_ctrl.p_rx_data);
+  }
+}
+
+static uint8_t *get_nci_loopback_data(uint8_t pbf, uint8_t *p_data,
+                                      int data_len) {
+  p_nci_data = osal_malloc((data_len + NCI_HEADER_SIZE) * sizeof(uint8_t));
+  p_nci_data[0] = pbf;
+  p_nci_data[1] = 0x00;
+  p_nci_data[2] = data_len;
+  memcpy((p_nci_data + NCI_HEADER_SIZE), p_data, data_len);
+  return p_nci_data;
+}
+static void write_internal(uint8_t *p_data, uint16_t data_len) {
+  EMVCO_STATUS status = EMVCO_STATUS_INVALID_PARAMETER;
+  nci_hal_ctrl.retry_cnt = 0;
+  static uint8_t reset_ntf[] = {0x60, 0x00, 0x06, 0xA0, 0x00,
+                                0xC7, 0xD4, 0x00, 0x00};
+retry:
+  status = tml_write(p_data, data_len);
+  if (status != EMVCO_STATUS_SUCCESS) {
+    data_len = 0;
+    if (nci_hal_ctrl.retry_cnt++ < MAX_RETRY_COUNT) {
+      LOG_EMVCOHAL_D(
+          "write_unlocked failed - controller Maybe in Standby Mode - Retry");
+      /* 10ms delay to give NFCC wake up delay */
+      usleep(1000 * 10);
+      goto retry;
+    } else {
+      LOG_EMVCOHAL_E("write_unlocked failed - controller Maybe in Standby Mode "
+                     "(max count = "
+                     "0x%x)",
+                     nci_hal_ctrl.retry_cnt);
+
+      osal_sem_post(&(nci_hal_ctrl.sync_nci_write));
+
+      status = tml_ioctl(ResetDevice);
+
+      if (EMVCO_STATUS_SUCCESS == status) {
+        LOG_EMVCOHAL_D("Controller Reset - SUCCESS\n");
+      } else {
+        LOG_EMVCOHAL_D("Controller Reset - FAILED\n");
+      }
+      if (nci_hal_ctrl.p_nfc_stack_data_cback != NULL &&
+          nci_hal_ctrl.p_rx_data != NULL &&
+          nci_hal_ctrl.hal_open_status == true) {
+        LOG_EMVCOHAL_D(
+            "Send the Core Reset NTF to upper layer, which will trigger the "
+            "recovery\n");
+        // Send the Core Reset NTF to upper layer, which will trigger the
+        // recovery.
+        nci_hal_ctrl.rx_data_len = sizeof(reset_ntf);
+        osal_memcpy(nci_hal_ctrl.p_rx_data, reset_ntf, sizeof(reset_ntf));
+        (*nci_hal_ctrl.p_nfc_stack_data_cback)(nci_hal_ctrl.rx_data_len,
+                                               nci_hal_ctrl.p_rx_data);
+      }
+    }
+  }
+}
+static void send_emvco_data_impl(int pbf, uint8_t *p_data, int data_len) {
+  LOG_EMVCOHAL_D("%s \n", __func__);
+  pthread_mutex_lock(&nci_data_lock);
+  p_nci_data = get_nci_loopback_data(pbf, p_data, data_len);
+  write_internal(p_nci_data, data_len + NCI_HEADER_SIZE);
+  if (p_nci_data != NULL) {
+    free(p_nci_data);
+    p_nci_data = NULL;
+  }
+  pthread_mutex_unlock(&nci_data_lock);
+}
+void send_emvco_data(uint8_t *p_data, uint16_t data_len) {
+  if (data_len > MAX_FRAGMENT_SIZE) {
+    while (data_len > MAX_FRAGMENT_SIZE) {
+      LOG_EMVCOHAL_D("%s sending segment packet \n", __func__);
+      send_emvco_data_impl(PBF_SEGMENT_MSG, p_data + NCI_HEADER_SIZE,
+                           MAX_FRAGMENT_SIZE - NCI_HEADER_SIZE);
+      data_len -= MAX_FRAGMENT_SIZE;
+      p_data += MAX_FRAGMENT_SIZE;
+    }
+    if (data_len > 0) {
+      send_emvco_data_impl(PBF_COMPLETE_MSG, p_data, data_len);
+    }
+  } else {
+    write_internal(p_data, data_len);
+  }
+}
+
+uint8_t send_deactivate_cmd(uint8_t de_act_type) {
+  uint8_t *pp, *p;
+  int len = NCI_MSG_HDR_SIZE + NCI_DISCOVER_PARAM_SIZE_DEACT;
+  p = (uint8_t *)osal_malloc(len);
+  if (p == NULL)
+    return (NCI_STATUS_FAILED);
+  pp = p;
+
+  NCI_MSG_BLD_HDR0(pp, MT_CMD, NCI_GID_RF_MANAGE);
+  NCI_MSG_BLD_HDR1(pp, NCI_MSG_RF_DEACTIVATE);
+  UINT8_TO_STREAM(pp, NCI_DISCOVER_PARAM_SIZE_DEACT);
+  UINT8_TO_STREAM(pp, de_act_type);
+
+  send_app_data_unlocked(len, p);
+  free(p);
+  return (NCI_STATUS_OK);
+}
\ No newline at end of file
diff --git a/emvco_hal_impl/nci/emvco_ncif.h b/emvco_hal_impl/nci/emvco_ncif.h
new file mode 100644
index 0000000..0ebfad4
--- /dev/null
+++ b/emvco_hal_impl/nci/emvco_ncif.h
@@ -0,0 +1,141 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/** \addtogroup EMVCO_STACK_NCI_API_INTERFACE
+ *  @brief interface to send the NCI packets and process the fragmented data
+ * received & loop back to NFCC
+ *  @{
+ */
+#ifndef EMVCO_NCIF_H
+#define EMVCO_NCIF_H
+
+#include <emvco_cl.h>
+#include <stdint.h>
+
+#define MAX_FRAGMENT_SIZE 256
+#define PBF_COMPLETE_MSG 0x00
+#define PBF_SEGMENT_MSG 0x10
+/* Macros to update the chained data state */
+#define SET_CHAINED_DATA() (nci_hal_ctrl.frag_rsp.is_chained = 1)
+#define RESET_CHAINED_DATA() (nci_hal_ctrl.frag_rsp.is_chained = 0)
+#define IS_CHAINED_DATA() (1 == nci_hal_ctrl.frag_rsp.is_chained)
+/**
+ *
+ * @brief      compose and send CORE RESET command to command queue
+ * @param[in]  reset_type specfies to keep the configuration or not
+ * @return          NFC status:
+ *                  NFCSTATUS_SUCCESS - command processed successfully
+ *                  NFCSTATUS_FAILED - failed to process the command
+ *
+ */
+uint8_t send_core_reset(uint8_t reset_type);
+
+/**
+ * @brief       compose and send CORE INIT command to command queue
+ * @param[in]   nci_version specfies the nci version
+ * @return          NFC status:
+ *                  NFCSTATUS_SUCCESS - command processed successfully
+ *                  NFCSTATUS_FAILED - failed to process the command
+ *
+ */
+uint8_t send_core_init(uint8_t nci_version);
+
+/**
+ *
+ * @brief       compose and send CORE SET_CONFIG command to command queue
+ * @param[in]       p_param_tlvs parameter in TLV format
+ * @param[in]       tlv_size tlv parameter size
+ * @return          NFC status:
+ *                  NFCSTATUS_SUCCESS - command processed successfully
+ *                  NFCSTATUS_FAILED - failed to process the command
+ *
+ */
+uint8_t send_core_set_config(uint8_t *p_param_tlvs, uint8_t tlv_size);
+
+/**
+ *
+ * @brief           compose and send RF Management DISCOVER command to command
+ *                  queue
+ *
+ * @param[in]       num number of polling types
+ * @param[in]       p_param contains type and frequency of the polling type
+ *
+ * @return          NFC status:
+ *                  NFCSTATUS_SUCCESS - command processed successfully
+ *                  NFCSTATUS_FAILED - failed to process the command
+ *
+ */
+uint8_t send_discover_cmd(uint8_t num, tEMVCO_DISCOVER_PARAMS *p_param);
+
+/**
+ *
+ * @brief           compose and sends proprietary command to controller
+ *
+ * @param[in]       data_len command length
+ * @param[in]       p_data   command data
+ *
+ * @return          NFC status:
+ *                  NFCSTATUS_SUCCESS - command processed successfully
+ *                  NFCSTATUS_FAILED - failed to process the command
+ *
+ **/
+uint8_t send_proprietary_act_cmd(uint16_t data_len, uint8_t *p_data);
+
+/**
+ *
+ * @brief           Process the Received data packet from NFCC,
+ *                  assembles and send it as complete packet
+ *                  to upper layer
+ *
+ * @param[in]       data_len command length
+ * @param[in]       p_data   command data
+ *
+ * @return          void
+ *
+ **/
+void process_emvco_data(uint8_t *p_data, uint16_t data_len);
+
+/**
+ *
+ * @brief           Process the Received data packet from Upper layer,
+ *                  de-assembles, if length is more the Max fragment data
+ *                  length and send it to NFCC
+ *
+ * @param[in]       data_len command length
+ * @param[in]       p_data   command data
+ *
+ * @return          void
+ *
+ **/
+void send_emvco_data(uint8_t *p_ntf, uint16_t p_len);
+
+/**
+ *
+ * @brief           Deactivates the RF field and moves in to deactivation type
+ *state
+ *
+ * @param[in]       de_act_type Idle or Discover state
+ *
+ * @return          NFC status:
+ *                  NFCSTATUS_SUCCESS - command processed successfully
+ *                  NFCSTATUS_FAILED - failed to process the command
+ *
+ **/
+uint8_t send_deactivate_cmd(uint8_t de_act_type);
+
+/** @}*/
+#endif /* EMVCO_NCIF_H */
\ No newline at end of file
diff --git a/emvco_hal_impl/nci/nci_defs.h b/emvco_hal_impl/nci/nci_defs.h
new file mode 100755
index 0000000..4387f67
--- /dev/null
+++ b/emvco_hal_impl/nci/nci_defs.h
@@ -0,0 +1,109 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+ *
+ *  This file contains the definition from NCI specification
+ *
+ ******************************************************************************/
+
+#ifndef NCI_DEFS_H
+#define NCI_DEFS_H
+
+#include <stdint.h>
+
+/* Define the message header size for all NCI Commands and Notifications.
+ */
+#define NCI_MSG_HDR_SIZE 3  /* per NCI spec */
+#define NCI_DATA_HDR_SIZE 3 /* per NCI spec */
+
+#define NCI_MT_SHIFT 5
+
+#define MT_CMD 1 /* (MT_CMD << NCI_MT_SHIFT) = 0x20 */
+#define MT_RSP 2 /* (MT_RSP << NCI_MT_SHIFT) = 0x40 */
+#define MT_NTF 3 /* (MT_NTF << NCI_MT_SHIFT) = 0x60 */
+
+/* Status Codes */
+#define NCI_STATUS_OK 0x00
+#define NCI_STATUS_FAILED 0x03
+
+/* GID: Group Identifier (byte 0) */
+#define NCI_GID_MASK 0x0F
+#define NCI_GID_CORE 0x00      /* 0000b NCI Core group */
+#define NCI_GID_RF_MANAGE 0x01 /* 0001b RF Management group */
+#define NCI_GID_EE_MANAGE 0x02 /* 0010b NFCEE Management group */
+#define NCI_GID_PROP 0x0F      /* 1111b Proprietary */
+/* 0111b - 1110b RFU */
+
+/* OID: Opcode Identifier (byte 1) */
+#define NCI_OID_MASK 0x3F
+#define NCI_OID_SHIFT 0
+
+/**********************************************
+ * RF MANAGEMENT Group Opcode    - 1
+ **********************************************/
+#define NCI_MSG_RF_DISCOVER_MAP 0
+#define NCI_MSG_RF_SET_ROUTING 1
+#define NCI_MSG_RF_GET_ROUTING 2
+#define NCI_MSG_RF_DISCOVER 3
+#define NCI_MSG_RF_DISCOVER_SELECT 4
+#define NCI_MSG_RF_INTF_ACTIVATED 5
+#define NCI_MSG_RF_DEACTIVATE 6
+#define NCI_MSG_RF_FIELD 7
+#define NCI_DISCOVER_PARAM_SIZE_DEACT 0x01
+
+/* builds byte0 of NCI Command and Notification packet */
+#define NCI_MSG_BLD_HDR0(p, mt, gid)                                           \
+  *(p)++ = (uint8_t)(((mt) << NCI_MT_SHIFT) | (gid));
+
+/* builds byte1 of NCI Command and Notification packet */
+#define NCI_MSG_BLD_HDR1(p, oid) *(p)++ = (uint8_t)(((oid) << NCI_OID_SHIFT));
+
+#define UINT8_TO_STREAM(p, u8)                                                 \
+  { *(p)++ = (uint8_t)(u8); }
+
+#define ARRAY_TO_STREAM(p, a, len)                                             \
+  {                                                                            \
+    int ijk;                                                                   \
+    for (ijk = 0; ijk < (len); ijk++)                                          \
+      *(p)++ = (uint8_t)(a)[ijk];                                              \
+  }
+/**********************************************
+ * NCI Core Group Opcode        - 0
+ **********************************************/
+#define MSG_CORE_RESET 0
+#define MSG_CORE_INIT 1
+#define MSG_CORE_SET_CONFIG 2
+#define MSG_CORE_GET_CONFIG 3
+
+/* Define the message header size for all NCI Commands and Notifications.
+ */
+#define NCI_MSG_HDR_SIZE 3 /* per NCI spec */
+
+/**********************************************
+ * NCI Core Group Params
+ **********************************************/
+#define NCI_CORE_PARAM_SIZE_RESET 0x01
+
+#define NCI_VERSION_UNKNOWN 0x00
+#define NCI_VERSION_1_0 0x10
+#define NCI_VERSION_2_0 0x20
+#define NCI_CORE_PARAM_SIZE_INIT(X) (((X) == NCI_VERSION_2_0) ? (0x02) : (0x00))
+#define NCI2_0_CORE_INIT_CMD_BYTE_0 0x00
+#define NCI2_0_CORE_INIT_CMD_BYTE_1 0x00
+
+#endif /* NCI_DEFS_H */
\ No newline at end of file
diff --git a/emvco_hal_impl/osal/osal_log.h b/emvco_hal_impl/osal/osal_log.h
new file mode 100644
index 0000000..50b992b
--- /dev/null
+++ b/emvco_hal_impl/osal/osal_log.h
@@ -0,0 +1,41 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _OSAL_LOG_H_
+#define _OSAL_LOG_H_
+
+#include <log/log.h>
+
+/**
+ * @brief Prints logging information
+ *
+ * @param[in] prio priority of the log level
+ * @param[in] tag TAG name
+ * @param[in] ... additional information of the log
+ */
+#define OSAL_LOG_PRI(prio, tag, ...)                                           \
+  { LOG_PRI(prio, tag, __VA_ARGS__); }
+
+/**
+ * @brief writes error logging information
+ *
+ * @param[in] tag TAG name
+ * @param[in] subTag asub tag name
+ */
+#define __osal_log_error_write(tag, subTag)                                    \
+  __android_log_error_write(tag, subTag, -1, NULL, 0)
+#endif /* _OSAL_LOG_H_*/
\ No newline at end of file
diff --git a/emvco_hal_impl/osal/osal_memory.c b/emvco_hal_impl/osal/osal_memory.c
new file mode 100644
index 0000000..98f671e
--- /dev/null
+++ b/emvco_hal_impl/osal/osal_memory.c
@@ -0,0 +1,41 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <emvco_log.h>
+#include <osal_memory.h>
+#include <stdlib.h>
+#include <string.h>
+void *osal_malloc(int size) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return malloc(size);
+}
+
+void osal_free(void *pMem) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return free(pMem);
+}
+
+void osal_memset(void *pMem, int bVal, int size) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  memset(pMem, bVal, size);
+}
+
+void osal_memcpy(void *pDest, const void *pSrc, int size) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  memcpy(pDest, pSrc, size);
+}
\ No newline at end of file
diff --git a/emvco_hal_impl/osal/osal_memory.h b/emvco_hal_impl/osal/osal_memory.h
new file mode 100644
index 0000000..3de1a88
--- /dev/null
+++ b/emvco_hal_impl/osal/osal_memory.h
@@ -0,0 +1,70 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _OSAL_MEMORY_H_
+#define _OSAL_MEMORY_H_
+
+/** \addtogroup EMVCO_STACK_OSAL_API_INTERFACE
+ *  @{
+ */
+
+/**
+ *
+ * @brief  Allocates some memoryAllocates some memory
+ *
+ * @param[in] dwSize   Size, in uint32_t, to be allocated
+ *
+ * @return            NON-NULL value:  The memory is successfully allocated ;
+ *                    the return value is a pointer to the allocated memory
+ * location NULL:The operation is not successful.
+ *
+ */
+void *osal_malloc(int dwSize);
+
+/**
+ * @brief This API allows to free already allocated memory.
+ *
+ * \param[in] pMem  Pointer to the memory block to be deallocated
+ * @return    void
+ */
+void osal_free(void *pMem);
+
+/**
+ * @brief                Sets the given value in the memory locations.
+ *
+ * @param[in] pMem      Pointer to the memory block to be set to a value
+ * @param[in] bVal      Value to be set
+ * @param[in] dwSize    Number of bytes to be set.
+ *
+ * @return    void
+ */
+void osal_memset(void *pMem, int bVal, int dwSize);
+
+/**
+ * @brief                Copies the values stored in the source memory to the
+ *                       values stored in the destination memory.
+ *
+ * @param[in] pDest     Pointer to the Destination Memory
+ * @param[in] pSrc      Pointer to the Source Memory
+ * @param[in] dwSize    Number of bytes to be copied.
+ *
+ * @return    void
+ */
+void osal_memcpy(void *pDest, const void *pSrc, int size);
+
+/** @}*/
+#endif /* _OSAL_MEMORY_H_*/
\ No newline at end of file
diff --git a/emvco_hal_impl/osal/osal_message_queue_lib.c b/emvco_hal_impl/osal/osal_message_queue_lib.c
new file mode 100644
index 0000000..7107444
--- /dev/null
+++ b/emvco_hal_impl/osal/osal_message_queue_lib.c
@@ -0,0 +1,242 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/*
+ * DAL independent message queue implementation for Android (can be used under
+ * Linux too)
+ */
+
+#include <emvco_log.h>
+#include <emvco_types.h>
+#include <errno.h>
+#include <linux/ipc.h>
+#include <osal_message_queue_lib.h>
+#include <pthread.h>
+#include <semaphore.h>
+
+typedef struct message_queue_item {
+  lib_emvco_message_t n_msg;
+  struct message_queue_item *p_prev;
+  struct message_queue_item *p_next;
+} message_queue_item_t;
+
+typedef struct message_queue {
+  message_queue_item_t *p_items;
+  pthread_mutex_t n_critical_section_mutex;
+  sem_t n_process_semaphore;
+
+} message_queue_t;
+
+/*******************************************************************************
+**
+** Function         osal_msg_get
+**
+** Description      Allocates message queue
+**
+** Parameters       Ignored, included only for Linux queue API compatibility
+**
+** Returns          (int) value of pQueue if successful
+**                  -1, if failed to allocate memory or to init mutex
+**
+*******************************************************************************/
+intptr_t osal_msg_get(key_t key, int msgflg) {
+  message_queue_t *pQueue;
+  UNUSED(key);
+  UNUSED(msgflg);
+  pQueue = (message_queue_t *)malloc(sizeof(message_queue_t));
+  if (pQueue == NULL)
+    return -1;
+  memset(pQueue, 0, sizeof(message_queue_t));
+  if (pthread_mutex_init(&pQueue->n_critical_section_mutex, NULL) != 0) {
+    free(pQueue);
+    return -1;
+  }
+  if (sem_init(&pQueue->n_process_semaphore, 0, 0) == -1) {
+    free(pQueue);
+    return -1;
+  }
+
+  return ((intptr_t)pQueue);
+}
+
+/*******************************************************************************
+**
+** Function         osal_msg_release
+**
+** Description      Releases message queue
+**
+** Parameters       msqid - message queue handle
+**
+** Returns          None
+**
+*******************************************************************************/
+void osal_msg_release(intptr_t msqid) {
+  message_queue_t *pQueue = (message_queue_t *)msqid;
+
+  if (pQueue != NULL) {
+    sem_post(&pQueue->n_process_semaphore);
+    usleep(3000);
+    if (sem_destroy(&pQueue->n_process_semaphore)) {
+      LOG_EMVCO_TML_E("Failed to destroy semaphore (errno=0x%08x)", errno);
+    }
+    pthread_mutex_destroy(&pQueue->n_critical_section_mutex);
+
+    free(pQueue);
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         osal_msg_ctl
+**
+** Description      Destroys message queue
+**
+** Parameters       msqid - message queue handle
+**                  cmd, buf - ignored, included only for Linux queue API
+**                  compatibility
+**
+** Returns          0,  if successful
+**                  -1, if invalid handle is passed
+**
+*******************************************************************************/
+int osal_msg_ctl(intptr_t msqid, int cmd, void *buf) {
+  message_queue_t *pQueue;
+  message_queue_item_t *p;
+  UNUSED(cmd);
+  UNUSED(buf);
+  if (msqid == 0)
+    return -1;
+
+  pQueue = (message_queue_t *)msqid;
+  pthread_mutex_lock(&pQueue->n_critical_section_mutex);
+  if (pQueue->p_items != NULL) {
+    p = pQueue->p_items;
+    while (p->p_next != NULL) {
+      p = p->p_next;
+    }
+    while (p->p_prev != NULL) {
+      p = p->p_prev;
+      free(p->p_next);
+      p->p_next = NULL;
+    }
+    free(p);
+  }
+  pQueue->p_items = NULL;
+  pthread_mutex_unlock(&pQueue->n_critical_section_mutex);
+  pthread_mutex_destroy(&pQueue->n_critical_section_mutex);
+  free(pQueue);
+
+  return 0;
+}
+
+/*******************************************************************************
+**
+** Function         osal_msg_snd
+**
+** Description      Sends a message to the queue. The message will be added at
+**                  the end of the queue as appropriate for FIFO policy
+**
+** Parameters       msqid  - message queue handle
+**                  msgp   - message to be sent
+**                  msgsz  - message size
+**                  msgflg - ignored
+**
+** Returns          0,  if successful
+**                  -1, if invalid parameter passed or failed to allocate memory
+**
+*******************************************************************************/
+intptr_t osal_msg_snd(intptr_t msqid, lib_emvco_message_t *msg, int msgflg) {
+  message_queue_t *pQueue;
+  message_queue_item_t *p;
+  message_queue_item_t *pNew;
+  UNUSED(msgflg);
+  if ((msqid == 0) || (msg == NULL))
+    return -1;
+
+  pQueue = (message_queue_t *)msqid;
+  pNew = (message_queue_item_t *)malloc(sizeof(message_queue_item_t));
+  if (pNew == NULL)
+    return -1;
+  memset(pNew, 0, sizeof(message_queue_item_t));
+  memcpy(&pNew->n_msg, msg, sizeof(lib_emvco_message_t));
+  pthread_mutex_lock(&pQueue->n_critical_section_mutex);
+
+  if (pQueue->p_items != NULL) {
+    p = pQueue->p_items;
+    while (p->p_next != NULL) {
+      p = p->p_next;
+    }
+    p->p_next = pNew;
+    pNew->p_prev = p;
+  } else {
+    pQueue->p_items = pNew;
+  }
+  pthread_mutex_unlock(&pQueue->n_critical_section_mutex);
+
+  sem_post(&pQueue->n_process_semaphore);
+
+  return 0;
+}
+
+/*******************************************************************************
+**
+** Function         osal_msg_rcv
+**
+** Description      Gets the oldest message from the queue.
+**                  If the queue is empty the function waits (blocks on a mutex)
+**                  until a message is posted to the queue with osal_msg_snd
+**
+** Parameters       msqid  - message queue handle
+**                  msgp   - message to be received
+**                  msgsz  - message size
+**                  msgtyp - ignored
+**                  msgflg - ignored
+**
+** Returns          0,  if successful
+**                  -1, if invalid parameter passed
+**
+*******************************************************************************/
+int osal_msg_rcv(intptr_t msqid, lib_emvco_message_t *msg, long msgtyp,
+                 int msgflg) {
+  message_queue_t *pQueue;
+  message_queue_item_t *p;
+  UNUSED(msgflg);
+  UNUSED(msgtyp);
+  if ((msqid == 0) || (msg == NULL))
+    return -1;
+
+  pQueue = (message_queue_t *)msqid;
+
+  if (-1 == sem_wait(&pQueue->n_process_semaphore)) {
+    LOG_EMVCO_TML_E("sem_wait didn't return success\n");
+  }
+
+  pthread_mutex_lock(&pQueue->n_critical_section_mutex);
+
+  if (pQueue->p_items != NULL) {
+    memcpy(msg, &(pQueue->p_items)->n_msg, sizeof(lib_emvco_message_t));
+    p = pQueue->p_items->p_next;
+    free(pQueue->p_items);
+    pQueue->p_items = p;
+  }
+  pthread_mutex_unlock(&pQueue->n_critical_section_mutex);
+
+  return 0;
+}
diff --git a/emvco_hal_impl/osal/osal_message_queue_lib.h b/emvco_hal_impl/osal/osal_message_queue_lib.h
new file mode 100644
index 0000000..f770240
--- /dev/null
+++ b/emvco_hal_impl/osal/osal_message_queue_lib.h
@@ -0,0 +1,102 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef _OSAL_MESSAGE_QUEUE_LIB_H_
+#define _OSAL_MESSAGE_QUEUE_LIB_H_
+/** \addtogroup EMVCO_STACK_OSAL_API_INTERFACE
+ *  @brief      Interface for message queue, log, dynamic memory management,
+ * thread, timer and transport mapping layer implementation in Android
+ */
+#include <emvco_types.h>
+#include <linux/ipc.h>
+
+/**
+ *
+ * @brief            Allocates message queue
+ *
+ * @param[in]       Ignored, included only for Linux queue API compatibility
+ *
+ * @return           (int) value of pQueue if successful
+ *                  -1, if failed to allocate memory or to init mutex
+ *
+ */
+intptr_t osal_msg_get(key_t key, int msgflg);
+
+/**
+ *
+ * @brief       Releases message queue
+ *
+ * @param[in]        msqid - message queue handle
+ *
+ * @return           None
+ *
+ */
+void osal_msg_release(intptr_t msqid);
+
+/**
+ *
+ * @brief      Destroys message queue
+ *
+ * @param[in]       msqid - message queue handle
+ *                  cmd, buf - ignored, included only for Linux queue API
+ *                  compatibility
+ *
+ * @return          0,  if successful
+ *                  -1, if invalid handle is passed
+ *
+ */
+int osal_msg_ctl(intptr_t msqid, int cmd, void *buf);
+
+/**
+ *
+ * @brief      Sends a message to the queue. The message will be added at
+ *                  the end of the queue as appropriate for FIFO policy
+ *
+ * @param[in]       msqid  - message queue handle
+ *                  msgp   - message to be sent
+ *                  msgsz  - message size
+ *                  msgflg - ignored
+ *
+ * @return          0,  if successful
+ *                  -1, if invalid parameter passed or failed to allocate memory
+ *
+ */
+intptr_t osal_msg_snd(intptr_t msqid, lib_emvco_message_t *msg, int msgflg);
+
+/**
+ *
+ * @brief       Gets the oldest message from the queue.
+ *                  If the queue is empty the function waits (blocks on a mutex)
+ *                  until a message is posted to the queue with
+ * phDal4EMVCo_msgsnd
+ *
+ * @param[in]        msqid  - message queue handle
+ *                  msgp   - message to be received
+ *                  msgsz  - message size
+ *                  msgtyp - ignored
+ *                  msgflg - ignored
+ *
+ * @return           0,  if successful
+ *                  -1, if invalid parameter passed
+ *
+ */
+int osal_msg_rcv(intptr_t msqid, lib_emvco_message_t *msg, long msgtyp,
+                 int msgflg);
+
+/** @}*/
+#endif /*  _OSAL_MESSAGE_QUEUE_LIB_H_  */
diff --git a/emvco_hal_impl/osal/osal_thread.c b/emvco_hal_impl/osal/osal_thread.c
new file mode 100644
index 0000000..24b558c
--- /dev/null
+++ b/emvco_hal_impl/osal/osal_thread.c
@@ -0,0 +1,83 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include "osal_thread.h"
+#include <emvco_log.h>
+#include <semaphore.h>
+
+EMVCO_STATUS osal_thread_create(pthread_t *thread, const pthread_attr_t *attr,
+                                void *(*start_routine)(void *), void *arg) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return pthread_create(thread, attr, start_routine, arg);
+}
+
+EMVCO_STATUS osal_mutex_lock(void *hMutex) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return pthread_mutex_lock(hMutex);
+}
+EMVCO_STATUS osal_mutex_unlock(void *hMutex) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return pthread_mutex_unlock(hMutex);
+}
+EMVCO_STATUS osal_mutex_init(void *hMutex) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return pthread_mutex_init(hMutex, NULL);
+}
+EMVCO_STATUS osal_mutex_destroy(void *hMutex) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return pthread_mutex_destroy(hMutex);
+}
+EMVCO_STATUS osal_thread_join(pthread_t thread, void *retval) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return pthread_join(thread, retval);
+}
+
+int osal_sem_wait(sem_t *sem) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return sem_wait(sem);
+}
+
+int osal_sem_timedwait(sem_t *sem, const struct timespec *abs_timeout) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return sem_timedwait(sem, abs_timeout);
+}
+
+int osal_sem_post(sem_t *sem) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return sem_post(sem);
+}
+
+int osal_sem_destroy(sem_t *sem) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return sem_destroy(sem);
+}
+
+int osal_sem_init(sem_t *sem, int pshared, unsigned int value) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return sem_init(sem, pshared, value);
+}
+
+int osal_sem_getvalue(sem_t *sem, int *sval) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return sem_getvalue(sem, sval);
+}
+
+int osal_sem_timedwait_monotonic_np(sem_t *__sem, const struct timespec *__ts) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return sem_timedwait_monotonic_np(__sem, __ts);
+}
\ No newline at end of file
diff --git a/emvco_hal_impl/osal/osal_thread.h b/emvco_hal_impl/osal/osal_thread.h
new file mode 100644
index 0000000..3a85839
--- /dev/null
+++ b/emvco_hal_impl/osal/osal_thread.h
@@ -0,0 +1,267 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef _OSAL_THREAD_H_
+#define _OSAL_THREAD_H_
+/** \addtogroup EMVCO_STACK_OSAL_API_INTERFACE
+ *  @{
+ */
+#include <emvco_types.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <time.h>
+
+/**
+ * \brief Interface to Thread and syncronization.
+ *
+ * Thread and syncronization implementation for Android
+ *
+ */
+typedef struct osal_semaphore {
+  sem_t object_handle; /**<Handle of the semaphore object */
+} osal_semaphore_t;    /**< Variable for Structure Instance*/
+
+/**
+ *
+ * @brief                   This function creates a thread in the underlying
+ system.
+ *                          To delete the created thread use the
+ phOsalEMVCo_Thread_Delete
+ *                          function.
+ *
+ *
+ * @param[in] hThread    The Thread handle: The caller has to prepare a void
+ *                           pointer
+ *                           that need not to be initialized.
+ *                           The value (content) of the pointer is set by the
+ *                           function.
+ * @param[in] attr            It points to a pthread_attr_t structure whose
+                             contents are used at thread creation time to
+ *                           determine attributes for the new thread
+ * @param[in] pThreadFunction Pointer to a function within the
+ *                           implementation that shall be called by the Thread
+ *                           procedure. This represents the Thread main
+ *                           function.
+ *                           When this function exits the thread exits.
+ * @param[in] pParam          A pointer to a user-defined location the thread
+ *                           function receives.
+ *
+ * @return #EMVCOSTATUS_SUCCESS                    The operation was successful.
+ * @return #EMVCOSTATUS_INSUFFICIENT_RESOURCES     At least one parameter value
+ is
+ *                                               invalid.
+ * @return #PH_OSALEMVCO_THREAD_CREATION_ERROR     A new Thread could not be
+ *                                               created due to system error.
+ * @return #EMVCOSTATUS_NOT_INITIALISED            Osal Module is not
+ Initialized.
+ *
+ */
+EMVCO_STATUS osal_thread_create(pthread_t *hThread, const pthread_attr_t *attr,
+                                void *(*pThreadFunction)(void *), void *pParam);
+/**
+ *
+ * @brief                               This function locks a mutex used for
+ * handling critical section of code. However the function blocks till the Mutex
+ * is available to be occupied.
+ *
+ * @param[in] hMutex                    The handle of the Mutex.
+ *
+ * @return #EMVCOSTATUS_SUCCESS            The operation was successful.
+ * @return #EMVCOSTATUS_INVALID_PARAMETER  Parameter passed to the function is
+ * not Correct.
+ * @return #PH_OSALEMVCO_MUTEX_LOCK_ERROR  The mutex cannot be locked due
+ *                                       to a system error or invalid handle.
+ * @return #EMVCOSTATUS_NOT_INITIALISED    OsalModule is not Initialized.
+ *
+ */
+EMVCO_STATUS osal_mutex_lock(void *hMutex);
+/**
+ *
+ * @brief                              This function unlocks a mutex after
+ * updating critical section of code.
+ *
+ * @param[in] hMutex        The handle of the Mutex.
+ *
+ * @return #EMVCOSTATUS_SUCCESS                The operation was successful.
+ * @return #EMVCOSTATUS_INVALID_PARAMETER      Parameter passed to the function
+ * is not Correct.
+ * @return #PH_OSALEMVCO_MUTEX_UNLOCK_ERROR    The mutex cannot be
+ *                                           locked due to a system error or
+ *                                           invalid handle.
+ * @return #EMVCOSTATUS_NOT_INITIALISED        Osal Module is not Initialized.
+ *
+ */
+EMVCO_STATUS osal_mutex_unlock(void *hMutex);
+/**
+ *
+ * @brief                    This function creates a Mutex in the underlying
+ * system.
+ *
+ * @param[in] hMutex        The handle: The caller has to prepare a void
+ *                           pointer where the handle of mutex shall be
+ *                           returned.
+ *
+ * @return #EMVCOSTATUS_SUCCESS                    The operation was successful.
+ * @return #EMVCOSTATUS_INVALID_PARAMETER          Parameter passed to the
+ *                                               function is not Correct.
+ * @return #EMVCOSTATUS_INSUFFICIENT_RESOURCES     All Mutexes are occupied by
+ * other threads.
+ * @return #PH_OSALEMVCO_MUTEX_CREATION_ERROR      A new mutex could not be
+ * created due to system error.
+ * @return #EMVCOSTATUS_NOT_INITIALISED            Osal Module is not
+ * Initialized.
+ *
+ */
+EMVCO_STATUS osal_mutex_init(void *hMutex);
+/**
+ *
+ * @brief                                    This function deletes a Mutex in
+ * the underlying system.
+ *
+ * @param[in] hMutex                         The handle of the Mutex.
+ *
+ * @return #EMVCOSTATUS_SUCCESS                The operation was successful.
+ * @return #PH_OSALEMVCO_MUTEX_DELETE_ERROR    The mutex cannot be deleted due
+ * to a system error or invalid handle.
+ * @return #EMVCOSTATUS_NOT_INITIALISED         Osal Module is not Initialized.
+ *
+ */
+EMVCO_STATUS osal_mutex_destroy(void *hMutex);
+/**
+ *
+ * @brief                                    The pthread_join() function waits
+ * for the thread specified by thread to terminate
+ * @param[in] hMutex                         The handle of the Mutex.
+ *
+ * @return #EMVCOSTATUS_SUCCESS                The operation was successful.
+ * @return #EDEADLK                          A deadlock was detected.
+ * @return #EINVAL                           Thread is not a joinable thread.
+ * @return #EINVAL                           Another thread is alredy waiting to
+ *                                           join with this thread.
+ * @return #ESRCH                            No thread with the ID thread
+ *                                           could be found.
+ */
+EMVCO_STATUS osal_thread_join(pthread_t thread, void *retval);
+/**
+ *
+ * @brief  lock a semaphore
+ *
+ * @param[in] sem_t               Semaphore.
+ *
+ * @return #0                     on success
+ * @return #EAGAIN                The operation could not be performed
+ *                                without blocking
+ * @return #EINTR                 The call was interrupted by
+ *                                a signal handler.
+ * @return #EINVAL                sem is not a valid semaphore..
+ */
+int osal_sem_wait(sem_t *sem);
+/**
+ *
+ * @brief lock a semaphore with timeout
+ *
+ * @param[in] sem_t                          Semaphore.
+ *
+ * @return #0                on success
+ * @return #EAGAIN           The operation could not be performed
+ *                           without blocking
+ * @return #EINTR            The call was interrupted by a signal handler.
+ * @return #EINVAL           sem is not a valid semaphore..
+ * @return #EINVAL           The value of abs_timeout.tv_nsecs is
+ *                           less than 0, or greater than or
+ *                           equal to 1000 million
+ * @return #ETIMEDOUT        The call timed out before the semaphore
+ *                           could be locked.
+ */
+int osal_sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
+
+/**
+ *
+ * @brief unlock a semaphore
+ *
+ * @param[in] sem_t                          Semaphore.
+ *
+ * @return #0                on success
+ * @return #EINVAL           sem is not a valid semaphore..
+ * @return #EOVERFLOW        The maximum allowable value for a semaphore would
+ *                           be exceeded
+ */
+int osal_sem_post(sem_t *sem);
+
+/**
+ *
+ * @brief  destroys an semaphore
+ *
+ * @param[in] sem_t          Semaphore.
+ *
+ * @return #0                on success
+ * @return #EINVAL           sem is not a valid semaphore..
+ *
+ */
+int osal_sem_destroy(sem_t *sem);
+
+/**
+ *
+ * @brief initialize an unnamed semaphore
+ *
+ * @param[in] sem_t                          Semaphore.
+ *
+ * @return #0                on success
+ * @return #EINVAL           value exceeds SEM_VALUE_MAX
+ * @return #ENOSYS           pshared is nonzero, but the system does not support
+ *                           process-shared semaphores
+ *
+ */
+int osal_sem_init(sem_t *sem, int pshared, unsigned int value);
+
+/**
+ *
+ * @brief get the value of a semaphore
+ *
+ * @param[in] sem_t          Semaphore.
+ *
+ * @return #0                on success
+ * @return #EINVAL           sem is not a valid semaphore
+ *
+ */
+int osal_sem_getvalue(sem_t *sem, int *sval);
+
+/**
+ *
+ * @brief lock a semaphore with monotonic timeout
+ *
+ * @param[in] sem_t                          Semaphore.
+ *
+ * @return #0             on success
+ * @return #EAGAIN        The operation could not be performed
+ *                        without blocking
+ *
+ * @return #EINTR         The call was interrupted by
+ *                        a signal handler.
+ * @return #EINVAL        sem is not a valid semaphore..
+ * @return #EINVAL        The value of abs_timeout.tv_nsecs is
+ *                        less than 0, or greater than or
+ *                        equal to 1000 million
+ * @return #ETIMEDOUT     The call timed out before the semaphore
+ *                        could be locked.
+ */
+int osal_sem_timedwait_monotonic_np(sem_t *__sem, const struct timespec *__ts)
+    __INTRODUCED_IN(28);
+
+/** @}*/
+#endif /* _OSAL_THREAD_H_*/
\ No newline at end of file
diff --git a/emvco_hal_impl/osal/osal_timer.c b/emvco_hal_impl/osal/osal_timer.c
new file mode 100644
index 0000000..5443c18
--- /dev/null
+++ b/emvco_hal_impl/osal/osal_timer.c
@@ -0,0 +1,454 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/*
+ * OSAL Implementation for Timers.
+ */
+
+#include <emvco_dm.h>
+#include <emvco_log.h>
+#include <emvco_osal_common.h>
+#include <emvco_types.h>
+#include <osal_message_queue_lib.h>
+#include <osal_timer.h>
+#include <signal.h>
+
+#define EMVCO_MAX_TIMER (5U)
+static osal_emvco_timer_handle_t apTimerInfo[EMVCO_MAX_TIMER];
+
+extern nci_hal_ctrl_t nci_hal_ctrl;
+
+/*
+ * Defines the base address for generating timerid.
+ */
+#define EMVCO_TIMER_BASE_ADDRESS (100U)
+
+/*
+ *  Defines the value for invalid timerid returned during timeSetEvent
+ */
+#define EMVCO_TIMER_ID_ZERO (0x00)
+
+/*
+ * Invalid timer ID type. This ID used indicate timer creation is failed */
+#define EMVCO_TIMER_ID_INVALID (0xFFFF)
+
+/* Forward declarations */
+static void post_timer_msg(lib_emvco_message_t *pMsg);
+static void osal_emvco_deferred_call(void *pParams);
+static void osal_emvco_timer_expired(union sigval sv);
+
+/*
+ *************************** Function Definitions ******************************
+ */
+
+/*******************************************************************************
+**
+** Function         osal_timer_create
+**
+** Description      Creates a timer which shall call back the specified function
+**                  when the timer expires. Fails if OSAL module is not
+**                  initialized or timers are already occupied
+**
+** Parameters       None
+**
+** Returns          timer_id
+**                  timer_id value of PH_OSALNFC_TIMER_ID_INVALID indicates that
+**                  timer is not created
+**
+*******************************************************************************/
+uint32_t osal_timer_create(void) {
+  /* dw_timer_id is also used as an index at which timer object can be stored */
+  uint32_t dw_timer_id = PH_OSALNFC_TIMER_ID_INVALID;
+  static struct sigevent se;
+  osal_emvco_timer_handle_t *pTimerHandle;
+  /* Timer needs to be initialized for timer usage */
+
+  se.sigev_notify = SIGEV_THREAD;
+  se.sigev_notify_function = osal_emvco_timer_expired;
+  se.sigev_notify_attributes = NULL;
+  dw_timer_id = osal_check_for_available_timer();
+
+  /* Check whether timers are available, if yes create a timer handle structure
+   */
+  if ((EMVCO_TIMER_ID_ZERO != dw_timer_id) &&
+      (dw_timer_id <= EMVCO_MAX_TIMER)) {
+    pTimerHandle = (osal_emvco_timer_handle_t *)&apTimerInfo[dw_timer_id - 1];
+    /* Build the Timer Id to be returned to Caller Function */
+    dw_timer_id += EMVCO_TIMER_BASE_ADDRESS;
+    se.sigev_value.sival_int = (int)dw_timer_id;
+    /* Create POSIX timer */
+    if (timer_create(CLOCK_REALTIME, &se, &(pTimerHandle->timer_handle)) ==
+        -1) {
+      dw_timer_id = EMVCO_TIMER_ID_INVALID;
+    } else {
+      /* Set the state to indicate timer is ready */
+      pTimerHandle->eState = eTimerIdle;
+      /* Store the Timer Id which shall act as flag during check for timer
+       * availability */
+      pTimerHandle->timer_id = dw_timer_id;
+    }
+  } else {
+    dw_timer_id = EMVCO_TIMER_ID_INVALID;
+  }
+
+  /* Timer ID invalid can be due to Uninitialized state,Non availability of
+   * Timer */
+  return dw_timer_id;
+}
+
+/*******************************************************************************
+**
+** Function         osal_timer_start
+**
+** Description      Starts the requested, already created, timer.
+**                  If the timer is already running, timer stops and restarts
+**                  with the new timeout value and new callback function in case
+**                  any ??????
+**                  Creates a timer which shall call back the specified function
+**                  when the timer expires
+**
+** Parameters       dw_timer_id - valid timer ID obtained during timer creation
+**                  dwRegTimeCnt - requested timeout in milliseconds
+**                  pApplication_callback - application callback interface to be
+**                                          called when timer expires
+**                  p_context - caller context, to be passed to the application
+**                             callback function
+**
+** Returns          NFC status:
+**                  EMVCO_STATUS_SUCCESS - the operation was successful
+**                  EMVCO_STATUS_NOT_INITIALISED - OSAL Module is not
+*initialized
+**                  EMVCO_STATUS_INVALID_PARAMETER - invalid parameter passed to
+**                                                the function
+**                  PH_OSALNFC_TIMER_START_ERROR - timer could not be created
+**                                                 due to system error
+**
+*******************************************************************************/
+EMVCO_STATUS
+osal_timer_start(uint32_t dw_timer_id, uint32_t dwRegTimeCnt,
+                 p_osal_emvco_timer_callback_t pApplication_callback,
+                 void *p_context) {
+  EMVCO_STATUS wStartStatus = EMVCO_STATUS_SUCCESS;
+
+  struct itimerspec its;
+  uint32_t dwIndex;
+  osal_emvco_timer_handle_t *pTimerHandle;
+  /* Retrieve the index at which the timer handle structure is stored */
+  dwIndex = dw_timer_id - EMVCO_TIMER_BASE_ADDRESS - 0x01;
+  pTimerHandle = (osal_emvco_timer_handle_t *)&apTimerInfo[dwIndex];
+  /* OSAL Module needs to be initialized for timer usage */
+  /* Check whether the handle provided by user is valid */
+  if ((dwIndex < EMVCO_MAX_TIMER) && (0x00 != pTimerHandle->timer_id) &&
+      (NULL != pApplication_callback)) {
+    its.it_interval.tv_sec = 0;
+    its.it_interval.tv_nsec = 0;
+    its.it_value.tv_sec = dwRegTimeCnt / 1000;
+    its.it_value.tv_nsec = 1000000 * (dwRegTimeCnt % 1000);
+    if (its.it_value.tv_sec == 0 && its.it_value.tv_nsec == 0) {
+      /* This would inadvertently stop the timer*/
+      its.it_value.tv_nsec = 1;
+    }
+    pTimerHandle->Application_callback = pApplication_callback;
+    pTimerHandle->p_context = p_context;
+    pTimerHandle->eState = eTimerRunning;
+    /* Arm the timer */
+    if ((timer_settime(pTimerHandle->timer_handle, 0, &its, NULL)) == -1) {
+      wStartStatus = EMVCOSTVAL(CID_EMVCO_OSAL, PH_OSALNFC_TIMER_START_ERROR);
+    }
+  } else {
+    wStartStatus = EMVCOSTVAL(CID_EMVCO_OSAL, EMVCO_STATUS_INVALID_PARAMETER);
+  }
+
+  return wStartStatus;
+}
+
+/*******************************************************************************
+**
+** Function         osal_timer_stop
+**
+** Description      Stops already started timer
+**                  Allows to stop running timer. In case timer is stopped,
+**                  timer callback will not be notified any more
+**
+** Parameters       dw_timer_id - valid timer ID obtained during timer creation
+**
+** Returns          NFC status:
+**                  EMVCO_STATUS_SUCCESS - the operation was successful
+**                  EMVCO_STATUS_NOT_INITIALISED - OSAL Module is not
+*initialized
+**                  EMVCO_STATUS_INVALID_PARAMETER - invalid parameter passed to
+**                                                the function
+**                  PH_OSALNFC_TIMER_STOP_ERROR - timer could not be stopped due
+**                                                to system error
+**
+*******************************************************************************/
+EMVCO_STATUS osal_timer_stop(uint32_t dw_timer_id) {
+  EMVCO_STATUS wStopStatus = EMVCO_STATUS_SUCCESS;
+  static struct itimerspec its = {{0, 0}, {0, 0}};
+
+  uint32_t dwIndex;
+  osal_emvco_timer_handle_t *pTimerHandle;
+  dwIndex = dw_timer_id - EMVCO_TIMER_BASE_ADDRESS - 0x01;
+  pTimerHandle = (osal_emvco_timer_handle_t *)&apTimerInfo[dwIndex];
+  /* OSAL Module and Timer needs to be initialized for timer usage */
+  /* Check whether the timer_id provided by user is valid */
+  if ((dwIndex < EMVCO_MAX_TIMER) && (0x00 != pTimerHandle->timer_id) &&
+      (pTimerHandle->eState != eTimerIdle)) {
+    /* Stop the timer only if the callback has not been invoked */
+    if (pTimerHandle->eState == eTimerRunning) {
+      if ((timer_settime(pTimerHandle->timer_handle, 0, &its, NULL)) == -1) {
+        wStopStatus = EMVCOSTVAL(CID_EMVCO_OSAL, PH_OSALNFC_TIMER_STOP_ERROR);
+      } else {
+        /* Change the state of timer to Stopped */
+        pTimerHandle->eState = eTimerStopped;
+      }
+    }
+  } else {
+    wStopStatus = EMVCOSTVAL(CID_EMVCO_OSAL, EMVCO_STATUS_INVALID_PARAMETER);
+  }
+
+  return wStopStatus;
+}
+
+/*******************************************************************************
+**
+** Function         osal_timer_delete
+**
+** Description      Deletes previously created timer
+**                  Allows to delete previously created timer. In case timer is
+**                  running, it is first stopped and then deleted
+**
+** Parameters       dw_timer_id - valid timer ID obtained during timer creation
+**
+** Returns          NFC status:
+**                  EMVCO_STATUS_SUCCESS - the operation was successful
+**                  EMVCO_STATUS_NOT_INITIALISED - OSAL Module is not
+*initialized
+**                  EMVCO_STATUS_INVALID_PARAMETER - invalid parameter passed to
+**                                                the function
+**                  PH_OSALNFC_TIMER_DELETE_ERROR - timer could not be stopped
+**                                                  due to system error
+**
+*******************************************************************************/
+EMVCO_STATUS osal_timer_delete(uint32_t dw_timer_id) {
+  EMVCO_STATUS wDeleteStatus = EMVCO_STATUS_SUCCESS;
+
+  uint32_t dwIndex;
+  osal_emvco_timer_handle_t *pTimerHandle;
+  dwIndex = dw_timer_id - EMVCO_TIMER_BASE_ADDRESS - 0x01;
+  pTimerHandle = (osal_emvco_timer_handle_t *)&apTimerInfo[dwIndex];
+  /* OSAL Module and Timer needs to be initialized for timer usage */
+
+  /* Check whether the timer_id passed by user is valid and Deregistering of
+   * timer is successful */
+  if ((dwIndex < EMVCO_MAX_TIMER) && (0x00 != pTimerHandle->timer_id) &&
+      (EMVCO_STATUS_SUCCESS == osal_check_timer_presence(pTimerHandle))) {
+    /* Cancel the timer before deleting */
+    if (timer_delete(pTimerHandle->timer_handle) == -1) {
+      wDeleteStatus = EMVCOSTVAL(CID_EMVCO_OSAL, PH_OSALNFC_TIMER_DELETE_ERROR);
+    }
+    /* Clear Timer structure used to store timer related data */
+    memset(pTimerHandle, (uint8_t)0x00, sizeof(osal_emvco_timer_handle_t));
+  } else {
+    wDeleteStatus = EMVCOSTVAL(CID_EMVCO_OSAL, EMVCO_STATUS_INVALID_PARAMETER);
+  }
+  return wDeleteStatus;
+}
+
+/*******************************************************************************
+**
+** Function         osal_timer_cleanup
+**
+** Description      Deletes all previously created timers
+**                  Allows to delete previously created timers. In case timer is
+**                  running, it is first stopped and then deleted
+**
+** Parameters       None
+**
+** Returns          None
+**
+*******************************************************************************/
+void osal_timer_cleanup(void) {
+  /* Delete all timers */
+  uint32_t dwIndex;
+  osal_emvco_timer_handle_t *pTimerHandle;
+  for (dwIndex = 0; dwIndex < EMVCO_MAX_TIMER; dwIndex++) {
+    pTimerHandle = (osal_emvco_timer_handle_t *)&apTimerInfo[dwIndex];
+    /* OSAL Module and Timer needs to be initialized for timer usage */
+
+    /* Check whether the timer_id passed by user is valid and Deregistering of
+     * timer is successful */
+    if ((0x00 != pTimerHandle->timer_id) &&
+        (EMVCO_STATUS_SUCCESS == osal_check_timer_presence(pTimerHandle))) {
+      /* Cancel the timer before deleting */
+      if (timer_delete(pTimerHandle->timer_handle) == -1) {
+        LOG_EMVCO_TML_E("timer %d delete error!", dwIndex);
+      }
+      /* Clear Timer structure used to store timer related data */
+      memset(pTimerHandle, (uint8_t)0x00, sizeof(osal_emvco_timer_handle_t));
+    }
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         osal_emvco_deferred_call
+**
+** Description      Invokes the timer callback function after timer expiration.
+**                  Shall invoke the callback function registered by the timer
+**                  caller function
+**
+** Parameters       pParams - parameters indicating the ID of the timer
+**
+** Returns          None                -
+**
+*******************************************************************************/
+static void osal_emvco_deferred_call(void *pParams) {
+  /* Retrieve the timer id from the parameter */
+  unsigned long dwIndex;
+  osal_emvco_timer_handle_t *pTimerHandle;
+  if (NULL != pParams) {
+    /* Retrieve the index at which the timer handle structure is stored */
+    dwIndex = (uintptr_t)pParams - EMVCO_TIMER_BASE_ADDRESS - 0x01;
+    pTimerHandle = (osal_emvco_timer_handle_t *)&apTimerInfo[dwIndex];
+    if (pTimerHandle->Application_callback != NULL) {
+      /* Invoke the callback function with osal Timer ID */
+      pTimerHandle->Application_callback((uintptr_t)pParams,
+                                         pTimerHandle->p_context);
+    }
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         post_timer_msg
+**
+** Description      Posts message on the user thread
+**                  Shall be invoked upon expiration of a timer
+**                  Shall post message on user thread through which timer
+**                  callback function shall be invoked
+**
+** Parameters       pMsg - pointer to the message structure posted on user
+**                         thread
+**
+** Returns          None
+**
+*******************************************************************************/
+static void post_timer_msg(lib_emvco_message_t *pMsg) {
+  (void)osal_msg_snd(
+      nci_hal_ctrl.gDrvCfg
+          .n_client_id /*gpphOsalNfc_Context->dwCallbackThreadID*/,
+      pMsg, 0);
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         osal_emvco_timer_expired
+**
+** Description      posts message upon expiration of timer
+**                  Shall be invoked when any one timer is expired
+**                  Shall post message on user thread to invoke respective
+**                  callback function provided by the caller of Timer function
+**
+** Returns          None
+**
+*******************************************************************************/
+static void osal_emvco_timer_expired(union sigval sv) {
+  uint32_t dwIndex;
+  osal_emvco_timer_handle_t *pTimerHandle;
+
+  dwIndex = ((uint32_t)(sv.sival_int)) - EMVCO_TIMER_BASE_ADDRESS - 0x01;
+  pTimerHandle = (osal_emvco_timer_handle_t *)&apTimerInfo[dwIndex];
+  /* Timer is stopped when callback function is invoked */
+  pTimerHandle->eState = eTimerStopped;
+
+  pTimerHandle->tDeferedCallInfo.pDeferedCall = &osal_emvco_deferred_call;
+  pTimerHandle->tDeferedCallInfo.pParam = (void *)((intptr_t)(sv.sival_int));
+
+  pTimerHandle->tOsalMessage.e_msgType = EMVCO_DEFERRED_CALL_MSG;
+  pTimerHandle->tOsalMessage.p_msg_data =
+      (void *)&pTimerHandle->tDeferedCallInfo;
+
+  /* Post a message on the queue to invoke the function */
+  post_timer_msg((lib_emvco_message_t *)&pTimerHandle->tOsalMessage);
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         osal_check_for_available_timer
+**
+** Description      Find an available timer id
+**
+** Parameters       void
+**
+** Returns          Available timer id
+**
+*******************************************************************************/
+uint32_t osal_check_for_available_timer(void) {
+  /* Variable used to store the index at which the object structure details
+     can be stored. Initialize it as not available. */
+  uint32_t dwIndex = 0x00;
+  uint32_t dwRetval = 0x00;
+
+  /* Check whether Timer object can be created */
+  for (dwIndex = 0x00; ((dwIndex < EMVCO_MAX_TIMER) && (0x00 == dwRetval));
+       dwIndex++) {
+    if (!(apTimerInfo[dwIndex].timer_id)) {
+      dwRetval = (dwIndex + 0x01);
+    }
+  }
+
+  return (dwRetval);
+}
+
+/*******************************************************************************
+**
+** Function         osal_check_timer_presence
+**
+** Description      Checks the requested timer is present or not
+**
+** Parameters       pobject_handle - timer context
+**
+** Returns          EMVCO_STATUS_SUCCESS if found
+**                  Other value if not found
+**
+*******************************************************************************/
+EMVCO_STATUS osal_check_timer_presence(void *pobject_handle) {
+  uint32_t dwIndex;
+  EMVCO_STATUS wRegisterStatus = EMVCO_STATUS_INVALID_PARAMETER;
+
+  for (dwIndex = 0x00; ((dwIndex < EMVCO_MAX_TIMER) &&
+                        (wRegisterStatus != EMVCO_STATUS_SUCCESS));
+       dwIndex++) {
+    /* For Timer, check whether the requested handle is present or not */
+    if (((&apTimerInfo[dwIndex]) ==
+         (osal_emvco_timer_handle_t *)pobject_handle) &&
+        (apTimerInfo[dwIndex].timer_id)) {
+      wRegisterStatus = EMVCO_STATUS_SUCCESS;
+    }
+  }
+  return wRegisterStatus;
+}
diff --git a/emvco_hal_impl/osal/osal_timer.h b/emvco_hal_impl/osal/osal_timer.h
new file mode 100644
index 0000000..bbf732c
--- /dev/null
+++ b/emvco_hal_impl/osal/osal_timer.h
@@ -0,0 +1,194 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/** \addtogroup EMVCO_STACK_OSAL_API_INTERFACE
+ *  @{
+ */
+
+#ifndef _OSAL_TIMER_H_
+#define _OSAL_TIMER_H_
+#include <emvco_common.h>
+/*
+************************* Include Files ****************************************
+*/
+
+/**
+ * @brief Timer callback interface which will be called once registered timer
+ * time out expires.
+ *  @param[in]       TimerId  - Timer Id for which callback is called.
+ *  @param[in]       p_context - Parameter to be passed to the callback function
+ */
+typedef void (*p_osal_emvco_timer_callback_t)(uint32_t TimerId,
+                                              void *p_context);
+
+/*
+ * The Timer could not be created due to a
+ * system error */
+#define PH_OSALNFC_TIMER_CREATE_ERROR (0X00E0)
+
+/*
+ * The Timer could not be started due to a
+ * system error or invalid handle */
+#define PH_OSALNFC_TIMER_START_ERROR (0X00E1)
+
+/*
+ * The Timer could not be stopped due to a
+ * system error or invalid handle */
+#define PH_OSALNFC_TIMER_STOP_ERROR (0X00E2)
+
+/*
+ * The Timer could not be deleted due to a
+ * system error or invalid handle */
+#define PH_OSALNFC_TIMER_DELETE_ERROR (0X00E3)
+
+/*
+ * Invalid timer ID type.This ID used indicate timer creation is failed */
+#define PH_OSALNFC_TIMER_ID_INVALID (0xFFFF)
+
+/*
+ * OSAL timer message .This message type will be posted to
+ * calling application thread.*/
+#define PH_OSALNFC_TIMER_MSG (0x315)
+
+/*
+***************************Globals,Structure and Enumeration ******************
+*/
+
+/**
+ *
+ *
+ * @brief           Creates a timer which shall call back the specified function
+ *                  when the timer expires. Fails if OSAL module is not
+ *                  initialized or timers are already occupied
+ *
+ * @param[in]       None
+ *
+ * @return          TimerId
+ *                  TimerId value of PH_OSALEMVCO_TIMER_ID_INVALID indicates
+ * that timer is not created
+ *
+ */
+uint32_t osal_timer_create(void);
+
+/**
+ *
+ *
+ * @brief           Starts the requested, already created, timer.
+ *                  If the timer is already running, timer stops and restarts
+ *                  with the new timeout value and new callback function in case
+ *                  any ??????
+ *                  Creates a timer which shall call back the specified function
+ *                  when the timer expires
+ *
+ * @param[in]       dwTimerId - valid timer ID obtained during timer creation
+ *                  dwRegTimeCnt - requested timeout in milliseconds
+ *                  pApplication_callback - application callback interface to be
+ *                                          called when timer expires
+ *                  pContext - caller context, to be passed to the application
+ *                             callback function
+ *
+ * @return          EMVCO status:
+ *                  EMVCOSTATUS_SUCCESS - the operation was successful
+ *                  EMVCOSTATUS_NOT_INITIALISED - OSAL Module is not initialized
+ *                  EMVCOSTATUS_INVALID_PARAMETER - invalid parameter passed to
+ *                                                the function
+ *                  PH_OSALEMVCO_TIMER_START_ERROR - timer could not be created
+ *                                                 due to system error
+ *
+ */
+EMVCO_STATUS
+osal_timer_start(uint32_t dw_timer_id, uint32_t dwRegTimeCnt,
+                 p_osal_emvco_timer_callback_t pApplication_callback,
+                 void *p_context);
+/**
+ *
+ * @brief           Stops already started timer
+ *                  Allows to stop running timer. In case timer is stopped,
+ *                  timer callback will not be notified any more
+ *
+ * @param[in]       dwTimerId - valid timer ID obtained during timer creation
+ *
+ * @return          EMVCO status:
+ *                  EMVCOSTATUS_SUCCESS - the operation was successful
+ *                  EMVCOSTATUS_NOT_INITIALISED - OSAL Module is not initialized
+ *                  EMVCOSTATUS_INVALID_PARAMETER - invalid parameter passed to
+ *                                                the function
+ *                  PH_OSALEMVCO_TIMER_STOP_ERROR - timer could not be stopped
+ * due to system error
+ *
+ */
+EMVCO_STATUS osal_timer_stop(uint32_t dw_timer_id);
+
+/**
+ *
+ * @brief           Deletes previously created timer
+ *                  Allows to delete previously created timer. In case timer is
+ *                  running, it is first stopped and then deleted
+ *
+ * @param[in]       dwTimerId - valid timer ID obtained during timer creation
+ *
+ * @return          EMVCO status:
+ *                  EMVCOSTATUS_SUCCESS - the operation was successful
+ *                  EMVCOSTATUS_NOT_INITIALISED - OSAL Module is not initialized
+ *                  EMVCOSTATUS_INVALID_PARAMETER - invalid parameter passed to
+ *                                                the function
+ *                  PH_OSALEMVCO_TIMER_DELETE_ERROR - timer could not be stopped
+ *                                                  due to system error
+ *
+ */
+EMVCO_STATUS osal_timer_delete(uint32_t dw_timer_id);
+
+/**
+ *
+ *
+ * @brief           Deletes all previously created timers
+ *                  Allows to delete previously created timers. In case timer is
+ *                  running, it is first stopped and then deleted
+ *
+ * @param[in]        none
+ *
+ * @return          None
+ *
+ */
+void osal_timer_cleanup(void);
+
+/**
+ *
+ * @brief      Find an available timer id
+ *
+ * @param[in]       void
+ *
+ * @return          Available timer id
+ *
+ */
+uint32_t osal_check_for_available_timer(void);
+
+/**
+ *
+ * @brief       Checks the requested timer is present or not
+ *
+ * @param[in]       pObjectHandle - timer context
+ *
+ * @return          EMVCOSTATUS_SUCCESS if found
+ *                  Other value if not found
+ *
+ */
+EMVCO_STATUS osal_check_timer_presence(void *pobject_handle);
+
+/** @}*/
+#endif /* _OSAL_TIMER_H_ */
diff --git a/emvco_hal_impl/osal/osal_tml.c b/emvco_hal_impl/osal/osal_tml.c
new file mode 100644
index 0000000..2741f42
--- /dev/null
+++ b/emvco_hal_impl/osal/osal_tml.c
@@ -0,0 +1,57 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <emvco_log.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+
+int osal_tml_close(int fd) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return close(fd);
+}
+
+int osal_tml_open(const char *pathname, int flags) {
+  LOG_EMVCO_TML_D("%s Opening port=%s\n", __func__, pathname);
+  return open(pathname, flags);
+}
+
+int osal_tml_read(int fd, void *buf, size_t count) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return read(fd, buf, count);
+}
+
+int osal_tml_write(int fd, const void *buf, size_t count) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  return write(fd, buf, count);
+}
+
+int osal_tml_ioctl(int fd, unsigned long request, unsigned long reset_type,
+                   int count) {
+  LOG_EMVCO_TML_D("%s\n", __func__);
+  if (count == 1) {
+    return ioctl(fd, request);
+  } else if (count == 2) {
+    return ioctl(fd, request, reset_type);
+  } else {
+    LOG_EMVCO_TML_E(
+        "%s\n  Failed. Not supported for more than one variable argument",
+        __func__);
+    return -1;
+  }
+}
\ No newline at end of file
diff --git a/emvco_hal_impl/osal/osal_tml.h b/emvco_hal_impl/osal/osal_tml.h
new file mode 100644
index 0000000..f68da55
--- /dev/null
+++ b/emvco_hal_impl/osal/osal_tml.h
@@ -0,0 +1,94 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _PHOSALNFC_TML_H_
+#define _PHOSALNFC_TML_H_
+/** \addtogroup EMVCO_STACK_OSAL_API_INTERFACE
+ *  @{
+ */
+
+/**
+ *
+ * @brief  closes the file specified by pathname
+ *
+ * @param[in]  pathname               path of the file.
+ *
+ * @return  #>0                       on success
+ * @return  #-1                       error
+ *
+ */
+int osal_tml_close(int fd);
+
+/**
+ *
+ * @brief  opens the file specified by pathname
+ *
+ * @param[in] pathname                path of the file.
+ *
+ * @return  #0                         on success
+ * @return  #-1                        error
+ *
+ */
+int osal_tml_open(const char *pathname, int flags);
+
+/**
+ *
+ * @brief                             attempts to read up to count bytes from
+ * file descriptor fd into the buffer starting at buf
+ *
+ * @param[in] fd                      file descriptor of the file.
+ * @param[in] buf                     buffer to store the read data
+ * @param[in] count                   read up to count bytes
+ *
+ * @return  #0 or >0                   on success
+ * @return  #-1                        error
+ *
+ */
+int osal_tml_read(int fd, void *buf, size_t count);
+
+/**
+ *
+ * @brief                          writes up to count bytes from the buffer
+ * starting at buf to the file referred to by the file descriptor fd
+ *
+ * @param[in] fd                   file descriptor of the file.
+ * @param[in] buf                  buffer to store the read data
+ * @param[in] count                read up to count bytes
+ *
+ * @return #0 or >0                on success
+ * @return #-1                     error
+ *
+ */
+int osal_tml_write(int fd, const void *buf, size_t count);
+
+/**
+ * @brief performs a variety of control functions on STREAMS devices
+ *
+ * @param[in]  fd                      file descriptor of the file
+ * @param[in]   request                 selects the control function
+ *                                    to be performed
+ * @param[in]  reset_type              NFCC power control
+ * @param[in]  count                   read up to count bytes
+ *
+ * @return #otherthan -1              on success
+ * @return #-1                        error
+ *
+ */
+int osal_tml_ioctl(int fd, unsigned long request, unsigned long reset_type,
+                   int count);
+/** @}*/
+#endif /* _PHOSALNFC_TML_H_*/
\ No newline at end of file
diff --git a/emvco_hal_impl/peripherals/peripherals.c b/emvco_hal_impl/peripherals/peripherals.c
new file mode 100644
index 0000000..3e354d1
--- /dev/null
+++ b/emvco_hal_impl/peripherals/peripherals.c
@@ -0,0 +1,67 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#include "emvco_tml_i2c.h"
+#include <emvco_log.h>
+#include <emvco_status.h>
+#include <emvco_tml.h>
+
+EMVCO_STATUS led_switch_control(led_control_t led_control) {
+  LOG_EMVCOHAL_D("%s led_control:%d", __func__, led_control);
+  EMVCO_STATUS status = EMVCO_STATUS_FAILED;
+  switch (led_control) {
+  case GREEN_LED_ON: {
+    status = tml_ioctl(GreenLedOn);
+    if (EMVCO_STATUS_SUCCESS == status) {
+      LOG_EMVCOHAL_D("GREEN LED ON - SUCCESS\n");
+    } else {
+      LOG_EMVCOHAL_D("GREEN LED ON - FAILED\n");
+    }
+    break;
+  }
+  case GREEN_LED_OFF: {
+    status = tml_ioctl(GreenLedOff);
+    if (EMVCO_STATUS_SUCCESS == status) {
+      LOG_EMVCOHAL_D("GREEN LED OFF - SUCCESS\n");
+    } else {
+      LOG_EMVCOHAL_D("GREEN LED OFF  - FAILED\n");
+    }
+    break;
+  }
+  case RED_LED_ON: {
+    status = tml_ioctl(RedLedOn);
+    if (EMVCO_STATUS_SUCCESS == status) {
+      LOG_EMVCOHAL_D("RED LED ON - SUCCESS\n");
+    } else {
+      LOG_EMVCOHAL_D("RED LED ON - FAILED\n");
+    }
+    break;
+  }
+  case RED_LED_OFF: {
+    status = tml_ioctl(RedLedOff);
+    if (EMVCO_STATUS_SUCCESS == status) {
+      LOG_EMVCOHAL_D("RED LED OFF - SUCCESS\n");
+    } else {
+      LOG_EMVCOHAL_D("RED LED OFF  - FAILED\n");
+    }
+    break;
+  }
+  default:
+    break;
+  }
+  return status;
+}
\ No newline at end of file
diff --git a/emvco_hal_impl/peripherals/peripherals.h b/emvco_hal_impl/peripherals/peripherals.h
new file mode 100644
index 0000000..9cdb03f
--- /dev/null
+++ b/emvco_hal_impl/peripherals/peripherals.h
@@ -0,0 +1,45 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef _PERIPHERALS_H_
+#define _PERIPHERALS_H_
+
+/** \addtogroup EMVCO_STACK_PERIPHERAL_API_INTERFACE
+ *  @brief      Interface for handling hardware peripherals
+ *  @{
+ */
+#include "emvco_tml_i2c.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief       This function sets the led according to emvco status
+ * @param[in]   led_control GREEN_LED_ON turn green led and GREEN_LED_OFF turns
+ * green led off
+ * @return           EMVCO_STATUS
+ *
+ */
+EMVCO_STATUS led_switch_control(led_control_t led_control);
+
+#ifdef __cplusplus
+}
+#endif /*  C++ Compilation guard */
+/** @}*/
+#endif /* _PERIPHERALS_H_ */
diff --git a/emvco_hal_impl/tml/emvco_tml.c b/emvco_hal_impl/tml/emvco_tml.c
new file mode 100644
index 0000000..7f0ad00
--- /dev/null
+++ b/emvco_hal_impl/tml/emvco_tml.c
@@ -0,0 +1,520 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/*
+ * TML Implementation.
+ */
+
+#include <emvco_config.h>
+#include <emvco_log.h>
+#include <emvco_tml.h>
+#include <emvco_tml_i2c.h>
+#include <emvco_util.h>
+#include <osal_message_queue_lib.h>
+#include <osal_thread.h>
+#include <osal_timer.h>
+
+/*
+ * Duration of Timer to wait after sending an Nci packet
+ */
+#define PHTMLNFC_MAXTIME_RETRANSMIT (200U)
+#define MAX_WRITE_RETRY_COUNT 0x03
+#define MAX_READ_RETRY_DELAY_IN_MILLISEC (150U)
+
+/* Value to reset variables of TML  */
+#define TML_EMVCO_RESET_VALUE (0x00)
+
+/* Initialize Context structure pointer used to access context structure */
+tml_emvco_context_t *gptml_emvco_context = NULL;
+/* Local Function prototypes */
+static EMVCO_STATUS tml_emvco_start_thread(void);
+static void tml_readDeferredCb(void *pParams);
+static void *emvco_tml_thread(void *pParam);
+
+/* Function definitions */
+
+EMVCO_STATUS tml_init(ptml_emvco_Config_t pConfig) {
+  EMVCO_STATUS wInitStatus = EMVCO_STATUS_SUCCESS;
+
+  /* Check if TML layer is already Initialized */
+  if (NULL != gptml_emvco_context) {
+    /* TML initialization is already completed */
+    wInitStatus = EMVCOSTVAL(CID_EMVCO_TML, EMVCO_STATUS_ALREADY_INITIALISED);
+  }
+  /* Validate Input parameters */
+  else if ((NULL == pConfig) ||
+           (TML_EMVCO_RESET_VALUE == pConfig->dw_get_msg_thread_id)) {
+    /*Parameters passed to TML init are wrong */
+    wInitStatus = EMVCOSTVAL(CID_EMVCO_TML, EMVCO_STATUS_INVALID_PARAMETER);
+  } else {
+    /* Allocate memory for TML context */
+    gptml_emvco_context =
+        (tml_emvco_context_t *)malloc(sizeof(tml_emvco_context_t));
+
+    if (NULL == gptml_emvco_context) {
+      wInitStatus = EMVCOSTVAL(CID_EMVCO_TML, EMVCO_STATUS_FAILED);
+    } else {
+      /* Initialise all the internal TML variables */
+      memset(gptml_emvco_context, TML_EMVCO_RESET_VALUE,
+             sizeof(tml_emvco_context_t));
+      /* Make sure that the thread runs once it is created */
+      gptml_emvco_context->b_thread_done = 1;
+
+      /* Open the device file to which data is read/written */
+      wInitStatus =
+          i2c_open_and_configure(pConfig, &(gptml_emvco_context->p_dev_handle));
+
+      if (EMVCO_STATUS_SUCCESS != wInitStatus) {
+        wInitStatus = EMVCOSTVAL(CID_EMVCO_TML, EMVCO_STATUS_INVALID_DEVICE);
+        gptml_emvco_context->p_dev_handle = NULL;
+      } else {
+        gptml_emvco_context->t_read_info.b_enable = 0;
+        gptml_emvco_context->t_read_info.b_thread_busy = false;
+        if (osal_mutex_init(&gptml_emvco_context->read_info_update_mutex) !=
+            0) {
+          wInitStatus = EMVCO_STATUS_FAILED;
+        } else if (0 != sem_init(&gptml_emvco_context->rx_semaphore, 0, 0)) {
+          wInitStatus = EMVCO_STATUS_FAILED;
+        } else if (0 !=
+                   sem_init(&gptml_emvco_context->post_msg_semaphore, 0, 0)) {
+          wInitStatus = EMVCO_STATUS_FAILED;
+        } else {
+          sem_post(&gptml_emvco_context->post_msg_semaphore);
+          /* Start TML thread (to handle write and read operations) */
+          if (EMVCO_STATUS_SUCCESS != tml_emvco_start_thread()) {
+            wInitStatus = EMVCOSTVAL(CID_EMVCO_TML, EMVCO_STATUS_FAILED);
+          } else {
+            /* Create Timer used for Retransmission of NCI packets */
+            gptml_emvco_context->dw_timer_id = osal_timer_create();
+            if (PH_OSALNFC_TIMER_ID_INVALID !=
+                gptml_emvco_context->dw_timer_id) {
+              /* Store the Thread Identifier to which Message is to be posted */
+              gptml_emvco_context->dw_callback_thread_id =
+                  pConfig->dw_get_msg_thread_id;
+              /* Enable retransmission of Nci packet & set retry count to
+               * default */
+              gptml_emvco_context->e_config = disable_retrans;
+              /* Retry Count = Standby Recovery time of NFCC / Retransmission
+               * time + 1 */
+              gptml_emvco_context->b_retry_count =
+                  (2000 / PHTMLNFC_MAXTIME_RETRANSMIT) + 1;
+            } else {
+              wInitStatus = EMVCOSTVAL(CID_EMVCO_TML, EMVCO_STATUS_FAILED);
+            }
+          }
+        }
+      }
+    }
+  }
+  /* Clean up all the TML resources if any error */
+  if (EMVCO_STATUS_SUCCESS != wInitStatus) {
+    /* Clear all handles and memory locations initialized during init */
+    tml_shutdown_cleanup();
+  }
+
+  return wInitStatus;
+}
+
+/*******************************************************************************
+**
+** Function         tml_emvco_start_thread
+**
+** Description      Initializes comport, reader and writer threads
+**
+** Parameters       None
+**
+** Returns          NFC status:
+**                  EMVCO_STATUS_SUCCESS - threads initialized successfully
+**                  EMVCO_STATUS_FAILED - initialization failed due to system
+*error
+**
+*******************************************************************************/
+static EMVCO_STATUS tml_emvco_start_thread(void) {
+  EMVCO_STATUS wStartStatus = EMVCO_STATUS_SUCCESS;
+  void *h_threadsEvent = 0x00;
+  int pthread_create_status = 0;
+
+  /* Create Reader and Writer threads */
+  pthread_create_status =
+      osal_thread_create(&gptml_emvco_context->reader_thread, NULL,
+                         &emvco_tml_thread, (void *)h_threadsEvent);
+  if (0 != pthread_create_status) {
+    wStartStatus = EMVCO_STATUS_FAILED;
+  }
+
+  return wStartStatus;
+}
+
+/*******************************************************************************
+**
+** Function         emvco_tml_thread
+**
+** Description      Read the data from the lower layer driver
+**
+** Parameters       pParam  - parameters for Writer thread function
+**
+** Returns          None
+**
+*******************************************************************************/
+static void *emvco_tml_thread(void *pParam) {
+  EMVCO_STATUS w_status = EMVCO_STATUS_SUCCESS;
+  int32_t dwNoBytesWrRd = TML_EMVCO_RESET_VALUE;
+  uint8_t temp[260];
+  uint8_t readRetryDelay = 0;
+  /* Transaction info buffer to be passed to Callback Thread */
+  static osal_transact_info_t tTransactionInfo;
+  /* Structure containing Tml callback function and parameters to be invoked
+     by the callback thread */
+  static lib_emvco_deferred_call_t tDeferredInfo;
+  /* Initialize Message structure to post message onto Callback Thread */
+  static lib_emvco_message_t tMsg;
+  UNUSED(pParam);
+  LOG_EMVCO_TML_D("PN72X - Tml Reader Thread Started................\n");
+
+  /* Writer thread loop shall be running till shutdown is invoked */
+  while (gptml_emvco_context->b_thread_done) {
+    /* If Tml write is requested */
+    /* Set the variable to success initially */
+    w_status = EMVCO_STATUS_SUCCESS;
+    if (-1 == sem_wait(&gptml_emvco_context->rx_semaphore)) {
+      LOG_EMVCO_TML_E("sem_wait didn't return success \n");
+    }
+    /* If Tml read is requested */
+    if (1 == gptml_emvco_context->t_read_info.b_enable) {
+      LOG_EMVCO_TML_D("PN72X - Read requested.....\n");
+      /* Set the variable to success initially */
+      w_status = EMVCO_STATUS_SUCCESS;
+
+      /* Variable to fetch the actual number of bytes read */
+      dwNoBytesWrRd = TML_EMVCO_RESET_VALUE;
+
+      /* Read the data from the file onto the buffer */
+      if (NULL != gptml_emvco_context->p_dev_handle) {
+        LOG_EMVCO_TML_D("PN72X - Invoking I2C Read.....\n");
+        dwNoBytesWrRd = i2c_read(gptml_emvco_context->p_dev_handle, temp, 260);
+        if (-1 == dwNoBytesWrRd) {
+          LOG_EMVCO_TML_E("PN72X - Error in I2C Read.....\n");
+          if (readRetryDelay < MAX_READ_RETRY_DELAY_IN_MILLISEC) {
+            /*sleep for 30/60/90/120/150 msec between each read trial incase of
+             * read error*/
+            readRetryDelay += 30;
+          }
+          usleep(readRetryDelay * 1000);
+          sem_post(&gptml_emvco_context->rx_semaphore);
+        } else if (dwNoBytesWrRd > 260) {
+          LOG_EMVCO_TML_E("Numer of bytes read exceeds the limit 260.....\n");
+          readRetryDelay = 0;
+          sem_post(&gptml_emvco_context->rx_semaphore);
+        } else {
+          osal_mutex_lock(&gptml_emvco_context->read_info_update_mutex);
+          memcpy(gptml_emvco_context->t_read_info.p_buffer, temp,
+                 dwNoBytesWrRd);
+          readRetryDelay = 0;
+
+          LOG_EMVCO_TML_D("PN72X - I2C Read successful.....\n");
+          /* This has to be reset only after a successful read */
+          gptml_emvco_context->t_read_info.b_enable = 0;
+          if ((enable_retrans == gptml_emvco_context->e_config) &&
+              (0x00 != (gptml_emvco_context->t_read_info.p_buffer[0] & 0xE0))) {
+            LOG_EMVCO_TML_D("PN72X - Retransmission timer stopped.....\n");
+            /* Stop Timer to prevent Retransmission */
+            uint32_t timerStatus =
+                osal_timer_stop(gptml_emvco_context->dw_timer_id);
+            if (EMVCO_STATUS_SUCCESS != timerStatus) {
+              LOG_EMVCO_TML_E("PN72X - timer stopped returned failure.....\n");
+            }
+          }
+          /* Update the actual number of bytes read including header */
+          gptml_emvco_context->t_read_info.w_length = (uint16_t)(dwNoBytesWrRd);
+          print_packet("RECV", gptml_emvco_context->t_read_info.p_buffer,
+                       gptml_emvco_context->t_read_info.w_length);
+
+          dwNoBytesWrRd = TML_EMVCO_RESET_VALUE;
+
+          /* Fill the Transaction info structure to be passed to Callback
+           * Function */
+          tTransactionInfo.w_status = w_status;
+          tTransactionInfo.p_buff = gptml_emvco_context->t_read_info.p_buffer;
+          /* Actual number of bytes read is filled in the structure */
+          tTransactionInfo.w_length = gptml_emvco_context->t_read_info.w_length;
+
+          /* Read operation completed successfully. Post a Message onto Callback
+           * Thread*/
+          /* Prepare the message to be posted on User thread */
+          tDeferredInfo.p_callback = &tml_readDeferredCb;
+          tDeferredInfo.p_parameter = &tTransactionInfo;
+          tMsg.e_msgType = EMVCO_DEFERRED_CALL_MSG;
+          tMsg.p_msg_data = &tDeferredInfo;
+          tMsg.size = sizeof(tDeferredInfo);
+          // pthread_mutex_unlock(&gptml_emvco_context->read_info_update_mutex);
+          osal_mutex_unlock(&gptml_emvco_context->read_info_update_mutex);
+          LOG_EMVCO_TML_D("PN72X - Posting read message.....\n");
+          tml_deferred_call(gptml_emvco_context->dw_callback_thread_id, &tMsg);
+        }
+      } else {
+        LOG_EMVCO_TML_D("PN72X -gptml_emvco_context->p_dev_handle is NULL");
+      }
+    } else {
+      LOG_EMVCO_TML_D("PN72X - read request NOT enabled");
+      usleep(10 * 1000);
+    }
+  } /* End of While loop */
+
+  return NULL;
+}
+
+void tml_cleanup(void) {
+  if (NULL == gptml_emvco_context) {
+    return;
+  }
+  if (NULL != gptml_emvco_context->p_dev_handle) {
+    (void)i2c_nfcc_reset(gptml_emvco_context->p_dev_handle, MODE_POWER_OFF);
+    gptml_emvco_context->b_thread_done = 0;
+  }
+  sem_destroy(&gptml_emvco_context->rx_semaphore);
+  sem_destroy(&gptml_emvco_context->post_msg_semaphore);
+  i2c_close(gptml_emvco_context->p_dev_handle);
+  gptml_emvco_context->p_dev_handle = NULL;
+  /* Clear memory allocated for storing Context variables */
+  free((void *)gptml_emvco_context);
+  /* Set the pointer to NULL to indicate De-Initialization */
+  gptml_emvco_context = NULL;
+
+  return;
+}
+
+EMVCO_STATUS tml_shutdown(void) {
+  EMVCO_STATUS wShutdownStatus = EMVCO_STATUS_SUCCESS;
+
+  /* Check whether TML is Initialized */
+  if (NULL != gptml_emvco_context) {
+    /* Reset thread variable to terminate the thread */
+    gptml_emvco_context->b_thread_done = 0;
+    usleep(1000);
+    /* Clear All the resources allocated during initialization */
+    sem_post(&gptml_emvco_context->rx_semaphore);
+    usleep(1000);
+    sem_post(&gptml_emvco_context->post_msg_semaphore);
+    usleep(1000);
+    sem_post(&gptml_emvco_context->post_msg_semaphore);
+    usleep(1000);
+    osal_mutex_destroy(&gptml_emvco_context->read_info_update_mutex);
+    if (0 !=
+        osal_thread_join(gptml_emvco_context->reader_thread, (void **)NULL)) {
+      LOG_EMVCO_TML_E("Fail to kill reader thread!");
+    }
+    LOG_EMVCO_TML_D("b_thread_done == 0");
+
+  } else {
+    wShutdownStatus = EMVCOSTVAL(CID_EMVCO_TML, EMVCO_STATUS_NOT_INITIALISED);
+  }
+
+  return wShutdownStatus;
+}
+
+EMVCO_STATUS tml_write(uint8_t *p_buffer, uint16_t w_length) {
+  EMVCO_STATUS write_status = EMVCO_STATUS_SUCCESS;
+  if ((NULL != gptml_emvco_context->p_dev_handle) && (NULL != p_buffer) &&
+      (TML_EMVCO_RESET_VALUE != w_length)) {
+    LOG_EMVCO_TML_D("PN72X - Invoking I2C Write.....\n");
+    int32_t num_of_bytes_wrote =
+        i2c_write(gptml_emvco_context->p_dev_handle, p_buffer, w_length);
+    if (-1 == num_of_bytes_wrote) {
+      LOG_EMVCO_TML_D("PN72X - Error in I2C Write.....\n");
+      write_status = EMVCOSTVAL(CID_EMVCO_TML, EMVCO_STATUS_FAILED);
+    } else {
+      print_packet("SEND", p_buffer, w_length);
+    }
+
+    if (EMVCO_STATUS_SUCCESS == write_status) {
+      LOG_EMVCO_TML_D("PN72X - I2C Write successful.....\n");
+    }
+  } else {
+    LOG_EMVCO_TML_D("PN72X - Write error invalid parameter");
+    write_status = EMVCOSTVAL(CID_EMVCO_TML, EMVCO_STATUS_INVALID_PARAMETER);
+  }
+
+  return write_status;
+}
+
+EMVCO_STATUS tml_update_read_complete_callback(
+    transact_completion_callback_t pTmlReadComplete) {
+  EMVCO_STATUS w_status = EMVCO_STATUS_FAILED;
+  if ((NULL != gptml_emvco_context) && (NULL != pTmlReadComplete)) {
+    gptml_emvco_context->t_read_info.p_thread_callback = pTmlReadComplete;
+    w_status = EMVCO_STATUS_SUCCESS;
+  }
+  return w_status;
+}
+
+EMVCO_STATUS tml_read(uint8_t *p_buffer, uint16_t w_length,
+                      transact_completion_callback_t pTmlReadComplete,
+                      void *p_context) {
+  EMVCO_STATUS wReadStatus;
+
+  /* Check whether TML is Initialized */
+  if (NULL != gptml_emvco_context) {
+    if ((gptml_emvco_context->p_dev_handle != NULL) && (NULL != p_buffer) &&
+        (TML_EMVCO_RESET_VALUE != w_length) && (NULL != pTmlReadComplete)) {
+      if (!gptml_emvco_context->t_read_info.b_thread_busy) {
+        osal_mutex_lock(&gptml_emvco_context->read_info_update_mutex);
+        /* Setting the flag marks beginning of a Read Operation */
+        gptml_emvco_context->t_read_info.b_thread_busy = true;
+        /* Copy the buffer, length and Callback function,
+           This shall be utilized while invoking the Callback function in thread
+           */
+        gptml_emvco_context->t_read_info.p_buffer = p_buffer;
+        gptml_emvco_context->t_read_info.w_length = w_length;
+        gptml_emvco_context->t_read_info.p_thread_callback = pTmlReadComplete;
+        gptml_emvco_context->t_read_info.p_context = p_context;
+        wReadStatus = EMVCO_STATUS_PENDING;
+
+        /* Set event to invoke Reader Thread */
+        gptml_emvco_context->t_read_info.b_enable = 1;
+        osal_mutex_unlock(&gptml_emvco_context->read_info_update_mutex);
+        sem_post(&gptml_emvco_context->rx_semaphore);
+      } else {
+        wReadStatus = EMVCOSTVAL(CID_EMVCO_TML, EMVCO_STATUS_BUSY);
+      }
+    } else {
+      wReadStatus = EMVCOSTVAL(CID_EMVCO_TML, EMVCO_STATUS_INVALID_PARAMETER);
+    }
+  } else {
+    wReadStatus = EMVCOSTVAL(CID_EMVCO_TML, EMVCO_STATUS_NOT_INITIALISED);
+  }
+
+  return wReadStatus;
+}
+
+EMVCO_STATUS tml_read_abort(void) {
+  EMVCO_STATUS w_status = EMVCO_STATUS_INVALID_PARAMETER;
+  gptml_emvco_context->t_read_info.b_enable = 0;
+
+  /*Reset the flag to accept another Read Request */
+  gptml_emvco_context->t_read_info.b_thread_busy = false;
+  w_status = EMVCO_STATUS_SUCCESS;
+
+  return w_status;
+}
+
+EMVCO_STATUS tml_ioctl(emvco_control_code_t eControlCode) {
+  EMVCO_STATUS w_status = EMVCO_STATUS_SUCCESS;
+
+  if (NULL == gptml_emvco_context) {
+    w_status = EMVCO_STATUS_FAILED;
+  } else {
+    switch (eControlCode) {
+    case ResetDevice: {
+      /*Reset PN72X*/
+      i2c_nfcc_reset(gptml_emvco_context->p_dev_handle, MODE_POWER_ON);
+      usleep(100 * 1000);
+      i2c_nfcc_reset(gptml_emvco_context->p_dev_handle, MODE_POWER_OFF);
+      usleep(100 * 1000);
+      i2c_nfcc_reset(gptml_emvco_context->p_dev_handle, MODE_POWER_ON);
+      break;
+    }
+    case EnableNormalMode: {
+      /*Reset PN72X*/
+      i2c_nfcc_reset(gptml_emvco_context->p_dev_handle, MODE_POWER_OFF);
+      usleep(10 * 1000);
+      i2c_nfcc_reset(gptml_emvco_context->p_dev_handle, MODE_POWER_ON);
+      usleep(100 * 1000);
+      break;
+    }
+    case RedLedOff: {
+      i2c_led_control(gptml_emvco_context->p_dev_handle, RED_LED_OFF);
+      break;
+    }
+    case RedLedOn: {
+      i2c_led_control(gptml_emvco_context->p_dev_handle, RED_LED_ON);
+      break;
+    }
+    case GreenLedOff: {
+      i2c_led_control(gptml_emvco_context->p_dev_handle, GREEN_LED_OFF);
+      break;
+    }
+    case GreenLedOn: {
+      i2c_led_control(gptml_emvco_context->p_dev_handle, GREEN_LED_ON);
+      break;
+    }
+    case NFCCModeSwitchOn: {
+      i2c_nfcc_profile_switch(gptml_emvco_context->p_dev_handle, EMVCO_MODE);
+      break;
+    }
+    case NFCCModeSwitchOff: {
+      i2c_nfcc_profile_switch(gptml_emvco_context->p_dev_handle, NCI_MODE);
+      break;
+    }
+    case SMCUModeSwitchOn: {
+      i2c_smcu_profile_switch(gptml_emvco_context->p_dev_handle, EMVCO_MODE);
+      break;
+    }
+    case SMCUModeSwitchOff: {
+      i2c_smcu_profile_switch(gptml_emvco_context->p_dev_handle, NCI_MODE);
+      break;
+    }
+    default: {
+      w_status = EMVCO_STATUS_INVALID_PARAMETER;
+      break;
+    }
+    }
+  }
+
+  return w_status;
+}
+
+void tml_deferred_call(uintptr_t dwThreadId, lib_emvco_message_t *ptWorkerMsg) {
+  intptr_t bPostStatus;
+  UNUSED(dwThreadId);
+  /* Post message on the user thread to invoke the callback function */
+  if (-1 == sem_wait(&gptml_emvco_context->post_msg_semaphore)) {
+    LOG_EMVCO_TML_E("sem_wait didn't return success \n");
+  }
+  bPostStatus =
+      osal_msg_snd(gptml_emvco_context->dw_callback_thread_id, ptWorkerMsg, 0);
+  sem_post(&gptml_emvco_context->post_msg_semaphore);
+}
+
+/*******************************************************************************
+**
+** Function         tml_readDeferredCb
+**
+** Description      Read thread call back function
+**
+** Parameters       pParams - context provided by upper layer
+**
+** Returns          None
+**
+*******************************************************************************/
+static void tml_readDeferredCb(void *pParams) {
+  /* Transaction info buffer to be passed to Callback Function */
+  osal_transact_info_t *pTransactionInfo = (osal_transact_info_t *)pParams;
+
+  /* Reset the flag to accept another Read Request */
+  gptml_emvco_context->t_read_info.b_thread_busy = false;
+  gptml_emvco_context->t_read_info.p_thread_callback(
+      gptml_emvco_context->t_read_info.p_context, pTransactionInfo);
+
+  return;
+}
+
+EMVCO_STATUS tml_shutdown_cleanup() {
+  EMVCO_STATUS wShutdownStatus = tml_shutdown();
+  tml_cleanup();
+  return wShutdownStatus;
+}
diff --git a/emvco_hal_impl/tml/emvco_tml.h b/emvco_hal_impl/tml/emvco_tml.h
new file mode 100644
index 0000000..c3d0429
--- /dev/null
+++ b/emvco_hal_impl/tml/emvco_tml.h
@@ -0,0 +1,400 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef _EMVCO_TML_H_
+#define _EMVCO_TML_H_
+
+/** \addtogroup EMVCO_STACK_TML_API_INTERFACE
+ *  @brief      Transport Mapping Layer header files containing APIs related to
+ * initializing, reading and writing data into files provided by the driver
+ * interface.
+ *
+ * API listed here encompasses Transport Mapping Layer interfaces required to be
+ * mapped
+ * to different Interfaces and Platforms.
+ *  @{
+ */
+
+#include <emvco_osal_common.h>
+
+/*
+ * Message posted by Reader thread upon
+ * completion of requested operation
+ */
+#define TMLNFC_READ_MESSAGE (0xAA)
+
+/*
+ * Message posted by Writer thread upon
+ * completion of requested operation
+ */
+#define TMLNFC_WRITE_MESSAGE (0x55)
+
+/*
+ * Value indicates to reset device
+ */
+#define TMLNFC_RESETDEVICE (0x00008001)
+
+/*
+***************************Globals,Structure and Enumeration ******************
+*/
+
+/**
+ * @brief Transaction (Tx/Rx) completion information structure of TML
+ *
+ * This structure holds the completion callback information of the
+ * transaction passed from the TML layer to the Upper layer
+ * along with the completion callback.
+ *
+ * The value of field w_status can be interpreted as:
+ *
+ *     - EMVCO_STATUS_SUCCESS                    Transaction performed
+ * successfully.
+ *     - EMVCO_STATUS_FAILED                     Failed to wait on Read/Write
+ * operation.
+ *     - EMVCO_STATUS_INSUFFICIENT_STORAGE       Not enough memory to store data
+ * in case of read.
+ *     - EMVCO_STATUS_BOARD_COMMUNICATION_ERROR  Failure to Read/Write from the
+ * file or timeout.
+ */
+
+typedef struct osal_transact_info {
+  EMVCO_STATUS w_status; /* Status of the Transaction Completion*/
+  uint8_t *p_buff;       /* Response Data of the Transaction*/
+  uint16_t w_length;     /* Data size of the Transaction*/
+} osal_transact_info_t;  /* Instance of Transaction structure */
+
+/*nfc state flags*/
+enum emvco_state_flags {
+  /*nfc in unknown state */
+  EMVCO_STATE_UNKNOWN = 0,
+  /*nfc booted in download mode */
+  EMVCO_STATE_FW_DWL = 0x1,
+  /*nfc booted in NCI mode */
+  EMVCO_STATE_NCI = 0x2,
+};
+/**
+ * @brief TML transreceive completion callback to Upper Layer
+ *
+ * p_context - Context provided by upper layer
+ * pInfo    - Transaction info. See osal_transact_info
+ */
+typedef void (*transact_completion_callback_t)(void *p_context,
+                                               osal_transact_info_t *pInfo);
+
+/**
+ * @brief TML Deferred callback interface structure invoked by upper layer
+ *
+ * This could be used for read/write operations
+ *
+ * dw_msg_posted_thread Message source identifier
+ * pParams Parameters for the deferred call processing
+ */
+typedef void (*defer_func_pointer_t)(uint32_t dw_msg_posted_thread,
+                                     void *pParams);
+
+/**
+ * @brief Enum definition contains  supported ioctl control codes.
+ *
+ * tml_ioctl
+ */
+typedef enum {
+  Invalid = 0,
+  ResetDevice = TMLNFC_RESETDEVICE, /* Reset the device */
+  EnableDownloadMode,               /* Do the hardware setting to enter into
+                                                  download mode */
+  EnableNormalMode, /* Hardware setting for normal mode of operation
+                     */
+  RedLedOff,        /* Turns off red led */
+  RedLedOn,         /* Turns on red led */
+  GreenLedOff,      /* Turns off green led */
+  GreenLedOn,       /* Turns on green led */
+  NFCCModeSwitchOn,
+  NFCCModeSwitchOff,
+  SMCUModeSwitchOn,
+  SMCUModeSwitchOff,
+} emvco_control_code_t; /* Control code for IOCTL call */
+
+/*
+ * Enable / Disable Re-Transmission of Packets
+ *
+ * tml_emvco_ConfigNciPktReTx
+ */
+typedef enum {
+  enable_retrans = 0x00, /*Enable retransmission of Nci packet */
+  disable_retrans = 0x01 /*Disable retransmission of Nci packet */
+} config_retrans_t;      /* Configuration for Retransmission */
+
+/*
+ * Structure containing details related to read and write operations
+ *
+ */
+typedef struct tml_read_write_info {
+  volatile uint8_t b_enable; /*This flag shall decide whether to perform
+                               Write/Read operation */
+  uint8_t b_thread_busy;     /*Flag to indicate thread is busy on respective
+                                operation */
+  /* Transaction completion Callback function */
+  transact_completion_callback_t p_thread_callback;
+  void *p_context;          /*Context passed while invocation of operation */
+  uint8_t *p_buffer;        /*Buffer passed while invocation of operation */
+  uint16_t w_length;        /*Length of data read/written */
+  EMVCO_STATUS work_status; /*Status of the transaction performed */
+} tml_read_write_info_t;
+
+/*
+ *Base Context Structure containing members required for entire session
+ */
+typedef struct tml_emvco_context {
+  pthread_t reader_thread; /*Handle to the thread which handles write and read
+                             operations */
+  volatile uint8_t
+      b_thread_done; /*Flag to decide whether to run or abort the thread */
+  config_retrans_t e_config; /*Retransmission of Nci Packet during timeout */
+  uint8_t b_retry_count;     /*Number of times retransmission shall happen */
+  uint32_t dw_timer_id;      /* Timer used to retransmit nci packet */
+  tml_read_write_info_t t_read_info; /*Pointer to Reader Thread Structure */
+  void *p_dev_handle;                /* Pointer to Device Handle */
+  uintptr_t dw_callback_thread_id; /* Thread ID to which message to be posted */
+  uint8_t b_enable_crc; /*Flag to validate/not CRC for input buffer */
+  sem_t rx_semaphore;
+  sem_t post_msg_semaphore; /* Semaphore to post message atomically by Reader &
+                             writer thread */
+  pthread_mutex_t
+      read_info_update_mutex; /*Mutex to synchronize read Info update*/
+} tml_emvco_context_t;
+
+/**
+ * @brief
+ * TML Configuration exposed to upper layer.
+ */
+typedef struct tml_emvco_Config {
+  /* Port name connected to PN72X
+   *
+   * Platform specific canonical device name to which PN72X is connected.
+   *
+   * e.g. On Linux based systems this would be /dev/PN72X
+   */
+  int8_t *p_dev_name;
+  /* Callback Thread ID
+   *
+   * This is the thread ID on which the Reader & Writer thread posts message. */
+  uintptr_t dw_get_msg_thread_id;
+  /* Communication speed between DH and PN72X
+   *
+   * This is the baudrate of the bus for communication between DH and PN72X */
+  uint32_t dw_baud_rate;
+} tml_emvco_Config_t, *ptml_emvco_Config_t; /* pointer to tml_emvco_Config_t */
+
+/*
+ * TML Deferred Callback structure used to invoke Upper layer Callback function.
+ */
+typedef struct {
+  /* Deferred callback function to be invoked */
+  defer_func_pointer_t p_def_call;
+  /* Source identifier
+   *
+   * Identifier of the source which posted the message
+   */
+  uint32_t dw_msg_posted_thread;
+  /** Actual Message
+   *
+   * This is passed as a parameter passed to the deferred callback function
+   * pDef_call. */
+  void *pParams;
+} tml_emvco_defer_msg_t; /* DeferMsg structure passed to User Thread */
+
+/* Function declarations */
+
+/**
+ * @brief           Provides initialization of TML layer and hardware interface
+ *                  Configures given hardware interface and sends handle to the
+ *                  caller
+ *
+ * @param[in]       pConfig - TML configuration details as provided by the upper
+ *                            layer
+ *
+ * @return          NFC status:
+ *                  EMVCO_STATUS_SUCCESS - initialization successful
+ *                  EMVCO_STATUS_INVALID_PARAMETER - at least one parameter is
+ *                                                invalid
+ *                  EMVCO_STATUS_FAILED - initialization failed (for example,
+ *                                     unable to open hardware interface)
+ *                  EMVCO_STATUS_INVALID_DEVICE - device has not been opened or
+ *                  has been disconnected
+ *
+ */
+EMVCO_STATUS tml_init(ptml_emvco_Config_t pConfig);
+/**
+ * @brief       Uninitializes TML layer and hardware interface
+ *
+ * @param[in]       None
+ *
+ *  @return          NFC status:
+ *                  EMVCO_STATUS_SUCCESS - TML configuration released
+ * successfully
+ *                  EMVCO_STATUS_INVALID_PARAMETER - at least one parameter is
+ *                                                invalid
+ *                  EMVCO_STATUS_FAILED - un-initialization failed (example:
+ * unable
+ *                                     to close interface)
+ *
+ */
+EMVCO_STATUS tml_shutdown(void);
+
+/**
+ *
+ * @brief       wrapper function  for shutdown  and cleanup of resources
+ *
+ * @param[in]       None
+ *
+ * @return           EMVCO_STATUS
+ *
+ */
+EMVCO_STATUS tml_shutdown_cleanup();
+
+/**
+ *
+ * @brief      Clears all handles opened during TML initialization
+ *
+ * @param[in]       None
+ *
+ * @return          None
+ *
+ */
+void tml_cleanup(void);
+
+/**
+ *
+ * @brief      Asynchronously writes given data block to hardware
+ *                  interface/driver. Enables writer thread if there are no
+ *                  write requests pending. Returns successfully once writer
+ *                  thread completes write operation. Notifies upper layer using
+ *                  callback mechanism.
+ *
+ *                  NOTE:
+ *                  * it is important to post a message with id
+ *                    TMLNFC_WRITE_MESSAGE to IntegrationThread after data
+ *                    has been written to PN72X
+ *                  * if CRC needs to be computed, then input buffer should be
+ *                    capable to store two more bytes apart from length of
+ *                    packet
+ *
+ * @param[in]       p_buffer - data to be sent
+ * @param[in]       w_length - length of data buffer
+ * @param[in]       pTmlWriteComplete - pointer to the function to be invoked
+ *                                      upon completion
+ * @param[in]       p_context - context provided by upper layer
+ *
+ * @return          NFC status:
+ *                  EMVCO_STATUS_PENDING - command is yet to be processed
+ *                  EMVCO_STATUS_INVALID_PARAMETER - at least one parameter is
+ *                                                invalid
+ *                  EMVCO_STATUS_BUSY - write request is already in progress
+ *
+ */
+EMVCO_STATUS tml_write(uint8_t *p_buffer, uint16_t w_length);
+/**
+ *
+ * @brief           Asynchronously reads data from the driver
+ *                  Number of bytes to be read and buffer are passed by upper
+ *                  layer.
+ *                  Enables reader thread if there are no read requests pending
+ *                  Returns successfully once read operation is completed
+ *                  Notifies upper layer using callback mechanism
+ *
+ * @param[in]       p_buffer - data to be sent
+ * @param[in]       w_length - length of data buffer
+ * @param[in]       pTmlWriteComplete  pointer to the function to be invoked
+ upon
+ * completion
+ * @param[in]       p_context        context provided by upper layer
+ *
+ * @return          NFC status:
+ *                  EMVCO_STATUS_PENDING - command is yet to be processed
+ *                  EMVCO_STATUS_INVALID_PARAMETER - at least one parameter is
+ *                                                invalid
+ *                  EMVCO_STATUS_BUSY - read request is already in progress
+
+ *
+ *
+ */
+EMVCO_STATUS tml_read(uint8_t *p_buffer, uint16_t w_length,
+                      transact_completion_callback_t pTmlReadComplete,
+                      void *p_context);
+/**
+ *
+ * @brief       Aborts pending read request (if any)
+ *
+ * @param[in]        None
+ *
+ * @return           NFC status:
+ *                  EMVCO_STATUS_SUCCESS - ongoing read operation aborted
+ *                  EMVCO_STATUS_INVALID_PARAMETER - at least one parameter is
+ *                                                invalid
+ *                  EMVCO_STATUS_NOT_INITIALIZED - TML layer is not initialized
+ *                  EMVCO_STATUS_BOARD_COMMUNICATION_ERROR - unable to cancel
+ *read
+ *                                                        operation
+ *
+ */
+EMVCO_STATUS tml_read_abort(void);
+/**
+ * @brief       Resets device when insisted by upper layer
+ *                  Number of bytes to be read and buffer are passed by upper
+ *                  layer
+ *                  Enables reader thread if there are no read requests pending
+ *                  Returns successfully once read operation is completed
+ *                  Notifies upper layer using callback mechanism
+ *
+ * @param[in]       eControlCode       - control code for a specific operation
+ *
+ * @return           NFC status:
+ *                  EMVCO_STATUS_SUCCESS  - ioctl command completed successfully
+ *                  EMVCO_STATUS_FAILED   - ioctl command request failed
+ *
+ */
+EMVCO_STATUS tml_ioctl(emvco_control_code_t eControlCode);
+
+/**
+ * @brief       Updates the callback to be invoked after read completed
+ *
+ * @param[in]       pTmlReadComplete - pointer to the function to be invoked
+ *                                     upon completion of read operation
+ *
+ * @return           NFC status:
+ *                  EMVCO_STATUS_SUCCESS - if TmlNfc context available
+ *                  EMVCO_STATUS_FAILED - otherwise
+ *
+ */
+EMVCO_STATUS tml_update_read_complete_callback(
+    transact_completion_callback_t pTmlReadComplete);
+
+/**
+ * @brief       Posts message on upper layer thread
+ *                  upon successful read or write operation
+ *
+ * @param[in]       dwThreadId  - id of the thread posting message
+ *                  ptWorkerMsg - message to be posted
+ *
+ * @return           None
+ *
+ */
+void tml_deferred_call(uintptr_t dwThreadId, lib_emvco_message_t *ptWorkerMsg);
+
+/** @}*/
+#endif /*  _EMVCO_TML_H_  */
diff --git a/emvco_hal_impl/tml/emvco_tml_i2c.c b/emvco_hal_impl/tml/emvco_tml_i2c.c
new file mode 100644
index 0000000..8fef85d
--- /dev/null
+++ b/emvco_hal_impl/tml/emvco_tml_i2c.c
@@ -0,0 +1,405 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/select.h>
+#include <termios.h>
+#include <unistd.h>
+
+#include "emvco_tml.h"
+#include "emvco_tml_i2c.h"
+#include "emvco_util.h"
+#include "osal_thread.h"
+#include "osal_tml.h"
+#include <emvco_log.h>
+#include <emvco_status.h>
+#include <string.h>
+
+#define CRC_LEN 2
+#define NORMAL_MODE_HEADER_LEN 3
+#define FW_DNLD_HEADER_LEN 2
+#define FW_DNLD_LEN_OFFSET 1
+#define NORMAL_MODE_LEN_OFFSET 2
+#define FRAGMENTSIZE_MAX PHNFC_I2C_FRAGMENT_SIZE
+
+static struct osal_semaphore mTxRxSemaphore;
+
+extern tml_emvco_context_t *gptml_emvco_context;
+
+/*******************************************************************************
+**
+** Function         i2c_close
+**
+** Description      Closes NFCC device
+**
+** Parameters       p_dev_handle - device handle
+**
+** Returns          None
+**
+*******************************************************************************/
+void i2c_close(void *p_dev_handle) {
+  if (NULL != p_dev_handle) {
+    osal_tml_close((intptr_t)p_dev_handle);
+  }
+  osal_sem_destroy(&mTxRxSemaphore.object_handle);
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         i2c_open_and_configure
+**
+** Description      Open and configure NFCC device
+**
+** Parameters       pConfig     - hardware information
+**                  pLinkHandle - device handle
+**
+** Returns          NFC status:
+**                  EMVCO_STATUS_SUCCESS - open_and_configure operation success
+**                  EMVCO_STATUS_INVALID_DEVICE - device open operation failure
+**
+*******************************************************************************/
+EMVCO_STATUS i2c_open_and_configure(ptml_emvco_Config_t pConfig,
+                                    void **pLinkHandle) {
+  int nHandle;
+
+  LOG_EMVCO_TML_D("%s Opening port=%s\n", __func__, pConfig->p_dev_name);
+  /* open port */
+  nHandle = osal_tml_open((const char *)pConfig->p_dev_name, O_RDWR);
+  if (nHandle < 0) {
+    LOG_EMVCO_TML_E("_i2c_open() Failed: retval %x", nHandle);
+    *pLinkHandle = NULL;
+    return EMVCO_STATUS_INVALID_DEVICE;
+  }
+
+  *pLinkHandle = (void *)((intptr_t)nHandle);
+  if (0 != osal_sem_init(&mTxRxSemaphore.object_handle, 0, 1)) {
+    LOG_EMVCO_TML_E("%s Failed: reason osal_sem_init : retval %x", __func__,
+                    nHandle);
+  }
+  /*Reset Controller*/
+  i2c_nfcc_reset((void *)((intptr_t)nHandle), MODE_POWER_OFF);
+  usleep(10 * 1000);
+  i2c_nfcc_reset((void *)((intptr_t)nHandle), MODE_POWER_ON);
+
+  return EMVCO_STATUS_SUCCESS;
+}
+
+int i2c_flush_data(void *p_dev_handle, uint8_t *p_buffer, int numRead) {
+  int retRead = 0;
+  uint16_t totalBtyesToRead =
+      p_buffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
+  /* we shall read totalBtyesToRead-1 as one byte is already read by calling
+   * function*/
+  retRead = osal_tml_read((intptr_t)p_dev_handle, p_buffer + numRead,
+                          totalBtyesToRead - 1);
+  if (retRead > 0) {
+    numRead += retRead;
+    print_packet("RECV", p_buffer, numRead);
+  } else if (retRead == 0) {
+    LOG_EMVCO_TML_E("%s _i2c_read() [pyld] EOF", __func__);
+  } else {
+    LOG_EMVCO_TML_D("%s _i2c_read() [hdr] received", __func__);
+    print_packet("RECV", p_buffer - numRead, NORMAL_MODE_HEADER_LEN);
+    LOG_EMVCO_TML_E("%s _i2c_read() [pyld] errno : %x", __func__, errno);
+  }
+  i2c_sem_post();
+  return -1;
+}
+
+/*******************************************************************************
+**
+** Function         phOsal_Read
+**
+** Description      Reads requested number of bytes from NFCC device into given
+**                  buffer
+**
+** Parameters       p_dev_handle       - valid device handle
+**                  p_buffer          - buffer for read data
+**                  nNbBytesToRead   - number of bytes requested to be read
+**
+** Returns          numRead   - number of successfully read bytes
+**                  -1        - read operation failure
+**
+*******************************************************************************/
+int i2c_read(void *p_dev_handle, uint8_t *p_buffer, int nNbBytesToRead) {
+  LOG_EMVCO_TML_D("%s i2c_read", __func__);
+  int ret_Read;
+  int ret_Select;
+  int numRead = 0;
+  struct timeval tv;
+  fd_set rfds;
+  uint16_t totalBtyesToRead = 0;
+
+  UNUSED(nNbBytesToRead);
+  if (NULL == p_dev_handle) {
+    return -1;
+  }
+
+  totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
+
+  /* Read with 2 second timeout, so that the read thread can be aborted
+     when the NFCC does not respond and we need to switch to FW download
+     mode. This should be done via a control socket instead. */
+  FD_ZERO(&rfds);
+  FD_SET((intptr_t)p_dev_handle, &rfds);
+  tv.tv_sec = 2;
+  tv.tv_usec = 1;
+
+  ret_Select =
+      select((int)((intptr_t)p_dev_handle + (int)1), &rfds, NULL, NULL, &tv);
+  if (ret_Select < 0) {
+    LOG_EMVCO_TML_D("%s errno : %x", __func__, errno);
+    return -1;
+  } else if (ret_Select == 0) {
+    LOG_EMVCO_TML_D("%s Timeout", __func__);
+    return -1;
+  } else {
+    ret_Read = osal_tml_read((intptr_t)p_dev_handle, p_buffer,
+                             totalBtyesToRead - numRead);
+    if (ret_Read > 0 && !(p_buffer[0] == 0xFF && p_buffer[1] == 0xFF)) {
+      i2c_sem_timed_wait();
+      numRead += ret_Read;
+    } else if (ret_Read == 0) {
+      LOG_EMVCO_TML_E("%s [hdr]EOF", __func__);
+      return -1;
+    } else {
+      LOG_EMVCO_TML_E("%s [hdr] errno : %x", __func__, errno);
+      LOG_EMVCO_TML_E(" %s p_buffer[0] = %x p_buffer[1]= %x", __func__,
+                      p_buffer[0], p_buffer[1]);
+      return -1;
+    }
+
+    totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
+#if (NXP_EXTNS == TRUE)
+    if (gptml_emvco_context->t_read_info.p_context != NULL &&
+        !memcmp(gptml_emvco_context->t_read_info.p_context, "MinOpen", 0x07) &&
+        !p_buffer[0] && p_buffer[1]) {
+      return i2c_flush_data(p_dev_handle, p_buffer, numRead);
+    }
+#endif
+
+    if (numRead < totalBtyesToRead) {
+      ret_Read = osal_tml_read((intptr_t)p_dev_handle, (p_buffer + numRead),
+                               totalBtyesToRead - numRead);
+
+      if (ret_Read != totalBtyesToRead - numRead) {
+        i2c_sem_post();
+        LOG_EMVCO_TML_E("%s [hdr] errno : %x", __func__, errno);
+        return -1;
+      } else {
+        numRead += ret_Read;
+      }
+    }
+    totalBtyesToRead =
+        p_buffer[NORMAL_MODE_LEN_OFFSET] + NORMAL_MODE_HEADER_LEN;
+    if ((totalBtyesToRead - numRead) != 0) {
+      ret_Read = osal_tml_read((intptr_t)p_dev_handle, (p_buffer + numRead),
+                               totalBtyesToRead - numRead);
+      if (ret_Read > 0) {
+        numRead += ret_Read;
+      } else if (ret_Read == 0) {
+        i2c_sem_post();
+        LOG_EMVCO_TML_E("%s [pyld] EOF", __func__);
+        return -1;
+      } else {
+        LOG_EMVCO_TML_D("_i2c_read() [hdr] received");
+        print_packet("RECV", p_buffer, NORMAL_MODE_HEADER_LEN);
+        i2c_sem_post();
+        LOG_EMVCO_TML_E("%s [pyld] errno : %x", __func__, errno);
+        return -1;
+      }
+    } else {
+      LOG_EMVCO_TML_E("%s _>>>>> Empty packet recieved !!", __func__);
+    }
+  }
+  i2c_sem_post();
+  return numRead;
+}
+
+/*******************************************************************************
+**
+** Function         i2c_write
+**
+** Description      Writes requested number of bytes from given buffer into
+**                  NFCC device
+**
+** Parameters       p_dev_handle       - valid device handle
+**                  p_buffer          - buffer for read data
+**                  nNbBytesToWrite  - number of bytes requested to be written
+**
+** Returns          numWrote   - number of successfully written bytes
+**                  -1         - i2c_write operation failure
+**
+*******************************************************************************/
+int i2c_write(void *p_dev_handle, uint8_t *p_buffer, int nNbBytesToWrite) {
+  int ret;
+  int numWrote = 0;
+  int numBytes = nNbBytesToWrite;
+  if (NULL == p_dev_handle) {
+    return -1;
+  }
+  while (numWrote < nNbBytesToWrite) {
+    i2c_sem_timed_wait();
+    ret = osal_tml_write((intptr_t)p_dev_handle, p_buffer + numWrote,
+                         numBytes - numWrote);
+    i2c_sem_post();
+    if (ret > 0) {
+      numWrote += ret;
+    } else if (ret == 0) {
+      LOG_EMVCO_TML_D("%s EOF", __func__);
+      return -1;
+    } else {
+      LOG_EMVCO_TML_D("%s errno : %x", __func__, errno);
+      if (errno == EINTR || errno == EAGAIN) {
+        continue;
+      }
+      return -1;
+    }
+  }
+
+  return numWrote;
+}
+
+/*******************************************************************************
+**
+** Function         i2c_nfcc_reset
+**
+** Description      Reset NFCC device, using VEN pin
+**
+** Parameters       p_dev_handle     - valid device handle
+**                  eType          - reset level
+**
+** Returns           0   - reset operation success
+**                  -1   - reset operation failure
+**
+*******************************************************************************/
+int i2c_nfcc_reset(void *p_dev_handle, enum NfccResetType eType) {
+  int ret = -1;
+  LOG_EMVCO_TML_D("%s, VEN eType %u", __func__, eType);
+
+  if (NULL == p_dev_handle) {
+    return -1;
+  }
+
+  ret = osal_tml_ioctl((intptr_t)p_dev_handle, NFC_SET_PWR, eType, 2);
+
+  if (ret < 0) {
+    LOG_EMVCO_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  return ret;
+}
+
+int i2c_led_control(void *p_dev_handle, enum LEDControl eType) {
+  int ret = -1;
+  LOG_EMVCO_TML_D("%s, LEDControl eType %u", __func__, eType);
+
+  if (NULL == p_dev_handle) {
+    return -1;
+  }
+
+  ret = osal_tml_ioctl((intptr_t)p_dev_handle, LEDS_CONTROL, eType, 2);
+
+  if (ret < 0) {
+    LOG_EMVCO_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  return ret;
+}
+
+int i2c_nfcc_profile_switch(void *p_dev_handle, enum ProfileMode eType) {
+  int ret = -1;
+  LOG_EMVCO_TML_D("%s, LEDControl eType %u", __func__, eType);
+
+  if (NULL == p_dev_handle) {
+    return -1;
+  }
+
+  ret = osal_tml_ioctl((intptr_t)p_dev_handle, NFCC_PROFILE_SWITCH, eType, 2);
+
+  if (ret < 0) {
+    LOG_EMVCO_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  return ret;
+}
+
+int i2c_smcu_profile_switch(void *p_dev_handle, enum ProfileMode eType) {
+  int ret = -1;
+  LOG_EMVCO_TML_D("%s, LEDControl eType %u", __func__, eType);
+
+  if (NULL == p_dev_handle) {
+    return -1;
+  }
+
+  ret = osal_tml_ioctl((intptr_t)p_dev_handle, SMCU_PROFILE_SWITCH, eType, 2);
+
+  if (ret < 0) {
+    LOG_EMVCO_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         i2c_sem_post
+**
+** Description      i2c_sem_post i2c_read / write
+**
+** Parameters       none
+**
+** Returns          none
+*******************************************************************************/
+void i2c_sem_post() {
+  int sem_val = 0;
+  osal_sem_getvalue(&mTxRxSemaphore.object_handle, &sem_val);
+  if (sem_val == 0) {
+    osal_sem_post(&mTxRxSemaphore.object_handle);
+  }
+}
+
+/*******************************************************************************
+**
+** Function         i2c_sem_timed_wait
+**
+** Description      Timed sem_wait for avoiding i2c_read & write overlap
+**
+** Parameters       none
+**
+** Returns          Sem_wait return status
+*******************************************************************************/
+int i2c_sem_timed_wait() {
+  EMVCO_STATUS status = EMVCO_STATUS_FAILED;
+  long sem_timedout = 500 * 1000 * 1000;
+  int s = 0;
+  struct timespec ts;
+  clock_gettime(CLOCK_REALTIME, &ts);
+  ts.tv_sec += 0;
+  ts.tv_nsec += sem_timedout;
+  while ((s = osal_sem_timedwait(&mTxRxSemaphore.object_handle, &ts)) == -1 &&
+         errno == EINTR) {
+    continue; /* Restart if interrupted by handler */
+  }
+  if (s != -1) {
+    status = EMVCO_STATUS_SUCCESS;
+  } else if (errno == ETIMEDOUT && s == -1) {
+    LOG_EMVCO_TML_E("%s :timed out errno = 0x%x", __func__, errno);
+  }
+  return status;
+}
diff --git a/emvco_hal_impl/tml/emvco_tml_i2c.h b/emvco_hal_impl/tml/emvco_tml_i2c.h
new file mode 100644
index 0000000..a4ca086
--- /dev/null
+++ b/emvco_hal_impl/tml/emvco_tml_i2c.h
@@ -0,0 +1,207 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef _EMVCO_TML_I2C_H_
+#define _EMVCO_TML_I2C_H_
+
+#include <emvco_tml.h>
+#include <emvco_types.h>
+
+#define NFC_MAGIC 0xE9
+/*
+ * NFCC power control via ioctl
+ * NFC_SET_PWR(0): power off
+ * NFC_SET_PWR(1): power on
+ * NFC_SET_PWR(2): reset and power on with firmware download enabled
+ */
+#define NFC_SET_PWR _IOW(NFC_MAGIC, 0x01, uint32_t)
+#define NFCC_PROFILE_SWITCH _IOW(NFC_MAGIC, 0x04, uint32_t)
+#define SMCU_PROFILE_SWITCH _IOW(NFC_MAGIC, 0x05, uint32_t)
+
+/*
+ * LED control via ioctl
+ * RED_LED_OFF(0): RED LED OFF
+ * RED_LED_ON(1):  RED LED ON
+ * GREEN_LED_OFF(2): GREEN LED OFF
+ * GREEN_LED_ON(3): GREEN LED ON
+ */
+#define LEDS_CONTROL _IOW(NFC_MAGIC, 0x06, uint32_t)
+
+enum NfccResetType : uint32_t {
+  MODE_POWER_OFF = 0x00,
+  MODE_POWER_ON,
+  MODE_FW_DWNLD_WITH_VEN,
+  MODE_ISO_RST,
+  MODE_FW_DWND_HIGH,
+  MODE_POWER_RESET,
+  MODE_FW_GPIO_LOW
+};
+
+typedef enum LEDControl : uint32_t {
+  RED_LED_OFF = 0x00,
+  RED_LED_ON,
+  GREEN_LED_OFF,
+  GREEN_LED_ON
+} led_control_t;
+
+/* Profile mode type */
+enum ProfileMode : uint32_t {
+  NCI_MODE = 0,
+  EMVCO_MODE,
+};
+
+/**
+ *
+ * @brief      Closes NFCC device
+ *
+ * @param[in]       p_dev_handle - device handle
+ *
+ * @return          None
+ *
+ **/
+void i2c_close(void *p_dev_handle);
+
+/**
+ *
+ * @brief       Open and configure NFCC device and transport layer
+ *
+ * @param[in]       pConfig     - hardware information
+ * @param[in]                 pLinkHandle - device handle
+ *
+ * @return           NFC status:
+ *                  EMVCO_STATUS_SUCCESS - open_and_configure operation success
+ *                  EMVCO_STATUS_INVALID_DEVICE - device open operation failure
+ *
+ */
+EMVCO_STATUS i2c_open_and_configure(ptml_emvco_Config_t pConfig,
+                                    void **pLinkHandle);
+
+/**
+ *
+ * @brief      Reads requested number of bytes from NFCC device into
+ *                 given buffer
+ *
+ * @param[in]       p_dev_handle       - valid device handle
+ * @param[in]       p_buffer          - buffer for read data
+ * @param[in]       nNbBytesToRead   - number of bytes requested to be read
+ *
+ * @return          numRead   - number of successfully read bytes
+ *                  -1        - read operation failure
+ *
+ */
+int i2c_read(void *p_dev_handle, uint8_t *p_buffer, int nNbBytesToRead);
+
+/**
+ *
+ * @brief      Writes requested number of bytes from given buffer into
+ *                  NFCC device
+ *
+ * @param[in]       p_dev_handle       - valid device handle
+ * @param[in]       p_buffer          - buffer for read data
+ * @param[in]       nNbBytesToWrite  - number of bytes requested to be written
+ *
+ * @return           numWrote   - number of successfully written bytes
+ *                  -1         - write operation failure
+ *
+ */
+int i2c_write(void *p_dev_handle, uint8_t *p_buffer, int nNbBytesToWrite);
+
+/**
+ *
+ * @brief      Reset NFCC device, using VEN pin
+ *
+ * @param[in]       p_dev_handle     - valid device handle
+ * @param[in]       eType          - NfccResetType
+ *
+ * @return            0   - reset operation success
+ *                  -1   - reset operation failure
+ *
+ */
+int i2c_nfcc_reset(void *p_dev_handle, enum NfccResetType eType);
+
+/**
+ *
+ * @brief      Timed sem_wait for avoiding i2c_read & write overlap
+ *
+ * @param[in]       none
+ *
+ * @return          Sem_wait return status
+ ***************************************************************************/
+int i2c_sem_timed_wait();
+
+/**
+ * @brief       sem_post 2c_read / write
+ *
+ * @param[in]       none
+ *
+ * @return          none
+ */
+void i2c_sem_post();
+
+/**
+ *
+ * @brief      Reads payload of FW rsp from NFCC device into given buffer
+ *
+ * @param[in]        p_dev_handle - valid device handle
+ * @param[in]        p_buffer    - buffer for read data
+ * @param[in]        numRead    - number of bytes read by calling function
+ *
+ * @return          always returns -1
+ *
+ */
+int i2c_flush_data(void *p_dev_handle, uint8_t *p_buffer, int numRead);
+
+/**
+ *
+ * @brief      Controls the RED and GREEN LED
+ *
+ * @param[in]       p_dev_handle     - valid device handle
+ *                  eType          - led control
+ *
+ * @return           0   - reset operation success
+ *                  -1   - reset operation failure
+ *
+ */
+int i2c_led_control(void *p_dev_handle, enum LEDControl eType);
+
+/**
+ *
+ * @brief      sets the mode switch to NFCC
+ *
+ * @param[in]       p_dev_handle     - valid device handle
+ *                  eType          - mode switch control
+ *
+ * @return           0   - reset operation success
+ *                  -1   - reset operation failure
+ *
+ */
+int i2c_nfcc_profile_switch(void *p_dev_handle, enum ProfileMode eType);
+
+/**
+ *
+ * @brief       sets the mode switch to NFCC
+ *
+ * @param[in]       p_dev_handle     - valid device handle
+ *                  eType          - mode switch control
+ *
+ * @return           0   - reset operation success
+ *                  -1   - reset operation failure
+ *
+ */
+int i2c_smcu_profile_switch(void *p_dev_handle, enum ProfileMode eType);
+#endif /* _EMVCO_TML_I2C_H_*/
\ No newline at end of file
diff --git a/emvco_hal_impl/utils/emvco_config.c b/emvco_hal_impl/utils/emvco_config.c
new file mode 100644
index 0000000..39ccf61
--- /dev/null
+++ b/emvco_hal_impl/utils/emvco_config.c
@@ -0,0 +1,402 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2011-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include "emvco_config.h"
+#include "emvco_log.h"
+#include "emvco_osal_common.h"
+#include "osal_memory.h"
+#include <emvco_ncif.h>
+#include <math.h>
+#include <pthread.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+
+struct map *fp_config_map = NULL;
+uint8_t *fp_buffer = NULL;
+pthread_mutex_t config_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+struct map *config_map = NULL;
+uint8_t cmd_idle_pwr_off_cfg[] = {0x04, 0xA0, 0x44, 0x01, 0x02};
+
+static size_t readConfigFile(const char *fileName, uint8_t **p_data) {
+  FILE *fd = fopen(fileName, "rb");
+  if (fd == NULL)
+    return 0;
+  fseek(fd, 0L, SEEK_END);
+  const size_t file_size = ftell(fd);
+  rewind(fd);
+
+  if ((long)file_size < 0) {
+    LOG_EXTNS_E("%s Invalid file size file_size = %zu\n", __func__, file_size);
+    fclose(fd);
+    return 0;
+  }
+
+  fp_buffer = (uint8_t *)malloc(file_size + 1);
+  if (!fp_buffer) {
+    fclose(fd);
+    return 0;
+  }
+  size_t read = fread(fp_buffer, file_size, 1, fd);
+  fclose(fd);
+
+  if (read == 1) {
+    fp_buffer[file_size] = '\n';
+    *p_data = fp_buffer;
+    return file_size + 1;
+  }
+  return 0;
+}
+
+/**
+ * @brief Determines if a given character is a digit in the specified number
+ * base.
+ * @param c The character to be evaluated.
+ * @param base The number base to be used for evaluation (valid values are 2 to
+ * 36).
+ * @return True if the character is a digit in the specified number base, false
+ * otherwise.
+ */
+bool isDigit(char c, int base) {
+  if ('0' <= c && c <= '9')
+    return true;
+  if (base == 16) {
+    if (('A' <= c && c <= 'F') || ('a' <= c && c <= 'f'))
+      return true;
+  }
+  return false;
+}
+
+/**
+ * @brief Converts a character representation of a digit to its integer value in
+ * the specified number base.
+ *
+ * @param c The character representation of a digit.
+ * @param base The number base to use for the conversion.
+ *
+ * @return The integer value of the digit in the specified number base.
+ */
+int getDigitValue(char c, int base) {
+  if ('0' <= c && c <= '9')
+    return c - '0';
+  if (base == 16) {
+    if ('A' <= c && c <= 'F')
+      return c - 'A' + 10;
+    else if ('a' <= c && c <= 'f')
+      return c - 'a' + 10;
+  }
+  return 0;
+}
+
+/**
+ * @brief Determines if the input character is printable.
+ *
+ * @param c The character to check.
+ *
+ * @return True if the character is printable, false otherwise.
+ */
+bool isPrintable(char c) {
+  return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||
+         (c >= '0' && c <= '9') || c == '/' || c == '_' || c == '-' || c == '.';
+}
+
+bool read_config(const char *name) {
+  pthread_mutex_lock(&config_mutex);
+  fp_config_map = map_create();
+  enum {
+    BEGIN_LINE = 1,
+    TOKEN,
+    STR_VALUE,
+    NUM_VALUE,
+    BEGIN_HEX,
+    BEGIN_QUOTE,
+    END_LINE
+  };
+
+  uint8_t *p_config = NULL;
+  size_t config_size = readConfigFile(name, &p_config);
+
+  if (p_config == NULL) {
+    LOG_EXTNS_E("%s Cannot open config file %s\n", __func__, name);
+    pthread_mutex_unlock(&config_mutex);
+    return false;
+  }
+
+  char token[255] = {'\0'};
+  char strValue[255] = {'\0'};
+  int numValue = 0;
+  int i = 0;
+  int base = 0;
+  char c;
+  int bflag = 0;
+  int token_index = 0;
+  int strValue_index = 0;
+  int state = BEGIN_LINE;
+
+  for (size_t offset = 0; offset != config_size; ++offset) {
+    c = p_config[offset];
+
+    switch (state & 0xff) {
+    case BEGIN_LINE:
+      if (c == '#')
+        state = END_LINE;
+      else if (isPrintable(c)) {
+        i = 0;
+        token_index = 0;
+        strValue_index = 0;
+        osal_memset(token, '\0', sizeof(token));
+        osal_memset(strValue, '\0', sizeof(strValue));
+        strValue[0] = '\0';
+        set_string_val(false);
+        state = TOKEN;
+        token[token_index++] = c;
+      }
+      break;
+    case TOKEN:
+      if (c == '=') {
+        token[token_index] = '\0';
+        state = BEGIN_QUOTE;
+      } else if (isPrintable(c))
+        token[token_index++] = c;
+      else
+        state = END_LINE;
+      break;
+    case BEGIN_QUOTE:
+      if (c == '"') {
+        state = STR_VALUE;
+        base = 0;
+      } else if (c == '0')
+        state = BEGIN_HEX;
+      else if (isDigit(c, 10)) {
+        state = NUM_VALUE;
+        base = 10;
+        numValue = getDigitValue(c, base);
+        i = 0;
+      } else if (c == '{') {
+        state = NUM_VALUE;
+        bflag = 1;
+        base = 16;
+        i = 0;
+        set_string_val(true);
+      } else
+        state = END_LINE;
+      break;
+    case BEGIN_HEX:
+      if (c == 'x' || c == 'X') {
+        state = NUM_VALUE;
+        base = 16;
+        numValue = 0;
+        i = 0;
+        break;
+      } else if (isDigit(c, 10)) {
+        state = NUM_VALUE;
+        base = 10;
+        numValue = getDigitValue(c, base);
+        break;
+      } else if (c != '\n' && c != '\r') {
+        state = END_LINE;
+        break;
+      }
+    case NUM_VALUE:
+      if (isDigit(c, base)) {
+        numValue *= base;
+        numValue += getDigitValue(c, base);
+        ++i;
+      } else if (bflag == 1 &&
+                 (c == ' ' || c == '\r' || c == '\n' || c == '\t')) {
+        break;
+      } else if (base == 16 &&
+                 (c == ',' || c == ':' || c == '-' || c == ' ' || c == '}')) {
+        if (c == '}') {
+          bflag = 0;
+        }
+        if (i > 0) {
+          int n = (i + 1) / 2;
+          while (n-- > 0) {
+            numValue = numValue >> (n * 8);
+            unsigned char c = (numValue)&0xFF;
+            strValue[strValue_index++] = c;
+          }
+          strValue[strValue_index] = '\0';
+        }
+        set_string_val(true);
+        numValue = 0;
+        i = 0;
+      } else {
+        if (c == '\n' || c == '\r') {
+          if (bflag == 0) {
+            state = BEGIN_LINE;
+          }
+        } else {
+          if (bflag == 0) {
+            state = END_LINE;
+          }
+        }
+        if (is_string_val() && base == 16 && i > 0) {
+          int n = (i + 1) / 2;
+          while (n-- > 0) {
+            strValue[strValue_index++] = (numValue >> (n * 8)) & 0xFF;
+          }
+        }
+        if (strlen(strValue) > 0) {
+          LOG_EXTNS_D("%s map_set key:%s, value:%s \n", __func__, token,
+                      strValue);
+          map_set(fp_config_map, &token, strlen(token) + 1, &strValue,
+                  strValue_index + 1);
+        } else {
+          int num_len = floor(log10(abs(numValue))) + 1;
+          LOG_EXTNS_D("%s map_set key:%s, value:%d", __func__, token, numValue);
+          map_set(fp_config_map, &token, strlen(token) + 1, &numValue, num_len);
+        }
+        numValue = 0;
+        osal_memset(token, '\0', sizeof(token));
+        osal_memset(strValue, '\0', sizeof(strValue));
+        strValue[0] = '\0';
+      }
+      break;
+    case STR_VALUE:
+      if (c == '"') {
+        strValue[strValue_index] = '\0';
+        state = END_LINE;
+        LOG_EXTNS_D("%s map_set key:%s, value:%s \n ", __func__, token,
+                    strValue);
+        map_set(fp_config_map, &token, strlen(token) + 1, &strValue,
+                strlen(strValue) + 1);
+      } else if (isPrintable(c))
+        strValue[strValue_index++] = c;
+      break;
+    case END_LINE:
+      if (c == '\n' || c == '\r')
+        state = BEGIN_LINE;
+      break;
+    default:
+      break;
+    }
+  }
+  if (p_config != NULL) {
+    free(p_config);
+    p_config = NULL;
+  }
+  pthread_mutex_unlock(&config_mutex);
+  return true;
+}
+
+int get_byte_array_value(const char *key, char **p_value,
+                         unsigned int *value_len) {
+  pthread_mutex_lock(&config_mutex);
+  unsigned int value_size;
+  void *value = map_get_value(fp_config_map, key, strlen(key) + 1, &value_size);
+  if (value != NULL) {
+    *p_value = osal_malloc(value_size);
+    if (!(*p_value)) {
+      LOG_EXTNS_E("%s: osal_malloc failed for key %s", __func__, key);
+      pthread_mutex_unlock(&config_mutex);
+      return FALSE;
+    }
+    memcpy(*p_value, value, value_size);
+    *value_len = value_size - 1;
+    pthread_mutex_unlock(&config_mutex);
+    return TRUE;
+  } else {
+    LOG_EXTNS_E("%s: key %s not found in configuration map", __func__, key);
+    pthread_mutex_unlock(&config_mutex);
+    return FALSE;
+  }
+}
+
+int get_byte_value(char *key, unsigned long *p_value, unsigned int *value_len) {
+  pthread_mutex_lock(&config_mutex);
+  unsigned long *num_value = (unsigned long *)map_get_value(
+      fp_config_map, key, strlen(key) + 1, value_len);
+  if (num_value != NULL) {
+    *p_value = *num_value;
+    pthread_mutex_unlock(&config_mutex);
+    return TRUE;
+  } else {
+    LOG_EXTNS_E("%s: Key:%s not found in configuration map\n", __func__, key);
+    pthread_mutex_unlock(&config_mutex);
+    return FALSE;
+  }
+}
+
+struct map *get_config_map(void) {
+  if (config_map == NULL) {
+    LOG_EXTNS_E("%s: config_map is NULL calling map_create \n", __func__);
+    config_map = map_create();
+  }
+  return config_map;
+}
+
+static void send_poll_profile_sel_set_config() {
+  LOG_EXTNS_E("%s:  \n", __func__);
+  int set_config_retry_cnt = 0;
+  uint8_t *p_cmd_idle_pwr_off_cfg = (uint8_t *)cmd_idle_pwr_off_cfg;
+  do {
+    if (EMVCO_STATUS_SUCCESS ==
+        send_core_set_config(&p_cmd_idle_pwr_off_cfg[1],
+                             p_cmd_idle_pwr_off_cfg[0])) {
+      break;
+    } else {
+      LOG_EMVCOHAL_E("NCI_SET_CONFIG_PROFILE_SELECTION: Failed");
+      ++set_config_retry_cnt;
+    }
+  } while (set_config_retry_cnt < 3);
+}
+
+void send_dynamic_set_config(void) {
+  struct map *m = get_config_map();
+  struct map_node *node = m->head;
+
+  while (node != NULL) {
+    int key = atoi((char *)node->key);
+    const int8_t *value = (int8_t *)node->value;
+    LOG_EXTNS_E("%s: POLL_PROFILE_SEL str_key:%s, value:%d \n", __func__,
+                (char *)node->key, *value);
+    switch (key) {
+    case POLL_PROFILE_SEL:
+      cmd_idle_pwr_off_cfg[4] = *value;
+      break;
+    default:
+      break;
+    }
+    node = node->next;
+  }
+
+  send_poll_profile_sel_set_config();
+
+  LOG_EXTNS_E("%s: end \n", __func__);
+}
\ No newline at end of file
diff --git a/emvco_hal_impl/utils/emvco_config.h b/emvco_hal_impl/utils/emvco_config.h
new file mode 100644
index 0000000..ce7f600
--- /dev/null
+++ b/emvco_hal_impl/utils/emvco_config.h
@@ -0,0 +1,161 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 1999-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef _EMVCO_CONFIG_H_
+#define _EMVCO_CONFIG_H_
+
+/** \addtogroup EMVCO_STACK_UTILITY_API_INTERFACE
+ *  @brief interface to read configuration values on stored on config file. Also
+ * provides Interface for getting the chip type, linked list and Semphore
+ * implementation.
+ *  @{
+ */
+
+#include "map.h"
+#include <emvco_status.h>
+#include <stdbool.h>
+#include <stdint.h>
+
+extern uint8_t cmd_idle_pwr_off_cfg[];
+
+struct map *fp_config_map;
+
+/**
+ * @brief Reads the configuration from a file.
+ *
+ * This function reads the configuration from a file with the given name and
+ * updates the internal configuration.
+ *
+ * @param[in] name The name of the configuration file.
+ *
+ * @return True if the configuration was successfully read, false otherwise.
+ */
+bool read_config(const char *name);
+
+/**
+ * @brief Retrieves an unsigned long value associated with a key in the map.
+ *
+ * @param key Pointer to the key to search for in the map.
+ * @param p_value Pointer to a variable that will hold the retrieved value.
+ * @param value_len Pointer to a variable that will hold the length of the
+ * retrieved value.
+ *
+ * @return TRUE if the key is found in the map, FALSE otherwise.
+ */
+int get_byte_value(char *key, unsigned long *p_value, unsigned int *value_len);
+
+/**
+ * @brief Retrieves the byte array value of the given key from the map
+ *
+ * @note Caller have to free the memory of p_value after usage.
+ *
+ * @param[in] key Key to retrieve the value of
+ * @param[out] p_value Pointer to store the retrieved value
+ * @param[out] value_len Length of the retrieved value
+ *
+ * @return Returns `TRUE` if the value was successfully retrieved, `FALSE`
+ * otherwise
+ */
+int get_byte_array_value(const char *key, char **p_value,
+                         unsigned int *value_len);
+
+/**
+ * @brief Determines if a given character is a digit in the specified number
+ * base.
+ * @param c The character to be evaluated.
+ * @param base The number base to be used for evaluation (valid values are 2 to
+ * 36).
+ * @return True if the character is a digit in the specified number base, false
+ * otherwise.
+ */
+bool isDigit(char c, int base);
+
+/**
+ * @brief Converts a character representation of a digit to its integer value in
+ * the specified number base.
+ *
+ * @param c The character representation of a digit.
+ * @param base The number base to use for the conversion.
+ *
+ * @return The integer value of the digit in the specified number base.
+ */
+int getDigitValue(char c, int base);
+
+/**
+ * @brief Determines if the input character is printable.
+ *
+ * @param c The character to check.
+ *
+ * @return True if the character is printable, false otherwise.
+ */
+bool isPrintable(char c);
+
+/**
+ * @brief Returns a pointer to the configuration map.
+ *
+ * This function returns a pointer to the configuration map, which is a `map`
+ * struct containing key-value pairs of configuration data.
+ *
+ * @return A pointer to the configuration map.
+ * @retval NULL If the configuration map is not found or cannot be accessed.
+ */
+struct map *get_config_map(void);
+
+/**
+ * @brief Sends the list of set configuration to NFCC which was saved
+ *        through setConfig API.
+ *
+ * @param void
+ * @return void.
+ */
+void send_dynamic_set_config(void);
+
+/* default configuration */
+#define emvco_hal_config_path "/vendor/etc/libemvco-nxp.conf"
+
+#ifndef uint8_t
+typedef unsigned char uint8_t;
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef TRUE
+#define TRUE (!FALSE)
+#endif
+/** @}*/
+#endif //_EMVCO_CONFIG_H_
\ No newline at end of file
diff --git a/emvco_hal_impl/utils/emvco_util.c b/emvco_hal_impl/utils/emvco_util.c
new file mode 100644
index 0000000..2608b89
--- /dev/null
+++ b/emvco_hal_impl/utils/emvco_util.c
@@ -0,0 +1,460 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#include <errno.h>
+#include <log/log.h>
+#include <pthread.h>
+
+#include "osal_memory.h"
+#include "osal_thread.h"
+#include <emvco_dm.h>
+#include <emvco_log.h>
+#include <emvco_util.h>
+
+extern uint8_t nfcdep_detected;
+/*********************** Link list functions **********************************/
+
+/*******************************************************************************
+**
+** Function         listInit
+**
+** Description      List initialization
+**
+** Returns          1, if list initialized, 0 otherwise
+**
+*******************************************************************************/
+int listInit(struct list_head *pList) {
+  pList->p_first = NULL;
+  if (osal_mutex_lock(&pList->mutex) != 0) {
+    LOG_EMVCOHAL_E("Mutex creation failed (errno=0x%08x)", errno);
+    return 0;
+  }
+
+  return 1;
+}
+
+/*******************************************************************************
+**
+** Function         listDestroy
+**
+** Description      List destruction
+**
+** Returns          1, if list destroyed, 0 if failed
+**
+*******************************************************************************/
+int listDestroy(struct list_head *pList) {
+  int bListNotEmpty = 1;
+  while (bListNotEmpty) {
+    bListNotEmpty = listGetAndRemoveNext(pList, NULL);
+  }
+
+  if (osal_mutex_destroy(&pList->mutex) != 0) {
+    LOG_EMVCOHAL_E("Mutex destruction failed (errno=0x%08x)", errno);
+    return 0;
+  }
+
+  return 1;
+}
+
+/*******************************************************************************
+**
+** Function         listAdd
+**
+** Description      Add a node to the list
+**
+** Returns          1, if added, 0 if otherwise
+**
+*******************************************************************************/
+int listAdd(struct list_head *pList, void *p_data) {
+  struct list_node *pNode;
+  struct list_node *pLastNode;
+  int result;
+
+  /* Create node */
+  pNode = (struct list_node *)osal_malloc(sizeof(struct list_node));
+  if (pNode == NULL) {
+    result = 0;
+    LOG_EMVCOHAL_E("Failed to osal_malloc");
+    goto clean_and_return;
+  }
+  pNode->p_data = p_data;
+  pNode->p_next = NULL;
+  osal_mutex_init(&pList->mutex);
+
+  /* Add the node to the list */
+  if (pList->p_first == NULL) {
+    /* Set the node as the head */
+    pList->p_first = pNode;
+  } else {
+    /* Seek to the end of the list */
+    pLastNode = pList->p_first;
+    while (pLastNode->p_next != NULL) {
+      pLastNode = pLastNode->p_next;
+    }
+
+    /* Add the node to the current list */
+    pLastNode->p_next = pNode;
+  }
+
+  result = 1;
+
+clean_and_return:
+  return result;
+}
+
+/*******************************************************************************
+**
+** Function         listRemove
+**
+** Description      Remove node from the list
+**
+** Returns          1, if removed, 0 if otherwise
+**
+*******************************************************************************/
+int listRemove(struct list_head *pList, void *p_data) {
+  struct list_node *pNode;
+  struct list_node *pRemovedNode;
+  int result;
+
+  osal_mutex_lock(&pList->mutex);
+
+  if (pList->p_first == NULL) {
+    /* Empty list */
+    LOG_EMVCOHAL_D("Failed to deallocate (list empty)");
+    result = 0;
+    goto clean_and_return;
+  }
+
+  pNode = pList->p_first;
+  if (pList->p_first->p_data == p_data) {
+    /* Get the removed node */
+    pRemovedNode = pNode;
+
+    /* Remove the first node */
+    pList->p_first = pList->p_first->p_next;
+  } else {
+    while (pNode->p_next != NULL) {
+      if (pNode->p_next->p_data == p_data) {
+        /* Node found ! */
+        break;
+      }
+      pNode = pNode->p_next;
+    }
+
+    if (pNode->p_next == NULL) {
+      /* Node not found */
+      result = 0;
+      LOG_EMVCOHAL_E("Failed to deallocate (not found %8p)", p_data);
+      goto clean_and_return;
+    }
+
+    /* Get the removed node */
+    pRemovedNode = pNode->p_next;
+
+    /* Remove the node from the list */
+    pNode->p_next = pNode->p_next->p_next;
+  }
+
+  /* Deallocate the node */
+  osal_free(pRemovedNode);
+
+  result = 1;
+
+clean_and_return:
+  osal_mutex_unlock(&pList->mutex);
+  return result;
+}
+
+/*******************************************************************************
+**
+** Function         listGetAndRemoveNext
+**
+** Description      Get next node on the list and remove it
+**
+** Returns          1, if successful, 0 if otherwise
+**
+*******************************************************************************/
+int listGetAndRemoveNext(struct list_head *pList, void **pp_data) {
+  struct list_node *pNode;
+  int result;
+
+  osal_mutex_lock(&pList->mutex);
+
+  if (pList->p_first == NULL) {
+    /* Empty list */
+    LOG_EMVCOHAL_D("Failed to deallocate (list empty)");
+    result = 0;
+    goto clean_and_return;
+  }
+
+  /* Work on the first node */
+  pNode = pList->p_first;
+
+  /* Return the data */
+  if (pp_data != NULL) {
+    *pp_data = pNode->p_data;
+  }
+
+  /* Remove and deallocate the node */
+  pList->p_first = pNode->p_next;
+  osal_free(pNode);
+
+  result = 1;
+
+clean_and_return:
+  listDump(pList);
+  osal_mutex_unlock(&pList->mutex);
+  return result;
+}
+
+/*******************************************************************************
+**
+** Function         listDump
+**
+** Description      Dump list information
+**
+** Returns          None
+**
+*******************************************************************************/
+void listDump(struct list_head *pList) {
+  struct list_node *pNode = pList->p_first;
+
+  LOG_EMVCOHAL_D("Node dump:");
+  while (pNode != NULL) {
+    LOG_EMVCOHAL_D("- %8p (%8p)", pNode, pNode->p_data);
+    pNode = pNode->p_next;
+  }
+
+  return;
+}
+
+/* END Linked list source code */
+
+/****************** Semaphore and mutex helper functions **********************/
+
+static phNxpNciHal_Monitor_t *nxpncihal_monitor = NULL;
+
+/*******************************************************************************
+**
+** Function         init_monitor
+**
+** Description      Initialize the semaphore monitor
+**
+** Returns          Pointer to monitor, otherwise NULL if failed
+**
+*******************************************************************************/
+phNxpNciHal_Monitor_t *init_monitor(void) {
+  LOG_EMVCOHAL_D("Entering init_monitor");
+
+  if (nxpncihal_monitor == NULL) {
+    nxpncihal_monitor =
+        (phNxpNciHal_Monitor_t *)osal_malloc(sizeof(phNxpNciHal_Monitor_t));
+  }
+
+  if (nxpncihal_monitor != NULL) {
+    memset(nxpncihal_monitor, 0x00, sizeof(phNxpNciHal_Monitor_t));
+
+    if (osal_mutex_init(&nxpncihal_monitor->reentrance_mutex) != 0) {
+      LOG_EMVCOHAL_E("reentrance_mutex creation returned 0x%08x", errno);
+      goto clean_and_return;
+    }
+
+    if (osal_mutex_init(&nxpncihal_monitor->concurrency_mutex) != 0) {
+      LOG_EMVCOHAL_E("concurrency_mutex creation returned 0x%08x", errno);
+      osal_mutex_destroy(&nxpncihal_monitor->reentrance_mutex);
+      goto clean_and_return;
+    }
+
+    if (listInit(&nxpncihal_monitor->sem_list) != 1) {
+      LOG_EMVCOHAL_E("Semaphore List creation failed");
+      osal_mutex_destroy(&nxpncihal_monitor->concurrency_mutex);
+      osal_mutex_destroy(&nxpncihal_monitor->reentrance_mutex);
+      goto clean_and_return;
+    }
+  } else {
+    LOG_EMVCOHAL_E("nxphal_monitor creation failed");
+    goto clean_and_return;
+  }
+
+  LOG_EMVCOHAL_D("Returning with SUCCESS");
+
+  return nxpncihal_monitor;
+
+clean_and_return:
+  LOG_EMVCOHAL_D("Returning with FAILURE");
+
+  if (nxpncihal_monitor != NULL) {
+    osal_free(nxpncihal_monitor);
+    nxpncihal_monitor = NULL;
+  }
+
+  return NULL;
+}
+
+/*******************************************************************************
+**
+** Function         cleanup_monitor
+**
+** Description      Clean up semaphore monitor
+**
+** Returns          None
+**
+*******************************************************************************/
+void cleanup_monitor(void) {
+  if (nxpncihal_monitor != NULL) {
+    osal_mutex_destroy(&nxpncihal_monitor->concurrency_mutex);
+    REENTRANCE_UNLOCK();
+    osal_mutex_destroy(&nxpncihal_monitor->reentrance_mutex);
+    releaseall_cb_data();
+    listDestroy(&nxpncihal_monitor->sem_list);
+  }
+
+  osal_free(nxpncihal_monitor);
+  nxpncihal_monitor = NULL;
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         get_monitor
+**
+** Description      Get monitor
+**
+** Returns          Pointer to monitor
+**
+*******************************************************************************/
+phNxpNciHal_Monitor_t *get_monitor(void) {
+  if (nxpncihal_monitor == NULL) {
+    LOG_EMVCOHAL_E("nxpncihal_monitor is null");
+  }
+  return nxpncihal_monitor;
+}
+
+/* Initialize the callback data */
+EMVCO_STATUS init_cb_data(nci_hal_sem *pCallbackData, void *p_context) {
+  /* Create semaphore */
+  if (sem_init(&pCallbackData->sem, 0, 0) == -1) {
+    LOG_EMVCOHAL_E("Semaphore creation failed (errno=0x%08x)", errno);
+    return EMVCO_STATUS_FAILED;
+  }
+
+  /* Set default status value */
+  pCallbackData->status = EMVCO_STATUS_FAILED;
+
+  /* Copy the context */
+  pCallbackData->p_context = p_context;
+
+  /* Add to active semaphore list */
+  if (listAdd(&get_monitor()->sem_list, pCallbackData) != 1) {
+    LOG_EMVCOHAL_E("Failed to add the semaphore to the list");
+  }
+
+  return EMVCO_STATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         cleanup_cb_data
+**
+** Description      Clean up callback data
+**
+** Returns          None
+**
+*******************************************************************************/
+void cleanup_cb_data(nci_hal_sem *pCallbackData) {
+  /* Destroy semaphore */
+  if (osal_sem_destroy(&pCallbackData->sem)) {
+    LOG_EMVCOHAL_E("cleanup_cb_data: Failed to destroy semaphore "
+                   "(errno=0x%08x)",
+                   errno);
+  }
+
+  /* Remove from active semaphore list */
+  if (listRemove(&get_monitor()->sem_list, pCallbackData) != 1) {
+    LOG_EMVCOHAL_E("cleanup_cb_data: Failed to remove semaphore from the "
+                   "list");
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         releaseall_cb_data
+**
+** Description      Release all callback data
+**
+** Returns          None
+**
+*******************************************************************************/
+void releaseall_cb_data(void) {
+  nci_hal_sem *pCallbackData;
+
+  while (
+      listGetAndRemoveNext(&get_monitor()->sem_list, (void **)&pCallbackData)) {
+    pCallbackData->status = EMVCO_STATUS_FAILED;
+    osal_sem_post(&pCallbackData->sem);
+  }
+
+  return;
+}
+
+/* END Semaphore and mutex helper functions */
+
+/**************************** Other functions *********************************/
+
+/*******************************************************************************
+**
+** Function         print_packet
+**
+** Description      Print packet
+**
+** Returns          None
+**
+*******************************************************************************/
+void print_packet(const char *pString, const uint8_t *p_data, uint16_t len) {
+  uint32_t i;
+  char print_buffer[len * 3 + 1];
+
+  memset(print_buffer, 0, sizeof(print_buffer));
+  for (i = 0; i < len; i++) {
+    snprintf(&print_buffer[i * 2], 3, "%02X", p_data[i]);
+  }
+  if (0 == memcmp(pString, "SEND", 0x04)) {
+    LOG_EMVCOX_D("len = %3d > %s", len, print_buffer);
+  } else if (0 == memcmp(pString, "RECV", 0x04)) {
+    LOG_EMVCOR_D("len = %3d > %s", len, print_buffer);
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         emergency_recovery
+**
+** Description      Emergency recovery in case of no other way out
+**
+** Returns          None
+**
+*******************************************************************************/
+
+void emergency_recovery(void) {
+  LOG_EMVCOHAL_E("%s: abort()", __func__);
+  abort();
+}
\ No newline at end of file
diff --git a/emvco_hal_impl/utils/emvco_util.h b/emvco_hal_impl/utils/emvco_util.h
new file mode 100644
index 0000000..7febc59
--- /dev/null
+++ b/emvco_hal_impl/utils/emvco_util.h
@@ -0,0 +1,103 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _EMVCO_UTILS_H_
+#define _EMVCO_UTILS_H_
+
+#include "osal_thread.h"
+#include <assert.h>
+#include <emvco_status.h>
+#include <pthread.h>
+#include <semaphore.h>
+/********************* Definitions and structures *****************************/
+
+/* List structures */
+struct list_node {
+  void *p_data;
+  struct list_node *p_next;
+};
+
+struct list_head {
+  struct list_node *p_first;
+  pthread_mutex_t mutex;
+};
+
+/* Semaphore handling structure */
+typedef struct nci_hal_sem_t {
+  /* Semaphore used to wait for callback */
+  sem_t sem;
+
+  /* Used to store the status sent by the callback */
+  EMVCO_STATUS status;
+
+  /* Used to provide a local context to the callback */
+  void *p_context;
+
+} nci_hal_sem;
+
+/* Semaphore helper macros */
+#define SEM_WAIT(cb_data) osal_sem_wait(&((cb_data).sem))
+#define SEM_POST(p_cb_data) osal_sem_post(&((p_cb_data)->sem))
+
+/* Semaphore and mutex monitor */
+typedef struct phNxpNciHal_Monitor {
+  /* Mutex protecting native library against reentrance */
+  pthread_mutex_t reentrance_mutex;
+
+  /* Mutex protecting native library against concurrency */
+  pthread_mutex_t concurrency_mutex;
+
+  /* List used to track pending semaphores waiting for callback */
+  struct list_head sem_list;
+
+} phNxpNciHal_Monitor_t;
+
+/************************ Exposed functions ***********************************/
+/* List functions */
+int listInit(struct list_head *pList);
+int listDestroy(struct list_head *pList);
+int listAdd(struct list_head *pList, void *p_data);
+int listRemove(struct list_head *pList, void *p_data);
+int listGetAndRemoveNext(struct list_head *pList, void **pp_data);
+void listDump(struct list_head *pList);
+
+/* NXP NCI HAL utility functions */
+phNxpNciHal_Monitor_t *init_monitor(void);
+void cleanup_monitor(void);
+phNxpNciHal_Monitor_t *get_monitor(void);
+EMVCO_STATUS init_cb_data(nci_hal_sem *pCallbackData, void *p_context);
+void cleanup_cb_data(nci_hal_sem *pCallbackData);
+void releaseall_cb_data(void);
+void print_packet(const char *pString, const uint8_t *p_data, uint16_t len);
+void emergency_recovery(void);
+
+/* Lock unlock helper macros */
+/* Lock unlock helper macros */
+#define REENTRANCE_LOCK()                                                      \
+  if (get_monitor())                                                           \
+  pthread_mutex_lock(&get_monitor()->reentrance_mutex)
+#define REENTRANCE_UNLOCK()                                                    \
+  if (get_monitor())                                                           \
+  pthread_mutex_unlock(&get_monitor()->reentrance_mutex)
+#define CONCURRENCY_LOCK()                                                     \
+  if (get_monitor())                                                           \
+  pthread_mutex_lock(&get_monitor()->concurrency_mutex)
+#define CONCURRENCY_UNLOCK()                                                   \
+  if (get_monitor())                                                           \
+  pthread_mutex_unlock(&get_monitor()->concurrency_mutex)
+
+#endif /* _EMVCO_UTILS_H_ */
diff --git a/emvco_hal_impl/utils/map.c b/emvco_hal_impl/utils/map.c
new file mode 100644
index 0000000..6279abc
--- /dev/null
+++ b/emvco_hal_impl/utils/map.c
@@ -0,0 +1,96 @@
+/******************************************************************************
+ *
+ *  Copyright 2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include "map.h"
+#include "emvco_log.h"
+#include "osal_memory.h"
+#include <stdlib.h>
+#include <string.h>
+
+struct map *map_create(void) {
+  struct map *m = (struct map *)osal_malloc(sizeof(struct map));
+  m->head = NULL;
+  m->size = 0;
+  return m;
+}
+
+void map_set(struct map *m, const void *key, int key_size, const void *value,
+             int value_size) {
+  if (!m || !key || key_size <= 0) {
+    return;
+  }
+  struct map_node *node = m->head;
+  while (node != NULL) {
+    if (key_size == node->key_size && memcmp(node->key, key, key_size) == 0) {
+      if (value_size != node->value_size) {
+        void *realloc_result = realloc(node->value, value_size);
+        if (realloc_result == NULL) {
+          return;
+        }
+        node->value = realloc_result;
+        node->value_size = value_size;
+      }
+      memcpy(node->value, value, value_size);
+      return;
+    }
+    node = node->next;
+  }
+
+  struct map_node *new_node =
+      (struct map_node *)osal_malloc(sizeof(struct map_node));
+  if (new_node == NULL) {
+    return;
+  }
+  new_node->key = osal_malloc(key_size);
+  if (new_node->key == NULL) {
+    free(new_node);
+    return;
+  }
+  memcpy(new_node->key, key, key_size);
+  new_node->key_size = key_size;
+  new_node->value = osal_malloc(value_size);
+  if (new_node->value == NULL) {
+    free(new_node->key);
+    free(new_node);
+    return;
+  }
+  memcpy(new_node->value, value, value_size);
+  new_node->value_size = value_size;
+  new_node->next = m->head;
+  m->head = new_node;
+  m->size++;
+}
+
+void *map_get_value(const struct map *m, const void *key, int key_size,
+                    unsigned int *value_size) {
+  if (!m || !key || key_size <= 0) {
+    return NULL;
+  }
+  struct map_node *node = m->head;
+  while (node != NULL) {
+    if (key_size == node->key_size && memcmp(node->key, key, key_size) == 0) {
+      *value_size = node->value_size;
+      return node->value;
+    }
+    node = node->next;
+  }
+  return NULL;
+}
+
+void set_string_val(bool value) { string_val = value; }
+bool is_string_val() { return string_val; }
\ No newline at end of file
diff --git a/emvco_hal_impl/utils/map.h b/emvco_hal_impl/utils/map.h
new file mode 100644
index 0000000..2719048
--- /dev/null
+++ b/emvco_hal_impl/utils/map.h
@@ -0,0 +1,86 @@
+/******************************************************************************
+ *
+ *  Copyright 2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef MAP_H
+#define MAP_H
+/** \addtogroup EMVCO_STACK_UTILITY_API_INTERFACE
+ *  @brief interface to read configuration values on stored on config file. Also
+ * provides Interface for getting the chip type, linked list and Semphore
+ * implementation.
+ *  @{
+ */
+#include <stdbool.h>
+struct map_node {
+  void *key;
+  void *value;
+  int key_size;
+  int value_size;
+  struct map_node *next;
+};
+
+struct map {
+  struct map_node *head;
+  int size;
+};
+
+bool string_val;
+
+/**
+ * @brief Sets the value of string_val
+ *
+ * @param value The value to be set for string_val
+ */
+void set_string_val(bool);
+
+/**
+ * @brief Returns the current value of string_val
+ *
+ * @return The current value of string_val
+ */
+bool is_string_val();
+
+/**
+ * @brief Creates a new map and returns a pointer to it.
+ * @return A pointer to the newly created map.
+ */
+struct map *map_create(void);
+/**
+ * @brief Sets a key-value pair in the map.
+ * If the key already exists, its value will be updated.
+ * @param m The map to set the key-value pair in.
+ * @param key The key.
+ * @param key_size The size of the key.
+ * @param value The value.
+ * @param value_size The size of the value.
+ */
+void map_set(struct map *m, const void *key, int key_size, const void *value,
+             int value_size);
+/**
+ * @brief Gets the value associated with a key from the map.
+ * @param m The map to retrieve the value from.
+ * @param key The key.
+ * @param key_size The size of the key.
+ * @param value_size A pointer to the location where the size of the value
+ * should be stored.
+ * @return The value associated with the key.
+ */
+void *map_get_value(const struct map *m, const void *key, int key_size,
+                    unsigned int *value_size);
+
+/** @}*/
+#endif /* MAP_H */
diff --git a/emvco_hal_impl/utils/sparse_crc32.c b/emvco_hal_impl/utils/sparse_crc32.c
new file mode 100644
index 0000000..29192b8
--- /dev/null
+++ b/emvco_hal_impl/utils/sparse_crc32.c
@@ -0,0 +1,120 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/*
+ *  First, the polynomial itself and its table of feedback terms.  The
+ *  polynomial is
+ *  X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0
+ *
+ *  Note that we take it "backwards" and put the highest-order term in
+ *  the lowest-order bit.  The X^32 term is "implied"; the LSB is the
+ *  X^31 term, etc.  The X^0 term (usually shown as "+1") results in
+ *  the MSB being 1
+ *
+ *  Note that the usual hardware shift register implementation, which
+ *  is what we're using (we're merely optimizing it by doing eight-bit
+ *  chunks at a time) shifts bits into the lowest-order term.  In our
+ *  implementation, that means shifting towards the right.  Why do we
+ *  do it this way?  Because the calculated CRC must be transmitted in
+ *  order from highest-order term to lowest-order term.  UARTs transmit
+ *  characters in order from LSB to MSB.  By storing the CRC this way
+ *  we hand it to the UART in the order low-byte to high-byte; the UART
+ *  sends each low-bit to hight-bit; and the result is transmission bit
+ *  by bit from highest- to lowest-order term without requiring any bit
+ *  shuffling on our part.  Reception works similarly
+ *
+ *  The feedback terms table consists of 256, 32-bit entries.  Notes
+ *
+ *      The table can be generated at runtime if desired; code to do so
+ *      is shown later.  It might not be obvious, but the feedback
+ *      terms simply represent the results of eight shift/xor opera
+ *      tions for all combinations of data and CRC register values
+ *
+ *      The values must be right-shifted by eight bits by the "updcrc
+ *      logic; the shift must be unsigned (bring in zeroes).  On some
+ *      hardware you could probably optimize the shift in assembler by
+ *      using byte-swap instructions
+ *      polynomial $edb88320
+ *
+ *
+ * CRC32 code derived from work by Gary S. Brown.
+ */
+
+/* Code taken from FreeBSD 8 */
+#include <stdint.h>
+
+static uint32_t crc32_tab[] = {
+    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
+    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
+    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
+    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
+    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
+    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
+    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
+    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
+    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
+    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
+    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
+    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
+    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
+    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
+    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
+    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
+    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
+    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
+    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
+    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
+    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
+    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
+    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
+    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
+    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
+    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
+    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
+    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
+    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
+    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
+    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
+    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
+    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
+    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
+    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
+    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
+    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
+    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
+    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
+    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d};
+
+/*
+ * A function that calculates the CRC-32 based on the table above is
+ * given below for documentation purposes. An equivalent implementation
+ * of this function that's actually used in the kernel can be found
+ * in sys/libkern.h, where it can be inlined.
+ */
+
+uint32_t sparse_crc32(uint32_t crc_in, const void *buf, int size) {
+  const uint8_t *p = (const uint8_t *)buf;
+  uint32_t crc;
+
+  crc = crc_in ^ ~0U;
+  while (size--)
+    crc = crc32_tab[(crc ^ *p++) & 0xFF] ^ (crc >> 8);
+  return crc ^ ~0U;
+}
diff --git a/emvco_hal_impl/utils/sparse_crc32.h b/emvco_hal_impl/utils/sparse_crc32.h
new file mode 100644
index 0000000..e40c408
--- /dev/null
+++ b/emvco_hal_impl/utils/sparse_crc32.h
@@ -0,0 +1,26 @@
+/******************************************************************************
+ *
+ *  Copyright 2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef _LIBSPARSE_SPARSE_CRC32_H_
+#define _LIBSPARSE_SPARSE_CRC32_H_
+
+#include <stdint.h>
+
+uint32_t sparse_crc32(uint32_t crc, const void *buf, int size);
+
+#endif
diff --git a/emvco_loopback_compliance_test/Android.bp b/emvco_loopback_compliance_test/Android.bp
new file mode 100644
index 0000000..c246c76
--- /dev/null
+++ b/emvco_loopback_compliance_test/Android.bp
@@ -0,0 +1,25 @@
+cc_test {
+    name: "EMVCoAidlHalComplianceTest",
+    defaults: [
+        "VtsHalTargetTestDefaults",
+        "use_libaidlvintf_gtest_helper_static",
+    ],
+    srcs: [
+        "EMVCoAidlHalComplianceTest.cpp",
+    ],
+    shared_libs: [
+        "libbinder",
+        "libbinder_ndk",
+    ],
+    static_libs: [
+        "android.hardware.emvco-V1-ndk",
+        "VtsHalHidlTargetTestBase",
+    ],
+    test_suites: [
+        "general-tests",
+        "vts",
+    ],
+    cppflags: [
+        "-fexceptions",
+    ],
+}
diff --git a/emvco_loopback_compliance_test/EMVCoAidlHalComplianceTest.cpp b/emvco_loopback_compliance_test/EMVCoAidlHalComplianceTest.cpp
new file mode 100755
index 0000000..320df68
--- /dev/null
+++ b/emvco_loopback_compliance_test/EMVCoAidlHalComplianceTest.cpp
@@ -0,0 +1,409 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "emvco_compliance_test"
+
+#include <aidl/Gtest.h>
+#include <aidl/android/hardware/emvco/BnEmvco.h>
+#include <aidl/android/hardware/emvco/BnEmvcoClientCallback.h>
+#include <aidl/android/hardware/emvco/ConfigType.h>
+#include <aidl/android/hardware/emvco/IEmvco.h>
+#include <aidl/android/hardware/emvco/IEmvcoContactlessCard.h>
+#include <aidl/android/hardware/emvco/IEmvcoProfileDiscovery.h>
+#include <android-base/stringprintf.h>
+#include <android/binder_auto_utils.h>
+#include <android/binder_enums.h>
+#include <android/binder_interface_utils.h>
+#include <android/binder_manager.h>
+#include <android/binder_process.h>
+#include <chrono>
+#include <future>
+#include <log/log.h>
+
+using aidl::android::hardware::emvco::ConfigType;
+using aidl::android::hardware::emvco::DeactivationType;
+using aidl::android::hardware::emvco::EmvcoEvent;
+using aidl::android::hardware::emvco::EmvcoStatus;
+using aidl::android::hardware::emvco::IEmvco;
+using aidl::android::hardware::emvco::IEmvcoClientCallback;
+using aidl::android::hardware::emvco::IEmvcoContactlessCard;
+using aidl::android::hardware::emvco::IEmvcoProfileDiscovery;
+using aidl::android::hardware::emvco::LedControl;
+using ndk::SpAIBinder;
+
+#define MIN_VALID_DATA_SIZE 9
+#define NCI_HEADER_SIZE 3
+#define NCI_SEND_PPSE                                                          \
+  {                                                                            \
+    0x00, 0xA4, 0x04, 0x00, 0x0E, 0x32, 0x50, 0x41, 0x59, 0x2E, 0x53, 0x59,    \
+        0x53, 0x2E, 0x44, 0x44, 0x46, 0x30, 0x31, 0x00                         \
+  }
+#define DEACTIVATE_IDLE_TIMEOUT 15000
+#define MIN_LED_GLOW_DURATION 500
+#define MAX_LED_GLOW_DURATION 3000
+#define EMVCO_POLLING_STARTED_EVT 4
+
+const std::vector<uint8_t> nci_send_ppse = NCI_SEND_PPSE;
+::ndk::ScopedAIBinder_DeathRecipient mDeathRecipient;
+static std::promise<void> psse_cb_promise_;
+static std::future<void> psse_cb_future_ = psse_cb_promise_.get_future();
+unsigned long long start_ts_, end_ts_;
+
+static std::vector<uint8_t> nci_send_loopback_;
+static volatile bool is_aborted_ = false;
+static volatile bool is_removal_procedure = false;
+static volatile uint8_t pollingConfiguration = 0;
+// Set the led glow duration to 500 milli second by default
+static volatile uint32_t led_glow_duration = 500;
+
+const int NFC_A_PASSIVE_POLL_MODE = 0;
+const int NFC_B_PASSIVE_POLL_MODE = 1;
+const int NFC_F_PASSIVE_POLL_MODE = 2;
+const int NFC_VAS_PASSIVE_POLL_MODE = 3;
+
+const int NFC_AB_PASSIVE_POLL_MODE_SUPPORTED = 3;
+const int NFC_F_PASSIVE_POLL_MODE_SUPPORTED = 4;
+const int NFC_ABF_PASSIVE_POLL_MODE_SUPPORTED = 7;
+const int NFC_ABVAS_PASSIVE_POLL_MODE_SUPPORTED = 11;
+const int NFC_ABFVAS_PASSIVE_POLL_MODE_SUPPORTED = 15;
+const int pollProfileSelectionVal = 0b00000010;
+int config_len = 0;
+
+std::mutex data_mutex_;
+std::mutex led_mutex_;
+int32_t aidl_return;
+
+std::shared_ptr<IEmvco> nxp_emvco_service_;
+std::shared_ptr<IEmvcoContactlessCard> nxp_emvco_cl_service_;
+std::shared_ptr<IEmvcoProfileDiscovery> nxp_emvco_prof_disc_service_;
+
+static void send(std::shared_ptr<IEmvcoContactlessCard> nxp_emvco_cl_service_,
+                 const std::vector<uint8_t> data, int32_t aidl_return,
+                 std::string dataTag);
+
+void setLedState(LedControl ledControl) {
+  const std::lock_guard<std::mutex> lock(led_mutex_);
+  aidl::android::hardware::emvco::EmvcoStatus _aidl_return;
+  nxp_emvco_prof_disc_service_->setLed(ledControl, &_aidl_return);
+}
+
+class EmvcoClientCallback
+    : public aidl::android::hardware::emvco::BnEmvcoClientCallback {
+public:
+  EmvcoClientCallback(
+      const std::function<void(EmvcoEvent, EmvcoStatus)> &on_hal_event_cb,
+      const std::function<void(const std::vector<uint8_t> &)> &on_nci_data_cb)
+      : on_nci_data_cb_(on_nci_data_cb), on_hal_event_cb_(on_hal_event_cb) {}
+  virtual ~EmvcoClientCallback() = default;
+
+  ::ndk::ScopedAStatus sendEvent(EmvcoEvent event,
+                                 EmvcoStatus event_status) override {
+    ALOGI("%s ", __func__);
+    if (!is_aborted_) {
+      on_hal_event_cb_(event, event_status);
+    }
+    return ::ndk::ScopedAStatus::ok();
+  };
+  ::ndk::ScopedAStatus sendData(const std::vector<uint8_t> &data) override {
+    ALOGI("%s before mutex ", __func__);
+    if (!is_aborted_) {
+      on_nci_data_cb_(data);
+    }
+    return ::ndk::ScopedAStatus::ok();
+  };
+
+private:
+  std::function<void(const std::vector<uint8_t> &)> on_nci_data_cb_;
+  std::function<void(EmvcoEvent, EmvcoStatus)> on_hal_event_cb_;
+};
+
+static void controlRedLed() {
+  setLedState(LedControl::RED_LED_ON);
+  std::chrono::milliseconds sleepTime(led_glow_duration);
+  std::this_thread::sleep_for(sleepTime);
+  setLedState(LedControl::RED_LED_OFF);
+}
+
+static bool isEndOfTest(std::vector<unsigned char> &data, int received_size) {
+  ALOGI("%s received_size:%d\n", __func__, received_size);
+  bool isEOT = false;
+  if (data.at(0) == 0x60 && data.at(1) == 0x08) {
+    ALOGI("Device Error");
+    switch (data.at(3)) {
+    case 0xB0:
+      ALOGI("Device lost - transmission error\n");
+      controlRedLed();
+      break;
+    case 0xB1:
+      ALOGI("Device lost - protocol error\n");
+      controlRedLed();
+      break;
+    case 0xB2:
+      ALOGI("Device lost - timeout error\n");
+      controlRedLed();
+      break;
+    default:
+      ALOGI("Default\n");
+      break;
+    }
+  } else if ((received_size >= 5) &&
+             (data.at(4) == 0x70 || data.at(4) == 0x72)) {
+    ALOGI("Device lost APDU received with NCI header\n");
+    if (data.at(4) == 0x70) {
+      is_removal_procedure = true;
+    }
+    isEOT = true;
+
+    setLedState(LedControl::GREEN_LED_ON);
+    std::chrono::milliseconds sleepTime(led_glow_duration);
+    std::this_thread::sleep_for(sleepTime);
+    setLedState(LedControl::GREEN_LED_OFF);
+  } else if ((data.at(0) == 0x00) && (data.at(received_size - 1) != 0x00) &&
+             (data.at(received_size - 2) != 0x90)) {
+    ALOGI("InValid status byte - starting removal procedure\n");
+    is_removal_procedure = true;
+    isEOT = true;
+  }
+  return isEOT;
+}
+
+static std::vector<uint8_t> getNCILoopbackData(uint8_t packetBoundaryFlag,
+                                               std::vector<uint8_t> apduData,
+                                               int dataLength) {
+  ALOGI("%s\n dataLength", __func__);
+  std::vector<uint8_t> nci_send_loopback_;
+  nci_send_loopback_.insert(nci_send_loopback_.begin(), packetBoundaryFlag);
+  nci_send_loopback_.insert(nci_send_loopback_.begin() + 1, 0x00);
+  nci_send_loopback_.insert(nci_send_loopback_.begin() + 2, dataLength);
+  nci_send_loopback_.insert(nci_send_loopback_.begin() + 3, apduData.begin(),
+                            apduData.end());
+  return nci_send_loopback_;
+}
+
+static void send(std::shared_ptr<IEmvcoContactlessCard> nxp_emvco_cl_service_,
+                 const std::vector<uint8_t> data, int32_t aidl_return,
+                 std::string dataTag) {
+  ALOGI("%s\n transceive data:%s", __func__, dataTag.c_str());
+  nxp_emvco_cl_service_->transceive(data, &aidl_return);
+}
+
+void signal_callback_handler(int signum) {
+  ALOGI("%s Self test App abort requested, signum:%d", __func__, signum);
+  is_aborted_ = true;
+  if (nxp_emvco_cl_service_ != nullptr) {
+    nxp_emvco_cl_service_->setEMVCoMode(pollingConfiguration, false);
+  }
+  psse_cb_promise_.set_value();
+  exit(signum);
+  ALOGI("%s Self test App aborted", __func__);
+}
+void setRFTechnologyMode(int modeType, bool isSet) {
+  ALOGI("%s Before set pollingConfiguration:%d\n", __func__,
+        pollingConfiguration);
+  if (isSet) {
+    pollingConfiguration = 1 << modeType | pollingConfiguration;
+  } else {
+    pollingConfiguration = ~(1 << modeType) & pollingConfiguration;
+  }
+  ALOGI("%s after set pollingConfiguration:%d\n", __func__,
+        pollingConfiguration);
+}
+
+void EmvcoHalBinderDied(void *cookie) {
+  ALOGI("EmvcoHalBinderDied");
+  (void)cookie;
+  AIBinder_unlinkToDeath(nxp_emvco_service_->asBinder().get(),
+                         mDeathRecipient.get(), 0);
+  exit(1);
+  ALOGI("Self test App aborted due to EMVCo HAL crash");
+}
+
+int main(int argc, char **argv) {
+  ABinderProcess_startThreadPool();
+  try {
+    ALOGI("%s Entered %d arguments", __func__, argc);
+    for (int i = 0; i < argc; ++i) {
+      ALOGI("%s argv:", argv[i]);
+    }
+    if (argc > 1) {
+      if (strstr(argv[1], "INTEROP") != 0 || strstr(argv[1], "interop") != 0) {
+        if ((argc > 3) && argv[3] != NULL) {
+          std::string duration_str = std::string(argv[3]);
+          if (!duration_str.empty()) {
+            int duration = std::stoi(argv[3]);
+            ALOGI("User provided duration:%d", duration);
+            if (duration >= MIN_LED_GLOW_DURATION &&
+                duration <= MAX_LED_GLOW_DURATION) {
+              led_glow_duration = duration;
+            } else {
+              printf(
+                  "Invalid duration. 500ms to 3sec is the supported LED glow "
+                  "duration \n. setting glow duration as 500ms \n");
+            }
+          }
+        }
+        ALOGI("Executing digital compliance with LED glow duration:%d",
+              led_glow_duration);
+      } else {
+        led_glow_duration = 0;
+        ALOGI("Executing digital compliance with out LED glow duration:%d",
+              led_glow_duration);
+      }
+    }
+    if (argc > 2) {
+      if (strstr(argv[2], "A") != 0 || strstr(argv[2], "a") != 0) {
+        setRFTechnologyMode(NFC_A_PASSIVE_POLL_MODE, true);
+      }
+      if (strstr(argv[2], "B") != 0 || strstr(argv[2], "b") != 0) {
+        setRFTechnologyMode(NFC_B_PASSIVE_POLL_MODE, true);
+      }
+      if (strstr(argv[2], "F") != 0 || strstr(argv[2], "f") != 0) {
+        setRFTechnologyMode(NFC_F_PASSIVE_POLL_MODE, true);
+      }
+      if (strstr(argv[2], "V") != 0 || strstr(argv[2], "v") != 0) {
+        setRFTechnologyMode(NFC_VAS_PASSIVE_POLL_MODE, true);
+      }
+    } else {
+      printf(
+          "\n Select atleast one polling technolgy to enable EMVCo mode\n "
+          "Example#1: \"./EMVCoAidlHalComplianceTest Type/interop A 600\" "
+          "will enable Type A "
+          "for polling with LED glow duration of 600ms \n Example#2: "
+          "\"./EMVCoAidlHalComplianceTest Type/interop AB 600\" "
+          "will enable Type/interop AB for polling with LED glow duration of "
+          "600ms\n \n ");
+      return 0;
+    }
+
+    if (pollingConfiguration == NFC_AB_PASSIVE_POLL_MODE_SUPPORTED ||
+        pollingConfiguration == NFC_F_PASSIVE_POLL_MODE_SUPPORTED ||
+        pollingConfiguration == NFC_ABF_PASSIVE_POLL_MODE_SUPPORTED ||
+        pollingConfiguration == NFC_ABVAS_PASSIVE_POLL_MODE_SUPPORTED ||
+        pollingConfiguration == NFC_ABFVAS_PASSIVE_POLL_MODE_SUPPORTED) {
+      printf("\n Valid Technology selected for polling\n ");
+    } else {
+      printf(
+          "\n Select supported polling technolgy (AB) to enable EMVCo mode\n "
+          "Example: \"./EMVCoAidlHalComplianceTest Type/interop "
+          "AB 600 \" will enable Type/interop AB for polling with LED glow "
+          "duration of 600ms\n \n ");
+      return 0;
+    }
+
+    signal(SIGINT, signal_callback_handler);
+
+    const std::string instance =
+        std::string() + IEmvco::descriptor + "/default";
+    SpAIBinder binder(AServiceManager_waitForService(instance.c_str()));
+    nxp_emvco_service_ = IEmvco::fromBinder(binder);
+
+    mDeathRecipient = ::ndk::ScopedAIBinder_DeathRecipient(
+        AIBinder_DeathRecipient_new(EmvcoHalBinderDied));
+    AIBinder_linkToDeath(nxp_emvco_service_->asBinder().get(),
+                         mDeathRecipient.get(), 0);
+
+    nxp_emvco_service_->getEmvcoContactlessCard(&nxp_emvco_cl_service_);
+    nxp_emvco_service_->getEmvcoProfileDiscoveryInterface(
+        &nxp_emvco_prof_disc_service_);
+    aidl::android::hardware::emvco::EmvcoStatus _aidl_return;
+    int tempPollProfileSelection = pollProfileSelectionVal;
+    while (tempPollProfileSelection != 0) {
+      tempPollProfileSelection /= 10;
+      ++config_len;
+    }
+    ALOGI("setByteConfig called with pollProfileSelectionVal:%d, config_len:%d",
+          pollProfileSelectionVal, config_len);
+
+    nxp_emvco_prof_disc_service_->setByteConfig(
+        ConfigType::POLL_PROFILE_SEL, config_len, pollProfileSelectionVal,
+        &_aidl_return);
+
+    auto mCallback = ::ndk::SharedRefBase::make<EmvcoClientCallback>(
+        [](auto event, auto status) {
+          ALOGI("Event callback event:%d", event);
+          (void)status;
+          if (EMVCO_POLLING_STARTED_EVT == (int)event) {
+            setLedState(LedControl::RED_LED_OFF);
+            setLedState(LedControl::GREEN_LED_OFF);
+          }
+        },
+        [](auto &in_data) {
+          ALOGI("Data callback");
+          const std::lock_guard<std::mutex> lock(data_mutex_);
+          ALOGI("Data callback after mutex lock");
+          try {
+            std::vector<uint8_t> data(in_data.begin(), in_data.end());
+            int received_size = data.size();
+            if (data.at(0) == 0x00 && received_size < MIN_VALID_DATA_SIZE) {
+              ALOGI("InValid Data length Packet - Sending PPSE\n");
+              send(nxp_emvco_cl_service_,
+                   getNCILoopbackData(0x00, nci_send_ppse, 20), aidl_return,
+                   "LOOPBACK_APDU");
+
+            } else if (isEndOfTest(data, received_size)) {
+              ALOGI("End of Test\n");
+              if (is_removal_procedure) {
+                is_removal_procedure = false;
+                ALOGI("stopRFDisovery with DISCOVER");
+                EmvcoStatus emvcoStatus;
+                nxp_emvco_cl_service_->stopRFDisovery(
+                    DeactivationType::DISCOVER, &emvcoStatus);
+              } else {
+                ALOGI("stopRFDisovery with IDLE");
+                EmvcoStatus emvcoStatus;
+                nxp_emvco_cl_service_->stopRFDisovery(DeactivationType::IDLE,
+                                                      &emvcoStatus);
+                std::chrono::microseconds sleepTime(DEACTIVATE_IDLE_TIMEOUT);
+                std::this_thread::sleep_for(sleepTime);
+                ALOGI("Poll again through setEMVCoMode immediately");
+                nxp_emvco_cl_service_->setEMVCoMode(pollingConfiguration, true);
+              }
+              ALOGI("\n Loopback application running - waiting for test "
+                    "equipment "
+                    "discovery ...\n");
+            } else if (data.at(0) == 0x00) {
+              std::vector<uint8_t> apduData(in_data.begin() + NCI_HEADER_SIZE,
+                                            in_data.end() - 2);
+              send(nxp_emvco_cl_service_,
+                   getNCILoopbackData(0x00, apduData,
+                                      received_size - NCI_HEADER_SIZE - 2),
+                   aidl_return, "LOOPBACK_APDU");
+            } else if (data.at(0) == 0x61 &&
+                       data.at(1) == 0x05) { // RF_ACTIVATION_NTF - 0x61 && 0x05
+              ALOGI("RF_ACTIVATION_NTF VERIFIED");
+
+              send(nxp_emvco_cl_service_,
+                   getNCILoopbackData(0x00, nci_send_ppse, 20), aidl_return,
+                   "LOOPBACK_APDU");
+            }
+          } catch (const std::future_error &e) {
+            ALOGE("%s data future_error", e.what());
+          }
+        });
+    bool register_status;
+    EXPECT_TRUE((*(nxp_emvco_cl_service_))
+                    .registerEMVCoEventListener(mCallback, &register_status)
+                    .isOk());
+    nxp_emvco_cl_service_->setEMVCoMode(pollingConfiguration, true);
+    psse_cb_future_.wait();
+
+  } catch (const std::length_error &e) {
+    ALOGE("%s std::length_error", e.what());
+  }
+  ALOGI("TEST APP EXITED");
+}
diff --git a/emvco_loopback_desfire_test/Android.bp b/emvco_loopback_desfire_test/Android.bp
new file mode 100644
index 0000000..434f58f
--- /dev/null
+++ b/emvco_loopback_desfire_test/Android.bp
@@ -0,0 +1,25 @@
+cc_test {
+    name: "EMVCoAidlHalDesfireTest",
+    defaults: [
+        "VtsHalTargetTestDefaults",
+        "use_libaidlvintf_gtest_helper_static",
+    ],
+    srcs: [
+        "EMVCoAidlHalDesfireTest.cpp",
+    ],
+    shared_libs: [
+        "libbinder",
+        "libbinder_ndk",
+    ],
+    static_libs: [
+        "android.hardware.emvco-V1-ndk",
+        "VtsHalHidlTargetTestBase",
+    ],
+    test_suites: [
+        "general-tests",
+        "vts",
+    ],
+    cppflags: [
+        "-fexceptions",
+    ],
+}
diff --git a/emvco_loopback_desfire_test/EMVCoAidlHalDesfireTest.cpp b/emvco_loopback_desfire_test/EMVCoAidlHalDesfireTest.cpp
new file mode 100755
index 0000000..a465acb
--- /dev/null
+++ b/emvco_loopback_desfire_test/EMVCoAidlHalDesfireTest.cpp
@@ -0,0 +1,316 @@
+/******************************************************************************
+ *
+ *  Copyright 2022-2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "emvco_aidl_hal_test"
+
+#include <aidl/Gtest.h>
+#include <aidl/Vintf.h>
+#include <aidl/android/hardware/emvco/BnEmvco.h>
+#include <aidl/android/hardware/emvco/BnEmvcoClientCallback.h>
+#include <aidl/android/hardware/emvco/IEmvco.h>
+#include <aidl/android/hardware/emvco/IEmvcoContactlessCard.h>
+#include <android-base/logging.h>
+#include <android-base/stringprintf.h>
+#include <android/binder_auto_utils.h>
+#include <android/binder_enums.h>
+#include <android/binder_interface_utils.h>
+#include <android/binder_manager.h>
+#include <android/binder_process.h>
+#include <binder/IServiceManager.h>
+#include <chrono>
+#include <future>
+#include <log/log.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <signal.h>
+#include <stdio.h>
+#include <time.h>
+#include <unistd.h>
+
+using aidl::android::hardware::emvco::EmvcoEvent;
+using aidl::android::hardware::emvco::EmvcoStatus;
+using aidl::android::hardware::emvco::IEmvco;
+using aidl::android::hardware::emvco::IEmvcoClientCallback;
+using aidl::android::hardware::emvco::IEmvcoContactlessCard;
+
+using ndk::ScopedAStatus;
+using ndk::SharedRefBase;
+using ndk::SpAIBinder;
+
+using aidl::android::hardware::emvco::ConfigType;
+using aidl::android::hardware::emvco::IEmvcoProfileDiscovery;
+using android::getAidlHalInstanceNames;
+using android::PrintInstanceNameToString;
+using android::base::StringPrintf;
+using ndk::enum_range;
+using ndk::ScopedAStatus;
+using ndk::SharedRefBase;
+using ndk::SpAIBinder;
+/* NCI Commands */
+
+#define NCI_SEND_PPSE                                                          \
+  {                                                                            \
+    0x00, 0xA4, 0x04, 0x00, 0x0E, 0x32, 0x50, 0x41, 0x59, 0x2E, 0x53, 0x59,    \
+        0x53, 0x2E, 0x44, 0x44, 0x46, 0x30, 0x31, 0x00                         \
+  }
+
+#define PPSE_SEND_MAX_TIMES 250
+
+std::shared_ptr<IEmvco> iIEmvco_;
+std::shared_ptr<IEmvcoContactlessCard> iEmvcoContactlessCard_;
+constexpr static int kCallbackTimeoutMs = 100;
+volatile static int index = 0;
+static std::vector<std::promise<void>> psse_cb_promise;
+unsigned long long start_ts, end_ts;
+static volatile bool is_aborted_ = false;
+static volatile uint8_t pollingConfiguration = 0;
+const int NFC_A_PASSIVE_POLL_MODE = 0;
+const int NFC_B_PASSIVE_POLL_MODE = 1;
+const int NFC_F_PASSIVE_POLL_MODE = 2;
+const int NFC_VAS_PASSIVE_POLL_MODE = 3;
+const int pollProfileSelection = 0b00000010;
+int count = 0;
+::ndk::ScopedAIBinder_DeathRecipient mDeathRecipient;
+std::shared_ptr<IEmvcoProfileDiscovery> nxp_emvco_prof_disc_service_;
+
+class EmvcoClientCallback
+    : public aidl::android::hardware::emvco::BnEmvcoClientCallback {
+public:
+  EmvcoClientCallback(
+      const std::function<void(EmvcoEvent, EmvcoStatus)> &on_hal_event_cb,
+      const std::function<void(const std::vector<uint8_t> &)> &on_nci_data_cb)
+      : on_nci_data_cb_(on_nci_data_cb), on_hal_event_cb_(on_hal_event_cb) {}
+  virtual ~EmvcoClientCallback() = default;
+
+  ::ndk::ScopedAStatus sendEvent(EmvcoEvent event,
+                                 EmvcoStatus event_status) override {
+    ALOGI("%s ", __func__);
+    if (!is_aborted_) {
+      on_hal_event_cb_(event, event_status);
+    }
+    return ::ndk::ScopedAStatus::ok();
+  };
+  ::ndk::ScopedAStatus sendData(const std::vector<uint8_t> &data) override {
+    ALOGI("%s ", __func__);
+    if (!is_aborted_) {
+      on_nci_data_cb_(data);
+    }
+    return ::ndk::ScopedAStatus::ok();
+  };
+
+private:
+  std::function<void(const std::vector<uint8_t> &)> on_nci_data_cb_;
+  std::function<void(EmvcoEvent, EmvcoStatus)> on_hal_event_cb_;
+};
+
+void signal_callback_handler(int signum) {
+  ALOGI("%s Self test App abort requested, signum:%d", __func__, signum);
+  is_aborted_ = true;
+  if (iEmvcoContactlessCard_ != nullptr) {
+    iEmvcoContactlessCard_->setEMVCoMode(pollingConfiguration, false);
+  }
+  exit(signum);
+  ALOGI("%s Self test App aborted", __func__);
+}
+
+void setRFTechnologyMode(int modeType, bool isSet) {
+  ALOGI("%s Before set pollingConfiguration:%d\n", __func__,
+        pollingConfiguration);
+  if (isSet) {
+    pollingConfiguration = 1 << modeType | pollingConfiguration;
+  } else {
+    pollingConfiguration = ~(1 << modeType) & pollingConfiguration;
+  }
+  ALOGI("%s after set pollingConfiguration:%d\n", __func__,
+        pollingConfiguration);
+}
+
+void EmvcoHalBinderDied(void *cookie) {
+  ALOGI("EmvcoHalBinderDied");
+  (void)cookie;
+  AIBinder_unlinkToDeath(iIEmvco_->asBinder().get(), mDeathRecipient.get(), 0);
+  exit(1);
+  ALOGI("Self test App aborted due to EMVCo HAL crash");
+}
+
+static std::vector<uint8_t> getNCILoopbackData(uint8_t packetBoundaryFlag,
+                                               std::vector<uint8_t> apduData,
+                                               int dataLength) {
+  ALOGI("%s\n dataLength", __func__);
+  std::vector<uint8_t> nci_send_loopback_;
+  nci_send_loopback_.insert(nci_send_loopback_.begin(), packetBoundaryFlag);
+  nci_send_loopback_.insert(nci_send_loopback_.begin() + 1, 0x00);
+  nci_send_loopback_.insert(nci_send_loopback_.begin() + 2, dataLength);
+  nci_send_loopback_.insert(nci_send_loopback_.begin() + 3, apduData.begin(),
+                            apduData.end());
+  return nci_send_loopback_;
+}
+
+int main(int argc, char **argv) {
+  ABinderProcess_startThreadPool();
+  try {
+    ALOGI("%s Entered %d arguments", __func__, argc);
+    for (int i = 0; i < argc; ++i) {
+      ALOGI("%s argv:", argv[i]);
+    }
+    if (argc == 3) {
+      if (strstr(argv[2], "A") != 0 || strstr(argv[2], "a") != 0) {
+        setRFTechnologyMode(NFC_A_PASSIVE_POLL_MODE, true);
+      }
+      if (strstr(argv[2], "B") != 0 || strstr(argv[2], "b") != 0) {
+        setRFTechnologyMode(NFC_B_PASSIVE_POLL_MODE, true);
+      }
+      if (strstr(argv[2], "F") != 0 || strstr(argv[2], "f") != 0) {
+        setRFTechnologyMode(NFC_F_PASSIVE_POLL_MODE, true);
+      }
+      if (strstr(argv[2], "V") != 0 || strstr(argv[2], "v") != 0) {
+        setRFTechnologyMode(NFC_VAS_PASSIVE_POLL_MODE, true);
+      }
+    } else {
+      printf(
+          "\n Select atleast one polling technolgy to enable EMVCo mode\n "
+          "Example#1: \"./EMVCoAidlHalDesfireTest Type A\" will enable Type A "
+          "for polling \n Example#2: \"./EMVCoAidlHalDesfireTest Type AB\" "
+          "will enable Type AB for polling \n \n ");
+      return 0;
+    }
+
+    if (pollingConfiguration == 0) {
+      printf(
+          "\n Select supported polling technolgy (A/B/F) to enable EMVCo "
+          "mode\n "
+          "Example#1: \"./EMVCoAidlHalDesfireTest Type A\" will enable "
+          "Type A for polling \n Example#2: \"./EMVCoAidlHalDesfireTest Type "
+          "AB\" will enable Type AB for polling \n \n ");
+      return 0;
+    }
+    signal(SIGINT, signal_callback_handler);
+
+    std::vector<uint8_t> nci_send_ppse = NCI_SEND_PPSE;
+    std::promise<void> start_discovery_emvco_cb_promise;
+
+    auto start_discovery_emvco_cb_future =
+        start_discovery_emvco_cb_promise.get_future();
+    std::vector<std::future<void>> psse_cb_future;
+
+    std::chrono::milliseconds timeout{kCallbackTimeoutMs};
+
+    for (int i = 0; i < PPSE_SEND_MAX_TIMES; i++) {
+      std::promise<void> promise;
+      psse_cb_future.push_back(promise.get_future());
+      psse_cb_promise.push_back(std::move(promise));
+    }
+
+    auto mCallback = ::ndk::SharedRefBase::make<EmvcoClientCallback>(
+        [](auto event, auto status) {
+          ALOGI("%s event callback", __func__);
+          (void)event;
+          (void)status;
+        },
+        [&start_discovery_emvco_cb_promise](auto &in_data) {
+          ALOGI("%s data callback", __func__);
+          std::vector<uint8_t> data(in_data.begin(), in_data.end());
+          size_t length = data.size();
+          ALOGI("%s data callback data.size():%zu", __func__, length);
+          // Validating RESET and NCI_DISABLE_STANDBY_MODE_CMD Response
+          try {
+            // RF_ACTIVATION_NTF - 0x61 && 0x05
+            if (data.at(0) == 97 && data.at(1) == 5) {
+              start_discovery_emvco_cb_promise.set_value();
+              ALOGI("%s  RF_ACTIVATION_NTF VERIFIED", __func__);
+            }
+            // Validating NCI_SET_EMV_PROFILE and PPSE Response
+            // PPSE 0x6A && 0x82
+            if (data.at(3) == 106 && data.at(4) == 130) {
+              ALOGI("%s  PPSE RESPONSE VERIFIED", __func__);
+              psse_cb_promise.at(index).set_value();
+            } else {
+              ALOGI("%s  ELSE OF NCI_SET_EMV_PROFILE and PPSE Response",
+                    __func__);
+            }
+          } catch (const std::future_error &e) {
+            ALOGE("%s event future_error", e.what());
+          }
+        });
+
+    const std::string instance =
+        std::string() + IEmvco::descriptor + "/default";
+    SpAIBinder binder(AServiceManager_waitForService(instance.c_str()));
+    iIEmvco_ = IEmvco::fromBinder(binder);
+    mDeathRecipient = ::ndk::ScopedAIBinder_DeathRecipient(
+        AIBinder_DeathRecipient_new(EmvcoHalBinderDied));
+    AIBinder_linkToDeath(iIEmvco_->asBinder().get(), mDeathRecipient.get(), 0);
+
+    iIEmvco_->getEmvcoContactlessCard(&iEmvcoContactlessCard_);
+
+    iIEmvco_->getEmvcoProfileDiscoveryInterface(&nxp_emvco_prof_disc_service_);
+    aidl::android::hardware::emvco::EmvcoStatus _aidl_return;
+    int tempPollProfileSelection = pollProfileSelection;
+    while (tempPollProfileSelection != 0) {
+      tempPollProfileSelection /= 10;
+      ++count;
+    }
+    ALOGI("setByteConfig called with pollProfileSelection:%d, count:%d",
+          pollProfileSelection, count);
+
+    nxp_emvco_prof_disc_service_->setByteConfig(ConfigType::POLL_PROFILE_SEL,
+                                                count, pollProfileSelection,
+                                                &_aidl_return);
+
+    // Open and wait for OPEN_CPLT
+    ALOGI("registerEMVCoEventListener");
+    bool register_status;
+    EXPECT_TRUE((*(iEmvcoContactlessCard_))
+                    .registerEMVCoEventListener(mCallback, &register_status)
+                    .isOk());
+
+    iEmvcoContactlessCard_->setEMVCoMode(pollingConfiguration, true);
+    start_discovery_emvco_cb_future.wait();
+
+    // NCI_SEND_PPSE
+    while (true) {
+      ALOGI("%s NCI_SEND_PPSE COUNT=%d", __func__, index);
+      if (index <= PPSE_SEND_MAX_TIMES - 1) {
+        const std::vector<uint8_t> &data6 = NCI_SEND_PPSE;
+        int32_t ppse_aidl_return1;
+        struct timespec tm;
+        clock_gettime(CLOCK_MONOTONIC, &tm);
+        start_ts = tm.tv_nsec * 1e-3 + tm.tv_sec * 1e+6;
+        ALOGI("%s PPSE command Sent at:%llu", __func__, start_ts);
+        iEmvcoContactlessCard_->transceive(getNCILoopbackData(0x00, data6, 20),
+                                           &ppse_aidl_return1);
+        EXPECT_EQ(psse_cb_future.at(index).wait_for(3 * timeout),
+                  std::future_status::ready);
+        clock_gettime(CLOCK_MONOTONIC, &tm);
+        end_ts = tm.tv_nsec * 1e-3 + tm.tv_sec * 1e+6;
+        ALOGI("%s PPSE response received at:%llu", __func__, end_ts);
+        ALOGI("%s PPSE command and response duration :%llu microsec", __func__,
+              end_ts - start_ts);
+        ++index;
+      } else {
+        ALOGI("%s not sending NCI_SEND_PPSE_RSP as index> 99 ", __func__);
+        break;
+      }
+    }
+
+    iEmvcoContactlessCard_->setEMVCoMode(pollingConfiguration, false);
+  } catch (const std::length_error &e) {
+    ALOGE("%s std::length_error", e.what());
+  }
+  ALOGI("TEST APP EXITED");
+}
diff --git a/emvco_transac_test/Android.bp b/emvco_transac_test/Android.bp
new file mode 100644
index 0000000..6e38554
--- /dev/null
+++ b/emvco_transac_test/Android.bp
@@ -0,0 +1,25 @@
+cc_test {
+    name: "EMVCoAidlHalTransacTest",
+    defaults: [
+        "VtsHalTargetTestDefaults",
+        "use_libaidlvintf_gtest_helper_static",
+    ],
+    srcs: [
+        "EMVCoAidlHalTransacTest.cpp",
+    ],
+    shared_libs: [
+        "libbinder",
+        "libbinder_ndk",
+    ],
+    static_libs: [
+        "android.hardware.emvco-V1-ndk",
+        "VtsHalHidlTargetTestBase",
+    ],
+    test_suites: [
+        "general-tests",
+        "vts",
+    ],
+    cppflags: [
+        "-fexceptions",
+    ],
+}
diff --git a/emvco_transac_test/EMVCoAidlHalTransacTest.cpp b/emvco_transac_test/EMVCoAidlHalTransacTest.cpp
new file mode 100644
index 0000000..0a895d0
--- /dev/null
+++ b/emvco_transac_test/EMVCoAidlHalTransacTest.cpp
@@ -0,0 +1,235 @@
+/******************************************************************************
+ *
+ *  Copyright 2023 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "emvco_transac_test"
+
+#include <aidl/Gtest.h>
+#include <aidl/android/hardware/emvco/BnEmvco.h>
+#include <aidl/android/hardware/emvco/BnEmvcoClientCallback.h>
+#include <aidl/android/hardware/emvco/ConfigType.h>
+#include <aidl/android/hardware/emvco/IEmvco.h>
+#include <aidl/android/hardware/emvco/IEmvcoContactlessCard.h>
+#include <aidl/android/hardware/emvco/IEmvcoProfileDiscovery.h>
+#include <android-base/stringprintf.h>
+#include <android/binder_auto_utils.h>
+#include <android/binder_enums.h>
+#include <android/binder_interface_utils.h>
+#include <android/binder_manager.h>
+#include <android/binder_process.h>
+#include <chrono>
+#include <future>
+#include <log/log.h>
+
+using aidl::android::hardware::emvco::ConfigType;
+using aidl::android::hardware::emvco::DeactivationType;
+using aidl::android::hardware::emvco::EmvcoEvent;
+using aidl::android::hardware::emvco::EmvcoStatus;
+using aidl::android::hardware::emvco::IEmvco;
+using aidl::android::hardware::emvco::IEmvcoClientCallback;
+using aidl::android::hardware::emvco::IEmvcoContactlessCard;
+using aidl::android::hardware::emvco::IEmvcoProfileDiscovery;
+using ndk::SpAIBinder;
+
+::ndk::ScopedAIBinder_DeathRecipient mDeathRecipient;
+
+static volatile uint8_t pollingConfiguration = 0;
+
+static volatile bool is_aborted_ = false;
+const int NFC_A_PASSIVE_POLL_MASK = 0;
+const int NFC_B_PASSIVE_POLL_MASK = 1;
+const int NFC_F_PASSIVE_POLL_MASK = 2;
+const int NFC_VAS_PASSIVE_POLL_MASK = 3;
+
+const int NFC_A_PASSIVE_POLL_MODE = 1;
+const int NFC_B_PASSIVE_POLL_MODE = 2;
+const int NFC_AB_PASSIVE_POLL_MODE_SUPPORTED = 3;
+
+int pollTypeAFirst = 0b00100000;
+int pollProfileSelection = 0b01000010;
+int count = 0;
+
+std::mutex data_mutex_;
+int32_t aidl_return;
+std::future<void> transac_future;
+std::promise<void> transac_promise;
+
+std::shared_ptr<IEmvco> nxp_emvco_service_;
+std::shared_ptr<IEmvcoContactlessCard> nxp_emvco_cl_service_;
+std::shared_ptr<IEmvcoProfileDiscovery> nxp_emvco_prof_disc_service_;
+
+class EmvcoClientCallback
+    : public aidl::android::hardware::emvco::BnEmvcoClientCallback {
+public:
+  EmvcoClientCallback(
+      const std::function<void(EmvcoEvent, EmvcoStatus)> &on_hal_event_cb,
+      const std::function<void(const std::vector<uint8_t> &)> &on_nci_data_cb)
+      : on_nci_data_cb_(on_nci_data_cb), on_hal_event_cb_(on_hal_event_cb) {}
+  virtual ~EmvcoClientCallback() = default;
+
+  ::ndk::ScopedAStatus sendEvent(EmvcoEvent event,
+                                 EmvcoStatus event_status) override {
+    ALOGI("%s ", __func__);
+    if (!is_aborted_) {
+      on_hal_event_cb_(event, event_status);
+    }
+    return ::ndk::ScopedAStatus::ok();
+  };
+  ::ndk::ScopedAStatus sendData(const std::vector<uint8_t> &data) override {
+    ALOGI("%s before mutex ", __func__);
+    if (!is_aborted_) {
+      on_nci_data_cb_(data);
+    }
+    return ::ndk::ScopedAStatus::ok();
+  };
+
+private:
+  std::function<void(const std::vector<uint8_t> &)> on_nci_data_cb_;
+  std::function<void(EmvcoEvent, EmvcoStatus)> on_hal_event_cb_;
+};
+
+void signal_callback_handler(int signum) {
+  ALOGI("%s Self test App abort requested, signum:%d", __func__, signum);
+
+  is_aborted_ = true;
+
+  if (nxp_emvco_cl_service_ != nullptr) {
+    nxp_emvco_cl_service_->setEMVCoMode(pollingConfiguration, false);
+  }
+  transac_promise.set_value();
+  exit(signum);
+  ALOGI("%s Self test App aborted", __func__);
+}
+void setRFTechnologyMode(int modeType, bool isSet) {
+  ALOGI("%s Before set pollingConfiguration:%d\n", __func__,
+        pollingConfiguration);
+  if (isSet) {
+    pollingConfiguration = 1 << modeType | pollingConfiguration;
+  } else {
+    pollingConfiguration = ~(1 << modeType) & pollingConfiguration;
+  }
+  ALOGI("%s after set pollingConfiguration:%d\n", __func__,
+        pollingConfiguration);
+}
+
+void EmvcoHalBinderDied(void *cookie) {
+  ALOGI("EmvcoHalBinderDied");
+  (void)cookie;
+  AIBinder_unlinkToDeath(nxp_emvco_service_->asBinder().get(),
+                         mDeathRecipient.get(), 0);
+  exit(1);
+  ALOGI("Self test App aborted due to EMVCo HAL crash");
+}
+
+int main(int argc, char **argv) {
+  ABinderProcess_startThreadPool();
+  ALOGI("%s Entered %d arguments", __func__, argc);
+  try {
+    for (int i = 0; i < argc; ++i) {
+      ALOGI("%s argv:", argv[i]);
+    }
+
+    if (argc > 2) {
+      if (strstr(argv[2], "A") != 0 || strstr(argv[2], "a") != 0) {
+        pollProfileSelection |= pollTypeAFirst;
+        setRFTechnologyMode(NFC_A_PASSIVE_POLL_MASK, true);
+      }
+      if (strstr(argv[2], "B") != 0 || strstr(argv[2], "b") != 0) {
+        setRFTechnologyMode(NFC_B_PASSIVE_POLL_MASK, true);
+      }
+      if (strstr(argv[2], "F") != 0 || strstr(argv[2], "f") != 0) {
+        setRFTechnologyMode(NFC_F_PASSIVE_POLL_MASK, true);
+      }
+      if (strstr(argv[2], "V") != 0 || strstr(argv[2], "v") != 0) {
+        setRFTechnologyMode(NFC_VAS_PASSIVE_POLL_MASK, true);
+      }
+    } else {
+      printf("\n Select atleast one polling technolgy to enable EMVCo mode\n "
+             "Example#1: \"./EMVCoAidlHalTransacTest Type A \" "
+             "will enable Type A poll first"
+             "for polling  \n Example#2: "
+             "\"./EMVCoAidlHalTransacTest Type B \" "
+             "will enable Type B poll first\n");
+      return 0;
+    }
+
+    if (pollingConfiguration == NFC_A_PASSIVE_POLL_MODE ||
+        pollingConfiguration == NFC_B_PASSIVE_POLL_MODE) {
+      printf("\n Valid Technology selected for polling\n ");
+    } else {
+      printf(
+          "\n Select supported polling technolgy (A/B) to enable EMVCo mode\n "
+          "Example#1: \"./EMVCoAidlHalTransacTest Type A \" "
+          "will enable Type A poll first"
+          "for polling  \n Example#2: "
+          "\"./EMVCoAidlHalTransacTest Type B \" "
+          "will enable Type B poll first\n");
+      return 0;
+    }
+
+    signal(SIGINT, signal_callback_handler);
+
+    const std::string instance =
+        std::string() + IEmvco::descriptor + "/default";
+    SpAIBinder binder(AServiceManager_waitForService(instance.c_str()));
+    nxp_emvco_service_ = IEmvco::fromBinder(binder);
+
+    mDeathRecipient = ::ndk::ScopedAIBinder_DeathRecipient(
+        AIBinder_DeathRecipient_new(EmvcoHalBinderDied));
+    AIBinder_linkToDeath(nxp_emvco_service_->asBinder().get(),
+                         mDeathRecipient.get(), 0);
+
+    nxp_emvco_service_->getEmvcoContactlessCard(&nxp_emvco_cl_service_);
+    nxp_emvco_service_->getEmvcoProfileDiscoveryInterface(
+        &nxp_emvco_prof_disc_service_);
+    aidl::android::hardware::emvco::EmvcoStatus _aidl_return;
+    int tempPollProfileSelection = pollProfileSelection;
+    while (tempPollProfileSelection != 0) {
+      tempPollProfileSelection /= 10;
+      ++count;
+    }
+    ALOGI("setByteConfig called with pollProfileSelection:%d, count:%d",
+          pollProfileSelection, count);
+
+    nxp_emvco_prof_disc_service_->setByteConfig(ConfigType::POLL_PROFILE_SEL,
+                                                count, pollProfileSelection,
+                                                &_aidl_return);
+
+    auto mCallback = ::ndk::SharedRefBase::make<EmvcoClientCallback>(
+        [](auto event, auto status) {
+          ALOGI("Event callback");
+          (void)event;
+          (void)status;
+        },
+        [](auto &in_data) {
+          ALOGI("Data callback");
+          (void)in_data;
+        });
+    bool register_status;
+    EXPECT_TRUE((*(nxp_emvco_cl_service_))
+                    .registerEMVCoEventListener(mCallback, &register_status)
+                    .isOk());
+
+    transac_future = transac_promise.get_future();
+    nxp_emvco_cl_service_->setEMVCoMode(NFC_AB_PASSIVE_POLL_MODE_SUPPORTED,
+                                        true);
+    transac_future.wait();
+  } catch (const std::length_error &e) {
+    ALOGE("%s std::length_error on setByteConfig call", e.what());
+  }
+  ALOGI("TEST APP EXITED");
+}
